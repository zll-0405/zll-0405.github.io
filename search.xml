<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[回顾]说说我这大学四年</title>
      <link href="/posts/2b9683dd.html"/>
      <url>/posts/2b9683dd.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近更新频率有些低,因为最近在忙着学校毕业的事情.今天有时间,爬上来说几句,关于我这大学四年.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">前几天是高考,当时还单一和母亲视频,和她说,四年之前的这个时候,考试完之后我没想到会经历这么多,四年之前的那个选择,从某种程度上,可以说对我的影响很大.<br>我还记得报志愿的那个夏天,我把自己关在屋子里,选了几个我想要去的学校,相当一部分的原因是因为我想要去那个城市.我很早就和父母说了,我要出省,他们心理也有准备,但是当我和他们说,我要去桂林,要去吉林的时候,还是被吓到了.<br>父亲后来一直和我交流,说不反对我出省,但是我一个女孩子,能不能不去那么远,后来父亲又说,你报吉林,报桂林也行,能不能让我也给你选一个学校,你把它放在最后面,如果你被前面的学校录取了,我也认.<br>好吧,最后我屈服了,然后父亲超级开心的去地图上,找他想要让我去的城市.<br>离河南比较近的,就是河北,安徽,山西那些周围的地方.<br>记得特别清楚,当时我在和父亲说以后要怎样怎样,父亲突然扭过头和我说,你觉得「廊坊」这个城市怎么样,离北京也近,离天津也近,到时候你想去哪儿玩去哪儿玩,然后去看了一下,有这么一个学校可以供我选择,就那样报上了.</font></p><p><font face="华文中宋" size="3">说实话,当时来这个学校,只是为了应付一下父亲,没想到真的会被它录取.桂林,吉林那两所大学差了一两分,然后就被这所学校录取了,工程管理专业.<br>大一来的时候,舅舅,舅妈,爸爸,妈妈都来送我.当时室友还说,你家人怎么那么宠你,上个大学,还单一开车跑到学校来送你.<br>大一其实想想,没干啥.正常上课,好好准备考试.唯一和别人不一样的就是没有参加学生会,没参加什么社团,所以时间多了很多,没事打打篮球,读读书.当时是要求自己一周要读一本书的(现在做不到了).<br>打篮球的那一帮人,真的是我在大学里遇到的很好的人.我特别感激我的前辈们,一直都在照顾我,现在有困难的时候,只要和她们说,就会帮你.因为一起经历过很多事情,也因为大家的脾性都很相近.<br>大二决定转行去做编程,然后在学习自己专业课的同时,还在自学编程.和别人相比,少了很多玩乐的时间,我其实是有些乐在其中的,从编程里面获得了很大的成就感.后来觉得只是自己在看着视频学,这些东西,在公司到底能不能用得上.<br>所以在大二暑假去找了一份实习工作,也是那个时候,开始在 CSDN 上写博客,没想到,一写就写到了现在.<br>我算是比较幸运的,当时能够找到一份实习工作,老大对我也不错,后来大三开学要辞职走的时候,老大说其实你可以边工作边学习的,当然了一切都以你学校那边事情为重,上完课了就可以过来工作.然后就答应下来,就这样以这样的节奏,一直在这家公司呆到了现在.</font></p><p><font face="华文中宋" size="3">现在回过头来看,这大学四年,做的最正确的决定就是,选择来这所学校就读,选择早点儿到社会上历练自己.<br>前几天还在和老友聊天,他们说,感觉和我聊天,就像是在和前辈聊天一样,不论是从思考方式,还是思考角度,都和他们不一样.<br>这大概就是我这四年经历的一个反映吧.</font></p><p><font face="华文中宋" size="3">我这个月就要毕业了,彻底失去了学生这个身份.<br>如果是要失去的身份,尽早失去是好的.这样你会知道,失去身份之后的你,还有什么资本.</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java] J2EE 之 13 个规范总结</title>
      <link href="/posts/888348b8.html"/>
      <url>/posts/888348b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="J2EE-Java-2-Platform-Enterprise-Edition"><a href="#J2EE-Java-2-Platform-Enterprise-Edition" class="headerlink" title="J2EE( Java 2 Platform Enterprise Edition )"></a><font face="华文中宋" size="5">J2EE( Java 2 Platform Enterprise Edition )</font></h1><p><font face="华文中宋" size="3">在说 13 个规范之前,我们需要先来谈谈 J2EE ,它产生的背景是什么,解决了什么问题,这样清楚之后,再来谈 13 个规范,不至于觉得太突兀.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">产生的背景:<br>在企业级应用中,都有一些通用企业需求模块,比如数据库连接,邮件服务,事务处理等等.<br>既然很多企业级应用都需要这些模块,一些大公司便开发了自己的通用模块服务,也就是我们说的中间件.这样做的好处,就是可以解决重复开发,开发周期长和代码可靠性差等问题.<br>但是,这个时候就有一个问题,我的公司有我自己的标准,你的公司有你独自的一套标准,那是不是两家公司的中间件不兼容的问题就出现了?这样当用户使用的时候,就没办法将它们组装在一起为自己服务了,对吧?<br>这个时候怎么办呢?你可以想想实际生活中,为什么插排买回来,插上就能用,为什么我知道空调要买特定的插排,而我买回来就能插上使用.因为有「标准」对吧?所以我们才不用管这个插排买回来能不能用的问题.制定好标准之后,大家都去遵守,然后统一生产,对用户来说也方便.<br>同样的道理和想法, J2EE 就诞生了. J2EE 就是基于 Java 技术的一系列标准.<br>既然是标准,那么它的核心就是:一组技术规范与指南,其中包含的各类组件,服务架构和技术层次都有共同的标准及规格,这样就能够让依循 J2EE 架构的不同平台之间,存在良好的兼容性,这样不就解决了上面那种问题了~</font></p><h1 id="13-种规范"><a href="#13-种规范" class="headerlink" title="13 种规范"></a><font face="华文中宋" size="5">13 种规范</font></h1><p> <font face="华文中宋" size="3">在理解 J2EE 之后,就应该有这样的认识:这 13 种规范,是我们应该去遵循的.问题就来了,我需要遵循哪儿些呢?接下来一个一个说(这个排名不分先后~)</font></p><p><font face="华文中宋" size="3">1 , JDBC ( JavaDatabase Connectivity )<br>JDBC 是以统一方式访问数据库的 API .<br>它提供了独立于平台的数据库访问,也就是说,当我有了 JDBC API 的时候,就不必再为访问 Oracle 数据库专门写一个程序,为访问 Sybase 数据库又专门写一个程序等等,只需要用 JDBC API 写一个程序就够了,它可以向相应数据库发送 SQL 调用. JDBC 是 Java 应用程序与各种不同数据库之间进行对话的方法的机制.简单地说,它做了三件事:与数据库建立连接–发送操作数据库的语句–处理结果.<br>说到这里,有没有想起来 ODBC ?<br>如果想起来了,有没有想起来我写过一篇文章?<a href="https://www.dynamic-zheng.com/posts/7f1c23b6.html">[java]说说 JDBC ,再聊聊 ODBC</a></font></p><p><font face="华文中宋" size="3">2 , JNDI ( JavaName and Directory Interface )<br>JNDI 是一组在 Java 应用中访问命名和目录服务的 API .<br>JNDI 为开发人员提供了查找和访问各种命名和目录服务的通用,统一的接口,利用 JNDI 的命名与服务功能可满足企业级 API 对命名与服务的访问,诸如 EJB , JMS , JDBC 2.0 以及 IIOP 上的 RMI 通过 JNDI 来使用 CORBA 的命名服务.<br>在这儿,想多说一点: JNDI 和 JDBC 类似,都是构建在抽象层上.因为它提供了标准的独立于命名系统的 API ,这些 API 构建在命名系统之上.这一层有助于将应用与实际数据源分离,因此不管是访问的 LDAP , RMI 还是 DNS .也就是说, JNDI 独立于目录服务的具体实现,只要有目录的服务提供接口或驱动,就可以使用目录.</font></p><p><font face="华文中宋" size="3">3 , EJB ( Enterprise JavaBean )<br>J2EE 将业务逻辑从客户端软件中抽取出来,封装在一个组件中.这个组件运行在一个独立的服务器上,客户端软件通过网络调用组件提供的服务以实现业务逻辑,而客户端软件的功能只是负责发送调用请求和显示处理结果.<br>在 J2EE 中,这个运行在一个独立的服务器上,并封装了业务逻辑的组件就是 EJB 组件.其实就是把原来放到客户端实现的代码放到服务器端,并依靠 RMI 进行通信.</font></p><p><font face="华文中宋" size="3">4 , RMI ( Remote MethodInvoke )<br>是一组用户开发分布式应用程序的 API .<br>这一协议调用远程对象上的方法使用了序列化的方式在客户端和服务器之间传递数据,使得原先的程序在同一操作系统的方法调用,变成了不同操作系统之间程序的方法调用,即 RMI 机制实现了程序组件在不同操作系统之间的通信.它是一种被 EJB 使用的更底层的协议.<br>RMI/JNI : RMI 可利用标准 Java 本机方法接口与现有的和原有的系统相连接<br>RMI/JDBC : RMI 利用标准 JDBC 包与现有的关系数据库连接<br>就实现了与非 Java 语言的现有服务器进行通信.</font></p><p><font face="华文中宋" size="3">5 , JavaIDL/CORBA ( Common Object Request BrokerArchitecture )<br>Java 接口定义语言/公用对象请求代理程序体系结构<br>在 JavaIDL 的支持下,开发人员可以将 Java 和 CORBA 集成在一起.他们可以创建 Java 对象并使之可以在 CORBA ORB 中展开,或者他们还可以创建 Java 类并作为和其它 ORB 一起展开的 CORBA 对象的客户.后一种方法提供了另外一种途径,通过 Java 可以被用于将新的应用和旧的系统相集成.<br>CORBA 是面向对象标准的第一步,有了这个标准,软件的实现与工作环境对用户和开发者不再重要,可以把精力更多地放在本地系统的实现与优化上.</font></p><p><font face="华文中宋" size="3">6 , JSP ( Java Server Pages )<br>JSP 页面 = HTML + Java ,其根本是一个简化的 Servlet 设计.<br>服务器在页面被客户端请求后,对这些 Java 代码进行处理,然后将执行结果连同原 HTML 代码生成的新 HTML 页面返回给客户端浏览器.</font></p><p><font face="华文中宋" size="3">7 , Java Servlet<br>Servlet 是一种小型的 Java 程序,扩展了 Web 服务器的功能,作为一种服务器的应用,当被请求时开始执行. Servlet 提供的功能大多和 JSP 类似,不过, JSP 通常是大多数的 HTML 代码中嵌入少量的 Java 代码,而 Servlet 全部由 Java 写成并生成 HTML .</font></p><p><font face="华文中宋" size="3">8 , XML<br>XML 是一个用来定义其它标记语言的语言,可用作数据共享. XML 的发展和 Java 是相互独立的.不过,它和 Java 具有的相同目标就是跨平台.通过将 Java 与 XML 结合,我们可以得到一个完全与平台无关的解决方案.<br>突然想起来,以前写过一篇博客,感兴趣可以看看:<a href="https://blog.csdn.net/zll_0405/article/details/82950037" target="_blank" rel="noopener">【XML】快速了解XML</a></font></p><p><font face="华文中宋" size="3">9 , JMS ( JavaMessage Service )<br>它是一种与厂商无关的 API ,用来访问消息收发系统消息.它类似于 JDBC . JDBC 是可以用来访问不同关系数据库的 API ,而 JMS 则提供同样与厂商无关的访问消息收发服务的方法,这样就可以通过消息收发服务实现从一个 JMS 客户机向另一个 JMS 客户机发送消息,所需要的是厂商支持 JMS .<br>换句话说, JMS 是 Java 平台上有关面向消息中间件的技术规范.</font></p><p><font face="华文中宋" size="3">10 , JTA ( JavaTransaction API )<br>定义了一种标准 API ,应用程序由此可以访问各种事务监控.它允许应用程序执行分布式事务处理–在两个或多个网络计算机资源上访问并且更新数据. JTA 和 JTS 为 J2EE 平台提供了分布式事务服务.<br>JTA 事务比 JDBC 事务更强大,一个 JTA 事务可以有多个参与者,而一个 JDBC 事务则被限定在一个单一的数据库连接.</font></p><p><font face="华文中宋" size="3">11 , JTS ( JavaTransaction Service )<br>JTS 是 CORBA OTS 事务监控器的一个基本实现. JTS 指定了一个事务管理器的实现（ Transaction Manager ）,这个管理器在一个高级别上支持 JTA 规范,并且在一个低级别上实现了 OMGOTS 规范的 Java 映射.一个 JTS 事务管理器为应用服务器,资源管理器, standalone 应用和通信资源管理器提供事务服务.</font></p><p><font face="华文中宋" size="3">12 , JavaMail<br>用于访问邮件服务器的 API ,提供了一套邮件服务器的抽象类.</font></p><p><font face="华文中宋" size="3">13 , JAF ( JavaBeansActivation Framework )<br>JAF 是一个专用的数据处理框架,它用于封装数据,并为应用程序提供访问和操作数据的接口.也就是说, JAF 让 Java 程序知道怎么对一个数据源进行查看,编辑,打印等.<br>JavaMail 利用 JAF 来处理 MIME 编码的邮件附件.</font></p><p><font face="华文中宋" size="3">在学习过程中,找到了一篇文章,总结的非常棒(我这篇文章,几乎都是借鉴着写过来的),推荐大家看看,特别是最后一张图,感觉很形象:<a href="https://blog.csdn.net/zhuanzhe117/article/details/38763483" target="_blank" rel="noopener">J2EE 的 13 个规范总结</a><br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]来谈谈写作这件事</title>
      <link href="/posts/cb0264f.html"/>
      <url>/posts/cb0264f.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">写作这件事,很多大佬都谈过,但我还是想从自己的角度去谈谈.<br><a id="more"></a></font></p><h1 id="说到写作-我们就需要来说-我为什么要去写作-或者说-写作带给了我什么"><a href="#说到写作-我们就需要来说-我为什么要去写作-或者说-写作带给了我什么" class="headerlink" title="说到写作,我们就需要来说,我为什么要去写作,或者说,写作带给了我什么."></a><font face="华文中宋" size="3">说到写作,我们就需要来说,我为什么要去写作,或者说,写作带给了我什么.</font></h1><p><font face="华文中宋" size="3">1 ,可以系统性的思考.<br>我觉得你肯定有这样的感受,就是一个知识点我明明懂了,可是给别人讲的时候,却总是讲不明白.知道为什么嘛?因为你只是以为你自己懂了,实际上你并没有懂.<br>而写作就相当于你在给别人讲,那么你为了写明白一个知识点,为了让别人读懂你这篇文章,你会怎么做?<br>就拿这篇文章来说,为了向别人说明写作的重要性,你会怎么展开?起码会从是什么,为什么,怎么做,这三点去展开说,对吧.<br>那么,当你这样去写的时候,你发现,我好像对是什么不太清楚,所以你就会去查资料;我为什么要去用这个呢,想不明白,再去查资料;我怎么用这个知识呢,再去查资料或者实践.<br>这样做一次两次三次…当你坚持这样写完 100 篇文章的时候,你的思考角度,思维模式,绝对和写作之前不一样.</font></p><p><font face="华文中宋" size="3">2 ,构建影响力.<br>对于一个人来说,最重要的是什么?是有自己的「影响力」.<br>当你有自己的影响力时,你就能够在整个行业里面脱颖而出,从而能够有机会结识更加优秀的人.<br>但是影响力很轻松就能构建?只想说,别做梦了.<br>那么,我怎么构建影响力?</font></p><ul><li><font face="华文中宋" size="3"> 高质量的内容<br><font face="华文中宋" size="3">一件事情,你一定要想清楚,就是你和我都互相不认识,那么我凭什么信任你,我凭什么受你的影响,对吧.靠的就是高质量的内容.<br>我写博客,特别是需要实操的内容,比如安装 mysql , keepalived 这些文章的时候,都是自己操作一遍之后,确实是成功了,才敢发表出来.自己没有实践就写出来,我觉得是对读者的不负责任,那自然也就没有信任这一说.</font></font></li><li><font face="华文中宋" size="3">交给时间<br><font face="华文中宋" size="3">只要保证自己的内容是高质量的,剩下的交给时间就行了.<br>因为时间会告诉你,这一切是值得还是不值得.</font></font></li></ul><h1 id="既然写作给我带来了以上好处-那我该怎么做"><a href="#既然写作给我带来了以上好处-那我该怎么做" class="headerlink" title="既然写作给我带来了以上好处,那我该怎么做?"></a><font face="华文中宋" size="3">既然写作给我带来了以上好处,那我该怎么做?</font></h1><p><font face="华文中宋" size="3">1 ,找到你擅长的内容,不断细分,细分再细分,然后锤炼,锤炼再锤炼.<br>关于你擅长的内容,这一点需要你自己去寻找.<br>比如我,对于前端,运维,后端,等等都有一些学习和钻研,那我就开始写这方面的内容.<br>但是前端,运维,后端每一个都是很大的方向,我怎么着手去写?一个办法:细分.细分到什么程度呢?比如说,我今天遇到了一个前端的问题,我写下来记录一下,可不可以?完全 OK 啊!<br>但是写完了就没事了?不是的,还需要再锤炼.<br>我一般是写完之后,就发表出来.如果有人给我评论一下,指出我哪里做的不是太好,我真是太开心了,又是一个可以成长的机会.<br>然后我过一段时间之后,会再来看之前写的文章,这里写的不太好,改改.那里排版看着不太舒服,再改改.<br>所以如果你感兴趣的话,可以看看我最近写的内容,和刚开始写的内容,不管是内容,深度,还是排版,我打保证,绝对是不一样的.<br>而这,都是因为我找到了擅长的内容,不断细分,然后一直锤炼的结果.</font></p><p><font face="华文中宋" size="3">2 ,站在巨人的肩膀上.<br>站在巨人的肩膀上,能够走得更远.写作这件事也不例外,你也可以站在巨人的肩膀上,或者更准确的说,模仿.<br>到底怎么做呢?这么多年了,肯定有一篇文章,能够打动你,或者你认为写得很好.那么这篇文章就是巨人的肩膀.不断地去剖析这篇文章的组织架构,不断地去思考为什么作者这样写.<br>思考完了你以为就可以了?不不不,还差得远.思考完了,你觉得把这篇文章理解的差不多了对吧,尝试着不看文章,就把这篇文章写下来.结果你发现跟原文还是不一样的,对吧?然后再思考,这里作者为什么要用这个词语呢,作者的构思在这里和我不太一样,他这样写是出于什么思考呢?然后觉得自己思考的差不多了,再尝试不看文章,就把这篇文章写下来.上面这个过程,重复,重复再重复,直到你真的写出来了原文.<br>这个时候,你以为没事了?不不不,然后你需要再寻找下一篇你觉得好的文章,再重复上面的内容,等你重复这样做几十遍之后,当你再自己写文章的时候,你会惊讶的.<br>啊?你跟我说,你没有欣赏的文章?那你可以去读一读阅读量 10W+ 的文章,一篇文章如果能够有 10W+ 的阅读量,说明这篇文章可圈可点的内容有很多,可以去分析,模仿,站在巨人的肩膀上,走的更快,也更远.</font></p><h1 id="既然写作有这么多的好处-为什么写作的人不多"><a href="#既然写作有这么多的好处-为什么写作的人不多" class="headerlink" title="既然写作有这么多的好处,为什么写作的人不多?"></a><font face="华文中宋" size="3">既然写作有这么多的好处,为什么写作的人不多?</font></h1><p><font face="华文中宋" size="3">我觉得相当一部分的原因是因为,大多数人还没开始写作,就自己被自己吓死了.<br>怎么讲?你有没有这样的忧虑,当你想要开始写作的时候,突然有压力了,我如果写不好怎么办,我如果写的非常差劲怎么办,我还没搜集好相关素材…然后写作这件事就一直被放在了一边.<br>有这样的想法再正常不过,因为我刚开始在 CSDN 上写博客的时候也是这样,一想要在 CSDN 上写博客,心里就犯怵,我的天啊, CSDN 上牛人那么多,人家写的那么好,我再打磨打磨自己,我再深入学习学习,巴啦啦各种借口.后来就是破罐子破摔了,写的烂就写的烂了,先写出来再说吧.就这么逼着自己,先做起来.<br>结果呢,写出来之后发现,哎,这件事也没自己想象中那么难嘛~然后就这么一路写了下来.</font></p><p><font face="华文中宋" size="3">写作的人不多,我觉得可能还有一个原因就是,我写了但是没有人看,没有人跟我互动,让我突然没有了坚持下去的动力.<br>对于这一点,我只想说「将欲取之,必先予之」.<br>你想让别人来看你的博客,想让别人评论你的博客,给你动力或者提意见,让你写的更好,凭什么?<br>有一段时间我就挺鸡贼的,就是跑到各个博主下面去评论博客,因为别人评论我博客的时候,我会顺手点到对方博客里面去,看一眼别人写的内容,感兴趣的话,我就评论一下.这种心态,我觉得每个人可能都有,所以呢,我就跑到各个博主下面去评论人家的博客,有的博主就礼尚往来一下,也评论一下我的博客.<br>然后我一看,哇塞,有人评论我的博客了,不行我得再给对方评论回去.就这么一来二去,博客评论竟然也不少了,还连带着骗了很多粉丝,然后给我的动力就更大了,这样就形成了一个正反馈的闭环,直到现在写作对我来说成为了习惯.<br>所以呢,遇到问题,先从自身想想,别人凭什么要给你评论博客,这样问题就比较好解决了.</font></p><h1 id="「写作」和「笔记」的区别"><a href="#「写作」和「笔记」的区别" class="headerlink" title="「写作」和「笔记」的区别"></a><font face="华文中宋" size="3">「写作」和「笔记」的区别</font></h1><p><font face="华文中宋" size="3">我是一直建议身边的朋友写作的,但是几乎每次建议的时候,他们都会说,我有写啊,你看我都有记笔记.<br>所以这里说一下,「写作」和「笔记」的区别.<br>写作就是你需要发表出来,让别人看.如果写的太差劲了,你肯定不好意思发表出来,对吧?所以为了写一篇文章,你可能要花上两三个小时去写,我现在写一篇文章,都是先写一点儿东西,然后放在一边,过几天再回来看,再进行修改,然后再放在一边,过几天再来看,然后再修改.就这么一来一回,一篇文章从开始写,到它发表出来,至少有 5 天的时间.我写年终总结的时候,都是花费一周两周甚至是一个月的时间去写的,因为怕自己没写好,就把自己好不容易建立起来的信任给弄没了.<br>但是笔记呢,就是自己看,不需要发表出来,也不用担心写的好不好,遣词造句这些都不需要考虑,所以就写的比较随意,一个笔记,可能一分钟两分钟就完事了.结果呢?<br>我自己记的笔记,有时候过一段时间再回来看,我这儿写的啥,这上下文啥意思,一脸懵逼.嗯,就是随意到这种程度.<br>所以「写作」和「笔记」不一样,受众不一样,花费的时间不一样,质量也就不一样,而且留给自己的印象也不一样.<br>如果可以,还是尽可能的「写作」吧.</font></p><h1 id="什么人最适合写作"><a href="#什么人最适合写作" class="headerlink" title="什么人最适合写作"></a><font face="华文中宋" size="3">什么人最适合写作</font></h1><p><font face="华文中宋" size="3">请注意一下,我这里说的是「最适合」,并不是说不是这类型的人就不适合写作,而且这是我个人的观点,你可以不赞同.<br>我觉得大学生最适合写作.之所以这样认为,是有以下几点:</font></p><p><font face="华文中宋" size="3">1 ,有时间.<br>在大学里面的自由时间真的是太多了.一天除了上课之外,其余的时间都是自己的,最爽的是还有周六日.<br>工作之后就不一样了,首先工作之后,每天的 8 个小时是肯定要给公司的,等到公司这边忙完了,下班了,上司叫你去一个饭局;男/女朋友想让你陪她溜达溜达…你发现了嘛,等你工作之后,你的时间就已经不是你的时间了.<br>好,就算下班之后,你什么事情都没有,工作了一天,觉得很累吧?自制力差点儿的,想放松放松,刷刷抖音吧?所以就算下班之后,什么事情都没有,还能有人逼着自己去学习,去思考,去写作,不能说没有,但是很少.<br>对了,上面的情况,还没算加班.这样一对比,就能发现在大学,能够利用的时间,真的是太多太多了.</font></p><p><font face="华文中宋" size="3">2 ,没有压力.<br>大学生有什么压力呢?不用买房;不需要考虑父母年纪大的问题;还没成家,不需要考虑孩子的问题,不需要考虑婆媳关系.没钱了,给父母打个电话,上一秒还穷的不行,下一秒就富得流油.<br>所以写作这件事,对于大学生来说,是一件毫无压力的事情.我今天有灵感,就多写点儿,明天心情不开心,就不写了.也不用刻意的去追求,这篇文章要达到多少多少的阅读量,随心而动,率性而为.<br>但是工作了的人,你跟他说,好好写作吧,写作给你带来了很多很多的好处,他们都听不进去的.<br>也可能听得进去,也可能想要去做,但是一篇文章需要耗费好几个小时,还需要写很长时间才能有效果,他们就熬不下去了.</font></p><p><font face="华文中宋" size="3">3 ,写作这件事情,肯定是越早开始越好.<br>什么?你还想问问我为什么这件事越早开始越好?建议你再翻到上面,看看写作给你带来了什么好处.<br>系统性的思考,这种能力,越早锻炼自己,在以后越能少走弯路.通过写作,让自己的思考慢慢变的严谨,想法慢慢变得成熟,知识慢慢变得系统.<br>这种能力,动动小脑就应该知道,越早培养越好,对吧!</font></p><p><font face="华文中宋" size="3">所以写作这件事,对大学生来说,真的是再适合不过了.(不要脸的说一句,我就是活生生的一个例子)</font></p><h1 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a><font face="华文中宋" size="3">最后说几句</font></h1><p><font face="华文中宋" size="3">写作这件事情,如果认认真真去做,坚持下来,直到成为习惯,真的可以给你带来很多东西,但是这些东西都是无形的,就像前面说到的,系统性的思考,影响力,这些都没办法去量化.<br>但是如果因为看不到写作的意义,就不去写作,我觉得是一件非常可惜的事情.<br>生活中很多事情,其实我们都看不到它的意义,但是正因为这样,生活才充满了无限可能和乐趣,对不对?</font></p><p><font face="华文中宋" size="3">以上.<br>非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java]说说 JDBC ,再聊聊 ODBC</title>
      <link href="/posts/7f1c23b6.html"/>
      <url>/posts/7f1c23b6.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果要了解 J2EE 的知识,就不可避免的接触到 13 种规范.作为规范之一的 JDBC 吸引起了我的注意,因为我比较了解 ODBC .<br>所以这篇文章,就先说说 JDBC ,然后咱们再聊聊 ODBC ,最后再对比说一下,这样印象更深刻一些.<br><a id="more"></a></font></p><h1 id="JDBC"><a href="#JDBC" class="headerlink" title=" JDBC"></a><font face="华文中宋" size="3"> JDBC</font></h1><p><font face="华文中宋" size="3">JDBC ( Java DataBase Connectivity , Java 数据库连接)是一种用于执行 SQL 语句的 Java API ,可以为多种关系数据库提供统一访问,由一组用 Java 语言编写的类和接口组成.<br>使用 JDBC 的步骤:加载 JDBC 驱动程序 –&gt;建立数据库连接 Connection –&gt;创建执行 SQL 的语句 Statement –&gt;处理执行结果 ResultSet –&gt;释放资源<br>既然是和数据库相关,就不可避免谈谈 JDBC 常用接口:</font></p><ul><li><font face="华文中宋" size="3">1 , Driver 接口<br><font face="华文中宋" size="3">Driver 接口由数据库厂家提供,作为java开发人员,只需要使用 Driver 接口就可以了.在编程中要连接数据库,必须先装载特定厂商的数据库驱动程序,不同的数据库有不同的装载方法.</font></font></li><li><p><font face="华文中宋" size="3">2 , Connection 接口<br><font face="华文中宋" size="3">connection 与特定数据库的连接,在连接上下文中执行 sql 语句并返回结果. DriverManager.getConnection(url, user, password) 方法建立在 JDBC URL 中定义的数据库 Connection 连接上.<br>常用方法:</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createStatement() :创建向数据库发送 sql 的 statement 对象</span><br><span class="line">prepareStatement(sql) :创建向数据库发送预编译 sql 的 PrepareSatement 对象</span><br><span class="line">prepareCall(sql) :创建执行存储过程的 callableStatement 对象</span><br><span class="line">setAutoCommit(boolean autoCommit) :设置事务是否自动提交</span><br><span class="line">commit() :在链接上提交事务</span><br><span class="line">rollback() :在此链接上回滚事务</span><br></pre></td></tr></table></figure></li><li><p><font face="华文中宋" size="3">3 , Statement 接口<br><font face="华文中宋" size="3">用于执行静态 SQL 语句并返回它所生成结果的对象<br>常用的 Statement 方法：</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute(String sql) :运行语句,返回是否有结果集</span><br><span class="line">executeQuery(String sql) :运行 select 语句,返回 ResultSet 结果集</span><br><span class="line">executeUpdate(String sql) :运行 insert/update/delete 操作,返回更新的行数</span><br><span class="line">addBatch(String sql) :把多条 sql 语句放到一个批处理中</span><br><span class="line">executeBatch() :向数据库发送一批 sql 语句执行</span><br></pre></td></tr></table></figure></li><li><p><font face="华文中宋" size="3">4 , ResultSet 接口<br><font face="华文中宋" size="3">ResultSet 提供检索不同类型字段的方法,常用的有:</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getString(int index),getString(String columnName) :获得在数据库里是 varchar,char 等类型的数据对象</span><br><span class="line">getFloat(int index),getFloat(String columnName) :获得在数据库里是 Float 类型的数据对象</span><br><span class="line">getDate(int index),getDate(String columnName) :获得在数据库里是 Date 类型的数据</span><br><span class="line">getBoolean(int index),getBoolean(String columnName) :获得在数据库里是 Boolean 类型的数据</span><br><span class="line">getObject(int index),getObject(String columnName) :获取在数据库里任意类型的数据</span><br></pre></td></tr></table></figure></li></ul><p><font face="华文中宋" size="3">使用之后,依次关闭的对象及连接为: ResultSet –&gt; Statement –&gt; Connection</font></p><h1 id="ODBC"><a href="#ODBC" class="headerlink" title=" ODBC"></a><font face="华文中宋" size="3"> ODBC</font></h1><p><font face="华文中宋" size="3">在上面说了 JDBC ,我觉得看到 JDBC ,应该能够想到 ODBC ,所以接下来咱们聊聊 ODBC .<br>ODBC ( Open Database Connectivity )开放数据库连接,是为了解决异构数据库间的数据共享而产生的,用于对数据库的访问.<br>ODBC 实际上是一个数据库访问函数库,这样可以使得程序可以直接操纵数据库中的数据. ODBC 是基于 SQL 语言的,是一种在 SQL 和应用界面之间的标准接口,这样就免除了应用软件随着数据库的改变而进行改变的麻烦.<br>所以 ODBC 的一个显著优点就是:它生成的程序与数据库或数据库引擎是无关的,这样就为数据库用户和开发人员屏蔽了异构环境的复杂性,提供了数据库访问的一个统一接口,也就使得应用程序实现与平台的无关性和可移植性成为了可能.</font></p><li> <font face="华文中宋" size="3">ODBC 主要由四部分构成:应用程序,驱动程序管理器,驱动程序,数据源.<br><ul><br>     <li><font face="华文中宋" size="3">应用程序( Application ),主要任务有:连接数据库,提交 SQL 语句给数据库,检索结果并处理错误,提交或者回滚 SQL 语句的事务,与数据库断开连接<br>     <li><font face="华文中宋" size="3">驱动程序管理器 ( Driver Manager ):每种数据库引擎都需要向 ODBC 驱动程序管理器注册自己的 ODBC 驱动程序,这种驱动程序对于不同的数据库引擎是不同的. ODBC 驱动程序管理器能将与 ODBC 兼容的 SQL 请求从应用程序传给驱动程序,随后由驱动程序把对数据库的操作翻译成相应数据库引擎所提供的固有调用,对数据库实现访问操作.<br>     <li><font face="华文中宋" size="3">驱动程序:驱动程序是一个用于支持 ODBC 函数调用的模块,应用程序调用驱动程序所支持的函数来操纵数据库.若想使应用程序操作不同类型的数据库,就要动态连接到不同的驱动程序上. ODBC 驱动程序处理 ODBC 函数调用,将应用程序的 SQL 请求提交给指定的数据源,接受由数据源返回的结果,传回给应用程序.<br>     <li><font face="华文中宋" size="3">数据源:是用户,应用程序要访问的数据文件或数据库,以及访问他们需要的有关信息.它定义了数据库服务器的名称,登录名和密码等选项<br></font></li></font></li></font></li></font></li></ul></font></li> <h1 id="JDBC-与-ODBC"><a href="#JDBC-与-ODBC" class="headerlink" title=" JDBC 与 ODBC"></a><font face="华文中宋" size="3"> JDBC 与 ODBC</font></h1><p><font face="华文中宋" size="3">先说说 JDBC 和 ODBC 的联系.<br>JDBC 和 ODBC 都是用来连接数据库的启动程序, JDBC 和 ODBC 由于具有数据库独立性甚至平台无关性,因而对 Internet 上异构数据库的访问提供了很好的支持.</font></p><p><font face="华文中宋" size="3">接下来,说说 JDBC 与 ODBC 的区别(参考自:<a href="https://www.geeksforgeeks.org/difference-odbc-jdbc/" target="_blank" rel="noopener">Difference between ODBC and JDBC</a>):</font></p><table><thead><tr><th style="text-align:center">ODBC</th><th style="text-align:center">JDBC</th></tr></thead><tbody><tr><td style="text-align:center">ODBC Stands for Open Database Connectivity.</td><td style="text-align:center">JDBC Stands for java database connectivity.</td></tr><tr><td style="text-align:center">Introduced by Microsoft in 1992.</td><td style="text-align:center">Introduced by SUN Micro Systems in 1997.</td></tr><tr><td style="text-align:center">We can use ODBC for any language like C,C++,Java etc.</td><td style="text-align:center">We can use JDBC only for Java languages.</td></tr><tr><td style="text-align:center">We can choose ODBC only windows platform.</td><td style="text-align:center">We can Use JDBC in any platform.</td></tr><tr><td style="text-align:center">Mostly ODBC Driver developed in native languages like C,C++.</td><td style="text-align:center">JDBC Stands for java database connectivity.</td></tr><tr><td style="text-align:center">For Java applications it is not recommended to use ODBC because performance will be down due to internal conversion and applications will become platform Dependent.</td><td style="text-align:center">For Java application it is highly recommended to use JDBC because there we no performance &amp; platform dependent problem.</td></tr><tr><td style="text-align:center">ODBC is procedural.</td><td style="text-align:center">JDBC is object oriented.</td></tr></tbody></table><p><font face="华文中宋" size="3">你如果跟我说,看不明白,那就踏实学英语去吧!<br>以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[mysql]修改 mysql 数据库端口</title>
      <link href="/posts/ade78a36.html"/>
      <url>/posts/ade78a36.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">背景:在一台 Linux 服务器上,安装了两个 mysql ,那么为了我能够同时连接到 mysql ,就需要对另外一个 mysql 修改连接端口.<br><a id="more"></a><br>修改 mysql 数据库之前,查看一下当前使用端口,命令(需要进入到 mysql 中进行操作),命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &apos;port&apos;;</span><br></pre></td></tr></table></figure></font></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3235nfvcaj30be036glo.jpg"></p><p><font face="华文中宋" size="3">可以看到,当前使用端口为 3306<br>接下来进入到 /etc 找到 my.cnf 文件,修改内容如下:<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g32369loe4j30di044q37.jpg"></font></p><p><font face="华文中宋" size="3">修改完成之后,重新启动 mysql 数据库,命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure></font></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3236vi7l6j30bl0403ym.jpg"></p><p><font face="华文中宋" size="3">此时,我们看到,已经修改成功.<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g323aigqywj30bg035t8t.jpg"></font></p><p><font face="华文中宋" size="3">端口已经修改成功了,如果 Navicat 连接不上 mysql 的话,就需要看看防火墙有没有打开相应的端口.想要打开特定端口,查看这篇文章吧,实在是懒得写了:<a href="https://blog.csdn.net/zll_0405/article/details/81208606" target="_blank" rel="noopener">CentOS7 开启防火墙及特定端口</a></font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[运维] proxmox ve 与 vSphere 对比</title>
      <link href="/posts/f77b1752.html"/>
      <url>/posts/f77b1752.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">一直关注我的博友,应该知道我曾经捣鼓过 vSphere 相关的内容,写过一个专栏: <a href="https://blog.csdn.net/zll_0405/column/info/21107" target="_blank" rel="noopener">VMware vSphere</a> ,起码有些许的成绩了,支撑起了公司大大小小的项目,虽然出过问题,但最后都有惊无险的熬了过来.<br><a id="more"></a><br>也算是基于兴趣,对这方面一直都有关注.前几天,贺信找到我,说发现了一个可以尝试的系统软件: proxmox ve (为了方便,下面我就写 proxmox 系统了).<br>在了解它之后,发现这个系统软件还真的不错,后期看看能不能推进一下这个方案,争取把这个方案落地.</font></p><p><font face="华文中宋" size="3">为什么想要推进这个方案,让它落地呢.我主要有以下几点考虑:<br>1 , proxmox ve 是开源的,而 vSphere 是收费的.<br>开源和收费,我觉得都没多大关系,只要符合自己公司当前发展的需求,我觉得付费也是 OK 的.但是开源的在于,它的氛围很不错,而且我看了一下,遇到的问题都有人写出过解决方案,这一点我是很看好的.(不过大部分解决方案都是英文,说明了英语的重要性)<br>vSphere 产品遇到问题的时候,一般查找不到相关解决资料,都是自己各种尝试,不知道哪儿懵对了,机器就好了,排查问题的时候,真的是靠个人经验.这一点,从我博客里面就能看出来,访问量最多的就是写 vSphere 的那几篇文章.说明在这方面沉淀的人少,所以搜索引擎把我的文章推出来.<br>而 proxmox ve 是开源的,这样就比较能够放心让别人大胆尝试,不至于遇到问题的时候,总是那几个人上,每个人都有锻炼的机会.<br>当然了,如果你真的比较土豪,购买 proxmox ve 系统也是 OK 的.</font></p><p><font face="华文中宋" size="3">2 , proxmox 虚拟机使用的是 kvm ,容器则使用的是 LXC( Linux Container ),也就是说,容器这方面相当于原生的,对于各类常见的应用软件容器,就不用再单独创建 Linux 虚拟机,可以直接在虚拟机上安装相关容器即可.<br>但是 proxmox 对物理服务器的限制是设定在 32 台物理主机,所以如果物理主机比较多的话,而且还需要统一集中在一个集群管理,它可能就不是最好的解决方案了.<br>但是就目前公司的需求来说,我觉得使用 proxmox 还是能够满足需求的.</font></p><p><font face="华文中宋" size="3">3 ,proxmox 支持市面上几乎所有的主流存储协议,特别是对 ceph 分布式存储的支持.这意味着,通过 ceph 可以实现虚拟机的 HA 功能,虚拟机动态迁移等高级特性,而且我觉得在以后,大数据是一个趋势,所以能够支持分布式存储的话,这一个优点无疑是比较吸引人的.</font></p><p><font face="华文中宋" size="3">4 , vSphere 出于商业收费和 license 的考虑,将很多功能进行了拆分,安装完 ESXi 之后,只能使用基本功能,如果想要使用高级功能,必须安装 vcenter 来进行相关操作才可以.<br>相比较之下, proxmox 就友好很多,安装完成之后,所有集群的物理节点都是平等的,通过每个物理节点都可以管理整个集群.<br>如果只是从稳定性来看的话, proxmox ve 和 vSphere 可以说是旗鼓相当,但是硬件兼容性则没有 proxmox 好,而且在 proxmox 中没有主次节点之分,所以它能够最大化的提高硬件的使用效率.</font></p><p><font face="华文中宋" size="3">5 ,这是最重要的一个原因: proxmox 相对于 vSphere 来说,它少了一层.<br>vSphere 的架构是:在服务器上安装 ESXi 系统,然后通过 vcenter 去管理,通过 vcenter 来创建虚拟机,管理集群等.<br>而 proxmox 架构是:在服务器上安装 proxmox 系统之后,就可以在上面创建虚拟机,随便访问一台物理节点,都可以来管理整个集群.<br>发现不同了嘛?好吧,我觉得你可能没发现.<br>proxmox 不需要经过 vcenter 这一层的管理,也就是少了一层通信.这一层通信少了之后,就可能将整个集群的读取速度,反应速度提升一个层次.<br>如果非要举个例子来说明的话(这个例子可能不太恰当,但是想不起来合适的了),就相当于你的笔记本从原来用机械硬盘,到后来改用固态,那种速度之间的差别,你可以想想.</font></p><p><font face="华文中宋" size="3">基于以上吧,我个人是觉得这个方案可以尝试去做.<br>后期看时间和精力,看看能不能弄起来.</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxmox ve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java]说说 JRE , JDK , JVM 三者之间的区别与联系</title>
      <link href="/posts/dfd14d26.html"/>
      <url>/posts/dfd14d26.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在写了很多代码之后,如果问 jre 和 jdk 之间有什么关系, jvm 又是什么,估计有相当一部分人不知道在说什么.所以这篇文章,就尝试解释一下这三者之间的区别和联系.<br><a id="more"></a></font></p><table><tr><td bgcolor="#1E90FF"><font face="楷体" color="white" size="5">基本概念</font></td></tr></table><p><font face="华文中宋" size="3">咱们先来说说, jvm , jre , jdk 都是什么.</font></p><p><font face="华文中宋" size="5">JVM ( Java Virtual Machine ):</font></p><p><font face="华文中宋" size="3">就是常说的 java 虚拟机,顾名思义,它就是一个虚拟出来的计算机,通过在实际的计算机上模拟各种计算机功能来实现.<br>JVM 是 java 实现跨平台最核心的部分,所有的 java 程序,首先会被编译成 .class 的类文件, JVM 的主要工作是解释自己的指令集(即字节码)并映射到本地的 CPU 的指令集或 OS 的系统调用. java 面对不同操作系统使用不同的虚拟机,这样实现了跨平台.<br>因为 JVM 对上层的 java 源文件怎样是不关心的,它关心的是由源文件生成的类文件.</font></p><p><font face="华文中宋" size="5">JRE ( Java Runtime Environment ):</font></p><p><font face="华文中宋" size="3">java 运行时环境.<br>它主要包括两部分: jvm 的标准实现和 java 的一些基本类库还有一些模块等.<br>在 java 平台下,所有的 java 程序都需要在 JRE 下才能运行,这是因为在解释 class 时, JVM 需要调用解释所需要的类库 lib .<br>可以看看自己下载的 jre ,里面有 bin 和 lib , 在这里可以认为 bin 就是 JVM , lib 就是 JVM 所需要的类库. JVM 和 lib 合起来就称为 JRE .</font></p><p><font face="华文中宋" size="5">JDK (Java Development Kit ):</font></p><p><font face="华文中宋" size="3"> java 开发工具包.<br>jdk 是整个 java 开发的核心,包括了 java 的运行环境,一堆 java 工具和 java 基础的类库.你可以将 JDK 看成是 JRE 的一个超集.<br>由上,我们能够看出来,这三者之间的关系是层层嵌套的:<strong> JDK 包含 JRE , 而 JRE 包含 JVM .</strong></font></p><table><tr><td bgcolor="#1E90FF"><font face="楷体" color="white" size="5">Q &amp; A</font></td></tr></table><p><font face="华文中宋" size="3">在以上基础上,面试的时候,就有的问了.<br>比如:<br>Q : java 为什么能够跨平台,实现” write once , run anywhere “<br>A : java 能够跨平台运行的核心在于 jvm ,所以并不是 java 能够跨平台,而是它的 jvm 可以做到跨平台.<br>java 引入了字节码的概念, jvm 只认识字节码,并将它们解释到系统的 API 调用.不同的系统有不同的 jvm 实现,有 Linux 版本的 jvm 实现,也有 Windows 版本的 jvm 实现,但是同一段代码在编译后的字节码是一样的.<br>也就是说,我想要实现的功能,因为编译生成的字节码是唯一的,所以和系统无关,因为在不同的 jvm 实现上会映射到不同系统的 API 调用,从而实现了代码不做任何修改,就可以跨平台运行.</font></p><p><font face="华文中宋" size="3">Q : jdk 和 jre 有什么区别<br>A : 把&lt;基本概念&gt;里面的内容说说,然后再说一下在实际中:如果只是想跑 java 程序,只安装 jre 就可以了,如果想要写 java 程序并且运行,就需要 jdk .</font></p><p><font face="华文中宋" size="3">如果能够玩转 jre  , jdk , jvm ,你就可以骄傲的说,你有扎实的 java 基础了.<br>在这里推荐两篇博客,好好阅读,会有很多收获.<br><a href="http://www.cnblogs.com/zuoxiaolong/p/life51.html" target="_blank" rel="noopener">回答阿里社招面试如何准备，顺便谈谈对于Java程序猿学习当中各个阶段的建议</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/life53.html" target="_blank" rel="noopener">万能的林萧说：一篇文章教会你，如何做到招聘要求中的“要有扎实的Java基础”。</a></font></p><p><font face="华文中宋" size="3">感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Linux]时间同步设置 + 防火墙设置 + SELinux 设置</title>
      <link href="/posts/d1d9f7bd.html"/>
      <url>/posts/d1d9f7bd.html</url>
      
        <content type="html"><![CDATA[<table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> 时间同步设置</font></td></tr></table><p><font face="华文中宋" size="3">在大数据集群环境中，要求每台集群的时间必须是同步的，这样我们就会要求每台集群的时间必须和一台服务的时间是同步的。接下来介绍一下步骤：<br><a id="more"></a><br>1，设置ntp客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp 安装ntp时间同步软件</span><br><span class="line">systemctl enable ntpd 使软件可用</span><br><span class="line">systemctl start ntpd 启动ntp软件</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2，编辑/etc/ntp.conf文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ntp.conf</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">重点修改以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Use public servers from the pool.ntp.org project.</span><br><span class="line"># Please consider joining the pool (http://www.pool.ntp.org/join.html).</span><br><span class="line">#server 0.centos.pool.ntp.org iburst</span><br><span class="line"> </span><br><span class="line">server 192.168.243.133   -------&gt;（此处需要修改，以哪台为准就写那台的IP）</span><br><span class="line"> </span><br><span class="line">restrict 192.168.243.133 nomodify notrap noquery-------&gt;（此处需要修改，以哪台为准就写那台的IP）</span><br><span class="line"> </span><br><span class="line">server 192.168.243.***     -------&gt;（本机IP是多少就写多少）</span><br><span class="line">fudge 192.168.243.*** -------&gt;（本机IP是多少就写多少） stratum 10</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">3，重启ntpd服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ntpd</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">4，启动后，查看同步情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpq -p</span><br><span class="line">ntpstat</span><br></pre></td></tr></table></figure></font></p><table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> 防火墙设置</font></td></tr></table><p><font face="华文中宋" size="3">关闭firewall：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时关闭防火墙: systemctl stop firewalld </span><br><span class="line">永久关闭防火墙： systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">关闭iptables：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭命令： service iptables stop </span><br><span class="line">永久关闭防火墙：chkconfig iptables off </span><br><span class="line">检查防火墙状态：service iptables status</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看防火墙状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">检查firewall的状态：systemctl status firewalld.service</span><br><span class="line">检查iptables状态：service iptables status</span><br></pre></td></tr></table></figure></font></p><table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> SELinux设置</font></td></tr></table><p><font face="华文中宋" size="3">1，临时关闭SELinux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2，永久关闭SELinux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line">将配置文件中SELINUX=enforcing改为SELINUX=disabled</span><br><span class="line">注：修改配置文件需要重启机器，但我们已临时关闭SELinux，等下次机器重启后，配置文件自动生效</span><br></pre></td></tr></table></figure></font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
