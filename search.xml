<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[碎碎念]这周没有输入的我</title>
      <link href="/posts/76fe9e7d.html"/>
      <url>/posts/76fe9e7d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">一篇没有营养的文章<br>这不是今年的最后一个月了嘛,所以我最近的精力就在年终总结上了,写了几个版本都不满意,还在重新推翻重新写<br>然后,最后的这一个月,除了工作时间,其他时间几乎都约出去了,想着在 2021 年之前尽可能多见一些自己在乎的人吧,如果再不见的话,再见面就是 2021 年了,仪式感还是要有的</font></p><p><font face="华文中宋" size="3">这几天简单的复盘了一下去年的目标,除了一个目标没有实现之外,其他的目标都实现了,整体来说,对自己的表现还算满意吧,其实有些地方还是可以做的更好的,那就是明年要改进的地方了<br>今天和几个朋友去吃好吃的去了,吃了一肚子肉回来的我,现在满脑子大搞就是想要睡觉了~</font></p><p><font face="华文中宋" size="3">这周文章就是这样,没啥营养<br>依旧感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java]面试官你能不能别问我 HashMap 了?</title>
      <link href="/posts/7163f33e.html"/>
      <url>/posts/7163f33e.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果你是个 Java 程序员,那一定对 HashMap 不陌生,巧的是只要你去面试,大概率都会被问到 HashMap 的相关内容<br>基于此,就总结一篇,争取不让面试官问倒~<br><a id="more"></a></font></p><h1 id="HashMap-的底层数据结构"><a href="#HashMap-的底层数据结构" class="headerlink" title="HashMap 的底层数据结构"></a><font face="华文中宋" size="3">HashMap 的底层数据结构</font></h1><p><font face="华文中宋" size="3">先来聊聊 HashMap 的底层数据结构<br>HashMap 的底层数据结构, 1.7 版本和 1.8 版本是有些不同的,但大体上都是 数组 + 链表 的形式来实现的<br>1.7 版本是这个样子:<br><img src="https://img-blog.csdnimg.cn/2020112912213098.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">1.8 版本是这样:<br><img src="https://img-blog.csdnimg.cn/2020112912221571.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">很明显就能看出来, 1.8 版本怎么多了一个树?还是红黑的?<br>这就要来分析 1.7 版本 HashMap 的实现有什么不足了.<br>1.7 版本主要就是 数组 + 链表,那么如果有一个 hash 值总是会发生碰撞,那么由此对应的链表结构也会越来越长,这个时候如果再想要进行查询操作,就会非常耗时,所以该如何优化这一点就是 1.8 版本想要实现的<br>1.8 版本采用了 数组 + 链表 + 红黑树 的方式去实现,当链表的长度大于 8 时,就会将链表转为红黑树.</font></p><p><font face="华文中宋" size="3">这个时候问题就来了,为什么会将链表转红黑树的值设定为 8 ?<br>这个问题我们或许可以从源码中窥探一二:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution </span><br><span class="line">with a parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing threshold of <span class="number">0.75</span>, although </span><br><span class="line">with a large variance because of resizing granularity. Ignoring variance, the expected </span><br><span class="line"><span class="function">occurrences of list size k <span class="title">are</span> <span class="params">(exp(<span class="number">-0.5</span>)</span> * <span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span> / <span class="title">factorial</span><span class="params">(k)</span>). </span></span><br><span class="line"><span class="function">The first values are:</span></span><br><span class="line"><span class="function">      0:    0.60653066</span></span><br><span class="line"><span class="function">      1:    0.30326533</span></span><br><span class="line"><span class="function">      2:    0.07581633</span></span><br><span class="line"><span class="function">      3:    0.01263606</span></span><br><span class="line"><span class="function">      4:    0.00157952</span></span><br><span class="line"><span class="function">      5:    0.00015795</span></span><br><span class="line"><span class="function">      6:    0.00001316</span></span><br><span class="line"><span class="function">      7:    0.00000094</span></span><br><span class="line"><span class="function">      8:    0.00000006</span></span><br><span class="line"><span class="function">      more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">为什么将链表转为红黑树,而不是平衡二叉树( AVL 树)呢?</font></p><ul><li><font face="华文中宋" size="3">因为 AVL 树比红黑树保持着更加严格的平衡, AVL 树中从根到最深叶的路径最多为 <code>1.44lg(n + 2)</code> ,红黑树中则最多为 <code>2lg( n + 1)</code> ,所以 AVL 树查找效果会比较快,如果是查找密集型任务使用 AVL 树比较好,相反插入密集型任务,使用红黑树效果就比较 nice</font></li><li><font face="华文中宋" size="3">AVL 树在每个节点上都会存储平衡因子</font></li><li><font face="华文中宋" size="3">AVL 树的旋转比红黑树的旋转更加难以平衡和调试,如果两个都给 O(lgn) 查找, AVL 树可能需要 O(log n) 旋转,而红黑树最多需要两次旋转使其达到平衡</font></li></ul><h1 id="HashMap-为什么是线程不安全的"><a href="#HashMap-为什么是线程不安全的" class="headerlink" title="HashMap 为什么是线程不安全的?"></a><font face="华文中宋" size="3">HashMap 为什么是线程不安全的?</font></h1><p><font face="华文中宋" size="3">HashMap 的线程不安全主要体现在两个方面: 扩容时导致的死循环 &amp; 数据覆盖<br>扩容时导致的死循环,这个问题只会在 1.7 版本及以前出现,因为在 1.7 版本及以前,扩容时的实现,采用的是头插法,这样就会导致循环链表的问题<br>什么时候会触发扩容呢?如果存储的数据,大于 当前的 <code>HashMap 长度( Capacity ) * 负载因子( LoadFactor )</code> 时,就会发生扩容.比如当前容量是 16 , <code>16 * 0.75 = 12</code> ,当存储第 13 个元素时,经过判断发现需要进行扩容,那么这个时候 HashMap 就会先进行扩容的操作<br>扩容也不是简简单单的将原来的容量扩大就完事儿了,扩容时,首先创建一个新的 Entry 空数组,长度是原数组的 2 倍,扩容完毕之后还会再进行 ReHash ,也就是将原 Entry 数组里面的数据,重新 hash 到新数组里面去<br>假设现在有一个 Entry 数组,大小是 2 ,那么当我们插入第 2 个元素时,大于 <code>2 * 0.75</code> 那么此时就会发生扩容,具体如下图:<br><img src="https://img-blog.csdnimg.cn/20201129192459721.jpg#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">扩容完毕之后,因为采用的是头插法,所以后面的元素会放在头部位置,那么就可能会这样:<br><img src="https://img-blog.csdnimg.cn/20201129193144151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">刚开始记录的是 <code>A.next = B</code> ,经过扩容之后是 <code>B.next = A</code> ,那么最后可能就是这样了:<br><img src="https://img-blog.csdnimg.cn/20201129193349908.jpg#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">明显看到造成了死循环,比较好的是, 1.8 版本之后采用了尾插法,解决了这个问题<br>还有个问题, 1.8 版本是没有解决的,那就是数据覆盖问题<br>假设现在线程 A 和线程 B 同时进行 put 操作,特别巧的是这两条不同的数据 hash 值一样,并且这个位置数据为 null ,那么是不是应该让线程 A 和 B 都执行 put 操作.假设线程 A 在要进行插入数据时被挂起,然后线程 B 正常执行将数据插入了,然后线程 A 获得了 CPU 时间片,也开始进行数据插入操作,那么就将线程 B 的数据给覆盖掉了<br>因为 HashMap 对 put 操作没有进行加锁的操作,那么就不能保证下一个线程 get 到的值,就一定是没有被修改过的值,所以 HashMap 是不安全的</font></p><h1 id="那既然-HashMap-线程不安全-你给推荐一个安全的"><a href="#那既然-HashMap-线程不安全-你给推荐一个安全的" class="headerlink" title="那既然 HashMap 线程不安全,你给推荐一个安全的?"></a><font face="华文中宋" size="3">那既然 HashMap 线程不安全,你给推荐一个安全的?</font></h1><p><font face="华文中宋" size="3">如果推荐的话,那肯定推荐 ConcurrentHashMap ,说到 ConcurrentHashMap 也有一个比较有趣的事情,那就是 ConcurrentHashMap 的 1.7 版本和 1.8 版本实现也不是很一样<br>在 1.7 版本, ConcurrentHashMap 采用的是分段锁( ReentrantLock + Segment + HashEntry )实现,也就是将一个 HashMap 分成多个段,然后每一段都分配一把锁,这样去支持多线程环境下的访问.但是这样锁的粒度太大了,因为你锁的直接就是一段嘛<br>所以 1.8 版本又做了优化,使用 CAS + synchronized + Node + 红黑树 来实现,这样就将锁的粒度降低了,同时使用 synchronized 来加锁,相比于 ReentrantLock 来说,会节省比较多的内存空间</font></p><p><font face="华文中宋" size="3">HashMap 这块,其实还可以扩展,比如 HashMap 和 HashTable 的区别, ConcurrentHashMap 1.7 版本和 1.8 版本具体的实现,等等等等<br>但是这篇文章已经比较长了,就写到这里吧~<br>感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JVM]来说说垃圾回收怎么样~</title>
      <link href="/posts/a228901d.html"/>
      <url>/posts/a228901d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">JVM 的自动内存管理,让原本应该是开发人员去做的事情,变成了垃圾回收器来做的事情<br><a id="more"></a><br>既然是别人帮忙做的事情,那么可能就不是自己想要的,所以就需要我们了解一下垃圾回收相关的内容</font></p><h1 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a><font face="华文中宋" size="3">引用计数法与可达性分析</font></h1><p><font face="华文中宋" size="3">垃圾回收,垃圾回收,那就是有的内存分配给了一些对象,但是这些对象已经用完了,那么它所占用的内存也就应该该释放掉了,却还没有释放<br>那么,这里就有个问题:该如何确定一个对象用完了呢?<br>其中一种方法就是引用计数法</font></p><p><font face="华文中宋" size="3">引用计数法就是给每个对象添加一个引用计数器,来统计指向该对象的引用个数<br>比如:如果有一个引用,被赋值为某一个对象,那么这个对象的引用计数器就 +1 ,如果一个指向这个对象的引用,被赋值为了其他的值,那么这个对象的引用计数器就 -1 ,这样如果这个对象的引用计数器为 0 ,我们就可以认为这个对象已经使用完毕,它所占用的内存空间可以回收掉了<br>这种方案听上去无懈可击,但是有一个致命的漏洞,就是没办法处理循环引用的问题<br>比如说: A 和 B 互相引用,除此之外也没有其他的引用指向 A 或者 B ,在这种情况下,其实 A 和 B 所占用的内存就可以释放掉了,但是因为它们互相都有引用,所以此时的引用计数器并不为 0 ,在这种情况下,就不能对它们进行回收<br>现在只是两个对象,如果再来两个,再来两个,这样循环引用的对象多了之后,就会造成内存泄露</font></p><p><font face="华文中宋" size="3">基于引用计数法的弊端,当前 JVM 主流的垃圾回收器采取的是可达性分析算法<br>这个算法本质就是将一系列的 GC Roots 作为初始的存活对象合集( live set ),然后从这个合集出发,探索所有能够被该集合引用到的对象,并把这些对象加入到集合中来,这个过程就叫做标记( mark ),遍历到最后,没有被探索到的对象就是可以回收的对象<br>那么什么是 GC Roots 嘞?一般包括(但不限于)以下几种:</font></p><ul><li><font face="华文中宋" size="3">Java 方法栈桢中的局部变量</font></li><li><font face="华文中宋" size="3">已加载类的静态变量</font></li><li><font face="华文中宋" size="3">JNI handles</font></li><li><font face="华文中宋" size="3">已启动并且没有停止的 Java 线程</font></li></ul><p><font face="华文中宋" size="3">刚才说因为引用计数法存在循环引用的问题,所以目前主流垃圾回收器选用的都是可达性分析法,也就是说,它解决了循环引用问题,其实这一点也比较好理解,虽然 A 和 B 相互引用,但是这个时候从 GC Roots 开始出发,是没有办法到达 A 和 B 的,那么就不会把它们放到存活对象合集之中,自然也就会被回收掉<br>但是在实际中还是会有问题的,比如:在多线程环境下,就会有其他线程更新已经访问过的对象中的引用,但是是多线程并行的嘛,这个时候可达性分析法已经把这个引用设置成了 null ,或者这个对象还在使用,但可达性分析法把它标记为了没有被访问过的对象,被回收掉了,这种情况可能直接导致 JVM 崩溃掉</font></p><h1 id="Stop-the-world-amp-safepoint"><a href="#Stop-the-world-amp-safepoint" class="headerlink" title="Stop-the-world &amp; safepoint"></a><font face="华文中宋" size="3">Stop-the-world &amp; safepoint</font></h1><p><font face="华文中宋" size="3">既然可达性分析法也有自己的一些缺陷,总得有解决方案吧?比较暴力的一种方法就是 Stop-the-world ,估计听名字也能知道,就是让全世界都停下来,也就是说,在进行垃圾回收的时候,其他所有非垃圾回收线程的工作都需要停下来,先让垃圾回收器工作完毕再说.这就是所谓的暂停时间( GC pause )<br>Stop-the-world 是通过安全点( safepoint )机制来实现的.啥意思嘞?咱先想个场景,现在你敲代码敲的特别开心,又有思路,状态又好,美滋滋的正在工作,突然毫无缘由的就让你现在不准敲代码,你会不会不开心?好不容易思路来了对吧,就一点儿理由都不给的就让我停下,不合理吧?<br>同样的场景,一个线程现在跑的特别 happy ,而且再有一秒钟就完成了任务,这个时候 JVM 收到了 Stop-the-world 请求,二话不说就把所有的线程给停掉,不太好吧?那么这个时候安全点( safepoint )机制就登场了.有了安全点机制,当 JVM 收到 Stop-the-world 请求的时候,它就会等待所有的线程都达到安全点,才允许请求 Stop-the-world 的线程进行独占的工作<br>那么,什么时候是安全点呢?举个例子来说:当 Java 程序通过 JNI 执行本地代码时,如果这段代码不访问 Java 对象,不调用 Java 方法,不返回到原 Java 方法,那么 Java 虚拟机的堆栈就不会发生改变,那这段本地代码就可以作为一个安全点.只要不离开这个安全点, JVM 就可以在垃圾回收的同时,继续运行这段本地代码<br>因为本地代码需要通过 JNI 的 API 来完成上述三个操作,因此 JVM 只需要在 API 的入口处进行安全点检测( safepoint poll ),看看有没有其他线程请求停留在安全点这里,就可以在必要的时候挂起当前线程</font></p><h1 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a><font face="华文中宋" size="3">垃圾回收的三种方式</font></h1><p><font face="华文中宋" size="3">当标记好存活的对象之后,就可以进行垃圾回收了<br>主流的垃圾回收方式,可以分为三种:清除( sweep ),压缩( compact ),复制( copy ).</font></p><p><font face="华文中宋" size="3">清除,就是把死亡对象所占据的内存标记成空闲内存,并把它记录在一个空闲列表( free list )中,当需要新建对象的时候,就直接在空闲列表中寻找空闲内存,划分给新建的对象就完了<br>但是这里会产生一个问题,因为死亡的对象所占据的内存可能是随机的,回收完毕之后,内存就是碎片化的,如果此时有对象申请一块连续的内存空间,尽管碎片化的内存空间是够用的,也没办法进行分配</font></p><p><font face="华文中宋" size="3">压缩,就是把存活的对象聚集到内存区域的起始位置,这样就可以留下一段连续的内存空间.这样去做的话,可以解决内存碎片化的问题,代价就是压缩算法带来的性能开销</font></p><p><font face="华文中宋" size="3">复制,就是把内存区域分成两等分,分别用两个指针 from 和 to 来维护,并且只是用 from 指针指向的内存区域来分配内存.当进行垃圾回收时,就把存活的对象复制到 to 指针指向的内存区域中,并且交换 from 指针和 to 指针的内容.<br>复制这种方式也可以解决内存碎片化的问题,但是它的缺点也是比较明显的,因为把内存区域分成了两等分嘛,那利用率就比较低咯,最高也是 50% 了,不能再高了</font></p><h1 id="垃圾回收在-JVM-中的应用"><a href="#垃圾回收在-JVM-中的应用" class="headerlink" title="垃圾回收在 JVM 中的应用"></a><font face="华文中宋" size="3">垃圾回收在 JVM 中的应用</font></h1><p><font face="华文中宋" size="3">上面说的三种垃圾回收方式是理论上的,那么在 JVM 中是如何应用的呢?<br>这就先要来了解下 JVM 的堆划分<br>大概就是这样子:</font></p><p><img src="/images/2020/内存区域划分.jpg"></p><p><font face="华文中宋" size="3">JVM 将堆划分为新生代和老年代,在新生代中又划分为 Eden 区,还有两个大小相同的 Survivor 区<br>当程序调用 new 指令时,会在 Eden 区中划出一块作为存储对象的内存,但是因为堆空间是线程共享的,所以在这里面划分空间的话就需要同步,要不然出现了两个对象共用一段内存,那不就该打架了嘛<br>JVM 为了避免两个对象打架的事情发生,就让每个线程向 JVM 申请一段连续的内存,来作为线程私有的 TLAB ( Thread Local Allocation Buffer ,对应虚拟机参数 <code>-XX:+UseTLAB</code> ,默认开启的)<br>Eden 区一直进行分配,总有空间分配完毕的时候,该怎么办?此时 JVM 就会触发一次 Minor GC ,来收集新生代的垃圾,存活下来的对象就会被送到 Survivor 区<br>在图中可以看到, Survivor 区有两个,一个是 from ,一个是 to ,其中 to 指向的 Survivor 区是空的</font></p><p><font face="华文中宋" size="3">当发生 Minor GC 时, Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区,然后交换 from 和 to 指针,这样就保证了下一次 Minor GC 时, to 指向的 Survivor 区还是空的<br>同时 JVM 会记录 Survivor 区的对象一共被来回复制了几次,如果一个对象被复制的次数为 15 (对应虚拟机参数 <code>-XX:+MaxTenuringThreshold</code> ),这个对象就会被晋升( promote )到老年代</font></p><p><font face="华文中宋" size="3">那么在发生 Minor GC 时,采用哪种垃圾回收方式会比较好一些呢?采用复制方式,也就是 标记-复制 算法会好一些.为什么呢?因为在新生代中,大部分的 Java 对象只存活一小段时间,那么我们就可以采用耗时比较短的垃圾回收算法,让大部分的垃圾都能在新生代被回收掉.使用 标记-复制 算法的话,理想情况下就是 Eden 区中的对象基本都死亡了,那么需要复制的数据非常少,此时这种算法的优势就被极大的体现了出来</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p><p><font face="华文中宋" size="3">参考:<br>极客时间  – 深入拆解 Java 虚拟机</font></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JVM] JVM 是如何加载 Java 类的?</title>
      <link href="/posts/743ef9a0.html"/>
      <url>/posts/743ef9a0.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">看到这个题目的时候,你可能就会觉得,这不是挺简单的一个问题么<br><a id="more"></a><br>如何加载?不就是 加载,链接,初始化 这三步嘛,说白了不就是类加载过程么<br>那么,你知道这三步具体又做了什么嘛?这就是本篇文章想要写的</font></p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a><font face="华文中宋" size="3">加载</font></h1><p><font face="华文中宋" size="3">加载的过程,就是查找字节流,并根据查找到的字节流来创建类的一个过程<br>Java 语言的类型可以分成两大类:基本类型和引用类型.基本类型就是由 JVM 预先定义好的,所以也就没有查找字节流这一说了<br>对于引用类型来说的话,又可以细分为四种:类,接口,数组类和泛型参数.因为泛型参数在编译过程中会被擦除,所以在 JVM 中就只有前三种.而数组类又是由 JVM 直接生成的,所以查找字节流的话,就只有类和接口了.</font></p><p><font face="华文中宋" size="3">那么 JVM 是怎么查找字节流的呢?如果你对这块内容比较熟的话,应该就能想起来类加载器,它主要有四类: 启动类加载器,扩展类加载器,应用程序类加载器和用户自定义类加载器<br>这块又有个知识点就是双亲委派机制:大概就是如果一个类加载器收到了类加载的请求,首先不会自己去加载这个类,而是把这个请求委派给父类加载器去完成.通过双亲委派机制就能保证同样一个类只被加载一次<br>经过类加载器之后,这个类就算是加载进来了</font></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a><font face="华文中宋" size="3">链接</font></h1><p><font face="华文中宋" size="3">链接这块又分为三部分:验证,准备,解析</font></p><p><font face="华文中宋" size="3">验证阶段就是想要看看 class 文件的前 8 位是不是 java 标识符,想看看符不符合规范什么的</font></p><p><font face="华文中宋" size="3">准备阶段就是给静态字段分配内存.除了分配内存之外,部分 JVM 还会在此阶段构造其他跟类层次相关的数据结构,比如说用来实现虚方法的动态绑定的方法表<br>在 class 文件被加载到 JVM 之前,这个类没办法知道其他类和方法,字段所对应的具体地址,甚至都不知道自己的方法,字段的地址,所以如果需要引用这些成员时, Java 编译器就会生成一个符号引用,在运行阶段,这个符号引用一般都可以准确的定位到具体目标上</font></p><p><font face="华文中宋" size="3">解析阶段主要就是将符号引用解析成实际引用.如果符号引用指向一个未被加载的类,或者没有被加载类的字段或方法,此时解析阶段就会触发这个类的加载(但不一定会触发这个类的链接以及初始化)</font></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><font face="华文中宋" size="3">初始化</font></h1><p><font face="华文中宋" size="3">在 Java 代码中,如果想要初始化一个静态字段,可以在声明的时候直接赋值,也可以选择在静态代码块中对它赋值<br>如果直接赋值的静态字段被 final 修饰了,而且这个静态字段是基本类型或者字符串时,就会被 Java  编译器标记成常量值,初始化就直接被 JVM 完成了.除此之外的直接赋值操作,还有所有静态代码块中的代码,就会被 Java 编译器放到同一个方法中,并且把它命名为 <code>&lt;clinit&gt;</code><br>类加载的最后一步就是初始化,就是给标记为常量值的字段赋值,执行 <code>&lt;clinit&gt;</code> 方法的过程.这个时候 JVM 会通过加锁来确保类的 <code>&lt;clinit&gt;</code> 方法只被执行一次<br>至此, JVM 成功的加载了 Java 类</font></p><h1 id="类的初始化何时会被触发"><a href="#类的初始化何时会被触发" class="headerlink" title="类的初始化何时会被触发?"></a><font face="华文中宋" size="3">类的初始化何时会被触发?</font></h1><p><font face="华文中宋" size="3">那么,类的初始化什么时候会被触发呢?<br>JVM 规范列举了以下几种触发情况:<br>1 , 当虚拟机启动时,初始化用户指定的主类;<br>2 ,当遇到用以新建目标类实例的 new 指令时,初始化 new 指令的目标类;<br>3 ,当遇到调用静态方法的指令时,初始化该静态方法所在的类;<br>4 ,当遇到访问静态字段的指令时,初始化该静态字段所在的类;<br>5 ,子类的初始化会触发父类的初始化;<br>6 ,如果一个接口定义了 default 方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化;<br>7 ,使用反射 API 对某个类进行反射调用时,初始化这个类;<br>8 ,当初次调用 MethodHandle 实例时,初始化该 MethodHandle 指向的方法所在的类</font></p><h1 id="再谈-双亲委派机制"><a href="#再谈-双亲委派机制" class="headerlink" title="再谈 双亲委派机制"></a><font face="华文中宋" size="3">再谈 双亲委派机制</font></h1><p><font face="华文中宋" size="3">在上面类加载机制那块,提了一下双亲委派机制<br>我觉得之所以有这样的机制,就是为了避免资源的浪费.上面的双亲委派机制我们在现实中也可以找到例子,比如说:公司部门有位程序员 A 发现如果做一个数据系统的话,来把公司各部门的数据打通,这样就可以减少很多交流成本,那么他可能就会和老大去说,申请去做这个系统,如果老大发现这个完全可以写成公共系统啊,就会对 A 说,这个系统我来做就可以了(公共内容父类加载器进行加载),那如果老大发现不太适合做成公共系统,就会对 A 说,想做就去做吧(父类不进行加载时,子类才进行加载)巧的是,程序员 B 也发现了,他也去找老大说,这个时候老大会说什么呢?这个事情 A 去做了,就不用太担心了(同样一个类只加载一次)<br>那如果程序员 A 和 B 发现了之后没有和老大交流,都自己闷头去做了,这样的话,同样的系统做了两遍,还浪费了两个人的时间精力,由此造成的资源浪费太大了<br>我觉得双亲委派的机制类似于这样,因为这个机制的存在,让资源浪费的现象大大减少了</font></p><p><font face="华文中宋" size="3">但是 tomcat 打破了这种机制,这怎么说?<br>我们都知道 tomcat 是个 web 容器,那么它应该:</font></p><ul><li><font face="华文中宋" size="3">支持部署两个应用程序,不同的应用程序可能会依赖同一个第三方类库的不同版本,就比如两个应用程序,其中一个依赖的是一个类库的 v1.0 ,另外一个依赖的是同样一个类库的 v2.0 ,那么 tomcat 是不是应该允许这个类库的 1.0 和 2.0 版本都存在?</font></li><li><font face="华文中宋" size="3">部署在同一个 web 容器中相同的类库相同的版本是应该可以共享的.就比如,服务器上有 100 个应用程序,这些程序依赖的都是相同的类库,那 tomcat 总不能把这 100 份相同的类库都加载到虚拟机里面去吧,要是非要加载进去,那服务器不得分分钟炸了</font></li><li><font face="华文中宋" size="3">web 容器需要支持 jsp 文件的修改,也就是说,当程序运行之后,我对 jsp 文件进行了修改,那么 tomcat 是不是也应该支持?如果不支持的话,那我修改一次就不能用了,不合适吧?</font></li></ul><p><font face="华文中宋" size="3">基于上面三点,就能看到 tomcat 其实是打破了双亲委派机制的<br>比如第一个问题,第三方类库就是同样一个资源,在双亲委派机制中,同样一个资源是不应该加载两次的,但是在 tomcat 里面却被允许了;但是第二个问题好像又在说双亲委派的机制,正是因为双亲委派机制的存在,所以第二个问题就不是问题了嘛;第三个问题又打破了双亲委派机制,因为如果不打破的话,原来的 jsp 文件已经加载进来了,现在对它进行了修改,那么应该还会加载原来的 jsp 文件,这样的话修改岂不是无效了?<br>所以, tomcat 打破了双亲委派机制,但并不是完全打破</font></p><p><font face="华文中宋" size="3">至于 tomcat 打破双亲委派的机制,我还没搞懂,等我搞懂了再来写吧<br>或者你搞懂了嘛?给我讲讲~</font></p><p><font face="华文中宋" size="3">参考: 极客时间 – 深入拆解 Java 虚拟机</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]是不是 redo log 和 binlog 傻傻分不清楚?</title>
      <link href="/posts/42d9f222.html"/>
      <url>/posts/42d9f222.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在 MySQL 中,特别是存储引擎使用的是 InnoDB 时,那肯定绕不过去两个概念: redo log (重做日志) 和 binlog (二进制日志)<br><a id="more"></a><br>简单点儿说: redo log 是 InnoDB 存储引擎层方面的日志,所以如果你使用的存储引擎不是 InnoDB 的话,那就根本谈不上 redo log<br>binlog 是 MySQL Server 层记录的日志,所以不管是用的什么存储引擎,只要是 MySQL 都是会有 binlog 的存在,在做 MySQL 主从复制的时候,利用的就是 binlog<br>那么,你有疑问嘛?为什么要有 redo log 和 binlog ,只用一个 log 不可以嘛?<br>咱们详细来看看它们都分别做了啥</font></p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a><font face="华文中宋" size="3">redo log</font></h1><p><font face="华文中宋" size="3">为什么要有 redo log ?<br>我们可以这样想,如果没有 redo log 的话, MySQL 是如何进行工作的<br>查询还好说,毕竟只是查询一下记录而已,并没有对数据进行更改<br>那如果是增加和更新操作呢?现在一条 update 语句过来,后面是不是一定会有限定条件,就比如现在要更新一条记录,把 A 的银行卡余额更新到 1k ,那这条语句是不是应该来个限定条件,类似 <code>where userName = &#39;A&#39;</code> ,也就是说,一般 update 操作都伴随着查询的操作,得先找到这个人,然后再进行更新操作对吧<br>如果数据量比较小还好,很快就能找到并且更新完毕<br>但是如果数据量比较大,里面有一亿条数据,怎么办?而且更新操作肯定是要写到磁盘上去的,那这中间的 IO 成本呢?如果我有好几十条 update 语句先后更新呢?这样想的话,你就能想到,就这些操作,成本就高的不行,那能不能降低一下这些成本呢?</font></p><p><font face="华文中宋" size="3">这就是 redo log 的作用<br>就是当有一条记录更新的时候, InnoDB 引擎就会先把记录写到 redo log 里面去,同时更新内存,这样就算是更新这条数据成功了<br>但是此时,它并没有更新到磁盘上去对吧?别担心, InnoDB 会在恰当的时候,把这条及记录更新到磁盘上去<br>这样的思想或者技术,有个专有名词: WAL 技术,也就是 WriteAheadLogging ,核心就是先写日志,再写磁盘</font></p><p><font face="华文中宋" size="3">同样,这里面有个问题<br>redo log 不能一直写吧?如果更新操作一直写入到 redo log 中的话,不限制大小的话,可能服务器上的存储空间都被 redo log 给占满了<br>所以 InnoDB 的 redo log 是固定大小的,比如我们配置了一组 4 个文件,每个文件大小是 1GB ,那么它的操作可能就会这样:</font></p><p><img src="/images/2020/mysql.jpg"></p><p><font face="华文中宋" size="3">能够看到,主要就是 write pos 和 checkpoint , write pos 比较好理解,它就是当前记录的位置,有需要记录的操作就从当前位置向后移,等把 ib_logfile_3 写完之后,就回到 ib_logfile_0 文件开头继续写<br>checkpoint 是当前要擦除的位置,就是 InnoDB 引擎不是会在恰当的时候,将这些操作进行持久化,更新到磁盘上去,那持久化之后的数据是不是就可以擦除了<br>write pos 和 checkpoint 之间的部分就是可以用来记录操作的部分,那么如果 write pos 和 checkpoint 相遇了怎么办?相遇了是不是说明这个时候分配的 redo log 大小用完了,那这时候就不能再进行更新操作了,必须停下来处理一下,将 checkpoint 往前推推才行</font></p><p><font face="华文中宋" size="3">就是因为有了 redo log ,所以 InnoDB 才可以保证即使数据库发生了异常重启,也没关系,之前提交的记录都还在,只需要根据 redo log 里面的记录进行相应恢复就可以了<br>所以如果你和 DBA 比较熟的话,可以问问,咱们的 MySQL 是不是可以恢复到半个月内任意一秒的状态,如果对方回答是,别怀疑,他真的不是在吹牛逼</font></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a><font face="华文中宋" size="3">binlog</font></h1><p><font face="华文中宋" size="3">binlog 是 MySQL Server 层的记录日志,这块举个例子来说吧</font></p><p><font face="华文中宋" size="3">在说之前,我们要明白 redo log 和 binlog 的区别:</font></p><ul><li><font face="华文中宋" size="3">redo log 是 InnoDB 引擎特有的, binlog 是 MySQL 的 Server 层实现的,所有的引擎都是可以的</font></li><li><font face="华文中宋" size="3">redo log 是物理日志,记录的是”在 XXX 页上做了 XXX 修改”; binlog 是逻辑日志,比如” 给 id = 2 这一行的 c 字段加 1”</font></li><li><font face="华文中宋" size="3">redo log 是有固定大小的,所以它的空间会用完,如果用完的话,一定要进行一些写入磁盘的操作才可以继续; binlog 是可以追加写入的,也就是 binlog 没有空间的概念,一直写就行了</font></li></ul><p><font face="华文中宋" size="3">理解了它们之间区别之后,我们拿一个更新操作来举例<br>我现在要给 <code>id = 2 这一行的 c 字段加 1</code> ,到 MySQL 层面,它是如何去做的呢?<br>首先,会先找到这条 <code>id = 2</code> 的数据,然后找到 c 字段进行加 1 操作,这个时候,引擎会将这行数据更新到内存中,同时把这个更新操作记录到 redo log 里面,这个时候 redo log 处于 prepare 状态,随后执行器生成这个操作的 binlog ,并且把 binlog 写入到磁盘完成之后,执行器调用引擎的提交事务接口,引擎把刚刚写入的 redo log 从 prepare 状态改成 commit 状态,这样更新操作才算完成</font></p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><font face="华文中宋" size="3">两阶段提交</font></h1><p><font face="华文中宋" size="3">在上面的描述中,你能发现 redo log 竟然是先 prepare 状态,等 binlog 写完之后,才是 commit 状态,这种方式就叫”两阶段提交”<br>为什么会有这种方式呢?<br>redo log 和 binlog 都可以用于表示事务的提交状态,而两阶段提交就是让这两个状态保持逻辑上的一致</font></p><p><font face="华文中宋" size="3">可以假设一下,如果不采用这种方式,而是就先写 redo log ,再写 binlog ,会怎样?<br>如果在写 binlog 时,发生了异常,更新操作已经到 redo log 中了,但是此时 binlog 并没有进行更新,是不是出现了数据不一致?<br>先写 binlog 再写 redo log 也是一样<br>所以,在写时,先让 redo log 处于 prepare 状态,等 binlog 写完之后,再让 redo log 处于 commit 状态,这样就保持了逻辑上的一致</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇~</font></p><p><font face="华文中宋" size="3">参考<br>极客时间 – MySQL 实战 45 讲</font></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[项目]在 swagger 界面实现 token 验证</title>
      <link href="/posts/e23cc848.html"/>
      <url>/posts/e23cc848.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我先说下背景:我最近不是换了家公司工作,然后这家公司就是不管发什么请求都是需要带着 token 信息的,也就是说,比如现在我写好代码了,想要验证我写的代码对不对,咱们现在用的都是 springboot , springcloud 框架,写完了直接在 swagger 界面上进行调试就 OK 了,但是现在不管什么请求都要携带 token 信息,默认的 swagger 配置是没有的<br><a id="more"></a><br>我在上家公司的时候,当时的权限部门帮我们都做好了 token 验证,只要是能够进入到我们系统的用户,那就是有权限的,所以当时的项目直接在 swagger 界面上进行测试就 OK 了<br>我刚接手项目熟悉的时候,想要测试一下请求, swagger 上没办法添加 token 信息,所以我就得用 postman 去测</font></p><p><font face="华文中宋" size="3">对我来说是有点儿难受的,你想想,我以前就是写好了接口,启动项目,去 swagger 项目上一测试,没问题提交代码完事儿,有问题我就可以直接进行调试<br>现在使用 postman 测试没问题还好,有问题的话, token 不知道怎么添加进去,感觉就是明明可以直接使用 swagger 的,现在要再进行一个第三方 postman ,就感觉用的不是很顺手嘛</font></p><p><font face="华文中宋" size="3">所以我就想,能不能在 swagger 上直接就可以添加上 token 信息,这样的话,我就不需要再借助第三方工具 postman 了<br>一倒腾还真的让我给搞成功了</font></p><p><font face="华文中宋" size="3">swagger 整合细节我就不说了,这里主要就是 swagger 启动那里需要设置,具体代码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">controllerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加 head 参数配置 start</span></span><br><span class="line">    ParameterBuilder token = <span class="keyword">new</span> ParameterBuilder();</span><br><span class="line">    List&lt;Parameter&gt; pars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    token.name(<span class="string">"Authorization"</span>).description(<span class="string">"token 信息"</span>).modelRef(<span class="keyword">new</span> ModelRef(<span class="string">"String"</span>))</span><br><span class="line">            .parameterType(<span class="string">"header"</span>).required(<span class="keyword">false</span>).build();</span><br><span class="line">    pars.add(token.build());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .enable(enable)</span><br><span class="line">            .apiInfo(<span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                    .title(projectName + <span class="string">"接口文档"</span>)</span><br><span class="line">                    .description(projectDesc + <span class="string">""</span>)</span><br><span class="line">                    .license(<span class="string">"郑璐璐 csdn"</span>)</span><br><span class="line">                    .licenseUrl(<span class="string">"https://blog.csdn.net/zll_0405"</span>)</span><br><span class="line">                    .version(version)</span><br><span class="line">                    .build())</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(basePackage))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            <span class="comment">// 注意一下 globalOperationParameters 这行配置</span></span><br><span class="line">            .globalOperationParameters(pars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">OK ,添加好上面的代码之后,再启动就能在 swagger 界面上看到下面的改动了:</font></p><p><img src="/images/2020/token.png"></p><p><font face="华文中宋" size="3">在图中红框框的地方,输入 token 信息,然后执行一下,你就会发现,使用 swagger 我又可以了,哈哈哈</font></p><p><font face="华文中宋" size="3">注意:给出的代码只是一个小 demo ,具体信息请根据自己的项目信息去配置<br>以上,感谢您的阅读哇~</font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]是的,我换了家公司工作</title>
      <link href="/posts/83a68896.html"/>
      <url>/posts/83a68896.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近我在忙着换公司工作的事情,虽然平时也一直在学习 &amp; 输出,也一直在尽力把自己写的文章系统化,但是去面试还是要好好准备的,所以各位读者可能也感受到了,最近这两周的文章质量都不是很高,毕竟我的时间精力都在那里嘛<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">经过最近的面试之后,有些感受,在这里写写,如果对你能够有所帮助的话,那可真是太好了</font></p><p><font face="华文中宋" size="3">1 ,自己简历上的东西,既然写了熟悉或者精通,那就一定要能够达到那样的层次<br>面试官面试的时候,都是根据你的简历来问你的,所以一定要对自己的简历负责.如果写了精通,那就一定要有对应的深度<br>因为我上家公司是做在线教育方面的,我负责的主要业务就是学生考试,并发量什么的都是比较多的,那最好就是使用多线程去处理啦,所以我对多线程这块就很熟悉,如果面试的话,不问那就算了,只要一问这块就是我的亮点<br>那么你肯定就会问了,什么程度算是精通呢,什么算是熟练使用呢,什么算是熟悉呢<br>我觉得精通的话,那肯定是不管这方面问你什么问题都是问不倒的.比如你说你精通多线程这块内容是吧,那么多内容,别的咱先别问,就问个 synchronized 关键字,它的锁膨胀是怎样的呢,你是怎么判断当前是有锁状态,无锁状态的, synchronized 后来做了优化,具体优化是什么呢,提到 synchronized 的话,它和 ReentrantLock 有什么区别? ReentrantLock 又是基于 AQS 实现的,又能说出来多少.我觉得如果这些问题都没问住你的话,那么你说你精通,我是相信的.<br>熟练使用的话,就需要你达到出现了问题知道怎么解决,比如你说你熟练使用 mysql , OK ,那现在有个 sql 语句执行特别慢,如果是你的话,你会怎么处理呢,其中的几个关键参数也是能够说出来的;你说你熟练使用 Linux 命令,那么我想要查看日志,想要查看特定进程,是不是都应该答上来<br>熟悉的话,我觉得就是一个你知道的层次,比如你说你熟悉 GC 算法,那 标记清除/标记复制/标记整理 优缺点,适用于新生代还是老年代就应该答出来<br>所以简历上如果写了精通,那就一定要有对应的深度;如果写了熟悉,那一些基本的知识应该能够答上来的</font></p><p><font face="华文中宋" size="3">2 ,如果面试官问了你不会的内容,那就坦白说自己不会<br>说来比较愧疚,虽然一直在用 ssm, springboot, springcloud 这些框架,但是 spring 源码我还没读过,一直都处在使用的层面<br>当时面试的时候,面试官就问我有没有阅读过 spring 的源码,我就很坦白的说,我没有阅读过,只是一直在用,面试官也就没有继续追问下去<br>如果我当时为了装逼说我阅读过源码的话,那估计被吊打的就是我了</font></p><p><font face="华文中宋" size="3">3 ,如果你面了几家公司,后续都没有了消息,别怀疑自己,只是职位不匹配而已<br>我当时在找工作的时候,恰好另外一位朋友也在找工作,所以我俩那时候交流就比较多嘛<br>然后他面了有十几家公司了,面到最后都没有了后话,那段时间他就一直问我,是不是自己不够好,是不是自己不够优秀.有一说一,我那位朋友技术上比我厉害是真的,所以我就安慰他,没事儿的,再面面,说不定下家公司就要你了呢<br>结果现在他手上有好几个 offer ,在愁去哪家公司比较好.<br>所以在面试的过程中,如果面了几家,几十家公司,还没收到一份 offer ,别怀疑自己,真的<br>这就像你去超市买东西一样,怎么那么多东西不拿,就拿快乐肥宅水呢,无他,只是匹配你的需求而已.那其他的就不好么?不是,只是目前还没有遇到买家而已<br>找工作也是这样,可能只是你的技术栈和对方不匹配,但总会有一家公司的技术栈和你是匹配的对吧,别灰心,继续努力就行</font></p><p><font face="华文中宋" size="3">4 ,面试过程中,不要怕,展示你自己就可以了<br>我记得我当时投简历的时候,想要换个领域去看看嘛,毕竟世界那么大<br>我就投了一家区块链公司,说真的,区块链公司和我目前接触的领域,差别太大了.我目前接触的领域,一天的数据量最多也就几百万数据,这还是最多的,但是我去面的那家区块链公司,数据量都已经达到了 T 级别<br>而且大家应该也都知道,很小的一个问题,当数据量非常大的时候,那么这个小问题可能就是一个大问题.比如现在要往数据库里面插入一条数据,插入之前先看看数据库中有没有,如果有的话,那就直接更新,如果没有再做插入<br>如果我来做的话,那就直接一个 if else 就完了,但是面试官说,如果直接 if else 的话,我现在的数据量就是几个 T ,只是判断数据库中有没有这条数据就可能要花费很多时间<br>就我上面的这个例子,大家也能看到,我接触的领域对于区块链领域来说,是非常不匹配的,当时面试的时候面试官也很坦率,就和我说他们想要的 java 不是我这样的,技术栈不匹配<br>我当时听了面试官这样说,就觉得都这样说了,可能就没有后续了,结果面试官说,但是在面试的整个过程中,我觉得你的性格,沟通能力都是蛮不错的,很适合和我们团队一起做事<br>所以嘞,面试过程中,别怕,哪怕去面试的领域不是自己擅长的领域,那也没啥怕的,会就说,不会就说不会,不懂就向面试官请教,说不定你身上的哪点特质就被面试官相中了呢~</font></p><p><font face="华文中宋" size="3">5,算法和数据结构是真的重要<br>实话实说,我的算法就不是很好,去面试的时候能够感觉到不管是大公司,还是小公司都是挺看重算法的,动不动就让你手写几个算法,真的就是标配了<br>所以面试的话,这块最好还是准备一下</font></p><p><font face="华文中宋" size="3">经过面试之后,发现了自己需要提高的地方还是蛮多的,接下来我就继续努力就完了</font></p><p><font face="华文中宋" size="3">感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]爬上来说两句</title>
      <link href="/posts/78166b12.html"/>
      <url>/posts/78166b12.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">先道个歉,因为上周博客我鸽了,另外我再摸着良心说,尴尬,我没良心<br>这周技术上没啥输入,也就没啥高质量的输出了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我最近在准备换家公司工作的事情,所以不管是时间上,还是精力上,都有些不够用,有时候真的恨不得把自己掰成好几个,一个在工作,一个在学习,一个在输出高质量文章,一个在准备面试,一个在面试,哈哈哈</font></p><p><font face="华文中宋" size="3">在交接工作的时候,我才发现原来在过去的时间里我成长了这么多<br>不管是开发,还是运维,还是管理,或是沟通,或是表达,都让我和几年前的自己全然不同<br>不过,能够有这样的我,中间付出了多少,怕是只有自己才知道吧<br>但是付出的东西我不想总是过多的去说,因为这都是我想要付出的,无怨无悔的那种,而且还是非常享受的那种,甘之如始</font></p><p><font face="华文中宋" size="3">我记得面试的时候,面试官问过我接下来的发展,这两天我也在问自己,未来到底是想要成为什么<br>我到现在都没有想清楚,我未来到底是想要成为什么,但是有一点是非常清楚的,就是我喜欢去钻技术,我想让自己的技术沉淀下来,我想通过业务去将我身上的技术价值发挥到最大,我喜欢看着自己写的代码通过网络给一些人带去了一些改变和方便<br>这是我目前享受,乐意去做的事情</font></p><p><font face="华文中宋" size="3">我觉得现在让我去计划五年之后的事情,太难了<br>就像五年前的我,没有想过我会走上编程的道路,成为一个程序媛一样,现在让我去想五年后的事情,我想象不出来<br>我能够想象出来的就是,五年之后的我,肯定比现在的自己,还要优秀.因为我在坚持每天进步一点点~</font></p><p><font face="华文中宋" size="3">就这样吧~主要是自己这周没啥输入,所以废话了好多文字<br>总是写这样的文章,我自己心里感觉也是挺过意不去的,因为我最近总是水文…</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[redis]关于 缓存穿透/缓存击穿/缓存雪崩 看这篇文章就够了</title>
      <link href="/posts/2d85a910.html"/>
      <url>/posts/2d85a910.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">redis 在项目中用的话,主要就是用作缓存了<br>既然用作缓存,那就肯定会有 缓存穿透/缓存击穿/缓存雪崩 的问题<br>这篇文章就来说说,遇到这种情况时,该如何去处理<br><a id="more"></a></font></p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><font face="华文中宋" size="3">缓存穿透</font></h1><p><font face="华文中宋" size="3">首先咱们搞明白什么是缓存穿透?这三个词这么像,得把概念搞清楚不是<br>其实只是从字面意思上来看的话,大概也能知道一点儿,缓存穿透嘛,就是直接穿过了缓存,将请求打到了数据库上面去<br>一般情况下,去查询数据的话,缓存里面应该都是有的,但是防不住黑客呀,如果黑客请求查询的是数据库里面根本不存在的数据,数据库里面都没有的数据,缓存里面肯定也不会有了,对吧,那么此时请求就会打到咱们的数据库里面去,这就是<strong>缓存穿透</strong><br>你想啊,黑客想要攻击的话,怎么可能只请求一次呢,肯定是大量的请求过来,因为是拿数据库里面不存在的 id 来请求的,那么这些请求毫无疑问直接打到了数据库上面去,那咱们的数据库可能就会因为这些大量的请求直接宕掉</font></p><p><font face="华文中宋" size="3">如何解决呢?<br>咱们回到产生这个问题的场景中,为什么大量的请求会打到数据库上面来?因为缓存里面没有对应的 key 对吧,所以才会越过缓存直接到数据库<br>那么问题就好解决了嘛,缓存里面没有对应的 key ? OK,如果这个 key 数据库里面也没有,那我就在 redis 里面,存上这个 key ,值是 null ,这样如果有查询这个 key 的请求,我直接返回 null 就完事儿了,也就不用打到数据库上面去了<br>注意一下,要记得设置它的过期时间,一般三到五分钟就够了</font></p><p><font face="华文中宋" size="3">但是对方是个黑客呀,可能就用一个 key 去请求么?他可能会在短时间内用大量的 key 来发送请求,那如果一个 key 就在 redis 中存储一个 null 值的话,那么多 key 是不是就会存储那么多个 null 值嘞?<br>这样的话, redis 里面是不是都是值为 null 的了?<br>所以有没有更好的解决办法呢?<br>那必须得有!<br>布隆过滤器,你值得尝试</font></p><p><font face="华文中宋" size="3">什么是布隆过滤器呢?就是它能告诉你,某个值一定不存在或者可能存在( emmmm ,也不知道我有没有说清楚<br>所以可以将数据库的内容缓存一份到布隆过滤器,这样的话,当大量的请求过来的时候,<br> redis 里面没有,没关系,再去布隆过滤器过滤一下,这样请求不用打到数据库上面去,就能确定这个 key 数据库中有没有<br> 这样不就降低了数据库的压力么,可真是个天才~</font></p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><font face="华文中宋" size="3">缓存击穿</font></h1><p><font face="华文中宋" size="3">缓存击穿说的是,在高并发情况下,如果好多个请求都在查询一个 key ,好巧不巧的是,这个 key 因为某些原因失效了(比如设置的过期时间到了,缓存服务器宕机了),这样就会导致那么多的请求都直接打到数据库上面去了<br>那如果这些请求的数量足够大的话,可能直接把数据库就干掉了</font></p><p><font face="华文中宋" size="3">知道了造成结果的原因,那么寻找解决方案也就好办了<br>不是因为好多个请求打到了数据库嘛,但是它们请求的都只是一个 key ,所以这里可以使用排斥锁来实现,第一个请求达到请求 key 发现缓存里面没有,允许它去数据库查询,同时加锁,这样第二个请求,第三个请求…都会被锁阻塞到当前,不会再打到数据库,这样就减少了数据库的并发压力</font></p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><font face="华文中宋" size="3">缓存雪崩</font></h1><p><font face="华文中宋" size="3">缓存雪崩,雪崩雪崩嘛,就比较严重,击穿说的是一个 key 失效的情况,雪崩指的是大规模的缓存失效情况的发生,这是有可能发生的,比如说我的缓存服务器宕机了,那是不是直接就大规模的缓存失效了;或者说,我当时为了图省事,好多个 key 设置的过期时间都是一样的,然后刚好在缓存都失效的时候,好多请求不同的 key 过来了</font></p><p><font face="华文中宋" size="3">解决方案的话,其实就不适合使用加锁的方式去解决了,因为这是好多请求不同的 key ,它不是一个嘛<br>而且嘞,咱们是因为好多个 key 设置的过期时间都是一样的,所以解决方案就是,咱们不设置同样的时间让缓存失效了,咱们给一个随机时间,让缓存随机失效,这样的话,大规模的缓存失效情况就减少很多了<br>那还要一种情况呢,就是如果我的缓存服务器直接宕机了,这怎么办?也好弄,来个集群就解决了,这里只是一个解决方案,它的落地实现不是本文重点哈~</font></p><h1 id="再谈-布隆过滤器"><a href="#再谈-布隆过滤器" class="headerlink" title="再谈 布隆过滤器"></a><font face="华文中宋" size="3">再谈 布隆过滤器</font></h1><p><font face="华文中宋" size="3">OK ,你如果看到这里的话,其实这篇文章的内容就说完了<br>但是我感觉布隆过滤器那块,我没有说清楚,所以在这里拿出来详细说一说</font></p><p><font face="华文中宋" size="3">布隆过滤器是一种数据结构,它是一种概率型的数据结构,就是它能告诉你”某样东西一定不存在或者可能存在”<br>唉,你可能会说,这话刚刚不是说过了嘛,本来就挺拗口的,你咋还说<br>还不是因为这句话比较重要,我觉得把这句话理解透彻了,那么对布隆过滤器理解的应该也就到位了</font></p><p><font face="华文中宋" size="3">来,为了形象生动一些,咱们举个例子~<br>布隆过滤器是一个 bit 向量或者说 bit 数组,大概长这样:</font></p><p><img src="/images/2020/布隆过滤器-初始.jpg"></p><p><font face="华文中宋" size="3">现在,我们需要把 “AliPay” 这个字段给存储进去<br>大概的存储过程就是:将要映射的值,使用多个不同的哈希函数生成多个哈希值,然后每个生成的哈希值指向的 bit 置为 1<br>以给的为例,我们现在将 “AliPay” 这个值,通过三个不同的哈希函数进行映射,那么大概就是这样了:</font></p><p><img src="/images/2020/布隆过滤器-第一次映射.jpg"></p><p><font face="华文中宋" size="3">同样,现在我要存储另外一个值 “WechatPay” ,那么可能映射之后就是下面这样:</font></p><p><img src="/images/2020/布隆过滤器-第二次映射.jpg"></p><p><font face="华文中宋" size="3">细心的你可能就会发现, 4 号位置的值,刚开始不是给 “AliPay” 了么,后来 “WechatPay” 也在那里,这样的话,值不就给覆盖掉了嘛<br>嗯,没错,是给覆盖到了</font></p><p><font face="华文中宋" size="3">接下来,我们查询 “Ali” 那么查询之后,布隆过滤器可能会给你 “0,1,2” 的值, 结果呢 “2” 的位置是 0 ,说明没有任何值映射到这个位置上来,所以我们就可以判定数据库里面没有 “Ali” 这个值<br>那我查询 “AliPay” 的话,毫无疑问,肯定会返回给我 “1,4,6” ,那我们能说数据库里面一定有 “AliPay” 么?不能,因为 “1,4,6” 的值有可能被其他的值给映射了,所以我们只能说,数据库里可能存在 “AliPay”<br>这就是布隆过滤器说的”某个值一定不存在或者可能存在”<br>你理解了嘛?(不理解的话,我也就写到这儿了~</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]面试官:三个线程顺序执行,你来说说有几种实现方式?</title>
      <link href="/posts/f0d1ecb0.html"/>
      <url>/posts/f0d1ecb0.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">写在前面:<br>越是基础知识,越要系统<br><a id="more"></a><br>正文开始:</font></p><p><font face="华文中宋" size="3">先说下要求,就是三个线程,假设是线程 1,2,3, 现在的要求是:必须是线程 1 先执行,然后线程 2 再执行,最后是线程 3 执行<br>然后有几种实现方法呢?<br>其实它的本质就是实现,让线程 2,3  等待线程 1 执行完毕,所以重点就是有哪些方法可以让线程 2,3 等待</font></p><h1 id="join"><a href="#join" class="headerlink" title="join"></a><font face="华文中宋" size="3">join</font></h1><p><font face="华文中宋" size="3">第一反应应该就是使用 join 方法,因为 join 本来就是支持这种机制的<br>比如,我在线程 B 中调用了线程 A 的 join 方法,那么线程 B 就会等线程 A 执行结束之后再执行.<br>那么具体应该怎么使用嘞?<br>别慌嘛,我这里有例子,你瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(<span class="keyword">null</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t1));</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t2));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Thread beforeThread)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果有线程,就 join 进来,没有的话就直接输出</span></span><br><span class="line">            <span class="keyword">if</span> (beforeThread != <span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join();</span><br><span class="line">                    System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><font face="华文中宋" size="3">CountDownLatch</font></h1><p><font face="华文中宋" size="3">刚才说了,本质就是让线程 B,C 等待线程 A 执行完毕<br>那么信号量就是一个不错的选择<br>如果想要实现的话,那大概就是下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置线程 1 的信号量为 0</span></span><br><span class="line">        CountDownLatch cOne = <span class="keyword">new</span> CountDownLatch(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置线程 2 的信号量为 1</span></span><br><span class="line">        CountDownLatch cTwo = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置线程 3 的信号量为 1</span></span><br><span class="line">        CountDownLatch cThree = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 cOne 为 0 ,故 t1 可以直接执行</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cOne,cTwo));</span><br><span class="line">        <span class="comment">// 线程 t1 执行完毕之后,此时的 cTwo 为 0 , t2 开始执行</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cTwo,cThree));</span><br><span class="line">        <span class="comment">// 线程 t2 执行完毕,此时 cThree 为 0 , t3 开始执行</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cThree,cThree));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        CountDownLatch cOne;</span><br><span class="line">        CountDownLatch cTwo;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(CountDownLatch cOne, CountDownLatch cTwo)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.cOne = cOne;</span><br><span class="line">            <span class="keyword">this</span>.cTwo = cTwo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前一个线程信号量为 0 时,才执行</span></span><br><span class="line">                cOne.await();</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 后一个线程信号量减 1</span></span><br><span class="line">                cTwo.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用单个线程池"><a href="#使用单个线程池" class="headerlink" title="使用单个线程池"></a><font face="华文中宋" size="3">使用单个线程池</font></h1><p> <font face="华文中宋" size="3">之所以线程 1,2,3 的执行顺序无法保证,是因为在编译器可能会去做一些优化,导致没有办法按照顺序执行<br> 如果我们使用单个线程池去执行的话,那就没有这样的问题了<br> 具体实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopThree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run one"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run two"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run three"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 将线程依次加入到线程池中</span></span><br><span class="line">        executor.submit(t1);</span><br><span class="line">        executor.submit(t2);</span><br><span class="line">        executor.submit(t3);</span><br><span class="line">        <span class="comment">// 及时将线程池关闭</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><font face="华文中宋" size="3">CompletableFuture</font></h1><p><font face="华文中宋" size="3">如果使用 CompletableFuture 来实现的话,代码就非常简洁了</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopFour</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(()-&gt; t1.start())</span><br><span class="line">                .thenRun(()-&gt;t2.start())</span><br><span class="line">                .thenRun(()-&gt;t3.start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">你还有别的什么方法么?欢迎评论区和我交流~<br>以上,非常感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]面试官让我手写一个读写锁出来,我...</title>
      <link href="/posts/76a7b252.html"/>
      <url>/posts/76a7b252.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">题目是个标题党,主要是想写一下 ReentrantReadWriteLock<br><a id="more"></a></font></p><h1 id="ReentrantReadWriteLock-与-ReentrantLock-区别"><a href="#ReentrantReadWriteLock-与-ReentrantLock-区别" class="headerlink" title="ReentrantReadWriteLock 与 ReentrantLock 区别?"></a><font face="华文中宋" size="3">ReentrantReadWriteLock 与 ReentrantLock 区别?</font></h1><p><font face="华文中宋" size="3">在这篇文章中:  <a href="https://blog.csdn.net/zll_0405/article/details/105927574" target="_blank" rel="noopener">[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</a>  对 ReentrantLock 已经做了非常详细的讲解了<br>那么,今天想要说的 ReentrantReadWriteLock 和 ReentrantLock 有什么区别呢?如果只是从名字上来说的话,就是多了一个 ReadWrite 嘛<br>如果对 ReentrantLock 比较熟的话,那么我问 ReentrantLock 是独占锁还是共享锁,你的第一反应就是: 独占锁</font></p><p><font face="华文中宋" size="3">ReentrantReadWriteLock 是在 ReentrantLock 的基础上做的优化,什么优化呢? ReentrantLock 就是不管操作是读操作还是写操作都会对资源进行加锁,但是你想想,如果好几个操作都只是读的话,并没有让数据的状态发生改变,这样的话是不是可以允许多个读操作同时运行?这样的话,相对来说是不是就提高了并发<br>很多事情都是说起来容易,具体是怎么实现的呢?<br>啥也不多说,咱们直接上源码好吧</font></p><p><font face="华文中宋" size="3">在使用 ReentrantReadWriteLock 时,一般都是调用 <code>writeLock</code> 和 <code>readLock</code> 两种方法,它在源码中定义如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">而 <code>writeLock</code> 和 <code>readLock</code> 是 <code>ReentrantReadWriteLock</code> 的两个内部类,其中这两种锁的实现如下(其中省略了一些代码):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享锁</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 共享锁</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 独占锁</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">从源码就能够看出,对于读锁 <code>readLock</code> 它使用的是共享锁,也就是多个线程读没问题<br>但是对于写锁 <code>writeLock</code> 它使用的是独占锁,就是当一个线程要进行写操作时,其他的线程都要停下来等待<br>简单点儿说就是:一个资源可以被多个读线程访问,或者被一个写线程访问,但是不能同时存在读线程和写线程,这也是读写锁的定义</font></p><h1 id="ReadLock-和-WriteLock-共享一个变量"><a href="#ReadLock-和-WriteLock-共享一个变量" class="headerlink" title="ReadLock 和 WriteLock 共享一个变量"></a><font face="华文中宋" size="3">ReadLock 和 WriteLock 共享一个变量</font></h1><p><font face="华文中宋" size="3">如果让你设计一个读写锁的话,会怎样设计?<br>我还真的认真想了想这个问题,如果让我设计的话,我应该会用两个变量去控制读和写,当线程获取到读锁时就对读变量进行 +1 操作,当获取到写锁时,就对写变量进行 +1 操作<br>但是通过看 ReentrantReadWriteLock 源码发现,它只是通过一个 state 来实现的<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">有两个关键方法 <code>sharedCount</code> 和 <code>exclusiveCount</code> ,乖,光是从名字意思来看应该也是可以猜出来的吧: <code>sharedCount</code> 就是共享锁的数量,而 <code>exclusiveCount</code> 则是独占锁的数量<br>通过看源码,能够看出来,对于 <code>sharedCount</code> 来说,它的计算方式就是无符号右移 16 位,空位都以 0 来补齐( <code>c &gt;&gt;&gt; SHARED_SHIFT;</code> )<br>对于 <code>exclusiveCount</code> 来说,它的计算方式就是将传进来的 c 和 <code>EXCLUSIVE_MASK</code> 做 “&amp;” 运算,那么 <code>EXCLUSIVE_MASK</code> 的值是什么呢?就是 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> ,如果对位运算比较熟的话,应该会很容易看出来 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> 的值就是 65535 ,化成二进制就是 16 个 1,传进来 c 的值,和 16 位全为 1 做 “&amp;” 运算的话,只有 <code>1 &amp; 1</code> 才为 1 ,也就是说,传进来的 c 值经过这样转换之后,还是原来的值</font></p><p> <font face="华文中宋" size="3">说到这里,可能有点儿懵了,没关系,咱们来个总结就好说了(为了好理解,我就用大白话说了,争取各位都能看懂<br> 对于 <code>sharedCount</code> 来说,只要传进来的值不大于 65535 ,那么经过计算之后,值都是 0<br> 对于 <code>exclusiveCount</code> 来说,传进来的值是多少,经过计算之后还是多少<br> 不管是 <code>sharedCount</code> 还是 <code>exclusiveCount</code> ,最大值都是 65535 ,因为是和 16 做位运算,其实这个数字也是相当够用了<br> 那么,看到这里,各位应该就比较了解了吧,对于 <code>ReadLock</code> 和 <code>WriteLock</code> 来说,在源码层次其实并不是用两个变量去做的,而是通过一个 state 来实现的,思路真的是非常的巧妙</font></p><p><font face="华文中宋" size="3">对于我上面说的,如果还是不清楚的话,可以自己写个 demo 去验证一下,很简单的,就比如下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shareCount = <span class="number">3000</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    System.out.println(<span class="string">"shareCount : "</span> + shareCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> exclusiveCount = <span class="number">1</span> &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"exclusiveCount : "</span> + exclusiveCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">等你运行完之后,你就发现,哇,怎么和我说的一样,哈哈哈哈<br>对于 <code>sharedCount</code> 来说,它是针对读锁的,所以不管多少进程进行读取资源,都没关系,所以它的值就是 0<br>对于 <code>exclusiveCount</code> 来说,它是针对写锁的,那么只要有一个进程在进行写入,其他线程都要停下来等待,所以它的值就是传进来的值<br>综上,使用一个状态的话,我们只需要去判断这个状态是否是 0 就可以了</font></p><h1 id="WriteLock-的具体实现"><a href="#WriteLock-的具体实现" class="headerlink" title="WriteLock 的具体实现"></a><font face="华文中宋" size="3">WriteLock 的具体实现</font></h1><p><font face="华文中宋" size="3">OK ,既然你都看到了这里,我就默认上面的内容你都理解了<br>WriteLock 说白了就是独占锁,所以在获取 WriteLock 时,不能只考虑是否有写锁在占用,还要考虑有没有读锁.接下来咱们就去探究一下, WriteLock 它具体是怎么实现的</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取到锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 获取写锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c != 0 说明有读锁/写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// w == 0 说明此时没有写锁,有读锁 或者 持有写锁的线程不是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果写锁数量超出了最大值,没啥说的,抛异常就完事儿了</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 当前线程持有写锁,为重入锁,直接 +acquires 即可</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS 操作,确保修改值成功</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">如果对 ReentrantLock 比较熟的话,你会发现,上面的代码大部分都是见过的<br>有一点区别就是调用了 <code>exclusiveCount</code> 方法,看当前是否有写锁存在,接下来通过 <code>c != 0 and w == 0</code> 判断了当前是否有读锁存在</font></p><h1 id="ReadLock-的具体实现"><a href="#ReadLock-的具体实现" class="headerlink" title="ReadLock 的具体实现"></a><font face="华文中宋" size="3">ReadLock 的具体实现</font></h1><p><font face="华文中宋" size="3">WriteLock 探究完了,接下来瞅瞅 ReadLock ,话不多说,直接上源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写锁不等于 0 时,看看当前写锁是否在尝试获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 读锁不需要阻塞,而且读锁需要小于最大读锁数量,同时 cas 操作进行加 1 操作</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 当前线程是第一个并且第一次获取读锁时</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程再次获取读锁,则直接进行 ++ 操作即可</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是第一个获取读锁的线程,就放入线程本地变量</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">看完有没有觉得和写锁那块挺像的,不同就在于因为是读锁嘛,所以只要没有写锁占用,而且读锁的数量没有超过最大的获取数量,就都可以获取读锁<br>在上面, <code>firstReader</code>  <code>firstReaderHoldCount</code>  <code>cachedHoldCounter</code> 都是为 <code>readHolds</code> 服务的,它是为了获取当前线程持有锁的数量,在 <code>ThreadLocal</code> 基础上添加了 Int 变量来统计,这样比较方便嘛<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程持有锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="comment">// 当前线程 ID</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回到题目-手写一个读写锁出来"><a href="#回到题目-手写一个读写锁出来" class="headerlink" title="回到题目,手写一个读写锁出来?"></a><font face="华文中宋" size="3">回到题目,手写一个读写锁出来?</font></h1><p><font face="华文中宋" size="3">接下来,再回到题目,如果面试官让手写一个读写锁出来,你会如何实现呢?<br>在读了源码之后,相信你心里应该有谱了<br>首先来个 state 变量,然后高 16 位设置为读锁数量,低 16 位设置为写锁数量低,然后在进行读锁时,先判断下是不是有写锁,如果没有,直接读取即可,如果有的话那就需要等待;在写锁想要拿到锁的时候,就要判断写锁和读锁是不是都存在了,如果存在那就等着,如果不存在才进行接下来的操作<br>在这里我给出一个简单版的实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个读写锁共享变量 state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 高 16 位为读锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getReadCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 低 16 位为写锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getWriteCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &amp; (( <span class="number">1</span> &lt;&lt; <span class="number">16</span> ) - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读锁时,先判断是否有写锁</span></span><br><span class="line">    <span class="comment">// 如果有写锁,就等待</span></span><br><span class="line">    <span class="comment">// 如果没有,进行加 1 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( getWriteCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"lockRead --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state = state + ( <span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放读锁数量减 1 ,通知其他线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unLockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = state - ( <span class="number">1</span> &lt;&lt; <span class="number">16</span> );</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取写锁时需要判断读锁和写锁是否都存在,有则等待,没有则将写锁数量加 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getReadCount() &gt; <span class="number">0</span> || getWriteCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"lockWrite --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放写锁数量减 1 ,通知所有等待线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWriters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state --;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">我自己测试了下,没啥大问题<br>但是如果细究的话,还是有问题的,就比如,如果现在我有好多个读锁,如果一直不释放的话,那么写锁是一直没办法获取到的,这样就造成了饥饿现象的产生嘛<br>解决的话也蛮好解决的,就是在上面添加一个记录写锁数量的变量,然后在读锁之前,去判断一下是否有线程要获取写锁,如果有的话,优先处理,没有的话再进行读锁操作<br>这块大家试试自己实现吧~我这里就不给具体实现了</font></p><p><font face="华文中宋" size="3">最后,我觉得一个专栏至少是要写 15 篇文章,才可以算得上专栏一说<br>Java 并发这个系列,带上这一篇,就已经写了 14 篇了,计划是再写一篇文章,然后 Java 并发这个系列就告一个段落,接下来 Java 并发系列的更新就随缘,看我兴趣了~<br>Java 并发结束之后,就想去写写 JVM/Dubbo/Zookeeper/Redis/RabbitMQ 等等的内容(总之是要写的内容还有好多</font></p><p><font face="华文中宋" size="3">保持饥饿,保持对技术的热情,就酱~<br>大晚上的更新一篇,感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]最近有点儿飘</title>
      <link href="/posts/38d2bcc6.html"/>
      <url>/posts/38d2bcc6.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周博客鸽了<br>因为最近有点儿飘<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">可能是前段时间逼自己太狠了,因为我在写博客之余,还和一群朋友们一起在做公众号,我负责的那一周文章几乎都是我自己硬怼出来的,再加上工作真的是把自己搞的有些累了<br>所以最近有点儿放松自己,下班之后没有看源码/技术书籍这种,是看了一本相对轻松愉快的书籍:  &lt;哑舍&gt;<br>这本书我在高中的时候就开始追了,但是没追完,毕竟当时学业比较繁重,后来上大学,工作了就忘了这回事儿,前几天在微信读书上看到这本书,顿时回忆袭来,所以下班之后就在看这本书了<br>这本书,是我看了这么久还不知道主角名字的一本书,但是它真的很好看,很适合我这种历史不好的人~</font></p><p><font face="华文中宋" size="3">昨天和朋友一起去爬了香山,爬完之后就觉得积累在自己心中的那些焦虑啊,迷茫啊,在这大自然面前都消失的无影无踪~<br>人生这么长,何必计较这一时的得与失,目前做的所有事情,都放在五年十年之后再看,就一定是另外一番景色,所以当下的得与失没必要看得那么重,继续踏踏实实的干就完事儿了<br>所以今天感觉自己以前的情绪,状态都回来了,明天我又是一个打不死的小强,哈哈哈哈<br>不过有一说一,爬完山的我,今天整个人都瘫了</font></p><p><font face="华文中宋" size="3">下周的博客应该会是一篇干货,写什么主题我还没有确定,不过写出来的话,应该不会让读文章的你失望的<br>就这样吧~<br>我再去看会儿书~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发] ThreadLocal 你怎么动不动就内存泄漏?</title>
      <link href="/posts/c4ae514c.html"/>
      <url>/posts/c4ae514c.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果说 ThreadLocal 的话,那肯定就会涉及到内存泄漏<br>为啥嘞<br>因为 吧啦吧啦 ~<br><a id="more"></a></font></p><h1 id="ThreadLocal-解决了什么问题呢"><a href="#ThreadLocal-解决了什么问题呢" class="headerlink" title="ThreadLocal 解决了什么问题呢?"></a><font face="华文中宋" size="3">ThreadLocal 解决了什么问题呢?</font></h1><p><font face="华文中宋" size="3">它是为了解决<strong>对象不能被多线程共享访问的问题</strong>,通过 threadLocal.set() 方法将对象实例保存在每个线程自己所拥有的 threadLocalMap 中,这样的话每个线程都使用自己的对象实例,彼此不会影响从而达到了隔离的作用,这样就解决了对象在被共享访问时带来的线程安全问题<br>啥意思呢?打个比方,现在公司所有人都要填写一个表格,但是只有一支笔,这个时候就只能上个人用完了之后,下个人才可以使用,为了保证”笔”这个资源的可用性,只需要保证在接下来每个人的获取顺序就可以了,这就是 lock 的作用,当这支笔被别人用的时候,我就加 lock ,你来了那就进入队列排队等待获取资源(非公平方式那就另外说了),这支笔用完之后就释放 lock ,然后按照顺序给下个人使用<br>但是完全可以一个人一支笔对不对,这样的话,你填写你的表格,我填写我的表格,咱俩谁都不耽搁谁.这就是 ThreadLocal 在做的事情.因为每个 Thread 都有一个副本,就不存在资源竞争,所以也就不需要加锁,这不就是拿空间去换了时间嘛</font></p><p><font face="华文中宋" size="3">在开始之前,咱们先把 Thread, ThreadLocal, ThreadLocalMap 的关系捋一捋</font></p><p><img src="/images/2020/thread.jpg"></p><p><font face="华文中宋" size="3">可以看到,在 Thread 中持有一个 ThreadLocalMap , ThreadLocalMap 又是由 Entry 来组成的,在 Entry 里面有 ThreadLocal 和 value</font></p><h1 id="ThreadLocal-为啥动不动就内存泄漏呢"><a href="#ThreadLocal-为啥动不动就内存泄漏呢" class="headerlink" title="ThreadLocal 为啥动不动就内存泄漏呢?"></a><font face="华文中宋" size="3">ThreadLocal 为啥动不动就内存泄漏呢?</font></h1><p><font face="华文中宋" size="3">在这里先给个解释,后面咱们再详细分析:<br>首先是因为 ThreadLocal 是基于 ThreadLocalMap 实现的,其中 ThreadLocalMap 的 Entry 继承了 WeakReference ,而 Entry 对象中的 key 使用了 WeakReference 封装,也就是说, Entry 中的 key 是一个弱引用类型,对于弱引用来说,它只能存活到下次 GC 之前<br>如果此时一个线程调用了 ThreadLocalMap 的 set 设置变量,当前的 ThreadLocalMap 就会新增一条记录,但由于发生了一次垃圾回收,这样就会造成一个结果: key 值被回收掉了,但是 value 值还在内存中,而且如果线程一直存在的话,那么它的 value 值就会一直存在<br>这样被垃圾回收掉的 key 就会一直存在一条引用链: Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; Value :</font></p><p><img src="/images/2020/引用链.jpg"></p><p><font face="华文中宋" size="3">就是因为这条引用链的存在,就会导致如果 Thread 还在运行,那么 Entry 不会被回收,进而 value 也不会被回收掉,但是 Entry 里面的 key 值已经被回收掉了<br>这只是一个线程,如果再来一个线程,又来一个线程…多了之后就会造成内存泄漏</font></p><p><font face="华文中宋" size="3">知道是怎么造成内存泄漏之后,接下来要做的事情就好说了,不是因为 value 值没有被回收掉所以才会导致内存泄露的嘛<br>那使用完 key 值之后,将 value 值通过 remove 方法 remove 掉,这样的话内存中就不会有 value 值了,也就防止了内存泄漏嘛</font></p><h1 id="ThreadLocal-是基于-ThreadLocalMap-实现的"><a href="#ThreadLocal-是基于-ThreadLocalMap-实现的" class="headerlink" title="ThreadLocal 是基于 ThreadLocalMap 实现的?"></a><font face="华文中宋" size="3">ThreadLocal 是基于 ThreadLocalMap 实现的?</font></h1><p><font face="华文中宋" size="3">OK ,上面的内容讲完了,接下来一一来看<br>首先,你怎么知道 ThreadLocal 是基于 ThreadLocalMap 实现的呢?<br>从源码知道的~<br>在源码中能够看到下面这几行代码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">代码中说的很清楚了,在 ThreadLocal 内部维护着 ThreadLocalMap ,而它的 Entry 则继承自 WeakReference 的 ThreadLocal&lt;?&gt; ,其中 Entry 的 k 为 ThreadLocal , v 为 Object ,在调用 super(k) 时就将 ThreadLocal 实例包装成了一个 WeakReference</font></p><p><font face="华文中宋" size="3">强弱引用这块内容我就直接放一个表格吧:</font></p><table><thead><tr><th style="text-align:center">引用类型</th><th style="text-align:center">功能特点</th></tr></thead><tbody><tr><td style="text-align:center">强引用 ( Strong Reference )</td><td style="text-align:center">被强引用关联的对象永远不会被垃圾回收器回收掉</td></tr><tr><td style="text-align:center">软引用( Soft Reference )</td><td style="text-align:center">软引用关联的对象,只有当系统将要发生内存溢出时,才会去回收软引用引用的对象</td></tr><tr><td style="text-align:center">弱引用 ( Weak Reference )</td><td style="text-align:center">只被弱引用关联的对象,只要发生垃圾收集事件,就会被回收</td></tr><tr><td style="text-align:center">虚引用 ( Phantom Reference )</td><td style="text-align:center">被虚引用关联的对象的唯一作用是能在这个对象被回收器回收时收到一个系统通知</td></tr></tbody></table><p><font face="华文中宋" size="3">从表格中应该能够看出来,弱引用的对象只要发生垃圾收集事件,就会被回收<br>所以弱引用的存活时间也就是下次 GC 之前了<br>在这里我有个问题:为什么 ThreadLocal 采用弱引用,而不是强引用呢?<br>在 ThreadLocalMap 上面有些注释,我在这里摘录一部分,或许可以从中窥探一二:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To help deal with very large and <span class="keyword">long</span>-lived usages, the hash table entries use WeakReferences <span class="keyword">for</span> keys</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">翻译一下就是:(虽然我英语不是很好<br>为了解决非常大且长期使用的问题,哈希表使用了弱引用的 key<br>假设,假设, ThreadLocal 使用的是强引用,会怎样呢?<br>如果是强引用的话,在表格中也能够看出来,被强引用关联的对象,永远都不会被垃圾回收器回收掉<br>如果引用的 ThreadLocal 对象被回收了,但是 ThreadLocalMap 还持有对 ThreadLocal 的强引用,如果没有 remove 的话, 在 GC 时进行可达性分析, ThreadLocal 依然可达,这样就不会对 ThreadLocal 进行回收,但是我们期望的是引用的 ThreadLocal 对象被回收,这样不就达不到目的了嘛<br>使用弱引用的话,虽然会出现内存泄漏的问题,但是在 ThreadLocal 生命周期里面,都有对 key 值为 null 时进行回收的处理操作<br>所以,使用弱引用的话,可以在 ThreadLocal 生命周期中尽可能保证不出现内存泄漏的问题</font></p><p><font face="华文中宋" size="3">啥?在 ThreadLcoal 生命周期里面,都有对 key 值为 null 时进行回收的处理操作?<br>有证据么?<br>我这篇文章都这么写了,要是没有敢拿出来说么(毕竟我是个负责任的博主不是;<br>在源码中, get 方法, set 方法中都有相应的处理,咱们瞅瞅具体是怎么做的(先来看 set 方法)</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         <span class="comment">// 如果 e 不为空,说明 hash 冲突,需要向后查找</span></span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 从这里可以看出, ThreadLocalMap 采用的是开放地址法解决的 hash 冲突</span></span><br><span class="line">         <span class="comment">// 是最经典的 线性探测法 --&gt; 我觉得之所以选择这种方法解决冲突时因为数据量不大</span></span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要查找的 ThreadLocal 对象找到了,直接设置需要设置的值,然后 return</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 k 为 null ,说明有 value 没有及时回收,此时通过 replaceStaleEntry 进行处理</span></span><br><span class="line">        <span class="comment">// replaceStaleEntry 具体内容等下分析</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 tab[i] == null ,则直接创建新的 entry 即可</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 在创建之后调用 cleanSomeSlots 方法检查是否有 value 值没有及时回收</span></span><br><span class="line">    <span class="comment">// 如果 sz &gt;= threshold ,则需要扩容,重新 hash 即, rehash();</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">通过源码可以看到,在 set 方法中,主要是通过 <code>replaceStaleEntry</code> 方法和 <code>cleanSomeSlots</code> 方法去做的检测和处理<br>那咱从源码看看 <code>replaceStaleEntry</code> 它干了啥</font></p><h1 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a><font face="华文中宋" size="3">replaceStaleEntry</font></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前 staleSlot 位置开始向前遍历</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 当 e.get() == null 时, slotToExpunge 记录下此时的 i 值</span></span><br><span class="line">            <span class="comment">// 即 slotToExpunge 记录的是 staleSlot 左手边第一个空的 Entry</span></span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来从当前 staleSlot 位置向后遍历</span></span><br><span class="line">    <span class="comment">// 这两个遍历是为了清理在左边遇到的第一个空的 entry 到右边的第一个空的 entry 之间所有过期的对象</span></span><br><span class="line">    <span class="comment">// 但是如果在向后遍历过程中,找到了需要设置值的 key ,就开始清理,不会再继续向下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 k == key 说明在插入之前就已经有相同的 key 值存在,所以需要替换旧的值</span></span><br><span class="line">        <span class="comment">// 同时和前面过期的对象进行交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 slotToExpunge == staleSlot 说明向前遍历时没有找到过期的</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 进行清理过期数据</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在向后遍历时,没有找到 value 被回收的 Entry 对象</span></span><br><span class="line">        <span class="comment">// 且刚开始 staleSlot 的 key 为空,那么它本身就是需要设置 value 的 Entry 对象</span></span><br><span class="line">        <span class="comment">// 此时不涉及到清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 key 在数组中找不到,那就好说了,直接创建一个新的就可以了</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 slotToExpunge != staleSlot 说明存在过期的对象,就需要进行清理</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 <code>replaceStaleEntry</code> 方法中,需要注意一下刚开始的两个 for 循环中内容(我再贴一下):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 当 e.get() == null 时, slotToExpunge 记录下此时的 i 值</span></span><br><span class="line">    <span class="comment">// 即 slotToExpunge 记录的是 staleSlot 左手边第一个空的 Entry</span></span><br><span class="line">    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line">                        </span><br><span class="line">    <span class="comment">// 如果 slotToExpunge == staleSlot 说明向前遍历时没有找到过期的</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    <span class="comment">// 进行清理过期数据</span></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这两个 for 循环中的 if 到底是在做什么?<br>看第一个 if ,当 <code>e.get() == null</code> 时,此时将 i 的值给 slotToExpunge<br>第二个 if ,当 <code>k ==key</code> 时,此时将 i 给了 staleSlot 来进行交换<br>为什么要对 staleSlot 进行交换呢?画图说明一下<br>如下图,假设此时表长为 10 ,其中下标为 3 和 5 的 key 已经被回收( key 被回收掉的就是 null ),因为采用的开放地址法,所以 15 mod 10 应该是 5 ,但是因为位置被占,所以在 6 的位置,同样 25 mod 10 也应该是 5 ,但是因为位置被占,下个位置也被占,所以就在第 7 号的位置上了<br>按照上面的分析,此时 slotToExpunge 值为 3 , staleSlot 值为 5 , i 为 6 </font></p><p><img src="/images/2020/exchangeOne.jpg"></p><p><font face="华文中宋" size="3">假设,假设这个时候如果不进行交换,而是直接回收的话,此时位置为 5 的数据就被回收掉,然后接下来要插入一个 key 为 15 的数据,此时 15 mod 10 算出来是 5 ,正好这个时候位置为 5 的被回收完毕,这个位置就被空出来了,那么此时就会这样:</font></p><p><img src="/images/2020/exchangeTwo.jpg"></p><p><font face="华文中宋" size="3">同样的 key 值竟然出现了两次?!这肯定是咱们不希望看到的结果,所以一定要进行数据交换<br>在上面代码中有一行代码 <code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code> ,说明接下来的处理是交给了 <code>expungeStaleEntry</code> ,接下来去分析一下 <code>expungeStaleEntry</code></font></p><h1 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry"></a><font face="华文中宋" size="3">expungeStaleEntry</font></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果 k == null ,说明 value 就应该被回收掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时直接将 e.value 置为 null </span></span><br><span class="line">            <span class="comment">// 这样就将 thread -&gt; threadLocalMap -&gt; value 这条引用链给打破</span></span><br><span class="line">            <span class="comment">// 方便了 GC</span></span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这个时候要重新 hash ,因为采用的是开放地址法,所以可以理解为就是将后面的元素向前移动</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">因为是在 <code>replaceStaleEntry</code> 方法中调用的此方法,传进来的值是 staleSlot ,继续上图,经过 <code>replaceStaleEntry</code> 之后,它的数据结构是这样:</font></p><p><img src="/images/2020/exchangeThree.jpg"></p><p><font face="华文中宋" size="3">此时传进来的 staleSlot 值为 6 ,因为此时的 key 为 null ,所以接下来会走 <code>e.value = null</code> ,这一步结束之后,就成了:</font></p><p><img src="/images/2020/exchangeFour.jpg"></p><p><font face="华文中宋" size="3">接下来 i 为 7 ,此时的 key 不为 null ,那么就会重新 hash : <code>int h = k.threadLocalHashCode &amp; (len - 1);</code> ,得到的 h 应该是 5 ,但是实际上 i 为 7 ,说明出现了 hash 冲突,就会继续向下走,最终的结果是这样:</font></p><p><img src="/images/2020/exchangeFive.jpg"></p><p><font face="华文中宋" size="3">可以看到,原来的 key 为 null ,值为 V5 的已经被回收掉了.我认为之所以回收掉之后,还要再次进行重新 hash ,就是为了防止 key 值重复插入情况的发生<br>假设 key 为 25 的并没有进行向前移动,也就是它还在位置 7 ,位置 6 是空的,再插入一个 key 为 25 ,经过 hash 应该在位置 5 ,但是有数据了,那就向下走,到了位置 6 ,诶,竟然是空的,赶紧插进去,这不就又造成了上面说到的问题,同样的一个 key 竟然出现了两次?!<br>而且经过 <code>expungeStaleEntry</code> 之后,将 key 为 null 的值,也设置为了 null ,这样就方便 GC</font></p><p><font face="华文中宋" size="3">分析到这里应该就比较明确了,在 <code>expungeStaleEntry</code> 中,有些地方是帮助 GC 的,而通过源码能够发现, set 方法调用了该方法进行了 GC 处理, get 方法也有,不信你瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果能够找到寻找的值,直接 return 即可</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果找不到,则调用 getEntryAfterMiss 方法去处理</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直探测寻找下一个元素,直到找到的元素是要找的</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果 k == null 说明有 value 没有及时回收</span></span><br><span class="line">            <span class="comment">// 调用 expungeStaleEntry 方法去处理,帮助 GC</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">get 和 set 方法都有进行帮助 GC ,所以正常情况下是不会有内存溢出的,但是如果创建了之后一直没有调用 get 或者 set 方法,还是有可能会内存溢出<br>那么最保险的方法就是,使用完之后就及时 remove 一下,加快垃圾回收,就完美的避免了垃圾回收</font></p><p><font face="华文中宋" size="3">以上,这篇文章到这里就结束了(说句真心话,我自己都没想到这篇文章写完这么长…<br>越深入理解就越是惊叹,大神的思考真是缜密~不是会因为没有及时回收 value 造成内存泄漏么,那我在 set 和 get 方法中再做一些处理,虽然没办法做到 100% 完美,但我做到 80% 可还行?</font></p><hr><p><font face="华文中宋" size="3">又是脑细胞疯狂死掉的一天 :|</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]再谈索引</title>
      <link href="/posts/4fa89adb.html"/>
      <url>/posts/4fa89adb.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在这篇文章:  <a href="https://www.dynamic-zheng.com/posts/a02f5441.html#more">[mysql]手把手教你给 SQL 做个优化</a>  中介绍了,给 SQL 做优化的时候,最主要的一点就是建索引<br><a id="more"></a><br>那你有没有新的疑问呢?<br>索引采用的数据结构是啥呢,为什么一提到 mysql 就会问 B 树, B+ 树呢<br>今天这篇文章来说说</font></p><p><font face="华文中宋" size="3">在我们给数据库中一个字段建立索引的时候,能够看到可以选择是 Hash 类型,还是 BTREE 类型的索引</font></p><p><img src="/images/2020/索引.jpg"></p><p><font face="华文中宋" size="3">那为什么 InnoDB 引擎默认使用的是 B+ 树而不是 Hash 嘞<br>你想,你细想<br>使用 Hash 的话很容易出现哈希冲突,特别是在数据量非常大的时候,出现了大量的哈希冲突会导致程序的整体查询性能变慢<br>假设我现在有个查询语句是这样写的 <code>select name,age from student where age &gt; 18</code> 这不是蛮简单的嘛,就找出来所有 age 大于 18 的数据就可以了嘛<br>但是对于使用 Hash 数据结构的索引来说,太难了.因为 Hash 是 key-value 的结构,所以它擅长的是精确查询,如果你让它查找  <code>select name,age from student where age = 18</code> 它返回结果就非常快了<br>那既然 Hash 不支持范围查询,支持 key-value ,那它的应用场景是啥呢?就是等值查询咯,给我一个 key 就可以快速回应一个 value ,咦?怎么和 Redis 那么像呢?<br>就是嘛, Redis , Memcached 它们都有用到 Hash 结构</font></p><p><font face="华文中宋" size="3">Hash 不支持范围查找,但是有序数组支持啊<br>那为啥不用有序数组嘞<br>没错,有序数组的查询性能可以说非常好了,不管是等值查询,还是范围查询,效率简直完爆其他<br>但是咱们的应用场景又不是只有查询对吧,还有插入,修改,删除呢,有序数组这个时候就顶不住了<br>特别是如果插入到头部,第一个位置,从第二位开始往后都要开始向后移动,将第一个位置空出来,这么一来,我的天,还没等你插入完毕,用户都等不及跑了</font></p><p><font face="华文中宋" size="3">那新的疑惑来了<br>B+ 树属于树的一种,二叉树也是树的一种,你咋不用二叉树呢<br>你想,你再想</font></p><p><img src="/images/2020/二叉树.jpg"></p><p><font face="华文中宋" size="3">二叉树是每个节点最多只有两个分支,每个节点只存储一个数据的树结构,那如果我的数据量非常大的话呢,比方说一个小目标, 1 亿数据<br>这个时候二叉树的高度就会变得非常高<br>既然是数据,不做持久化嘛?肯定是要持久化到磁盘的,而且就目前公司的成本来说,应该还没富到服务器的硬盘全是固态吧,有些还是机械硬盘,机械硬盘的读取速度又比较慢<br>那么此时我需要在 1 亿数据里面,查找一个数据,再加上机械硬盘的读取速度,可能给它一分钟的时间都找不到需要的数据<br>乖乖,让你在一个空白的页面上呆一分钟,你会么?<br>这个时候你的注意力早就不知道跑哪儿去了,或者这个界面打不开对么?行嘞,关闭界面,浏览下一个</font></p><p><font face="华文中宋" size="3">用户流失不是咱们希望看到的,对吧<br>所以嘞,既然二叉树是树的高度比较高,那我让它低点儿不就好了嘛<br>怎么低呢<br>因为二叉树每个节点只存储一个数据,那我现在让它一个节点多存储几个数据就好了嘛<br>这就是 B 树<br>B 树的一个节点可以存储多个数据</font></p><p><img src="/images/2020/B树.jpg"></p><p><font face="华文中宋" size="3">能够明显看到, B 树相对于二叉树来说,高度降低了不少<br>那为啥不用 B 树做索引呢,采用 B+ 树<br>因为 B+ 树在 B 树的基础上又做了优化<br>那做了什么优化呢<br>咱瞅瞅</font></p><p><img src="/images/2020/B+树.jpg"></p><p><font face="华文中宋" size="3">有没有看出来一些内容<br>在 B+ 树中,叶子节点之间有指针指向,在 B 树中则没有<br>在 B+ 树中,非叶子节点会冗余一份在叶子节点中(比如图中的数据 50 ,在叶子节点中也能看到它)<br>在 B+ 树中,非叶子节点不存储数据,只存储索引<br>在 B+树中,查询必须查找到叶子节点, B 树只要匹配到就可以了, 不需要 care 元素位置,所以 B+ 树查找更慢</font></p><p><font face="华文中宋" size="3">我这个人比较懒,图中用到的图片都是直接从网上拿下来的,拿完也忘了原文地址是啥(非常抱歉,我这个人懒不说,记性也不咋滴,懒 + 记性差到这种理直气壮的程度估计也是没谁了…<br>侵权的话您和我说一声,我立马撤下来</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 集合]你确定LinkedList 在新增/删除元素时,效率比 ArrayList 高?</title>
      <link href="/posts/bde049c8.html"/>
      <url>/posts/bde049c8.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在面试的时候都会被问到集合相关的问题,比如:你能讲讲 ArrayList 和 LinkedList 的区别吗?<br><a id="more"></a><br>那么我相信你肯定能够答上来: ArrayList 是基于数组实现的, LinkedList 是基于链表实现的<br>接下来面试官就会连环问了,那你能讲讲,它们都用在什么场景下吗?<br>我猜你一定会回答:因为 ArrayList 是基于数组实现的,所以在遍历的时候, ArrayList 的效率是要比 LinkedList 高的, LinkedList 是基于链表实现的,所以在进行新增/删除元素的时候, LinkedList 的效率是要比 ArrayList 高的<br>面试官:哦哦,好的,我大概了解了,我这边没有什么想问的了,您回去等消息可以吗<br>???发生了什么?</font></p><p><font face="华文中宋" size="3">哈哈,上面模拟了一个面试场景,是想引出来这篇文章的主题:LinkedList 在新增/删除元素时,效率比 ArrayList 高,这是真的吗?<br>我相信你也知道套路,一般这么一问,那肯定就不是真的了<br>放一张图片,这是经过我测试之后的真实结果</font></p><p><img src="/images/2020/ArrayList-LinkedList.jpg"></p><p><font face="华文中宋" size="3">测试代码因为比较多,我放在了 github 上,感兴趣想要自己动手实践的,可以去看看:  <a href="https://github.com/justdojava/java-samples/tree/master/arraylist-linkedlist-test" target="_blank" rel="noopener">arraylist-linkedlist-test</a><br>接下来分析下,为什么和以前认为的不一样</font></p><h2 id="ArrayList-与-LinkedList-新增元素比较"><a href="#ArrayList-与-LinkedList-新增元素比较" class="headerlink" title="ArrayList 与 LinkedList 新增元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 新增元素比较</font></h2><p><font face="华文中宋" size="3">从图中可以看出来, LinkedList 在新增元素时,它的效率不一定比 ArrayList 高,这是要分情况的<br>如果是从集合头部位置新增元素的话,那确实是 LinkedList 的效率要比 ArrayList 高<br>但是如果是从集合中间位置或者是尾部位置新增元素, ArrayList 效率反而要比 LinkedList 效率要高</font></p><p><font face="华文中宋" size="3">Excuse me ?竟然和我以前学的不一样?博主我学的浅,你别骗我<br>哈哈哈,为什么会这样呢<br>这是因为 ArrayList 是基于数组实现的嘛,而数组是一块连续的内存空间,所以在添加元素到数组头部时,需要对头部后面的数据进行复制重排,所以效率是蛮低的<br>但是 LinkedList 是基于链表实现的,在添加元素的时候,首先会通过循环查找到添加元素的位置,如果要添加的位置处于 List 前半段,那就从前向后找;如果位置在后半段,那就从后往前找,所以 LinkedList 添加元素到头部是非常高效的(小声 BB ,这我知道</font></p><p><font face="华文中宋" size="3">哦,这你知道?看来基础蛮不错的嘛~<br>所以当 ArrayList 在添加元素到数组中间时,有一部分数据需要复制重排,效率就不是很高,那为啥 LinkedList 比它还要低呢?这是因为 LinkedList 把元素添加到中间位置的时候,需要在添加之前先遍历查找,这个查找的时间比较耗时</font></p><p><font face="华文中宋" size="3">添加元素到尾部操作中, ArrayList 的效率要比 LinkedList 的还要高,这是为啥嘞<br>因为 ArrayList 在添加的时候不需要什么操作,直接插入就好了,所以效率蛮高的<br>但是 LinkedList 就不一样了,对于 LinkedList 来说,也不需要查找啥的,直接插入就可以了,但是需要 new 对象,还有变换指针指向对象呀,这些过程耗时加起来可就比 ArrayList 长了</font></p><p><strong><font face="华文中宋" size="3">它是有前提的,那就是 ArrayList 初始化容量是足够的情况下,才有上述的特点,如果 ArrayList 涉及到动态扩容,那它的效率肯定会降低</font></strong></p><h2 id="ArrayList-与-LinkedList-删除元素比较"><a href="#ArrayList-与-LinkedList-删除元素比较" class="headerlink" title="ArrayList 与 LinkedList 删除元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 删除元素比较</font></h2><p><font face="华文中宋" size="3">删除元素和新增元素的原理是一样的,所以删除元素的操作和新增元素的操作耗时也是很相近<br>这里就不再赘述</font></p><h2 id="ArrayList-与-LinkedList-遍历元素比较"><a href="#ArrayList-与-LinkedList-遍历元素比较" class="headerlink" title="ArrayList 与 LinkedList 遍历元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 遍历元素比较</font></h2><p><font face="华文中宋" size="3">测试结果非常明显,对于 LinkedList 来说,如果使用 for 循环的话,效率特别低,但是 ArrayList 使用 for 循环去遍历的话,就比较高<br>为啥呢?<br>emmm ,得从源码说起</font></p><p><font face="华文中宋" size="3">先来看 ArrayList 的源码吧,这个比较简单</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够看到, ArrayList 实现了 List , RandomAccess , Cloneable 还有 Serializable 接口<br>你是不是对 RandomAccess 这个接口挺陌生的?这是个啥?<br>但是通过查阅源码能够发现它也只是个空的接口罢了,那 ArrayList 为啥还要去实现它嘞<br>因为 RandomAccess 接口是一个标志接口,它标识着”只要实现该接口的 list 类,都可以实现快速随机访问”<br>实现快速随机访问?你能想到什么?这不就是数组的特性嘛!可以直接通过 index 来快速定位 &amp; 读取</font></p><p><font face="华文中宋" size="3">那你是不是就能想到, ArrayList 是数组实现的,所以实现了 RandomAccess 接口, LinkedList 是用链表实现的,所以它没有用 RandomAccess 接口实现吧?<br>beautiful ~就是这样<br>咱瞅瞅 LinkedList 源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">果然,跟咱们设想的一样,没有实现 RandomAccess 接口<br>那为啥 LinkedList 接口使用 for 循环去遍历的时候,慢的不行呢?<br>咱们瞅瞅 LinkedList 在 get 元素时,都干了点儿啥</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 get 方法中,主要调用了 node() 方法,因为 LinkedList 是双向链表,所以 <code>if (index &lt; (size &gt;&gt; 1))</code> 在判断 i 是在前半段还是后半段,如果是前半段就正序遍历,如果是在后半段那就倒序遍历,那么为什么使用 for 循环遍历 LinkedList 时,会这么慢?(好像离真相越来越近了<br>原因就在两个 for 循环之中,以第一个 for 循环为例</font></p><ul><li><font face="华文中宋" size="3">get(0) :直接拿到了node0 地址,然后拿到 node0 的数据</font></li><li><font face="华文中宋" size="3">get(1) :先拿到 node0 地址,然后 i &lt; index ,开始拿 node1 的地址,符合条件,然后去拿 node1 的数据</font></li><li><font face="华文中宋" size="3">get(2) :先拿到 node0 的地址,然后 i &lt; index ,拿到 node1 的地址, i &lt; index ,继续向下走,拿到 node2 的地址,符合条件,获取 node2 的数据</font></li></ul><p><font face="华文中宋" size="3">发现问题了嘛?我就是想要 2 的数据, LinkedList 在遍历时,将 0 和 1 也给遍历了,如果数据量非常大的话,那效率可不就唰唰的下来了嘛</font></p><p><font face="华文中宋" size="3">那到现在,咱们也就非常明确了,如果是要遍历 ArrayList 的话,最好是用 for 循环去做,如果要遍历 LinkedList 的话,最好是用迭代器去做<br>我猜你一定会说,那如果对方就给我传过来了一个 list ,我不知道它是 ArrayList 还是 LinkedList 呀?我该怎么办呢<br>还记得 ArrayList 和 LinkedList 有什么不同吗?是不是 ArrayList 实现了 RandomAccess 接口,但是 LinkedList 没有实现,所以可以从这点去着手解决</font></p><p><font face="华文中宋" size="3">我在这里给个简单的小 demo ,你可以参考下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/8/15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList.add(<span class="string">"aaa"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"bbb"</span>);</span><br><span class="line">        isUseIterator(arrayList);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        linkedList.add(<span class="string">"ccc"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"ddd"</span>);</span><br><span class="line">        isUseIterator(linkedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isUseIterator</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)&#123;</span><br><span class="line">            System.out.println(<span class="string">"实现了 RandomAccess 接口,使用 for 循环遍历"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.size(); i++ )&#123;</span><br><span class="line">                System.out.println(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有实现 RandomAccess 接口,使用迭代器遍历"</span>);</span><br><span class="line"></span><br><span class="line">            Iterator it = list.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                System.out.println(it.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">本篇文章用到的所有代码,都上传到了 github 上,需要的可以去看看:   <a href="https://github.com/justdojava/java-samples/tree/master/arraylist-linkedlist-test" target="_blank" rel="noopener">arraylist-linkedlist-test</a></font></p><p><font face="华文中宋" size="3">参考:<br>极客时间: Java 性能调优实战</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[设计模式]你不是对单例模式比较熟吗?你倒是写一个线程安全的出来呀!</title>
      <link href="/posts/2645232e.html"/>
      <url>/posts/2645232e.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我也不知道为什么,上周我明明写了文章传上来了,结果今天一瞅,嗯?我的文章呢?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">为了证明我没有说谎,我这里有图为证:</font></p><p><img src="/images/2020/设计模式.jpg"></p><p><font face="华文中宋" size="3">不多说了,咱们直接正文开始<br>单例模式比较好理解,就是保证只有一个对象被创建<br>如果是单线程下代码还比较好写一些:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面的是饿汉模式,在类加载时就开始创建<br>懒汉模式就比较懒,在使用的时候才会创建</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全--并不推荐,因为带来了性能上的开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">如果是在单线程环境下,上面的代码是没有任何问题的<br>但是如果是在多线程环境下呢?<br>现在同时有线程 A 和 B 要创建线程,此时线程 A 拿到了 instance 的值为 null ,然后 CPU 停止了当前线程 A ,线程 B 开始运行,也拿到了 instance 的值为 null ,接下来线程 A 和 B 都会去创建<br>怎么办呢?加个双重检测机制,再加个锁</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式--&gt;双重同步锁模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> * 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2, ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3, instance = memory 设置 instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 和 cpu 优化时,会发生指令重排</span></span><br><span class="line">    <span class="comment">// 有可能发生 1,3,2</span></span><br><span class="line">    <span class="comment">//此时会导致线程不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;   <span class="comment">// 使用了双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123;   <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这样双重检测再加锁看似是没有问题了<br>但是还记得吗? JVM 是会指令重排的,本来 1,2,3 运行下来没问题,结果呢,指令重排之后就变成了 1,3,2 ,还是两个线程,线程 A 拿到第一个的 instance 为 null ,线程 B 拿到的是指令重排之后的第二个 instance 为 null ,此时仍然有线程不安全的问题<br>那我不让它指令重排不就好了? volatile 就要大显身手了</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式--&gt;双重同步锁模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2, ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3, instance = memory 设置 instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 和 cpu 优化时,会发生指令重排</span></span><br><span class="line">    <span class="comment">// 有可能发生 1,3,2</span></span><br><span class="line">    <span class="comment">//此时会导致线程不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象--- volatile + 双重检测机制--&gt;禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;   <span class="comment">// 使用了双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class) &#123;   <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面都是对懒汉模式的优化,饿汉模式也想线程安全,该咋办嘞</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全---&gt;要注意 private static 和 static 的先后执行顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample6</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample6</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample6 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">还有一种最安全的方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全---最安全</span></span><br><span class="line"><span class="comment"> * 推荐使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line">        <span class="comment">// JVM 保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[mysql]手把手教你给 SQL 做个优化</title>
      <link href="/posts/a02f5441.html"/>
      <url>/posts/a02f5441.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">首先明确一个问题:如果我的 SQL 语句执行的足够快,还有没有必要去做优化?<br>完全没有必要对吧<br><a id="more"></a><br>所以我们一般说,要给 SQL 做个优化,那肯定就是这条 SQL 语句执行的比较慢了<br>那么,为什么它会执行比较慢呢?</font></p><h1 id="SQL-语句执行较慢的-3-个原因"><a href="#SQL-语句执行较慢的-3-个原因" class="headerlink" title="SQL 语句执行较慢的 3 个原因"></a><font face="华文中宋" size="3">SQL 语句执行较慢的 3 个原因</font></h1><h2 id="没有建立索引-或者索引失效导致了-SQL-语句执行较慢"><a href="#没有建立索引-或者索引失效导致了-SQL-语句执行较慢" class="headerlink" title="没有建立索引,或者索引失效导致了 SQL 语句执行较慢"></a><font face="华文中宋" size="3">没有建立索引,或者索引失效导致了 SQL 语句执行较慢</font></h2><p><font face="华文中宋" size="3">这个应该是比较好理解的,如果数据比较多,在千万级别以上,然后呢又没有建立索引,在这千万级别的数据中查找你想要的内容,简直就是在肉搏啊<br>索引失效这块内容说起来就比较多了,比如在查询的时候,让 like 通配符在前面了,比如经常念叨的”最左匹配原则”,又比如我们在查询条件中使用 or ,而且 or 前后条件中有一个列没有索引,等等这些情况都会导致索引失效</font></p><h2 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a><font face="华文中宋" size="3">锁等待</font></h2><p><font face="华文中宋" size="3">常用的存储引擎主要有 InnoDB 和 MyISAM 这两种了,前者支持行锁和表锁,后者就只支持表锁<br>如果数据库操作都是基于表锁的话,意思就是说,现在有个更新操作,就会把整张表锁起来,那么查询的操作都不被允许,所以就不要说提高系统的并发性能了</font></p><ul><li><font face="华文中宋" size="3">聪明的你肯定就知道了,既然 MyISAM 只支持表锁,那么使用 InnoDB 不就好了?你以为 InnoDB 的行锁不会升级成表锁嘛? too young too simple !</font></li><li><font face="华文中宋" size="3">如果对一张表进行大量的更新操作, mysql 就觉得你这样用会让事务的执行效率降低,到最后还是会导致性能下降,这样的话,还不如把你的行锁升级成表锁呢</font></li><li><font face="华文中宋" size="3">还有一点,行锁可是基于索引加的锁,在执行更新操作时,条件索引都失效了,那么这个锁也会执行从行锁升级为表锁</font></li></ul><h2 id="不恰当的-SQL-语句"><a href="#不恰当的-SQL-语句" class="headerlink" title="不恰当的 SQL 语句"></a><font face="华文中宋" size="3">不恰当的 SQL 语句</font></h2><p><font face="华文中宋" size="3">这个也比较常见了,啥是不恰当的 SQL 语句呢?就比如,明明你需要查找的内容是 name , age ,但是呢,为了省事,直接 select * ,或者在 order by 时,后面的条件不是索引字段,这就是不恰当的 SQL 语句</font></p><h1 id="优化-SQL-语句"><a href="#优化-SQL-语句" class="headerlink" title="优化 SQL 语句"></a><font face="华文中宋" size="3">优化 SQL 语句</font></h1><p><font face="华文中宋" size="3">在知道了 SQL 语句执行比较慢的原因之后,接下来要做的就是对症下药了<br>针对 没有索引/索引失效 这块,最有效的办法就是 EXPLAIN 语法了,其实 Show Profile 也可以<br>针对 锁等待 这块,没办法了,只能自己多注意<br>针对 不恰当的 SQL 语句 这块,介绍几个常用的 SQL 优化,比如分页查询怎么优化一下可以查询的更快一些呀,你不是说 select * 不是正确的打开方式嘛?那什么是正确的 select 方式呢?我下面都会讲讲<br>废话不多说,咱们开始了</font></p><h1 id="先来个表"><a href="#先来个表" class="headerlink" title="先来个表"></a><font face="华文中宋" size="3">先来个表</font></h1><p><font face="华文中宋" size="3">为了确保优化后的结果和我写的一样(起码 90% 是相符的<br>所以咱们用一样的数据库好不好<br>首先建个 demo 的数据库</font></p><p><img src="/images/2020/建库.jpg"></p><p><font face="华文中宋" size="3">接下来咱们建表,就建个非常简单的表好不好</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE demo.table(</span><br><span class="line"><span class="function">id <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> NOT NULL,</span></span><br><span class="line"><span class="function">a <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> DEFAULT NULL,</span></span><br><span class="line"><span class="function">b <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> DEFAULT NULL,</span></span><br><span class="line"><span class="function">PRIMARY <span class="title">KEY</span><span class="params">(id)</span></span></span><br><span class="line"><span class="function">) ENGINE </span>= INNODB</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">然后插入 10 万条数据</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS demo_insert;</span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">demo_insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">    DECLARE i INT</span>; </span><br><span class="line">SET i = <span class="number">1</span>;</span><br><span class="line">    WHILE i &lt;= <span class="number">100000</span> DO</span><br><span class="line">        INSERT INTO demo.`table` VALUES (i, i, i);</span><br><span class="line">        SET i = i + <span class="number">1</span> ;</span><br><span class="line">    END WHILE;</span><br><span class="line">END;</span><br><span class="line"><span class="function">CALL <span class="title">demo_insert</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3"> OK ,准备工作做好了,接下来开始实战</font></p><h2 id="通过-EXPLAIN-分析-SQL-是怎样执行的"><a href="#通过-EXPLAIN-分析-SQL-是怎样执行的" class="headerlink" title="通过 EXPLAIN 分析 SQL 是怎样执行的"></a><font face="华文中宋" size="3">通过 EXPLAIN 分析 SQL 是怎样执行的</font></h2><p><font face="华文中宋" size="3">只要说 SQL 调优,那就离不开 EXPLAIN </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `table` WHERE id &lt; <span class="number">100</span> ORDER BY a;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/explain.jpg"></p><p><font face="华文中宋" size="3">咱们能够看到有好几个参数:</font></p><ul><li><font face="华文中宋" size="3">id :每个执行计划都会有一个 id ,如果是一个联合查询的话,这里就会显示好多个 id</font></li><li><font face="华文中宋" size="3">select_type :表示的是 select 查询类型,常见的就是 SIMPLE (普通查询,也就是没有联合查询/子查询), PRIMARY (主查询), UNION ( UNION 中后面的查询), SUBQUERY (子查询)</font></li><li><font face="华文中宋" size="3">table :执行查询计划的表,在这里我查的就是 table ,所以显示的是 table, 那如果我给 table 起了别名 a ,在这里显示的就是 a</font></li><li><font face="华文中宋" size="3">type :查询所执行的方式,这是咱们在分析 SQL 优化的时候一个非常重要的指标,这个值从好到坏依次是: system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL <ul><li><font face="华文中宋" size="3">system/const :说明表中只有一行数据匹配,这个时候根据索引查询一次就能找到对应的数据</font></li><li><font face="华文中宋" size="3">eq_ref :使用唯一索引扫描,这个经常在多表连接里面,使用主键和唯一索引作为关联条件时可以看到</font></li><li><font face="华文中宋" size="3">ref :非唯一索引扫描,也可以在唯一索引最左原则匹配扫描看到</font></li><li><font face="华文中宋" size="3">range :索引范围扫描,比如查询条件使用到了 &lt; ,  &gt; ,  between 等条件</font></li><li><font face="华文中宋" size="3">index :索引全表扫描,这个时候会遍历整个索引树</font></li><li><font face="华文中宋" size="3">ALL :表示全表扫描,也就是需要遍历整张表才能找到对应的行</font></li></ul></font></li><li><font face="华文中宋" size="3">possible_keys :表示可能使用到的索引</font></li><li><font face="华文中宋" size="3">key :实际使用到的索引</font></li><li><font face="华文中宋" size="3">key_len :使用的索引长度</font></li><li><font face="华文中宋" size="3">ref :关联 id 等信息</font></li><li><font face="华文中宋" size="3">rows :找到符合条件时,所扫描的行数,在这里虽然有 10 万条数据,但是因为索引的缘故,所以扫描了 99 行的数据</font></li><li><font face="华文中宋" size="3">Extra :额外的信息,常见的有以下几种<ul><li><font face="华文中宋" size="3">Using where :不用读取表里面的所有信息,只需要通过索引就可以拿到需要的数据,这个过程发生在对表的全部请求列都是同一个索引部分时</font></li><li><font face="华文中宋" size="3">Using temporary :表示 mysql 需要使用临时表来存储结果集,常见于 group by / order by</font></li><li><font face="华文中宋" size="3">Using filesort :当查询的语句中包含 order by 操作的时候,而且 order by 后面的内容不是索引,这样就没有办法利用索引完成排序,就会使用”文件排序”,就像例子中给出的,建立的索引是 id , 但是我的查询语句 order by 后面是 a ,没有办法使用索引</font></li><li><font face="华文中宋" size="3">Using join buffer :使用了连接缓存</font></li><li><font face="华文中宋" size="3">Using index :使用了覆盖索引</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">如果对这些参数了解的非常不错,那么 EXPLAIN 这块内容就难不住你了</font></p><h2 id="Show-Profile-分析下-SQL-执行性能"><a href="#Show-Profile-分析下-SQL-执行性能" class="headerlink" title="Show Profile 分析下 SQL 执行性能"></a><font face="华文中宋" size="3">Show Profile 分析下 SQL 执行性能</font></h2><p><font face="华文中宋" size="3">通过 EXPLAIN 分析执行计划,只能说明 SQL 的外部执行情况,如果想要知道 mysql 具体是如何查询的,需要通过 Show Profile 来分析</font></p><p><font face="华文中宋" size="3">可以通过 <code>SHOW PROFILES;</code> 语句来查询最近发送给服务器的 SQL 语句,默认情况下是记录最近已经执行的 15 条记录,如下图我们可以看到:</font></p><p><img src="/images/2020/showprofile.jpg"></p><p><font face="华文中宋" size="3">我想看具体的一条语句,看到 Query_ID 了嘛?然后运行下 <code>SHOW PROFILE FOR QUERY 82;</code> 这条命令就可以了:</font></p><p><img src="/images/2020/queryid.jpg"></p><p><font face="华文中宋" size="3">可以看到,在结果中, Sending data 耗时是最长的,这是因为此时 mysql 线程开始读取数据并且把这些数据返回到客户端,在这个过程中会有大量磁盘 I/O 操作<br>通过这样的分析,我们就能知道, SQL 语句在查询过程中,到底是 磁盘 I/O 影响了查询速度,还是 System lock 影响了查询速度</font></p><h2 id="分页查询怎么可以更快一些"><a href="#分页查询怎么可以更快一些" class="headerlink" title="分页查询怎么可以更快一些"></a><font face="华文中宋" size="3">分页查询怎么可以更快一些</font></h2><p><font face="华文中宋" size="3">在使用分页查询时,都会使用 limit 关键字<br>但是对于分页查询,其实还可以优化一步<br>我这里给出的数据库不是太好,因为它太简单了,看不出来有什么区别,我使用目前项目上正在用的表来做个实验,可以看下区别(使用的 SQL 语句如下面):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `te_paper_record` ORDER BY id LIMIT <span class="number">10000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM `te_paper_record` WHERE id &gt;= ( SELECT id FROM `te_paper_record` ORDER BY id LIMIT <span class="number">10000</span>, <span class="number">1</span>) LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/不使用子查询.jpg"></p><p><img src="/images/2020/使用子查询.jpg"></p><p><font face="华文中宋" size="3">上面一张图片,我没有使用子查询,可以看到执行了 0.033s ,下面的查询语句,我使用了子查询去做优化,能够看到执行了 0.007s ,优化的结果还是很显而易见的</font></p><p><font face="华文中宋" size="3">那么,为什么使用了子查询,查询的速度就提上来了呢,这是因为当我们没有使用子查询时,查询到的 10020 行数据都返回回来了,接下来要对这 10020 行数据再进行操作<br>那可不可以直接就返回需要的 20 行数据呢?可以,子查询就是在做这件事情<br>所以查询时间上有了一个很大的优化</font></p><h2 id="正确的-select-打开方式"><a href="#正确的-select-打开方式" class="headerlink" title="正确的 select 打开方式"></a><font face="华文中宋" size="3">正确的 select 打开方式</font></h2><p><font face="华文中宋" size="3">在查询时,有时为了省事,直接使用 <code>select * from table where id = 1</code> 这样的 SQL 语句,但是这样的写法在一些环境下是会存在一定的性能损耗的<br>所以最好的 select 查询就是,需要什么字段就查询什么字段<br>一般在查询时,都会有条件,按照条件查找<br>这个时候正确的 select 打开方式是什么呢?</font></p><p><font face="华文中宋" size="3">如果可以通过主键索引的话, where 后面的条件,优先选择主键索引<br>为什么呢?这就要知道 MySQL 的存储规则<br>MySQL 常用的存储引擎有 MyISAM 和 InnoDB , InnoDB 会创建主键索引,而主键索引属于聚簇索引,也就是在存储数据时,索引是基于 B+ 树构成的,具体的行数据则存储在叶子节点</font></p><p><font face="华文中宋" size="3">也就是说,如果是通过主键索引查询的,会直接搜索 B+ 树,从而查询到数据<br>如果不是通过主键索引查询的,需要先搜索索引树,得到在 B+ 树上的值,再到 B+ 树上搜索符合条件的数据,这个过程就是”回表”<br>很显然,回表能够产生时间.<br>这也是为什么建议, where 后面的条件,优先选择主键索引</font></p><h1 id="其他调优"><a href="#其他调优" class="headerlink" title="其他调优"></a><font face="华文中宋" size="3">其他调优</font></h1><p><font face="华文中宋" size="3">看完上面的,心里应该就大概有数了, SQL 调优主要就是建立索引/防止产生锁等待/使用恰当的 SQL 语句去查询<br>但是,如果问你除了索引,除了上面这些手段,还有没有其他调优方式<br>啥?竟然还有?!<br>有的,这就需要跳出来,不要局限在具体的 SQL 语句上了,需要在数据库设计之初就考虑好<br>比如说,我们常说的要遵循三范式,但是其实有些时候,表里面有些冗余字段带来的效果要更好<br>当然了,这块的内容可能 DBA 就已经考虑好了,但是多了解一点儿也没什么坏处嘛</font></p><p><font face="华文中宋" size="3">OK ,这次的分享就这样啦~<br>非常感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]我最近在做的事情</title>
      <link href="/posts/6240cbda.html"/>
      <url>/posts/6240cbda.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周的时候,就已经预告了,这周文章也是水文一篇,因为我说最近比较忙嘛<br>那今天就来交代下,最近在忙什么<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">自考<br>八月初有考试,自学考试.(是的,你没看错,就是下周<br>我知道要早点儿开始学,但是一直到七月初我才开始看书,七月二十号的样子,才把课本第一遍看完,这个时候还没看课后题,也没有刷题<br>没办法,都是以前欠下的债<br>为了抓紧一切时间学习,大早上六点就起床,自己都被自己感动哭了</font></p><p><font face="华文中宋" size="3">写作训练营<br>我感觉自己最近写作遇到了瓶颈,我不知道该怎么去写一篇文章,写完之后阅读量也不怎么样,也不知道该写什么<br>这个时候就需要一位老师来帮助我了.正好一直信任的明白老师开了一个写作训练营,果断花了 1K+ 报名,说实话,因为训练营还有筛选机制,我还真的挺怕把我筛掉…不过蛮幸运的,没有被筛选掉<br>所以这几天的精力,除了工作,就是自考,要么是写作训练营</font></p><p><font face="华文中宋" size="3">三件事,就足够把我的时间和精力占满,每天都掏空了自己<br>总得想办法逃出自己的舒适区不是~<br>等我忙完了考试 &amp; 参加完训练营,我再认认真真写文章</font></p><p><font face="华文中宋" size="3">目前的话,我的脑袋里面已经有了一篇文章的大纲了,预计完整写出来的话,字数大概在 3000+<br>但是因为我下周有考试嘛,所以怎么也要等我考试完了,写完发出来的话,估计就是周日晚上了<br>就这样~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]坦白了,这是我最喜欢的一部动漫</title>
      <link href="/posts/18ababf6.html"/>
      <url>/posts/18ababf6.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">坦白点儿,最近没有沉迷于学习,下班了就赖在床上刷动漫,真香!<br>虽然考试在即,可我还是想去刷我的动漫(废材就是我了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我还记得小时候看这部动漫,下课了就跑回家就是为了看这部动漫,如果停电了,都能被气的半死…(那个时候孩子还小;<br>这部动漫就是:犬夜叉<br>我自己都不知道这是刷的第几次了,自己压力大的时候,睡不着的时候,就会刷一遍,然后再刷一遍</font></p><p><img src="/images/2020/犬夜叉.jpg"></p><p><font face="华文中宋" size="3">小时候最喜欢的几部动漫:犬夜叉,名侦探柯南,网球王子,黑子的篮球,东京食尸鬼…这么一数好像喜欢的不少<br>之所以喜欢追动漫,是因为它真的给了我很多力量,特别适合在自己压力大的时候,去看看,然后我就动力满满,跟打了鸡血一样</font></p><p><font face="华文中宋" size="3">犬夜叉这部是我最喜欢的一部动漫,既然是水文一篇,那我就随便说说咯</font></p><p><font face="华文中宋" size="3">犬夜叉<br>刚开始的他,总是想获得更强大的力量,想要成为真正的妖怪<br>但是遇到桔梗之后,懂得了守护,开始想要陪伴一个人,但是因为命运,唉~<br>后来遇到了戈薇,七宝,弥勒,珊瑚,在和他们一起奋斗的日子里,开始慢慢变得信任别人,自己恢复为人的日子是不能让别人知道的,因为在这天会失去妖力,如果让别人知道,自己可能就会失去性命,到最后,越来越多的人知道朔日之夜,在变成人类的那个夜晚,他也越来越坦然<br>应该是真正接受了自己的身份吧</font></p><p><font face="华文中宋" size="3">戈薇<br>不得不说高桥留老师的心思细腻,戈薇只是一个女孩,她喜欢犬夜叉,当她看到犬夜叉放不下桔梗的时候,自己也会悲伤,也会嫉妒<br>桔梗被奈落的瘴气所伤,能净化的只有戈薇,戈薇但凡是有一点不想救桔梗的心,就会失败<br>最后成功救到了桔梗,因为她的心是善良的<br>她会大大方方的承认自己喜欢犬夜叉,也大大方方的承认自己嫉妒桔梗,这份坦诚,真的让人很感动</font></p><p><font face="华文中宋" size="3">弥勒 &amp; 珊瑚<br>这两个人,背负的东西都太多了<br>一个是不知道自己什么时候会死,一个是亲眼目睹了自己的家人被弟弟亲手杀害<br>但他们在旅行的途中,彼此治愈着 &amp; 温暖着<br>特别是完结篇,弥勒为了能够更好的保护珊瑚,喝下了可以抑制痛苦的药;在最后珊瑚说想陪他,最后还是不忍心</font></p><p><font face="华文中宋" size="3">杀生丸<br>这个人物简直不要太帅~<br>我还记得小时候看的,觉得杀生丸特别讨厌犬夜叉,因为犬夜叉是半妖,杀生丸是从内心鄙视犬夜叉的<br>相比于犬夜叉因为半妖的身份受尽欺负,杀生丸简直是含着金钥匙出生的,一出生就拥有很强大的力量,直接就是别人的顶点,但也是这一点,让他不知道什么是害怕,什么是恐惧,别人执着的东西,他是不屑的,就像四魂之玉一样,别的妖怪费尽心思想要,他却一看都不看<br>一直执着于获得铁碎牙的他,却一直被铁碎牙的结界给拒绝,后来在玲的陪伴下,慢慢了解到什么是恐惧,在完结篇中,玲因为在冥界承受不住阴气失去呼吸,天生牙也没办法拯救她时,杀生丸慌了,整个表情痛苦不已<br>啊啊啊,整部动漫就这里让杀生丸痛苦了,可以想象他的改变有多大~<br>知道害怕和恐惧之后,不再执着于获得铁碎牙的力量,反而因此获得了自己的力量—爆碎牙</font></p><p><font face="华文中宋" size="3">奈落<br>每次看到他,都想不行,我一定要继续快点儿看,这样才能看到他死去<br>奈落为了获得四魂之玉伤害了很多人,利用了很多人,践踏别人的感情<br>但是他又是可怜的,他所做的一切,也不过是为了得到桔梗的心<br>但是啊,爱情这种事情,怎么可能是你想得到就可以得到的呢<br>爱而不得的奈落,杀死了桔梗,玩弄别人的感情在股掌之中,可是想想,如果不曾体会过感情的话,又怎么可能玩弄别人的感情呢<br>奈落是爱桔梗的,但是他的爱,等不来她</font></p><p><font face="华文中宋" size="3">桔梗<br>这个人物是我最不想写的,太悲情了<br>身为一个巫女,她的一生都是活在战斗中的,后来复活的她,也是为了消除四魂之玉奋斗着,独自一人奋斗着,想想就觉得好孤独啊<br>印象特别深刻的是一个场景:在一个夜晚,犬夜叉和戈薇起来看星星,戈薇身上披着的是犬夜叉的火鼠裘,靠在犬夜叉的肩上,而与此同时,桔梗孤独一人只有死魂虫陪着她,在月色下她在想:犬夜叉,你现在在做什么呢<br>太让人心疼了~<br>明明她也只是一个平凡的女子啊,明明她也只是想过平凡的日子呀</font></p><p><font face="华文中宋" size="3">这篇文章就是这样啦~其实其他人物也很饱满 &amp; 鲜活,如果有想写的,等我再刷一遍,哈哈哈<br>对了,预告下,估计下周的文章我也要水一篇了<br>emmm ,最近有点儿忙<br>就酱~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]CopyOnWrite 了解吗?</title>
      <link href="/posts/9af0bfae.html"/>
      <url>/posts/9af0bfae.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font face="华文中宋" size="3">概念</font></h1><p><font face="华文中宋" size="3">CopyOnWrite 只是看字面意思就能看出来,就是在写入时复制<br>说得轻巧,写入时复制,具体是怎么实现的呢?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">先来说说思想,具体怎么实现等下分析<br>CopyOnWrite 的思想就是:当向一个容器中添加元素的时候,不是直接在当前这个容器里面添加的,而是复制出来一个新的容器,在新的容器里面添加元素,添加完毕之后再将原容器的引用指向新的容器,这样就实现了写入时复制<br>你还记得在提到数据库的时候,我们经常说主从复制,读写分离吗? CopyOnWrite 的设计思想是不是和经常说的主从复制,读写分离如出一撤?</font></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><font face="华文中宋" size="3">优缺点</font></h1><p><font face="华文中宋" size="3">了解概念之后,对它的优缺点应该就比较好理解了<br>优点就是,读和写可以并行执行,因为读的是原来的容器,写的是新的容器,它们之间互不影响,所以读和写是可以并行执行的,在某些高并发场景下,可以提高程序的响应时间</font></p><p><font face="华文中宋" size="3">但是呢,你也看到了, CopyOnWrite 是在写入的时候,复制了一个新的容器出来,所以要考虑它的内存开销问题,又回到了在学算法时一直强调的一个思想:拿空间换时间<br>还有一点就是,它只保证数据的最终一致性.因为在读的时候,读取的内容是原容器里面的内容,新添加的内容是读取不到的</font></p><p><font face="华文中宋" size="3">基于它的优缺点应该就可以得出一个结论: CopyOnWrite 适用于写操作非常少的场景,而且还能够容忍读写的暂时不一致<br>如果你的应用场景不适合,那还是考虑使用别的方法来实现吧</font></p><p><font face="华文中宋" size="3">还有一点需要注意的是:在写入时,它会复制一个新的容器,所以如果有写入需求的话,最好可以批量写入,因为每次写入的时候,容器都会进行复制,如果能够减少写入的次数,就可以减少容器的复制次数</font></p><p><font face="华文中宋" size="3">在 JUC 包下,实现 CopyOnWrite 思想的就是 CopyOnWriteArrayList &amp; CopyOnWriteArraySet 这两个方法,本篇文章侧重于讲清楚 CopyOnWriteArrayList</font></p><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><font face="华文中宋" size="3">CopyOnWriteArrayList</font></h1><p><font face="华文中宋" size="3">在 CopyOnWriteArrayList 中,需要注意的是 add 方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 在写入的时候,需要加锁,如果不加锁的话,在多线程场景下可能会被 copy 出 n 个副本出来</span></span><br><span class="line">    <span class="comment">// 加锁之后,就能保证在进行写时,只有一个线程在操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制原来的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将要添加的元素添加到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将对原数组的引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在写的时候需要加锁,但是在读取的时候不需要添加<br>因为读取的是原数组的元素,对新数组没有什么影响,加了锁反而会增加性能开销</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子:"></a><font face="华文中宋" size="3">举个例子:</font></h1><p><font face="华文中宋" size="3">CopyOnWrite 在 JUC 包下,那么它就保证了线程安全<br>咱们来做个小 demo 验证一下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面是客户端请求 5000 次,有 200 个线程在同时请求,我使用的是 ArrayList 实现,咱们看下打印结果:</font></p><p><img src="/images/2020/ArrayListDemo.jpg"></p><p><font face="华文中宋" size="3">如果是线程安全的话,那么最后的结果应该是 5000 才对,多运行几次你会发现,每次程序的执行结果都是不一样的<br>如果是 CopyOnWriteArrayList 呢?</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"excepiton"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">多运行几次,结果都是一样的:</font></p><p><img src="/images/2020/CopyOnWriteArrayListDemo.jpg"></p><p><font face="华文中宋" size="3">CopyOnWriteArrayList 是线程安全的</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读~</font></p><hr><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[年中总结]若能控制住粗鄙的狂喜</title>
      <link href="/posts/2d11cb2d.html"/>
      <url>/posts/2d11cb2d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">每次都是感叹,时间怎么就过的这么快呢~<br>七月份了,说明啥?说明就这么一眨眼的时间,半年就过去了(要不我不眨眼了行不,时间就别过这么快了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">还记得以前自己的总结都能写出好长一篇出来,这次真的是有点儿惆怅了,不知道该写点儿啥</font></p><p><font face="华文中宋" size="3">要说起来的话,这半年就做了两件事:好好工作,好好精进自己<br>好好工作没啥说的,精进自己主要是从 技术 &amp; 眼界 两方面来提高自己</font></p><p><font face="华文中宋" size="3">今年情况也都知道,寒冬嘛,更应该做的就是提高自己<br>技术方面看我以前写的博客就能够看出来最近都干了啥<br>眼界这方面,第一就是自己不断地去学习吧(大年三十那天我还在读书 &amp; 写作,你敢信?<br>第二就是看自己身边优秀的朋友们都在做什么.我是觉得他们都那么厉害,那我跟着他们的脚步去走,最后应该也不会很差</font></p><p><font face="华文中宋" size="3">过去的一年,受明白老师影响蛮大的<br>看到他也会偷懒,看到他也会嫉妒,看到他也会焦虑,看到他也会纠结,让我觉得我不是一个人<br>我是那种,如果今天一天我是睡过去了,或者是玩过去了,没有看一会儿书,没有输出一点儿内容,就会无限制的责怪自己:你怎么能这样呢,时间这么宝贵,你怎么就这么浪费了呢<br>近距离观察明白老师之后,让我知道了再厉害的人也都有自己的情绪,所以现在我也在慢慢的去接受自己,或好或坏都在努力接受着<br>但是有时候如果一天什么都没做,就又会自觉不自觉的去责怪自己,比以前做的好的一点是:发现自己有这方面的倾向之后,觉察到自己的情绪之后,赶快去做调整<br>明白老师,乔老师还有 Ju 老师会在我不知所措的时候给我建议 &amp; 鼓励,能够得到他们的指点和教导,真的是一件值得感恩的事情<br>不知不觉认识他们都一年了,感觉就像是老友一般</font></p><p><font face="华文中宋" size="3">如果真要说起来的话,过去的半年,甚至是过去的很多年里,我一直都被身边的朋友们善待着 &amp; 治愈着<br>感恩,感谢遇到的所有~</font></p><p><font face="华文中宋" size="3">我知道,到了人生这一个时刻,其实都是要靠自己的,对那句话: <code>一个人的对手只有一个,那就是自己</code> 理解的也更加深刻<br>因为在这漫长的岁月中,你要不断的和自己的情绪,懒惰和意志去做斗争,而且你会发现,在绝大多数情况下,只能缴械投降,你还会发现,这事儿吧,就得你自己去做,你的朋友帮不了你,你的家人也帮不了你,只有你,只有你自己去面对这一切,是好的还是坏的,都是自己的,要自己接纳自己,要自己去努力 &amp; 奋斗<br>众生皆苦,只可自渡</font></p><p><font face="华文中宋" size="3">其实也正是因为能够深刻理解一个人才是常态,所以更加觉得成年人之间的温暖,是及其珍贵的<br>帮助过我的,一直惦记着我的,总是鼓励着我的,我都有记在心里,没啥说的,拿行动说话<br>如果你有幸感受到成年人之间的温暖,好好珍惜<br>如果还没有遇到,别太担心,照顾好自己</font></p><p><font face="华文中宋" size="3">人生最重要的不是快乐,而是平和<br>所以,如果能够控制住粗鄙的狂喜,就不会有深入骨髓的悲伤<br>人生路还长,不要着急,要慢慢来</font></p><p><font face="华文中宋" size="3">我又成功的水了一篇文章,又成功的骗你看到这里<br>哈哈哈,谢谢你,耐心看这篇文章到这里,看我的各种碎碎念</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年中总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]你知道不知道 Fork/Join ?</title>
      <link href="/posts/a16e4d0e.html"/>
      <url>/posts/a16e4d0e.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果要说 Fork/Join 的话,就得来说说分治.<br><a id="more"></a><br>分治分治,就是分而治之嘛,具体一点儿就是把一个复杂的问题分解成多个相似的子问题,然后呢,再把子问题分解成更小的子问题,直到子问题简单到可以直接求解才算结束<br>这种思想,是不是让你想起了归并排序/快速排序/二分查找?没错,这些算法的实现也是借助了分治的思想</font></p><p><font face="华文中宋" size="3">分治分治,估计可以猜出来吧,最重要的就是两点:一个是分,一个是治<br>分什么呢?就是把一个复杂的问题分解成子问题,直到子问题可以直接求解结束<br>治什么呢?刚刚把分解的子问题求解出来了对吧?那是不是要汇总一下,最后求出总问题的解?<br>千言万语不如一张图,那就来张图:</font></p><p><img src="/images/2020/fork&join.jpg"></p><p><font face="华文中宋" size="3">看完有没有觉得,哦,原来这就是 fork/join 的赶脚?<br>如果有的话,那我这张图就没白画,头发没白掉~</font></p><h1 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a><font face="华文中宋" size="3">ForkJoinTask</font></h1><p><font face="华文中宋" size="3">Fork/Join 是一个并行计算的框架,主要就是用来支持分治任务模型的<br>Fork/Join 计算框架主要包含两部分,一部分是<strong>分治任务的线程池 ForkJoinPool </strong> ,另一部分是<strong>分治任务 ForkJoinTask </strong> ,先来看 ForkJoinTask<br>因为如果你想要 join 的话,是不是要先有 fork ?而 fork 方法在 ForkJoinTask 里面,所以咱们先来看看它</font></p><p><font face="华文中宋" size="3">在源码中,能够看到 fork 方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// ForkJoinWorkerThread 是执行 ForkJoinTask 的专有线程</span></span><br><span class="line">    <span class="comment">// 判断当前线程是否是 ForkJoin 专有线程,如果是则将任务 push 到当前线程所负责的队列里面去</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 如果不是 ForkJoin 专有线程,就将任务提交到默认的 common 线程池中</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">仔细看的话, fork() 就做了一件事,就是把<strong>任务放到当前工作线程的工作队列中</strong><br>咱们继续往下看, fork() 结束,是怎么做的 join()</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">// 调用 dojoin 方法来获取当前任务的执行状态</span></span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">    <span class="comment">// 任务异常,抛出异常</span></span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="comment">// 任务完成,返回结果</span></span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够看到, join() 方法就是等待处理任务的线程结束,然后拿到返回值<br>在 join 方法中调用了 doJoin 方法,咱们来瞅瞅它具体是个啥</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="comment">// 首先判断任务是否执行完毕,如果执行完毕,直接返回结果就可以了</span></span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    <span class="comment">// 如果没有执行完毕,接下来要判断是不是 ForkJoinWorkerThread 线程</span></span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        <span class="comment">// 如果是,判断这个任务是不是在工作队列最前边(也就是下一个执行的就是它)</span></span><br><span class="line">        <span class="comment">// tryUnpush() 方法判断任务是不是在工作队列最前边,是的话就返回 true</span></span><br><span class="line">        <span class="comment">// doExec() 方法执行任务</span></span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        <span class="comment">// 如果是在工作队列最前边,并且任务执行完毕,直接返回结果即可</span></span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        <span class="comment">// 如果不是工作队列最前边或者任务没有执行完毕,调用 awaitJoin() 来执行任务</span></span><br><span class="line">        <span class="comment">// awaitJoin(): 使用自旋使得任务执行完成,返回结果</span></span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        <span class="comment">// 如果不是 ForkJoinWorkThread 线程,执行 externalAwaitDone() 返回任务结果</span></span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">我知道,你看完上面的分析之后,就懵逼了<br>因为我当时分析这块还理解了好久<br>那如果来张图呢?</font></p><p><img src="/images/2020/join流程图.png"></p><p><font face="华文中宋" size="3">ForkJoinTask 有两个子类 –&gt; RecursiveAction &amp; RecursiveTask ,它们都是通过递归的方式来处理分治任务的,这两个子类都定义了抽象方法 compute() ,不过区别就是 RecursiveAction 定义的 compute() 没有返回值,而 RecursiveTask 定义的 compute() 方法是有返回值的</font></p><h1 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><font face="华文中宋" size="3">ForkJoinPool</font></h1><p><font face="华文中宋" size="3">ForkJoinPool 是用来执行 ForkJoinTask 任务的线程池,它负责管理线程池中的线程和任务队列,还有就是线程池是否还接受任务,显示线程的运行状态也是在这里处理<br>ForkJoinPool 本质上是一个 生产者-消费者 的实现,但是它更加的只能,因为它可以窃取别的任务,也就是说,如果一个工作线程空闲了,那么它可以”窃取”其他工作队列中的任务来做<br>接下来咱们瞅瞅 ForkJoinPool 的源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> ForkJoinPool&#125; with the given parameters, without</span></span><br><span class="line"><span class="comment"> * any security checks or parameter validation.  Invoked directly by</span></span><br><span class="line"><span class="comment"> * makeCommonPool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 私有构造方法,没有任何的安全检查和参数校验,由 makeCommonPool 直接调用</span></span><br><span class="line"> <span class="comment">// parallelism 并行度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">ForkJoinPool 由 makeCommonPool 直接调用,来瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns the common pool, respecting user settings</span></span><br><span class="line"><span class="comment"> * specified via system properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通过系统指定相关参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing properties</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>);</span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.threadFactory"</span>);</span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.exceptionHandler"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 factory 为空</span></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 getSecurityManager 返回 null ,说明系统还没有为当前应用程序建立安全管理器</span></span><br><span class="line">    <span class="comment">// 使用 defaultForkJoinWorkerThreadFactory 来进行创建</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">        <span class="comment">// 如果 getSecurityManager 返回不是 null ,说明系统为当前应用程序建立好了安全管理器</span></span><br><span class="line">        <span class="comment">// 使用 InnocuousForkJoinWorkerThreadFactory 来进行创建</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                            <span class="string">"ForkJoinPool.commonPool-worker-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这篇文章到这里,我就要划一个句号了<br>摸着良心说,这篇文章内容,相对来说不是很多,因为很多源码都还没分析到,比如使用的 <code>workQueues</code> 队列,比如如何实现的任务窃取,都还没说到,等我回头再写一篇文章出来<br>主要是分析源码,太费脑细胞 &amp; 头发了 ٩(º﹃º٩)<br>再加上最近有点儿放飞自我,沉迷于动漫中,等我刷完了动漫我再把细节补充上来</font></p><p><font face="华文中宋" size="3">就酱~<br>感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发] ThreadPoolExecutor 是如何做到线程复用的</title>
      <link href="/posts/9595861d.html"/>
      <url>/posts/9595861d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在上篇文章 <a href="https://www.dynamic-zheng.com/posts/d3e00aa7.html#more">[Java 并发]详解 ThreadPoolExecutor</a>  中说过了,创建线程池的好处之一就是它可以做到线程复用<br>那么,它是如何做到线程复用的呢?<br>这事儿,还得从源码说起<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">先解决一个基础问题:啥是线程复用?<br>如果是一个线程的话,那么在它创建的时候,我们会给它指定一个线程任务对不对?那如果执行完任务之后,这个线程是不是就会自动销毁?<br>但是在线程池中可不是呦~线程池中的线程,在执行完任务之后不会销毁,会继续执行另外的任务<br>这就是我们说的,线程复用</font></p><p><font face="华文中宋" size="3">OK ,线程复用明白了,新的问题就来了:在 ThreadPoolExecutor 中,它是如何做到线程复用的呢?<br>这就得去看源码是怎么写的了</font></p><h1 id="execute"><a href="#execute" class="headerlink" title=" execute"></a><font face="华文中宋" size="3"> execute</font></h1><p><font face="华文中宋" size="3">做到线程复用,肯定要先 execute 起来吧(这块在刚开始的文章中已经有过解释了,就直接放源码了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于 corePoolSize 时,调用 addWorker 创建核心线程来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程数不小于 corePoolSize ,就将任务添加到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="comment">// 获取到当前线程的状态,赋值给 recheck ,是为了重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果 isRunning 返回 false ,那就 remove 掉这个任务,然后执行拒绝策略,也就是回滚重新排队</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 线程池处于 running 状态,但是没有线程,那就创建线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入 workQueue 失败,尝试通过创建非核心线程来执行任务</span></span><br><span class="line">    <span class="comment">// 如果还是失败,说明线程池已经关闭或者已经饱和,会拒绝执行该任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a><font face="华文中宋" size="3">addWorker</font></h1><p><font face="华文中宋" size="3">从上面能够看出来,主要是 addWorker 方法<br>addWorker 主要是用来创建核心线程的,它主要的实现逻辑是:</font></p><ul><li><font face="华文中宋" size="3">判断线程数量有没有超过规定的数量,如果超过了就返回 false</font></li><li><font face="华文中宋" size="3">如果没有超过,就会创建 worker 对象,并初始化一个 Thread 对象,然后启动这个线程对象</font></li></ul><p><font face="华文中宋" size="3">接下来瞅瞅源码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line"><span class="comment">// 线程池状态 &gt;= SHUTDOWN 时,不再接受新的任务,直接返回 false</span></span><br><span class="line"><span class="comment">// 如果 rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty() 同样不接受新的任务,返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"><span class="comment">// wc &gt;= CAPACITY 说明线程数不够,所以就返回 false</span></span><br><span class="line"><span class="comment">// wc &gt;= (core ? corePoolSize : maximumPoolSize) 是在做判断</span></span><br><span class="line"><span class="comment">// 如果 core 为 true ,说明要创建的线程是核心线程,接下来判断 wc 是否大于 核心线程数 ,如果大于返回 false</span></span><br><span class="line"><span class="comment">// 如果 core 为 false ,说明要创建的线程是非核心线程,接下来判断 wc 是否大于 最大线程数 ,如果大于返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// CAS 操作增加 workerCount 的值,如果成功跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"><span class="comment">// 判断线程池状态有没有变化,如果有变化,则重试</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// workerCount 增加成功之后开始走下面的代码</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 worker 对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"><span class="comment">// 实例化一个 Thread 对象</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 接下来的操作需要加锁进行</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"><span class="comment">// 将任务线程添加到线程池中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line"><span class="comment">// 启动任务线程,开始执行任务</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line"><span class="comment">// 如果任务线程启动失败调用 addWorkerFailed </span></span><br><span class="line"><span class="comment">// addWorkerFailed 方法里面主要做了两件事:将该线程从线程池中移除;将 workerCount 的值减 1</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Worker-类"><a href="#Worker-类" class="headerlink" title="Worker 类"></a><font face="华文中宋" size="3">Worker 类</font></h1><p><font face="华文中宋" size="3">在 addWorker 中,主要是由 Worker 类去做一些相应处理, worker 继承 AQS ,实现 Runnable 接口<br>线程池维护的是 <code>HashSet&lt;Worker&gt;</code> ,一个由 <code>worker</code> 对象组成的 <code>HashSet</code></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">worker 继承 AQS 主要是利用 AQS 独占锁机制,来标识线程是否空闲;另外, worker 还实现了 Runnable 接口,所以它本身就是一个线程任务,在构造方法中创建了一个线程,线程的任务就是自己 <code>this.thread = getThreadFactory().newThread(this);</code><br>咱们瞅瞅里面的源码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">        * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 处理任务的线程</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">// worker 传入的任务</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Worker(Runnable firstTask) &#123;</span><br><span class="line">       <span class="comment">// 将 state 设为 -1 ,避免 worker 在执行前被中断</span></span><br><span class="line">           setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">           <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line"><span class="comment">// 创建一个线程,来执行任务</span></span><br><span class="line">           <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           runWorker(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Lock methods</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">       <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           setState(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Thread t;</span><br><span class="line">           <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   t.interrupt();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a><font face="华文中宋" size="3">runWorker</font></h1><p><font face="华文中宋" size="3">worker 类在执行 run 方法时,实际上调用的是 runWorker 方法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">       Thread wt = Thread.currentThread();</span><br><span class="line">       Runnable task = w.firstTask;</span><br><span class="line">       w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 允许中断</span></span><br><span class="line">       w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">       <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 判断 task 是否为空,如果不为空直接执行</span></span><br><span class="line">       <span class="comment">// 如果 task 为空,调用 getTask() 方法,从 workQueue 中取出新的 task 执行</span></span><br><span class="line">           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 加锁,防止被其他线程中断</span></span><br><span class="line">               w.lock();</span><br><span class="line">               <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">               <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">               <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">               <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">               <span class="comment">// 检查线程池的状态,如果线程池处于 stop 状态,则需要中断当前线程</span></span><br><span class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                   !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 执行 beforeExecute </span></span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行任务</span></span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行 afterExecute 方法</span></span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 将 task 设置为 null ,循环操作</span></span><br><span class="line">                   task = <span class="keyword">null</span>;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   <span class="comment">// 释放锁</span></span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 runWorker 方法中,首先会去执行创建这个 worker 时就有的任务,当执行完这个任务之后, worker 并不会被销毁,而是在 while 循环中, worker 会不断的调用 getTask 方法从阻塞队列中获取任务然后调用 <code>task.run()</code> 来执行任务,这样就达到了<strong>复用线程</strong>的目的.通过循环条件 <code>while (task != null || (task = getTask()) != null)</code> 可以看出,只要 getTask 方法返回值不为 null ,就会一直循环下去,这个线程也就会一直在执行,从而达到了线程复用的目的</font></p><h1 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a><font face="华文中宋" size="3">getTask</font></h1><p><font face="华文中宋" size="3">咱们来看看 getTask 方法的实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">           <span class="comment">// allowCoreThreadTimeOut 变量默认为 false ,也就是核心线程就算是空闲也不会被销毁</span></span><br><span class="line">           <span class="comment">// 如果为 true ,核心线程在 keepAliveTime 内是空闲的,就会被销毁</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果运行线程数大于最大线程数,但是缓存队列已经空了,此时递减 worker 数量</span></span><br><span class="line">           <span class="comment">// 如果有设置允许线程超时或者线程数量超过了核心线程数量,并且线程在规定时间内没有 poll 到任务并且队列为空,此时也递减 worker 数量</span></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果 timed 为 true ,会调用 workQueue 的 poll 方法</span></span><br><span class="line">               <span class="comment">// 超时时间为 keepAliveTime ,如果超过 keepAliveTime 时长的话, poll 就会返回 null </span></span><br><span class="line">               <span class="comment">// 如果返回为 null ,在 runWorker 中 </span></span><br><span class="line">               <span class="comment">// while (task != null || (task = getTask()) != null) 循环条件被打破,从而跳出循环,此时线程执行完毕</span></span><br><span class="line">               <span class="comment">// 如果 timed 为 false ( allowCoreThreadTimeOut 为 false ,并且 wc &gt; corePoolSize 为 false )</span></span><br><span class="line">               <span class="comment">// 会调用 workQueue 的 take 方法阻塞到当前</span></span><br><span class="line">               <span class="comment">// 当队列中有任务加入时,线程被唤醒, take 方法返回任务,开始执行</span></span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> r;</span><br><span class="line">               timedOut = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">源码分析到这里就差不多清楚了<br>线程复用主要体现在 runWorker 方法中的 while 循环中,在 while 循环里面, worker 会不断的调用 getTask 方法,而在 getTask 方法里,如果任务队列中没有了任务,此时如果线程是核心线程则会一直卡在 workQueue.take 方法,这个时候会被阻塞并挂起,不会占用 CPU 资源,直到拿到任务然后返回 true , 此时 runWorker 中得到这个任务来继续执行任务,从而实现了线程复用</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]详解 ThreadPoolExecutor</title>
      <link href="/posts/d3e00aa7.html"/>
      <url>/posts/d3e00aa7.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">ThreadPoolExecutor 可能在别的地方已经看过好多了,那我就尽量讲点儿不一样的知识出来<br><a id="more"></a></font></p><h1 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a><font face="华文中宋" size="3">为什么要用线程池</font></h1><p><font face="华文中宋" size="3">你有没有这样的疑惑,为什么要用线程池呢?可能你会说,我可以复用已经创建的线程呀;线程是个重量级对象,为了避免频繁创建和销毁,使用线程池来管理最好了<br>没毛病,各位都很懂哈~<br>不过使用线程池还有一个重要的点:可以控制并发的数量.如果并发数量太多了,导致消耗的资源增多,直接把服务器给搞趴下了,肯定也是不行的</font></p><p><font face="华文中宋" size="3">咱们再看看 ThreadPoolExecutor ,把这三个单词分开看, <code>Thread 线程</code>, <code>Pool 池</code>, <code>Executor</code> 执行者.如果连起来的话,是线程池执行者<br>所以呢, ThreadPoolExecutor 它强调的是 <code>Executor</code> ,而不是一般意义上的池化资源</font></p><h1 id="绕不过去的几个参数"><a href="#绕不过去的几个参数" class="headerlink" title="绕不过去的几个参数"></a><font face="华文中宋" size="3">绕不过去的几个参数</font></h1><p><font face="华文中宋" size="3">提到 ThreadPoolExecutor 那么你的小脑袋肯定会想到那么几个参数,咱们来瞅瞅源码(我就直接放有 7 个参数的那个方法了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">咱们分别来看:</font></p><ul><li><font face="华文中宋" size="3">corePoolSize :<br><font face="华文中宋" size="3">核心线程数,在线程池中有两种线程,核心线程和非核心线程.在线程池中的核心线程,就算是它什么都不做,也会一直在线程池中,除非设置了  <code>allowCoreThreadTimeOut</code> 参数</font></font></li><li><font face="华文中宋" size="3">maximumPoolSize:<br><font face="华文中宋" size="3">线程池能够创建的最大线程数.这个值 = 核心线程数 + 非核心线程数</font></font></li><li><font face="华文中宋" size="3">keepAliveTime &amp; unit :<br><font face="华文中宋" size="3">线程池是可以撤销线程的,那么什么时候撤销呢?一个线程如果在一段时间内,都没有执行任务,那说明这个线程很闲啊,那是不是就可以把它撤销掉了?<br>所以呢,如果一个线程不是核心线程,而且在 keepAliveTime &amp; unit 这段时间内,还没有干活,那么很抱歉,只能请你走人了<br>核心线程就算是很闲,也不会将它从线程池中清除,没办法谁让它是 <code>core</code> 线程呢~</font></font></li><li><font face="华文中宋" size="3">workQueue :<br><font face="华文中宋" size="3">工作队列,这个队列维护的是等待执行的 Runnable 任务对象<br>常用的几个队列: LinkedBlockingQueue , ArrayBlockingQueue , SynchronousQueue , DelayQueue<br>大厂的编码规范,相信各位都知道,并不建议使用 Executors ,最重要的一个原因就是: Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue ,在高负载情况下,无界队列很容易就导致 OOM ,而 OOM 会让所有请求都无法处理,所以在使用时,<strong>强烈建议使用有界队列</strong>,因为如果你使用的是有界队列的话,当线程数量太多时,它会走拒绝策略</font></font></li><li><font face="华文中宋" size="3">threadFactory :<br><font face="华文中宋" size="3">创建线程的工厂,用来批量创建线程的.如果不指定的话,就会创建一个默认的线程工厂</font></font></li><li><font face="华文中宋" size="3">handler :<br><font face="华文中宋" size="3">拒绝处理策略.在 workQueue 那里说了,如果使用的是有界队列,那么当线程数量大于最大线程数的时候,拒绝处理策略就起到作用了<br>常用的有四种处理策略:<ul><li><font face="华文中宋" size="3">AbortPolicy :默认的拒绝策略,会丢弃任务并抛出 RejectedExecutionException 异常</font></li><li><font face="华文中宋" size="3">CallerRunsPolicy :提交任务的线程,自己去执行这个任务</font></li><li><font face="华文中宋" size="3">DiscardOldestPolicy :直接丢弃新来的任务,也没有任何异常抛出</font></li><li><font face="华文中宋" size="3">DiscardOldestPolicy :丢弃最老的任务,然后将新任务加入到工作队列中</font></li></ul></font></font></li></ul><p><font face="华文中宋" size="3">默认拒绝策略是 AbortPolicy ,会  throw RejectedExecutionException 异常,但是这是一个运行时异常,对于运行时异常编译器不会强制 catch 它,所以就会比较容易忽略掉错误.<br>所以,如果线程池处理的任务非常重要,<strong>尽量自定义自己的拒绝策略</strong></font></p><h1 id="线程池的几个状态"><a href="#线程池的几个状态" class="headerlink" title="线程池的几个状态"></a><font face="华文中宋" size="3">线程池的几个状态</font></h1><p><font face="华文中宋" size="3">这篇文章开始我就说了,希望能写出一点儿不一样的东西,那咱们就从源码撸一撸<br>撸啥呢,源码那么多,总不能毫无目的的撸吧?<br>咱们来吧线程池的 5 种状态来撸一撸<br>在源码中,我们能够很明显看到定义的 5 种状态:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>同时,使用 AtomicInteger 类型的变量 ctl 来控制线程池的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li><font face="华文中宋" size="3">线程池创建之后就处于 RUNNING 状态</font></li><li><font face="华文中宋" size="3">调用 shutdown() 方法之后处于 SHUTDOWN 状态,此时线程池不再接受新的任务,清除一些空闲 worker ,等待阻塞队列的任务完成</font></li><li><font face="华文中宋" size="3">调用 shutdownNow() 方法后处于 STOP 状态,此时线程池不再接受新的任务,中断所有的线程,阻塞队列中没有被执行的任务也会被全部丢弃</font></li><li><font face="华文中宋" size="3">当线程池中执行的任务为空时,也就是此时 ctl 的值为 0 时,线程池会变为 TIDYING 状态,接下来会执行 terminated() 方法</font></li><li><font face="华文中宋" size="3">执行完 terminated() 方法之后,线程池的状态就由 TIDYING 转到 TERMINATED 状态</font></li></ul><p><font face="华文中宋" size="3">最后上张图总结一下:</font></p><p><img src="/images/2020/线程池状态转换.jpg"></p><h2 id="线程池是如何处理任务的"><a href="#线程池是如何处理任务的" class="headerlink" title="线程池是如何处理任务的"></a><font face="华文中宋" size="3">线程池是如何处理任务的</font></h2><p><font face="华文中宋" size="3">线程池处理任务的核心方法是 execute ,大概思路就是:</font></p><ul><li><font face="华文中宋" size="3">如果 command 为 null ,没啥说的,直接抛出异常就完事儿了</font></li><li><font face="华文中宋" size="3">如果当前线程数小于 corePoolSize ,会新建一个核心线程执行任务</font></li><li><font face="华文中宋" size="3">如果当前线程数不小于 corePoolSize ,就会将任务放到队列中等待,如果任务排队成功,仍然需要检查是否应该添加线程,所以需要重新检查状态,并且在必要时回滚排队;如果线程池处于 running 状态,但是此时没有线程,就会创建线程</font></li><li><font face="华文中宋" size="3">如果没有办法给任务排队,说明这个时候,缓存队列满了,而且线程数达到了 maximumPoolSize 或者是线程池关闭了,系统没办法再响应新的请求,此时会执行拒绝策略</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于 corePoolSize 时,调用 addWorker 创建核心线程来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程数不小于 corePoolSize ,就将任务添加到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="comment">// 获取到当前线程的状态,赋值给 recheck ,是为了重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果 isRunning 返回 false ,那就 remove 掉这个任务,然后执行拒绝策略,也就是回滚重新排队</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 线程池处于 running 状态,但是没有线程,那就创建线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入 workQueue 失败,尝试通过创建非核心线程来执行任务</span></span><br><span class="line">    <span class="comment">// 如果还是失败,说明线程池已经关闭或者已经饱和,会拒绝执行该任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在上面源码中,判断了两次线程池的状态,为什么要这么做呢?<br>这是因为在多线程环境下,线程池的状态是时刻发生变化的,可能刚获取线程池状态之后,这个状态就立刻发生了改变.如果没有二次检查的话,线程池处于非 RUNNING 状态时, command 就永远不会执行<br>来张图,总结一下上面说的:</font></p><p><img src="/images/2020/线程执行任务过程.jpg"></p><p><font face="华文中宋" size="3">这篇文章写到这里就没有啦~<br>希望你能从中得到一些收获<br>感谢你的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]跳出来,看全貌</title>
      <link href="/posts/ccdbd4d7.html"/>
      <url>/posts/ccdbd4d7.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">Java 并发这块,比较难,为啥呢,因为这一个知识点,那一个知识点的,特别碎<br>所以这个时候最重要的就是要对 Java 并发这块的知识有一个全貌<br><a id="more"></a><br>我先上一张图,下面的内容主要就是围绕这张图来说:</font></p><p><img src="/images/2020/concurrent-programming.png"></p><h1 id="主要矛盾"><a href="#主要矛盾" class="headerlink" title="主要矛盾"></a><font face="华文中宋" size="3">主要矛盾</font></h1><p><font face="华文中宋" size="3">凡事都有它的发展规律, Java 并发也是如此,不可能说突然这个事物就出来了<br>那为什么会有并发编程呢?这就要说一说 CPU/内存/磁盘 它们之间的速度差异了<br>应该都知道 CPU 的速度非常快,比内存的速度还要快,如果拿”天上一天,地上一年”来比喻 CPU 和内存之间的差异我觉得也是很合适的.内存的速度又要比磁盘的速度要快,快的量级是十倍都不止,那么可想而知, CPU 的一天,对于磁盘来说可能就是十年了.</font></p><p><font face="华文中宋" size="3">怎么办呢?既然 CPU 这么快,那就用一用 CPU 缓存嘛,我先把一些数据放在 CPU 缓存中,这样是不是读取的速度就快一些;在操作系统层面,增加进程/线程,这样如果这个线程不用 CPU 了,赶紧换另外一个线程使用;编译程序在进行编译的时候,可以将指令进行一下优化<br>这样看起来是不错,但是它们分别带来了不同的问题.比如 CPU 缓存这一块,缓存最大的问题是什么?是数据不一致问题,源数据都已经做了更新,但是在 CPU 缓存中没有去做这个更新,此时别的程序来读,就很容易导致可见性问题;操作系统增加了进程/线程,那么线程之间的切换就没有办法导致原子性问题,比如经典的 i++ ;编译器不是会对指令进行优化吗,那就没办法保证优化之后的结果还是原来的执行顺序,这就导致了有序性问题</font></p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a><font face="华文中宋" size="3">JMM</font></h1><p><font face="华文中宋" size="3">有问题就要有解决方案嘛, JMM 的存在就解决了可见性和有序性的问题,怎么解决的呢?<br>这就要说, Happens-Before 规则, volatile , synchronized , final 这些内容了.<br>以前写过一些这部分的内容,就直接放链接了: </font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/e3a1cde0.html">[Java 并发]为什么会有重排序?和 happens-before 有啥关系</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/6bdf9b1b.html">[Java 并发]你确定你了解 volatile ?</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/c8ca8c17.html">[Java 并发]深入浅出 synchronized 与锁</a></font></p><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a><font face="华文中宋" size="3">核心</font></h1><p><font face="华文中宋" size="3">并发编程的核心主要有 3 点:</font></p><ul><li><font face="华文中宋" size="3">分工<br><font face="华文中宋" size="3">因为是多线程嘛,那就肯定要分工好咯,就像一个团队,这个功能你来开发,那个功能他来开发,如果两个人开发同样一个任务,那不就有点儿浪费资源了嘛<br>在并发编程这块,分工就是由 Executor/线程池/Fork/Join 来实现的</font></font></li><li><font face="华文中宋" size="3">协作<br>分工好了,接下来就是怎么互相协作一起做好,协作的核心技术是管程,其实分工里面就有协作的解决方案,比如 Fork/Join 它就有定义分工完了怎么再协作,所以导图就没有列出,主要说了 CountDownLantch/CyclicBarrier/Monitor ,因为接下来我想针对这几个方面去写几篇文章(不偷懒的话;</font></li><li><font face="华文中宋" size="3">互斥<br>分工/同步主要说的是性能,但是在并发程序里面还要求正确,也就是”线程安全”,解决这个问题的核心就是互斥.<br>解决互斥的方案就是锁嘛.所以就有无锁和互斥锁两种方案.具体可以见思维导图</font></li></ul><p><font face="华文中宋" size="3">思维导图里面涉及到的内容,接下来我会慢慢都写出来(就是不确定什么时候写完<br>有时候我觉得自己扎到细节里面去之后,就不知道在做什么了,需要再看看全貌,也就是这张导图<br>也算是对自己接下来要写的内容的一个总结吧</font></p><p><font face="华文中宋" size="3">最后推荐几篇文章,相信你看完再看这个导图会有不小的收获</font></p><p><font face="华文中宋" size="3">文章推荐:</font></p><ul><li><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a></font></li><li><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/23fd3456.html">[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</a></font></li></ul><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]听说,你对 Java 线程的生命周期了如指掌</title>
      <link href="/posts/90b87b3d.html"/>
      <url>/posts/90b87b3d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">有点儿尴尬,前几篇文章吭哧吭哧写完发现,把最基础的给忘了,这篇文章来补一补,关于 Java 线程的生命周期,可以说是基础而又必须掌握的内容了<br>话不多说,咱们直接开聊<br><a id="more"></a></font></p><h1 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a><font face="华文中宋" size="3">通用的线程生命周期</font></h1><p><font face="华文中宋" size="3">如果要说 Java 线程的生命周期的话,就绕不过去操作系统的线程生命周期<br>毕竟 JVM 是跑在操作系统上面的嘛,绕不过去的,而且可以说, Java 语言中的线程本质上就是操作系统的线程<br>聪明的你肯定也发现了,不管是操作系统,还是 Java 或者 C# 都有线程的概念.在它们之间,关于线程的生命周期这一部分,肯定是有相同之处的,否则的话,操作系统自己一套生命周期流程, Java 又有自己的一套, C# 又有自己的一套,而且相互之间还要能够互相配合,这种成本想想就大的不行对吧</font></p><p><font face="华文中宋" size="3">所以咱们就来看看,通用的线程生命周期都有啥<br>先直接上张图(这次的图,我画的还可以吧):</font></p><p><img src="/images/2020/system-thread-state.jpg"></p><p><font face="华文中宋" size="3">可以看到,主要有 new , ready , running , waiting , terminated 5 种状态<br>其中:</font></p><ul><li><font face="华文中宋" size="3">new 只是说,这个线程被创建了,但是还不允许分配 CPU 执行.因为这个状态只是说明你在编程语言层面被创建了,操作系统层面还没有被创建,肯定就谈不上分配 CPU 执行了</font></li><li><font face="华文中宋" size="3">ready 这个状态是说,在操作系统层面已经成功创建了,所以接下来就是等待分配 CPU 执行了.还记得那句经典的嘛? ready ? go !</font></li><li><font face="华文中宋" size="3">running 的状态,相信你就知道了,我都已经 ready 了,此时如果再给我分配一下 CPU 我是不是就可以 go 了?那不就是 running 状态了嘛</font></li><li><font face="华文中宋" size="3">waiting 状态,就是线程在 running 状态的时候,突然发现,哎,我需要进行一下 I/O 操作,或者需要等待某个事件发生(比如说需要某个条件变量),这个时候是不是就不能再继续 happy 的 running 了.那咋办, waiting 一下呗<ul><li><font face="华文中宋" size="3">那你都 waiting 了,占用的 CPU 资源是不是应该释放掉?所以说, waiting 状态的线程是永远没有机会获得 CPU 使用权的.</font></li><li><font face="华文中宋" size="3">你是不是一听「永远没有机会」这几个字就给吓坏了,我该不会永远没有机会执行了吧.放心吧,你不是在 waiting 嘛,等你 wait 的事件发生了,就可以继续到 running 状态</font></li></ul></font></li><li><font face="华文中宋" size="3">当整个线程执行完毕,或者出现异常的时候,就进入了 terminated 状态,也就是线程的使命就完成啦,处于 terminated 状态的线程不会再切换到其他状态了</font></li></ul><p><font face="华文中宋" size="3">通用的线程生命周期以及它们之间是如何切换的,到这里,应该就比较清楚了<br>接下来咱们看看 Java 线程的生命周期,在这个基础上是怎么做的优化,有什么区别</font></p><h1 id="Java-线程的生命周期"><a href="#Java-线程的生命周期" class="headerlink" title="Java 线程的生命周期"></a><font face="华文中宋" size="3">Java 线程的生命周期</font></h1><p><font face="华文中宋" size="3">咱们先来瞅瞅源码定义的状态(为了突出重点,我把注释都去掉了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">NEW,</span><br><span class="line">RUNNABLE,</span><br><span class="line">BLOCKED,</span><br><span class="line">WAITING,</span><br><span class="line">TIMED_WAITING,</span><br><span class="line">TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够清楚的看到,在源码中定义了 6 种线程状态<br>刚才的通用状态有几种来着? 5 种对吧,现在是 6 种.<br>哪 6 种呢?刚才的 5 种状态以及它们之间的切换我搞清楚了,这 6 种状态它们之间又是怎么切换的呢?<br>别急,这么贴心的我,肯定也是画好了一张图的:</font></p><p><img src="/images/2020/Thread-state.png"></p><p><font face="华文中宋" size="3">这 6 个状态咱们也是分别来看:</font></p><ul><li><font face="华文中宋" size="3">NEW 到 RUNNABLE ,应该是挺容易理解的,就是 thread 调用了 start 方法<ul><li><font face="华文中宋" size="3">Java 刚创建出来的 Thread 对象就是 NEW 状态,创建 Thread 对象主要有两种方法,一种是继承 Thread 对象,重写 run() 方法,一种是实现 Runnable 接口,重写 run() 方法,并将该实现类作为创建 Thread 对象的参数,相信各位比我还要懂哈~</font></li><li><font face="华文中宋" size="3">但是还记得嘛, NEW 只是说,这个线程在编程语言层面创建了,在操作系统层面还没有创建,那当然就不会被操作系统调度了对不对,就更谈不上执行了</font></li><li><font face="华文中宋" size="3">所以 Java 线程如果想要执行的话,就必须转换到 RUNNABLE 状态,也就是 thread 调用 start 方法</font></li></ul></font></li><li><font face="华文中宋" size="3"> RUNNABLE 与 BLOCKED ,如果线程等待 synchronized 的隐式锁时,就会从 RUNNABLE 状态转到 BLOCKED 状态.因为 synchronized 修饰的方法/代码块同一时刻只允许一个线程执行,所以其他线程就只能等待了呗,当等待的线程获得 synchronized 隐式锁时,就会从 BLOCKED 状态转到 RUNNABLE 状态<ul><li><font face="华文中宋" size="3">在这里有没有个疑问?就是线程在 wait 一个条件发生时,在操作系统层面线程会转到 waiting 状态,那么在 JVM 层面呢?在 JVM 层面, Java 线程状态是不会发生变化的.也就是此时 Java 线程的状态依然是 RUNNABLE 状态</font></li></ul></font></li><li><font face="华文中宋" size="3"> RUNNABLE 与 WAITING 状态转换,我感觉图已经说得很好了,在这里不再赘述</font></li><li><font face="华文中宋" size="3"> RUNNABLE 与 TIMED_WAITING 状态转换,我感觉图已经说得很好了,在这里也不再赘述,仔细观察下会发现, TIMED_WAITING 与 WAITING 相比,就是多了超时参数,毕竟 TIMED_WAITING 是有时限等待嘛</font></li><li><font face="华文中宋" size="3"> RUNNABLE 到 TERMINATED ,这个过程比较好理解,线程执行完 run() 方法之后,就自动到 TERMINATED 状态了,当然了如果在执行 run() 方法过程中有异常抛出,也会导致线程终止<ul><li><font face="华文中宋" size="3">有时候我们可能需要强制中断 run() 方法的执行,怎么办呢?是使用 stop() 方法还是 interrupt() 方法呢?正确的姿势是调用 interrupt() 方法</font></li><li><font face="华文中宋" size="3">stop() 方法会真的杀死线程,不给线程一点儿喘息的机会,如果被杀死的线程持有 synchronized 隐式锁,那就再也不会释放掉这个锁了,接下来的线程也就没办法获得 synchronized 隐式锁,是不是特别危险?同样 suspend() 和 resume() 这两个方法也是不建议使用</font></li><li><font face="华文中宋" size="3">interrupt() 方法相比于 stop() 方法就温柔很多,它只是通知线程后续的操作可以不用去执行了,线程可以选择执行现在就不执行,当然也可以选择再执行一段时间后再停止,或者我就不听你的,非要执行完,都没关系, interrupt() 只是通知一下你而已.就比如你要做火车去一个地方,突然通知你这个火车晚点了,你可以选择无视这个通知继续等待,或者选择另外一趟高铁,但是不管你做什么,和火车站都没啥关系,它通知的责任尽到了</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">看到这里应该就比较清楚了吧<br>在 Java 线程生命周期中, RUNNABLE 状态是将 ready 和 running 两种状态合并在了一起,而 BLOCKED , WAITING , TIMED_WAITING 这三种状态其实就是 waiting 状态,也就是线程要等待某些事件发生,才能继续向下执行下去<br>关于 Java 线程的生命周期,到这里就说完啦</font></p><p><font face="华文中宋" size="3">在文章刚开始就说了, Java 线程的生命周期,可以说是基础而又必须掌握的内容,因为只有理解了 Java 线程的生命周期以及各种状态之间的转换,在诊断多线程 Bug 的时候,才能够在最短的时间内定位到问题<br>看到这里的你,如果有所收获,我会非常开心的</font></p><p><font face="华文中宋" size="3">参考:<br>极客时间—&lt; Java 并发编程实战&gt;</font></p><p><font face="华文中宋" size="3">以上<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]进来唠唠嗑</title>
      <link href="/posts/9adc1e81.html"/>
      <url>/posts/9adc1e81.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">向各位读者大大们道个歉,最近比较忙,有好多事情都想要去做,所以这周可以说没啥输入,没有好的输入,那就很难有高质量的输出嘛,所以这篇文章咱们就来唠唠嗑.要是您不想看,就不要点进来了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">时间真的是太快了,一天天的,一眨眼,这都是 5 月底了,下个月就是 6 月,说明什么?这一年就过去了一半,再瞅瞅年初给自己定的目标,就问你慌不慌?<br>说实话,我是挺慌的~</font></p><p><font face="华文中宋" size="3">再慌也得一个一个脚印的踏踏实实去走不是~<br>特别是今年情况大家也都知道,身体是非常重要的,如果身体不太好,干啥啥没劲<br>所以自从天气暖和之后,恢复了以前的生物钟,早上 6 点起床溜达锻炼去(当然也有偷懒的时候,记得有次休息太累了,直接睡到了上午十点多)<br>然后每天都能走够 1 万步,谁说的 1 万步能够有效缓解亚健康状态来着,也不知道准不准,先自己每天做到了再说~</font></p><p><font face="华文中宋" size="3">最近是在精进并发多线程这块,不过这周是偷懒了,休息时间全都被我拿来刷动漫了,要不然我就不会厚着脸皮来写这篇碎碎念了~<br>其他不知道各位读者大大们想看啥,留个言?也算是给我点儿灵感</font></p><p><font face="华文中宋" size="3">以前的碎碎念,都是被我写 7,8 百字,我看了一下这篇碎碎念, 400 多字,所以知道我这周看动漫看的有多厉害了吧(逃;</font></p><p><font face="华文中宋" size="3">以上,就是这样啦~<br>你有想看的内容,记得留个言哇<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[MySQL]来讲讲一条查询语句的具体过程</title>
      <link href="/posts/4e657641.html"/>
      <url>/posts/4e657641.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">前几篇文章是关于 Java 并发,说实话比较费力气,因为一个知识点讲清楚,常常会牵扯出另外一个知识点,然后为了保证写的尽量是对的,还要去翻源码求证,所以你看到的一篇文章,我可能是一周的时间就出去了<br>这周的文章咱们来看个相对来说轻松的点儿的:一条查询语句在 MySQL 中是如何查询的(并发那块,等我回来有时间和精力了,我再慢慢补回来,肯定不会就到此为止的,啊,对了还有算法,有种欠了好多债的赶脚<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">一条看似非常简单的查询语句:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">然后 MySQL 就返回给了你结果,但是里面具体是如何执行的呢?<br>先上一张图:<br><img src="/images/2020/search.jpg"></font></p><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a><font face="华文中宋" size="3">连接器</font></h1><p><font face="华文中宋" size="3">当客户端连接 MySQL 时,会发出连接请求到连接器,连接器此时就会去验证这个连接的账号密码</font></p><ul><li><font face="华文中宋" size="3">如果账号或者密码不正确,客户端就会收到一个” Access denied for user”的错误,之后此次连接结束</font></li><li><font face="华文中宋" size="3">账号密码正确,连接器会到权限表里面查询出该账号所拥有的权限,之后这个连接里面的权限判断,都是以此时读到的权限为根据</font></li></ul><p><font face="华文中宋" size="3">所以你知道为什么更改了一个账号的权限之后,一定要断开再重连才有效吧~</font></p><p><font face="华文中宋" size="3">在实际中肯定有这样的情况,就是一个连接建立之后,但是我没有执行什么操作,那么就可以说这个连接处于空闲状态( sleep )<br>如果长时间都没有什么操作的话,连接器就会选择把它断开,这个时间是由 wait_timeout 来控制的,默认值是 8 小时<br>连接都被断开了,如果此时客户端再次发送请求想要进行一些操作的话,那就需要重新建立连接才能往下走</font></p><p><font face="华文中宋" size="3">在数据库中有两种连接:</font></p><ul><li><font face="华文中宋" size="3">短连接:每次执行完很少的几次查询就断开连接,下次想查询时,就要重新建立一个</font></li><li><font face="华文中宋" size="3">长连接:如果客户端持续有请求,那就一直使用同一个连接</font></li></ul><p><font face="华文中宋" size="3">建立连接是比较麻烦的,首先要发送请求吧,发送了请求要去验证账号密码吧,验证完了要去看你所拥有的权限吧,所以在使用过程中,尽量使用长连接<br>但是使用长连接又有新的问题:有时候,你会发现 MySQL 占用内存,因为是长连接嘛,所以它会在断开的时候才将资源释放掉.<br>可以考虑下面两种方案:</font></p><ul><li><font face="华文中宋" size="3">定期断开长连接</font></li><li><font face="华文中宋" size="3">如果使用的是 MySQL 5.7 或者更高版本,可以在每次执行一个比较大的操作之后,通过执行 mysql_reset_connection 来重新初始化连接资源,这个过程不需要重新连接和权限验证</font></li></ul><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a><font face="华文中宋" size="3">分析器</font></h1><p><font face="华文中宋" size="3">连接器这一关是过来了,接下来就是去查询缓存.<br>首先看缓存里面有没有,如果有呢,那就没有必要向下走,直接返回给客户端结果就可以了.<br>如果缓存中没有的话,那就去分析器.</font></p><p><font face="华文中宋" size="3">但是聪明的你肯定发现了,我的小标题并不是缓存,而是分析器,为啥呢?<br>因为查询缓存的失效非常频繁,只要有对一个表的更新,那在这个表上的所有查询缓存都会被清空.所以就会出现, MySQL 费劲吧啦的把缓存给建立起来了,结果呢还没怎么用,一个更新操作,给弄没了<br>所以 MySQL 8.0 版本直接将查询缓存的整块功能都给删掉了,那么在这里也不细说,免得奇怪的知识增加</font></p><p><font face="华文中宋" size="3">分析器首先会进行”词法分析”,词法分析就是 <code>select * from T where id=1;</code> ,它会将 <code>select</code> 识别出来,哦,这是一个查询语句,接下来会将 <code>T</code> 也识别出来,哦,你是想要在这个表中做查询,然后将 <code>where</code> 后面的条件也识别出来,原来我需要去查找这些内容<br>OK ,”词法分析”之后,接下来是”语法分析”,语法分析主要就是分析输入的 SQL 语句合不合法.<br>就比如英语里面的语法” 我用 is , 你用 are “这种,如果不对肯定是不可以的,语法分析之后发现你的 SQL 语句不符合规则,就会收到 <code>You hava an error in your SQL syntax</code> 的错误提示</font></p><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a><font face="华文中宋" size="3">优化器</font></h1><p><font face="华文中宋" size="3">经过分析器分析之后, MySQL就知道你要的是什么了.<br>但是就像条条大路通罗马一样,看似是一条简单的 SQL 查询语句,有可能有好多条执行路径可以走,比如说要查询的表里面有多个索引,我使用哪儿个索引效率会比较高呀;多表联查的时候,我先关联哪儿个表效率会比较高呀<br>像这种就是优化器需要做的事情</font></p><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a><font face="华文中宋" size="3">执行器</font></h1><p><font face="华文中宋" size="3">优化器做完优化之后,就到了执行器<br>执行器就是要去执行语句了嘛,那我肯定要看看对于要查询的表 <code>T</code> 有没有查询权限,如果没有直接就拒绝,这没啥说的<br>如果有的话,那就会这样(在这里以 InnoDB 为例):</font></p><ul><li><font face="华文中宋" size="3">调用 InnoDB 引擎接口取这个表的第一行,判断 <code>ID</code> 的值是不是 10 ,如果不是就跳过,如果是那就放在结果集中;</font></li><li><font face="华文中宋" size="3">调用引擎接口取”下一行”,重复相同的判断逻辑,直到这个表的最后一行</font></li><li><font face="华文中宋" size="3">执行器将上述遍历过程中所有满足条件的行,组成记录集返回给客户端</font></li></ul><p><font face="华文中宋" size="3">至此,语句执行结束.</font></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><font face="华文中宋" size="3">存储引擎</font></h1><p><font face="华文中宋" size="3">存储引擎,一听名字大概就能知道,它负责的是对数据的存储和提取.<br>关于存储引擎这块,最熟悉的应该就是 InnoDB 了,毕竟从 MySQL 5.5.5 版本开始它就成为了默认得存储引擎</font></p><p><font face="华文中宋" size="3">参考:<br>极客时间- MySQL 实战 45 讲</font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容了,是不是还好理解那么一点儿?<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</title>
      <link href="/posts/23fd3456.html"/>
      <url>/posts/23fd3456.html</url>
      
        <content type="html"><![CDATA[<h1 id="ReentrantLock-是可重入锁"><a href="#ReentrantLock-是可重入锁" class="headerlink" title="ReentrantLock 是可重入锁"></a><font face="华文中宋" size="3">ReentrantLock 是可重入锁</font></h1><a id="more"></a><p><font face="华文中宋" size="3">啥是可重入锁呢?比如:线程 1 通过调用 lock() 方法获取锁之后,再调用 lock 时,就不会再进行阻塞获取锁,而是直接增加重试次数.<br>在 <a href="https://www.dynamic-zheng.com/posts/c8ca8c17.html">[Java 并发]深入浅出 synchronized 与锁</a> 文章中,说过 synchronized 中有 monitorenter 和 monitorexit 两种指令来保证锁,而它们的作用可以理解为每个锁对象拥有一个锁计数器,也就是如果再次调用 lock() 方法,计数器会进行加 1 操作<br>所以, synchronized 和 ReentrantLock 都是可重入锁</font></p><h1 id="ReentrantLock-与-synchronized-区别"><a href="#ReentrantLock-与-synchronized-区别" class="headerlink" title="ReentrantLock 与 synchronized 区别"></a><font face="华文中宋" size="3">ReentrantLock 与 synchronized 区别</font></h1><p><font face="华文中宋" size="3">既然 synchronized 和 ReentrantLock 都是可重入锁,那 ReentrantLock 与 synchronized 有什么区别呢?</font></p><ul><li><font face="华文中宋" size="3">synchronized 是 Java 语言层面提供的语法,所以不需要考虑异常; ReentrantLock 是 Java 代码实现的锁,所以必须先要获取锁,然后再正确释放锁</font></li><li><font face="华文中宋" size="3">synchronized 在获取锁时必须一直等待没有额外的尝试机制; ReentrantLock 可以尝试获取锁(这一点等下分析源码时会看到)</font></li><li><font face="华文中宋" size="3">ReentrantLock 支持获取锁时的公平和非公平选择</font></li></ul><p><font face="华文中宋" size="3">在接下来之前,如果你对 AQS 不太熟悉,建议先花时间看看这篇博客: <a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a><br>不废话了,就直接上源码</font></p><h1 id="lock-amp-NonfairSync-amp-FairSync-详解"><a href="#lock-amp-NonfairSync-amp-FairSync-详解" class="headerlink" title="lock &amp; NonfairSync &amp; FairSync 详解"></a><font face="华文中宋" size="3">lock &amp; NonfairSync &amp; FairSync 详解</font></h1><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a><font face="华文中宋" size="3">lock</font></h2><p><font face="华文中宋" size="3">锁的入口是 lock() 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">其中, sync 是 ReentrantLock 的静态内部类,它继承 AQS 来实现重入锁的逻辑, Sync 有两个具体实现类: <code>NonfairSync</code> 和 <code>FairSync</code> </font></p><h2 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a><font face="华文中宋" size="3">NonfairSync</font></h2><p><font face="华文中宋" size="3">先来看一下 <code>NonfairSync</code> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">    * acquire on failure.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 重写 Sync 的 lock 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先不管其他,上来就先 CAS 操作,尝试抢占一下锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 如果抢占成功,就获得了锁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 没有抢占成功,调用 acquire() 方法,走里面的逻辑</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 重写了 AQS 的 tryAcquire 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a><font face="华文中宋" size="3">FairSync</font></h2><p><font face="华文中宋" size="3">接下来看一下 <code>FairSync</code> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 Sync 的 lock 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">    * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 重写了 Sync 的 tryAcquire 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前执行的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取 state 的值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 在无锁状态下</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有前驱节点且替换 state 的值成功时</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 保存当前获得锁的线程,下次再来时,就不需要尝试竞争锁,直接重入即可</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果是同一个线程来获得锁,直接增加重入次数即可</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="comment">// nextc 小于 0 ,抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="comment">// 获取锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="总结-NonfairSync-与-FairSync"><a href="#总结-NonfairSync-与-FairSync" class="headerlink" title="总结 NonfairSync 与 FairSync"></a><font face="华文中宋" size="3">总结 NonfairSync 与 FairSync</font></h2><p><font face="华文中宋" size="3">到这里,应该就比较清楚了,  Sync 有两个具体的实现类,分别是:</font></p><ul><li><font face="华文中宋" size="3">NonfairSync :可以抢占锁,调用 NonfairSync 时,不管当前队列上有没有其他线程在等待,上来我就先 CAS 操作一番,成功了就获得了锁,没有成功就走 acquire 的逻辑;在释放锁资源时,走的是 Sync.nonfairTryAcquire 方法</font></li><li><font face="华文中宋" size="3">FairSync :所有线程按照 FIFO 来获取锁,在 lock 方法中,没有 CAS 尝试,直接就是 acquire 的逻辑;在释放资源时,走的是自己的 tryAcquire 逻辑</font></li></ul><p><font face="华文中宋" size="3">接下来咱们看看 NonfairSync 和 FairSync 是如何获取锁的</font></p><h1 id="ReentrantLock-获取锁"><a href="#ReentrantLock-获取锁" class="headerlink" title="ReentrantLock 获取锁"></a><font face="华文中宋" size="3">ReentrantLock 获取锁</font></h1><h2 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock()"></a><font face="华文中宋" size="3">NonfairSync.lock()</font></h2><p><font face="华文中宋" size="3">在 NonfairSync 中,获取锁的方法是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不管别的,上来就先 CAS 操作,尝试抢占一下锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 如果抢占成功,就获得了锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 没有抢占成功,调用 acquire() 方法,走里面的逻辑</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">if 里面没啥说的,咱们来看看 acquire() 方法</font></p><h3 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire()"></a><font face="华文中宋" size="3">AQS.acquire()</font></h3><p><font face="华文中宋" size="3">acquire 是 AQS 的核心方法(如果你看了我这篇博客:  <a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a>   会觉得很熟悉,所以刚开始就让你看了,别偷懒,看到这里如果觉得不好理解,回过去看):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在这里,会先 tryAcquire 去尝试获取锁,如果获取成功,那就返回 true ,如果失败就通过 addWaiter 方法,将当前线程封装成 Node 插入到等待队列中<br>先来看 tryAcquire 方法:</font></p><h3 id="NonfairSync-tryAcquire-arg"><a href="#NonfairSync-tryAcquire-arg" class="headerlink" title="NonfairSync.tryAcquire(arg)"></a><font face="华文中宋" size="3">NonfairSync.tryAcquire(arg)</font></h3><p><font face="华文中宋" size="3">在 AQS 中 tryAcquire 方法没有具体实现,只是抛出了异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">NonfairSync 中的 tryAcquire() 方法,才是我们想要看的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取 state 的值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 当 state 为 0 是,说明此时为无锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// CAS 替换 state 的值,如果 CAS 成功,则获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 保存当前获得锁的线程,当该线程再次获得锁时,直接重入即可</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是同一个线程来竞争锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="comment">// 如果是,直接增加重入次数</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">// 获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">有没有一种似曾相识的赶脚?在 FairSync 那里,分析过 90% 的代码(好像说分析过 99% 的代码也不过分),只是 FairSync 多了一个判断就是,是否有前驱节点<br>tryAcquire 分析完毕了,接下来看 addWaiter 方法(虽然在这篇文章中:  <a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a>   分析过,但是在这里我还想再分析一遍,这样才是一个整体~原谅我这个人有点儿强迫症;</font></p><h3 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS.addWaiter"></a><font face="华文中宋" size="3">AQS.addWaiter</font></h3><p><font face="华文中宋" size="3">如果 tryAcquire() 方法获取锁成功,那就直接执行线程的任务就可以了,执行完毕释放锁<br>如果获取锁失败,就会调用 addWaiter 方法,将当前线程插入到等待队列中,插入的逻辑大概是这样的:</font></p><ul><li><font face="华文中宋" size="3">将当前线程封装成 Node 节点</font></li><li><font face="华文中宋" size="3">当前链表中 tail 节点(也就是下面的 pred )是否为空,如果不为空,则 CAS 操作将当前线程的 node 添加到 AQS 队列</font></li><li><font face="华文中宋" size="3">如果为空,或者 CAS 操作失败,则调用 enq 方法,再次自旋插入</font></li></ul><p><font face="华文中宋" size="3">咱们看具体的代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 生成该线程所对应的 Node 节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将 Node 插入队列中</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果 pred 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 CAS 操作,如果成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 pred == null 或者 CAS 操作失败,则调用 enq 方法再次自旋插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋 CAS 插入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">        <span class="comment">// 必须初始化,使用 CAS 操作进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            <span class="comment">// 初始化状态时,头尾节点指向同一节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 如果刚开始就是初始化好的,直接 CAS 操作,将 Node 插入到队尾即可</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h3 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS.acquireQueued"></a><font face="华文中宋" size="3">AQS.acquireQueued</font></h3><p><font face="华文中宋" size="3">通过 addWaiter 将当前线程加入到队列中之后,会走 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 方法<br>acquireQueued 方法实现的主要逻辑是:</font></p><ul><li><font face="华文中宋" size="3">获取当前节点的前驱节点 p</font></li><li><font face="华文中宋" size="3">如果节点 p 为 head 节点,说明当前节点为第二个节点,那么它就可以尝试获取锁,调用 tryAcquire 方法尝试进行获取</font></li><li><font face="华文中宋" size="3">调用 tryAcquire 方法获取锁成功之后,就将 head 指向自己,原来的节点 p 就需要从队列中删除</font></li><li><font face="华文中宋" size="3">如果获取锁失败,则调用 shouldParkAfterFailedAcquire 或者 parkAndCheckInterrupt 方法来决定后面操作</font></li><li><font face="华文中宋" size="3">最后,通过 cancelAcquire 方法取消获得锁</font></li></ul><p><font face="华文中宋" size="3">看具体的代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果 Node 的前驱节点 p 是 head,说明 Node 是第二个节点,那么它就可以尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果锁获取成功,则将 head 指向自己</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 锁获取成功之后,将 next 指向 null ,即将节点 p 从队列中移除</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点进入等待队列后,调用 shouldParkAfterFailedAcquire 或者 parkAndCheckInterrupt 方法</span></span><br><span class="line">            <span class="comment">// 进入阻塞状态,即只有头结点的线程处于活跃状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a><font face="华文中宋" size="3">shouldParkAfterFailedAcquire</font></h3><p><font face="华文中宋" size="3">线程获取锁失败之后,会通过调用 shouldParkAfterFailedAcquire 方法,来决定这个线程要不要挂起<br>shouldParkAfterFailedAcquire 方法实现的主要逻辑:</font></p><ul><li><font face="华文中宋" size="3">首先判断 pred 的状态是否为 SIGNAL ,如果是,则直接挂起即可</font></li><li><font face="华文中宋" size="3">如果 pred 的状态大于 0 ,说明该节点被取消了,那么直接从队列中移除即可</font></li><li><font face="华文中宋" size="3">如果 pred 的状态不是 SIGNAL 也不大于 0 ,进行 CAS 操作修改节点状态为 SIGNAL ,返回 false ,也就是不需要挂起</font></li></ul><p><font face="华文中宋" size="3">看一下代码是如何实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 pred 的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果状态为 SIGNAL ,那么直接返回 true ,挂起线程即可</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果状态大于 0 ,说明线程被取消</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 从链表中移除被 cancel 的线程,使用循环来保证移除成功</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// CAS 操作修改 pred 节点状态为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要挂起线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">到这里,关于 NonfairSync 的获取锁就结束了<br>接下来咱们看看 FairSync 的获取锁和它有什么不同</font></p><h2 id="FairSync-lock"><a href="#FairSync-lock" class="headerlink" title="FairSync.lock()"></a><font face="华文中宋" size="3">FairSync.lock()</font></h2><p><font face="华文中宋" size="3">在 FairSync.lock() 方法中是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">因为 FairSync 是公平锁,所以不存在 CAS 操作去竞争,直接就是调用 acquire 方法<br>接下来的逻辑就和上面一样了,这里我就不重复了<br>咱们瞅瞅 ReentrantLock 是怎么释放锁的</font></p><h1 id="ReentrantLock-释放锁"><a href="#ReentrantLock-释放锁" class="headerlink" title="ReentrantLock 释放锁"></a><font face="华文中宋" size="3">ReentrantLock 释放锁</font></h1><p><font face="华文中宋" size="3">在 ReentrantLock 释放锁时,调用的是 sync.release() 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">点进去发现调用的是 AQS 的 release 方法</font></p><h2 id="AQS-release"><a href="#AQS-release" class="headerlink" title="AQS.release()"></a><font face="华文中宋" size="3">AQS.release()</font></h2><p><font face="华文中宋" size="3">AQS 的 release 方法比较好理解,就直接看源码了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 获取 AQS 队列的头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果头结点不为空,且状态 != 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 unparkSuccessor 方法唤醒后续节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="ReentrantLock-tryRelease"><a href="#ReentrantLock-tryRelease" class="headerlink" title="ReentrantLock.tryRelease()"></a><font face="华文中宋" size="3">ReentrantLock.tryRelease()</font></h2><p><font face="华文中宋" size="3">在 AQS 中的 tryRelease 方法,只是抛出了异常而已,说明具体实现是由子类 ReentrantLock 来实现的<br>就直接看 ReentrantLock 中的 tryRelease 方法了<br>在 ReentrantLock 中实现 tryRelease 方法主要逻辑是:</font></p><ul><li><font face="华文中宋" size="3">首先,如果是同一个线程获取的同一个锁,那么它有可能被重入多次,所以需要获取到要释放线程的重入次数即 getState()</font></li><li><font face="华文中宋" size="3">然后判断,该线程是否为获取到锁的线程,只有获取到锁的线程,才有释放锁一说</font></li><li><font face="华文中宋" size="3">进行 unlock 释放锁,即:将 state 的值减到 0 ,才算是释放掉了锁,此时才能将 owner 置为 null 同时返回 true</font></li></ul><p><font face="华文中宋" size="3">看一下具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为获取到锁的线程,如果不是则抛出异常</span></span><br><span class="line">    <span class="comment">// 只有获取到锁的线程才释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 次数为 0 ,说释放锁完毕</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 释放之后,当前线程置为 null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新重入次数</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="AQS-unparkSuccessor"><a href="#AQS-unparkSuccessor" class="headerlink" title="AQS.unparkSuccessor"></a><font face="华文中宋" size="3">AQS.unparkSuccessor</font></h2><p><font face="华文中宋" size="3">释放锁成功之后,接下来要做的就是唤醒后面的进程,这个方法是在 AQS 中实现的<br>主要逻辑是:</font></p><ul><li><font face="华文中宋" size="3">获取当前节点状态,如果小于 0 ,则置为 0</font></li><li><font face="华文中宋" size="3">获取当前节点的下一个节点,如果不为空,直接唤醒</font></li><li><font face="华文中宋" size="3">如果为空,或者节点状态大于 0 ,则寻找下一个状态小于 0 的节点</font></li></ul><p><font face="华文中宋" size="3">代码的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果节点状态小于 0 ,则进行 CAS 操作设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 获取当前节点的下一个节点 s</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果 s 为空,则从尾部节点开始,或者s.waitStatus 大于 0 ,说明节点被取消</span></span><br><span class="line">    <span class="comment">// 从尾节点开始,寻找到距离 head 节点最近的一个 waitStatus &lt;= 0 的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// next 节点不为空,直接唤醒即可</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在 <a href>[Java 并发] AQS 是个啥?</a> 这篇文章中,留下过悬念,就是为什么要从尾节点开始寻找距离 head  节点最近的一个 waitStatus &lt;= 0 的节点<br>这是因为在 enq() 构建节点的方法中,最后是 <code>t.next = node</code> (忘了就再往上翻翻看),设置原来的 tail 的 next 节点指向新的节点<br>如果在 CAS 操作之后, <code>t.next = node</code> 操作之前,有其他线程调用 unlock 方法从 head 开始向后遍历,因为此时 <code>t.next = node</code> 还没有执行结束,意味着链表的关系还没有建立好,这样就会导致遍历的时候到 t 节点这里发生中断,因为此时 tail 还没有指向新的尾节点<br>所以如果从后向前遍历的话,就不会存在这样的问题</font></p><p><font face="华文中宋" size="3">接下来下一个线程就被唤醒了,然后程序会把它当成新的节点开始执行<br>而原来执行结束的线程,则会将它从队列中移除,然后开始循环循环</font></p><p><font face="华文中宋" size="3">到这里,这篇文章终于可以告一个段落了,有没有松一口气?反正我是松了一口<br>这篇文章,被我断断续续写了有一周的时间,我的拖延症哇<br>如果能够给你带来一些帮助,甚感高兴</font></p><ul><li><font face="华文中宋" size="3">参考<br>JDK 源码( 1.8 )<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580960149538" target="_blank" rel="noopener">廖雪峰的官方网站</a></font></li></ul><p><font face="华文中宋" size="3">以上<br>非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发] AQS 是个啥?</title>
      <link href="/posts/c1cacb19.html"/>
      <url>/posts/c1cacb19.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font face="华文中宋" size="3">基本概念</font></h1><p><font face="华文中宋" size="3">AQS 是 <code>AbstractQueuedSynchronizer</code> 的简称,翻译成中文就是 <code>抽象队列同步器</code> ,这三个单词分开来看:<br><a id="more"></a></font></p><ul><li><font face="华文中宋" size="3">Abstract (抽象):也就是说, AQS 是一个抽象类,只实现一些主要的逻辑,有些方法推迟到子类实现</font></li><li><font face="华文中宋" size="3">Queued (队列):队列有啥特征呢?先进先出( FIFO )对吧?也就是说, AQS 是用先进先出队列来存储数据的</font></li><li><font face="华文中宋" size="3">Synchronizer (同步):即 AQS 实现同步功能</font></li></ul><p><font face="华文中宋" size="3">以上概括一下, AQS 是一个用来构建锁和同步器的框架,使用 AQS 能简单而又高效地构造出同步器.</font></p><h1 id="AQS-内部实现"><a href="#AQS-内部实现" class="headerlink" title="AQS 内部实现"></a><font face="华文中宋" size="3">AQS 内部实现</font></h1><p><font face="华文中宋" size="3">AQS 队列在内部维护了一个 FIFO 的双向链表,如果对数据结构比较熟的话,应该很容易就能想到,在双向链表中,每个节点都有两个指针,分别指向直接前驱节点和直接后继节点.使用双向链表的优点之一,就是从任意一个节点开始都很容易访问它的前驱节点和后继节点.<br>在 AQS 中,每个 Node 其实就是一个线程封装,当线程在竞争锁失败之后,会封装成 Node 加入到 AQS 队列中;获取锁的线程释放锁之后,会从队列中唤醒一个阻塞的 Node (也就是线程)<br>AQS 使用 volatile 的变量 state 来作为资源的标识:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">关于 state 状态的读取与修改,子类可以通过覆盖 <code>getState()</code> 和 <code>setState()</code> 方法来实现自己的逻辑,其中比较重要的是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入期望值 expect ,想要修改的值 update ,然后通过 Unsafe 的 compareAndSwapInt() 即 CAS 操作来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">下面是 AQS 中两个重要的成员变量:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;   <span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;   <span class="comment">// 尾节点</span></span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">关于 AQS 维护的双向链表,在源码中是这样解释的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The wait queue is a variant of a <span class="string">"CLH"</span> (Craig, Landin, and Hagersten) lock queue. </span><br><span class="line">CLH locks are normally used <span class="keyword">for</span> spinlocks.  We instead use them <span class="keyword">for</span> blocking synchronizers, </span><br><span class="line">but use the same basic tactic of holding some of the control information </span><br><span class="line">about a thread in the predecessor of its node.</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">也就是 AQS 的等待队列是 “CLH” 锁定队列的变体<br>直接来一张图会更形象一些(每次画图头发都会掉不少,所以原来我这种不会配色的人,逃;):<br><img src="https://img-blog.csdnimg.cn/20200503111204645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">Node 节点维护的是线程,控制线程的一些操作,具体来看看是 Node 是怎么做的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="comment">// 标记一个节点,在 共享模式 下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="comment">// 标记一个节点,在 独占模式 下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示该节点从队列中取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示后继节点在等待唤醒</span></span><br><span class="line">    <span class="comment">// 只有处于 signal 状态的节点,才能被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示该节点在等待一些条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示有资源可以使用,新 head 节点需要唤醒后继节点</span></span><br><span class="line">    <span class="comment">// 如果是在共享模式下,同步状态应该无条件传播下去</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点状态,取值为 -3,-2,-1,0,1</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点所对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// condition 队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回前驱节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将线程构造成一个 Node 节点,然后添加到 condition 队列中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 等待队列用到的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h1 id="AQS-如何获取资源"><a href="#AQS-如何获取资源" class="headerlink" title="AQS 如何获取资源"></a><font face="华文中宋" size="3">AQS 如何获取资源</font></h1><p><font face="华文中宋" size="3">在 AQS 中,获取资源的入口是 <code>acquire(int arg)</code> 方法,其中 arg 是获取资源的个数,来看下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在获取资源时,会首先调用 <code>tryAcquire</code> 方法,这个方法是在子类中具体实现的<br>如果通过 <code>tryAcquire</code> 获取资源失败,接下来会通过 <code>addWaiter(Node.EXCLUSIVE)</code> 方法,将这个线程插入到等待队列中,具体代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 生成该线程所对应的 Node 节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将 Node 插入到队列中</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 CAS 操作,如果成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 pred == null 或者 CAS 操作失败,则调用 enq 方法再次自旋插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋 CAS 插入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在上面能够看到使用的是 CAS 自旋插入,这是因为在 AQS 中会存在多个线程同时竞争资源的情况,进而一定会出现多个线程同时插入节点的操作,这里使用 CAS 自旋插入是为了保证操作的线程安全性<br>现在呢,申请 <code>acquire(int arg)</code> 方法,然后通过调用 <code>addWaiter</code> 方法,将一个 Node 插入到了队列尾部.处于等待队列节点是从头结点开始一个一个的去获取资源,获取资源方式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果 Node 的前驱节点 p 是 head,说明 Node 是第二个节点,那么它就可以尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果资源获取成功,则将 head 指向自己</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点进入等待队列后,调用 shouldParkAfterFailedAcquire 或者 parkAndCheckInterrupt 方法</span></span><br><span class="line">            <span class="comment">// 进入阻塞状态,即只有头结点的线程处于活跃状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在获取资源时,除了 <code>acquire</code> 之外,还有三个方法:</font></p><ul><li><font face="华文中宋" size="3">acquireInterruptibly :申请可中断的资源(独占模式)</font></li><li><font face="华文中宋" size="3">acquireShared :申请共享模式的资源</font></li><li><font face="华文中宋" size="3">acquireSharedInterruptibly :申请可中断的资源(共享模式)</font></li></ul><p><font face="华文中宋" size="3">到这里,关于 AQS 如何获取资源就说的差不多了,接下来看看 AQS 是如何释放资源的</font></p><h1 id="AQS-如何释放资源"><a href="#AQS-如何释放资源" class="headerlink" title="AQS 如何释放资源"></a><font face="华文中宋" size="3">AQS 如何释放资源</font></h1><p><font face="华文中宋" size="3">释放资源相对于获取资源来说,简单了很多.源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 获取 AQS 队列中的头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果头结点不为空,且状态 != 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 unparkSuccessor(h) 方法,唤醒后续节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果状态是负数,尝试将它改为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 得到头结点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果 waitStatus 大于 0 ,说明这个节点被取消</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 那就从尾节点开始,找到距离 head 最近的一个 waitStatus&lt;=0 的节点进行唤醒</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果后继节点不为空,则将其从阻塞状态变为非阻塞状态</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在上面你肯定会有疑问,为什么要从尾节点开始,找距离 head 最近的一个节点,我直接从前向后不可以嘛?<br>这里就先留个悬念,等我再写篇文章来解答</font></p><h1 id="AQS-两种资源共享模式"><a href="#AQS-两种资源共享模式" class="headerlink" title="AQS 两种资源共享模式"></a><font face="华文中宋" size="3">AQS 两种资源共享模式</font></h1><p><font face="华文中宋" size="3">资源有两种共享模式:</font></p><ul><li><font face="华文中宋" size="3">独占模式( Exclusive ):资源是独占的,也就是一次只能被一个线程占有,比如 ReentrantLock</font></li><li><font face="华文中宋" size="3">共享模式( Share ):同时可以被多个线程获取,具体的资源个数可以通过参数来确定,比如 Semaphore/CountDownLatch </font></li></ul><p><font face="华文中宋" size="3">这一点,在刚开始介绍的 Node 节点源码那部分应该就能看到了.之所以把这部分内容写在后面,是想回头写几篇文章去分析一下 ReentrantLock/Semaphore/CountDownLatch (如果我有时间 + 不偷懒的话</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]深入浅出 synchronized 与锁</title>
      <link href="/posts/c8ca8c17.html"/>
      <url>/posts/c8ca8c17.html</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><font face="华文中宋" size="3">synchronized 关键字</font></h1><p><font face="华文中宋" size="3">说到锁,都会提 synchronized .这个英文单词儿啥意思呢?翻译成中文就是「同步」的意思<br>一般都是使用 synchronized 这个关键字来给一段代码或者一个方法上锁,使得这段代码或者方法,在同一个时刻只能有一个线程来执行它.<br><a id="more"></a><br>synchronized 相比于 volatile 来说,用的比较灵活,你可以在方法上使用,可以在静态方法上使用,也可以在代码块上使用.<br>关于 synchronized 这一块大概就说到这里,我想着重来说一下, synchronized 底层是怎么实现的</font></p><h2 id="JVM-是如何实现-synchronized-的"><a href="#JVM-是如何实现-synchronized-的" class="headerlink" title="JVM 是如何实现 synchronized 的?"></a><font face="华文中宋" size="3">JVM 是如何实现 synchronized 的?</font></h2><p><font face="华文中宋" size="3">我知道可以利用 synchronized 关键字来给程序进行加锁,但是它具体怎么实现的我不清楚呀,别急,咱们先来看个 demo :</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedDemo</span><span class="params">(Object lock)</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">lock.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面是我写的一个 demo ,然后进入到 class 文件所在的目录下,使用 <code>javap -v demo.class</code> 来看一下编译的字节码(在这里我截取了一部分):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedDemo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  descriptor: (Ljava/lang/Object;)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">2</span></span><br><span class="line">       <span class="number">0</span>: aload_1</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_2</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: aload_1</span><br><span class="line">       5: invokevirtual #2                  // Method java/lang/Object.hashCode:()I</span><br><span class="line">       <span class="number">8</span>: pop</span><br><span class="line">       <span class="number">9</span>: aload_2</span><br><span class="line">      <span class="number">10</span>: monitorexit</span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">19</span></span><br><span class="line">      <span class="number">14</span>: astore_3</span><br><span class="line">      <span class="number">15</span>: aload_2</span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: aload_3</span><br><span class="line">      <span class="number">18</span>: athrow</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">11</span>    <span class="number">14</span>   any</span><br><span class="line">          <span class="number">14</span>    <span class="number">17</span>    <span class="number">14</span>   any</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">应该能够看到当程序声明 synchronized 代码块时,编译成的字节码会包含 monitorenter 和 monitorexit 指令,这两种指令会消耗操作数栈上的一个引用类型的元素(也就是 synchronized 关键字括号里面的引用),作为所要加锁解锁的锁对象.如果看的比较仔细的话,上面有一个 monitorenter 指令和两个 monitorexit 指令,这是 Java 虚拟机为了确保获得的锁不管是在正常执行路径,还是在异常执行路径上都能够解锁.</font></p><p><font face="华文中宋" size="3">关于 monitorenter 和 monitorexit ,可以理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程指针:</font></p><ul><li><font face="华文中宋" size="3">当程序执行 monitorenter 时,如果目标锁对象的计数器为 0 ,说明这个时候它没有被其他线程所占有,此时如果有线程来请求使用, Java 虚拟机就会分配给该线程,并且把计数器的值加 1<ul><li><font face="华文中宋" size="3">目标锁对象计数器不为 0 时,如果锁对象持有的线程是当前线程, Java 虚拟机可以将其计数器加 1 ,如果不是呢?那很抱歉,就只能等待,等待持有线程释放掉</font></li></ul></font></li><li><font face="华文中宋" size="3">当执行 monitorexit 时, Java 虚拟机就将锁对象的计数器减 1 ,当计数器减到 0 时,说明这个锁就被释放掉了,此时如果有其他线程来请求,就可以请求成功</font></li></ul><p><font face="华文中宋" size="3">为什么采用这种方式呢?是为了允许同一个线程重复获取同一把锁.<br>比如,一个 Java 类中拥有好多个 synchronized 方法,那这些方法之间的相互调用,不管是直接的还是间接的,都会涉及到对同一把锁的重复加锁操作.这样去设计的话,就可以避免这种情况.</font></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a><font face="华文中宋" size="3">锁</font></h1><p><font face="华文中宋" size="3">在 Java 多线程中,所有的锁都是基于对象的.也就是说, Java 中的每一个对象都可以作为一个锁.你可能会有疑惑,不对呀,不是还有类锁嘛.但是 class 对象也是特殊的 Java 对象,所以呢,在 Java 中所有的锁都是基于对象的<br>在 Java6 之前,所有的锁都是”重量级”锁,重量级锁会带来一个问题,就是如果程序频繁获得锁释放锁,就会导致性能的极大消耗.为了优化这个问题,引入了”偏向锁”和”轻量级锁”的概念.所以在 Java6 及其以后的版本,一个对象有 4 种锁状态:无锁状态,偏向锁状态,轻量级锁状态,重量级锁状态.</font></p><p><font face="华文中宋" size="3">在 4 种锁状态中,无锁状态应该比较好理解,无锁就是没有锁,任何线程都可以尝试修改,所以这里就一笔带过了.</font></p><p><font face="华文中宋" size="3">随着竞争情况的出现,锁的升级非常容易发生,但是如果想要让锁降级,条件非常苛刻,有种你想来可以,但是想走不行的赶脚.</font></p><blockquote><p><font face="华文中宋" size="3">在这里啰嗦一句:很多文章说,锁如果升级之后是不能降级的,其实在 HotSpot JVM 中,是支持锁降级的</font></p><p><font face="华文中宋" size="3">锁降级发生在 Stop The World 期间,当 JVM 进入安全点的时候,会检查有没有闲置的锁,如果有就进行降级</font></p><p><font face="华文中宋" size="3">看到 Stop The World 和 安全点 可能有人比较懵,我这里简单说一下,具体还需要读者自己去探索一番.(因为这是 JVM 的内容,这篇文章的重点不是 JVM )</font></p><p><font face="华文中宋" size="3">在 Java 虚拟机里面,传统的垃圾回收算法采用的是一种简单粗暴的方式,就是 Stop-the-world ,而这个 Stop-the-world 就是通过安全点( safepoint )机制来实现的,安全点是什么意思呢?就是 Java 程序在执行本地代码时,如果这段代码不访问 Java 对象/调用 Java 方法/返回到原来的 Java 方法,那 Java 虚拟机的堆栈就不会发生改变,这就代表执行的这段本地代码可以作为一个安全点.当 Java 虚拟机收到 Stop-the-world 请求时,它会等所有的线程都到达安全点之后,才允许请求 Stop-the-world 的线程进行独占工作</font></p></blockquote><p><font face="华文中宋" size="3">接下来就介绍一下几种锁和锁升级</font></p><h2 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a><font face="华文中宋" size="3">Java 对象头</font></h2><p><font face="华文中宋" size="3">在刚开始就说了, Java 的锁都是基于对象的,那是怎么告诉程序我是个锁呢?就不得不来说, Java 对象头<br>每个 Java 对象都有对象头,如果是非数组类型,就用 2 个字宽来存储对象头,如果是数组,就用 3 个字宽来存储对象头.在 32 位处理器中,一个字宽是 32 位;在 64 位处理器中,字宽就是 64 位咯~对象头的内容就是下面这样:</font></p><table><thead><tr><th style="text-align:center">长度</th><th style="text-align:center">内容</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">32/64 bit</td><td style="text-align:center">Mark Word</td><td style="text-align:center">存储对象的 hashCode 或锁信息等</td></tr><tr><td style="text-align:center">32/64 bit</td><td style="text-align:center">Class Metadata Address</td><td style="text-align:center">存储到对象类型数据的指针</td></tr><tr><td style="text-align:center">32/64 bit</td><td style="text-align:center">Array length</td><td style="text-align:center">数组的长度(如果是数组)</td></tr></tbody></table><p><font face="华文中宋" size="3">咱们主要来看 Mark Word 的内容:</font></p><table><thead><tr><th style="text-align:center">锁状态</th><th style="text-align:center">29 bit/61 bit</th><th style="text-align:center">1 bit 是否是偏向锁</th><th style="text-align:center">2 bit 锁标志位</th></tr></thead><tbody><tr><td style="text-align:center">无锁</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">01</td></tr><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">线程 ID</td><td style="text-align:center">1</td><td style="text-align:center">01</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">指向栈中锁记录的指针</td><td style="text-align:center">此时这一位不用于标识偏向锁</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">指向互斥量(重量级锁)的指针</td><td style="text-align:center">此时这一位不用于标识偏向锁</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">GC 标记</td><td style="text-align:center"></td><td style="text-align:center">此时这一位不用于标识偏向锁</td><td style="text-align:center">11</td></tr></tbody></table><p><font face="华文中宋" size="3">从上面表格中,应该能够看到,是偏向锁时, <code>Mark Word</code> 存储的是偏向锁的线程 ID ;是轻量级锁时, <code>Mark Word</code> 存储的是指向线程栈中 <code>Lock Record</code> 的指针;是重量级锁时, <code>Mark Word</code> 存储的是指向堆中的 <code>monitor</code> 对象的指针</font></p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><font face="华文中宋" size="3">偏向锁</font></h2><p><font face="华文中宋" size="3">HotSpot 的作者经过大量的研究发现,在大多数情况下,<strong>锁不仅不存在多线程竞争,而且总是由同一线程多次获得</strong><br>基于此,就引入了偏向锁的概念</font></p><p><font face="华文中宋" size="3">所以啥是偏向锁呢?用大白话说就是,我现在给锁设置一个变量,当一个线程请求的时候,发现这个锁是 <code>true</code> ,也就是说这个时候没有所谓的资源竞争,那也不用走什么加锁/解锁的流程了,直接拿来用就行.但是如果这个锁是 <code>false</code> 的话,说明存在其他线程竞争资源,那咱们再走正规的流程</font></p><h3 id="看一下具体的实现原理"><a href="#看一下具体的实现原理" class="headerlink" title="看一下具体的实现原理:"></a><font face="华文中宋" size="3">看一下具体的实现原理:</font></h3><p><font face="华文中宋" size="3">当一个线程第一次进入同步块时,会在对象头和栈帧中的锁记录中存储锁偏向的线程 ID .当下次该线程进入这个同步块时,会检查锁的 Mark Word 里面存放的是不是自己的线程 ID.如果是,说明线程已经获得了锁,那么这个线程在进入和退出同步块时,都不需要花费 CAS 操作来加锁和解锁;如果不是,说明有另外一个线程来竞争这个偏向锁,这时就会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID .此时会有两种情况:</font></p><ul><li><font face="华文中宋" size="3">替换成功,说明之前的线程不存在了,那么 Mark Word 里面的线程 ID 为新线程的 ID ,锁不会升级,此时仍然为偏向锁</font></li><li><font face="华文中宋" size="3">替换失败,说明之前的线程仍然存在,那就暂停之前的线程,设置偏向锁标识为 0 ,并设置锁标志位为 00 ,升级为轻量级锁,按照轻量级锁的方式进行竞争锁</font></li></ul><h3 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a><font face="华文中宋" size="3">撤销偏向锁</font></h3><p><font face="华文中宋" size="3">偏向锁使用了一种等到竞争出现时才释放锁的机制.也就说,如果没有人来和我竞争锁的时候,那么这个锁就是我独有的,当其他线程尝试和我竞争偏向锁时,我会释放这个锁<br>在偏向锁向轻量级锁升级时,首先会暂停拥有偏向锁的线程,重置偏向锁标识,看起来这个过程挺简单的,但是开销是很大的,因为:</font></p><ul><li><font face="华文中宋" size="3">首先需要在一个安全点停止拥有锁的线程</font></li><li><font face="华文中宋" size="3">然后遍历线程栈,如果存在锁记录的话,就需要修复锁记录和 Mark Word ,变成无锁状态</font></li><li><font face="华文中宋" size="3">最后唤醒被停止的线程,把偏向锁升级成轻量级锁</font></li></ul><p><font face="华文中宋" size="3">你以为就是升级一个轻量级锁?  too young too simple<br>偏向锁向轻量级锁升级的过程中,是非常耗费资源的,如果应用程序中所有的锁通常都处于竞争状态,偏向锁此时就是一个累赘,此时就可以通过 JVM 参数关闭偏向锁: <code>-XX:-UseBiasedLocking=false</code> ,那么程序默认会进入轻量级锁状态<br>最后,来张图吧~</font></p><p><img src="/images/2020/偏向锁.jpg"></p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><font face="华文中宋" size="3">轻量级锁</font></h2><p><font face="华文中宋" size="3">如果多个线程在不同时段获取同一把锁,也就是不存在锁竞争的情况,那么 JVM 就会使用轻量级锁来避免线程的阻塞与唤醒</font></p><h3 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a><font face="华文中宋" size="3">轻量级锁加锁</font></h3><p><font face="华文中宋" size="3">JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间,称之为 Displaced Mark Word .如果一个线程获得锁的时候发现是轻量级锁,就会将锁的 Mark Word 复制到自己的 Displaced Mark Word 中.之后线程会尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针.<br>如果替换成功,当前线程获得锁,那么整个状态还是 <code>轻量级锁</code> 状态<br>如果替换失败了呢?说明 Mark Word 被替换成了其他线程的锁记录,那就尝试使用自旋来获取锁.(自旋是说,线程不断地去尝试获取锁,一般都是用循环来实现的)</font></p><p><font face="华文中宋" size="3">自旋是耗费 CPU 的,如果一直获取不到锁,线程就会一直自旋, CPU 那么宝贵的资源就这么被白白浪费了<br>解决这个问题最简单的办法就是指定自旋的次数,比如如果没有替换成功,那就循环 10 次,还没有获取到,那就进入阻塞状态<br>但是 JDK 采用了一个更加巧妙的方法—适应性自旋.就是说,如果这次线程自旋成功了,那我下次自旋次数更多一些,因为我这次自旋成功,说明我成功的概率还是挺大的,下次自旋次数就更多一些,那么如果自旋失败了,下次我自旋次数就减少一些,就比如,已经看到了失败的前兆,那我就先溜,而不是非要”不撞南墙不回头”</font></p><p><font face="华文中宋" size="3">自旋失败之后,线程就会阻塞,同时锁会升级成<strong>重量级锁</strong></font></p><h3 id="轻量级锁释放"><a href="#轻量级锁释放" class="headerlink" title="轻量级锁释放:"></a><font face="华文中宋" size="3">轻量级锁释放:</font></h3><p><font face="华文中宋" size="3">在释放锁时,当前线程会使用 CAS 操作将 Displaced Mark Word 中的内容复制到锁的 Mark Word 里面.如果没有发生竞争,这个复制的操作就会成功;如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁, CAS 操作就会失败,此时会释放锁同时唤醒被阻塞的过程</font></p><p><font face="华文中宋" size="3">同样,来一张图吧:</font></p><p><img src="/images/2020/轻量级锁及其膨胀.jpg"></p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><font face="华文中宋" size="3">重量级锁</font></h2><p><font face="华文中宋" size="3">重量级锁依赖于操作系统的互斥量( mutex )来实现.但是操作系统中线程间状态的转换需要相对比较长的时间(因为操作系统需要从用户态切换到内核态,这个切换成本很高),所以重量级锁效率很低,但是有一点就是,被阻塞的线程是不会消耗 CPU 的<br>每一个对象都可以当做一个锁,那么当多个线程同时请求某个对象锁时,它会怎么处理呢?<br>对象锁会设置集中状态来区分请求的线程:</font></p><blockquote><p><font face="华文中宋" size="3">Contention List:所有请求锁的线程将被首先放置到该竞争队列</font></p><p><font face="华文中宋" size="3">Entry List: Contention List 中那些有资格成为候选人的线程被移到 Entry List 中</font></p><p><font face="华文中宋" size="3">Wait Set:调用 wait 方法被阻塞的线程会被放置到 Wait Set 中</font></p><p><font face="华文中宋" size="3">OnDeck:任何时刻最多只能有一个线程正在竞争锁,该线程称为 OnDeck</font></p><p><font face="华文中宋" size="3">Owner:获得锁的线程称为 Owner</font></p><p><font face="华文中宋" size="3">!Owner:释放锁的线程</font></p></blockquote><p><font face="华文中宋" size="3">当一个线程尝试获得锁时,如果这个锁被占用,就会把该线程封装成一个 <code>ObjectWaiter</code> 对象插入到 Contention List 队列的队首,然后调用 <code>park</code> 函数挂起当前线程<br>当线程释放锁时,会从 Contention List 或者 Entry List 中挑选一个线程进行唤醒<br>如果线程在获得锁之后,调用了 <code>Object.wait</code> 方法,就会将该线程放入到 WaitSet 中,当被 <code>Object.notify</code> 唤醒后,会将线程从 WaitSet 移动到 Contention List 或者 Entry List 中.<br>但是,当调用一个锁对象的 <code>wait</code> 或 <code>notify</code> 方法时,<strong>如果当前锁的状态是偏向锁或轻量级锁,则会先膨胀成重量级锁</strong></font></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><font face="华文中宋" size="3">总结:</font></h2><p><font face="华文中宋" size="3">synchronized 关键字是通过 monitorenter 和 monitorexit 两种指令来保证锁的<br>当一个线程准备获取共享资源时:</font></p><ul><li><font face="华文中宋" size="3">首先检查 MarkWord 里面放的是不是自己的 ThreadID ,如果是,说明当前线程处于 “偏向锁”</font></li><li><font face="华文中宋" size="3">如果不是,锁升级,这时使用 CAS 操作来执行切换,新的线程根据 MarkWord 里面现有的 ThreadID 来通知之前的线程暂停,将 MarkWord 的内容置为空<br>然后,两个线程都将锁对象 HashCode 复制到自己新建的用于存储锁的记录空间中,接着开始通过 CAS 操作,把锁对象的 MarkWord 的内容修改为自己新建的记录空间地址,以这种方式竞争 MarkWord ,成功执行 CAS 的线程获得资源,失败的则进入自旋<ul><li><font face="华文中宋" size="3">自旋的线程在自旋过程中,如果成功获得资源(也就是之前获得资源的线程执行完毕,释放了共享资源),那么整个状态依然是 <code>轻量级锁</code> 的状态</font></li><li><font face="华文中宋" size="3">如果没有获得资源,就进入  <code>重量级锁</code> 的状态,此时,自旋的线程进行阻塞,等待之前线程执行完成并且唤醒自己</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">参考:</font></p><ul><li><font face="华文中宋" size="3">Java 并发编程的技术</font></li><li><font face="华文中宋" size="3">极客时间—深入拆解 Java 虚拟机</font></li></ul><p><font face="华文中宋" size="3">到这里,整篇文章的内容就算是结束了.<br>没想到这篇文章竟然被我写了有 5000 多字(我已经有些虚脱了<br>能够阅读到这里的各位,希望能够给你带来一些帮助<br>以上,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]你确定你了解 volatile ?</title>
      <link href="/posts/6bdf9b1b.html"/>
      <url>/posts/6bdf9b1b.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">学 Java 并发,过不去 volatile 和 synchronized ,既然过不去,那就不过了,踏踏实实把它搞懂,踩在脚下.<br><a id="more"></a><br>这篇文章先搞定 volatile ,后面我再写另外一篇文章关于 synchronized 和锁的.<br>以下,正文开始:</font></p><p><font face="华文中宋" size="3">在 Java 中, volatile 主要有两个功能:</font></p><ul><li><font face="华文中宋" size="3">保证变量的内存可见性</font></li><li><font face="华文中宋" size="3">禁止 volatile 变量与普通变量重排序</font></li></ul><p><font face="华文中宋" size="3">接下来一一来看这两个功能,以及是怎么实现的</font></p><h1 id="什么是内存可见性"><a href="#什么是内存可见性" class="headerlink" title="什么是内存可见性"></a><font face="华文中宋" size="3">什么是内存可见性</font></h1><p><font face="华文中宋" size="3">如果要谈 volatile 保证了变量的内存可见性,那就需要了解什么是内存可见性</font></p><blockquote><p><font face="华文中宋" size="3">所谓内存可见性是说,当一个线程对 <code>volatile</code> 修饰的变量进行<strong>写操作</strong>时, JMM 会立即将该线程对应的本地内存中的共享变量的值刷新到主内存中;当一个线程对 <code>volatile</code> 修饰的变量进行<strong>读操作</strong>时, JMM 会立即将该线程对应的本地内存设置为无效,然后从主内存中读取共享变量的值</font></p></blockquote><p><font face="华文中宋" size="3">在 JSR-133 之前的旧的 Java 内存模型中,是允许 volatile 变量与普通变量重排序的.<br>也就是说,虽然 volatile 变量能够保证内存可见性,但是可能程序执行的结果依旧不是你想要的.<br>如果直接使用锁的话,又会让整个程序变得比较重量级,基于以上考虑, JSR-133 专家组决定增强 volatile 的内存语义:<strong>严格限制编译器和处理器对 volatile 变量与普通变量的排序</strong></font></p><h1 id="如何禁止-volatile-变量与普通变量重排序"><a href="#如何禁止-volatile-变量与普通变量重排序" class="headerlink" title="如何禁止 volatile 变量与普通变量重排序"></a><font face="华文中宋" size="3">如何禁止 volatile 变量与普通变量重排序</font></h1><p><font face="华文中宋" size="3">俗话说,说得容易,做起来就比较难.定义了严格限制 volatile 变量与普通变量的排序,那是拿什么来做保证的呢? JVM 在处理器层面是通过<strong>内存屏障</strong>来实现的.</font></p><ul><li><font face="华文中宋" size="3">什么是内存屏障呢?从硬件层面来说,内存屏障分为两种:读屏障( Load Barrier )和写屏障( Store Barrier ).内存屏障有两个作用:<ul><li><font face="华文中宋" size="3">阻止屏障两侧的指令重排序</font></li><li><font face="华文中宋" size="3">强制把写缓冲区/高速缓存中的脏数据等写回主内存,或者让缓存中相应的数据失效.<br>这里的缓存主要是指: CPU 缓存,如 L1 , L2 等</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序.<br>在这里编译器选择了一个比较保守的 JMM 内存屏障插入策略,保守的好处就是,可以保证在任何处理器平台,任何程序中都能得到正确的 volatile 内存语义.这个保守策略就是( Load 代表读操作, Store 代表写操作):</font></p><ul><li><font face="华文中宋" size="3">在每个 volatile 写操作前,插入一个 StoreStore 屏障;<ul><li><font face="华文中宋" size="3">比如: <code>Store1 ; StoreStore ; Store2</code> 语句,在 Store2 及后续写入操作执行前,要保证 Store1 的写入操作对其他处理器可见</font></li></ul></font></li><li><font face="华文中宋" size="3">在每个 volatile 写操作后,插入一个 StoreLoad 屏障;<ul><li><font face="华文中宋" size="3">比如: <code>Store1 ; StoreLoad ; Load2</code> 语句,在 Load2 及后续所有读取操作之前,要保证 Store1 的写入对所有处理器可见</font></li></ul></font></li><li><font face="华文中宋" size="3">在每个 volatile 读操作后,插入一个 LoadLoad 屏障;<ul><li><font face="华文中宋" size="3">比如: <code>Load1 ; LoadLoad ; Load2</code> ,在 Load2 及后续读取操作要读取的数据被访问前,要保证 Load1 要读取的数据读取完毕</font></li></ul></font></li><li><font face="华文中宋" size="3">在每个 volatile 读操作后,再插入一个 LoadStore 屏障<ul><li><font face="华文中宋" size="3">比如: <code>Load1 ; LoadStore ; Store2</code> 在 Store2 及后续写入操作被刷出前,要保证 Load1 读取的数据读取完毕</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">是不是有点儿懵?别急,我这里画了两张图,可以看着理解一下</font></p><p><img src="/images/2020/volatile写.jpg"><br><img src="/images/2020/volatile读.jpg"></p><p><font face="华文中宋" size="3">写到这里了,就顺便介绍一下 volatile 和普通变量的重排序规则:</font></p><ul><li><font face="华文中宋" size="3">如果第一个操作是 volatile 读,那么不管第二个操作是什么,都不能重排序;</font></li><li><font face="华文中宋" size="3">如果第二个操作是 volatile 写,那么不管第一个操作是什么,都不能重排序;</font></li><li><font face="华文中宋" size="3">如果第一个操作是 volatile 写,第二个操作是 volatile 读,也不能重排序;</font></li></ul><p><font face="华文中宋" size="3">可以发现,针对 volatile 写操作来说,是比较严格的,但是如果第一个是普通变量的读,第二个是 volatile 的读,我可不可以重排序呢?可以</font></p><h1 id="volatile-怎么用"><a href="#volatile-怎么用" class="headerlink" title="volatile 怎么用"></a><font face="华文中宋" size="3">volatile 怎么用</font></h1><p><font face="华文中宋" size="3">看到这里,应该就能知道, volatile 保证了内存可见性以及禁止重排序.<br>在保证内存可见性这一点上,可以说 volatile 和锁有着相同的意义,所以 volatile 可以作为一个”轻量级”锁来使用.<br>volatile 的本质其实就是告诉 JVM ,我修饰的这个变量在寄存器中的值是不确定的,如果需要的话,不能直接从本地内存中读取,需要从主存中去拿,所以 volatile 它改变的只是变量的可见性,但是不保证原子性.<br>基于此,就需要搞清楚,在什么情况下使用 volatile 比较好.</font></p><p><font face="华文中宋" size="3">对于 volatile 关键字来说,当且仅当满足以下所有条件时,才可以使用:</font></p><ul><li><font face="华文中宋" size="3">对变量的写操作不依赖变量的当前值,或者确保只有单个线程更新变量的值</font></li><li><font face="华文中宋" size="3">变量没有包含在具有其他变量的不变式中</font></li></ul><p><font face="华文中宋" size="3">我觉得上面的条件,就是为了保证操作是原子性操作,因为 volatile 不保证原子性,那为了安全,就要保证你本身的操作就是原子性操作,相当于直接从源头上就把不是原子性操作给排除掉.<br>这样的话,就比较容易搞清楚 volatile 这个变量使用在什么场景下了:</font></p><ul><li><font face="华文中宋" size="3">用来标识状态,比如 <code>boolean flag</code> 这种</font></li><li><font face="华文中宋" size="3">一次性安全发布( one-time safe publication ):实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型</font></li><li><font face="华文中宋" size="3">独立观察( independent observation):安全使用 volatile 的另一种简单模式是:定期”发布” 观察结果供程序内部使用.例如,假设有一种环境传感器能够感觉环境温度,一个后台线程可能会每隔几秒读取一次该传感器,并更新包含当前文档的 volatile 变量.然后,其他线程可以读取这个变量,从而随时能够看到最新的温度值</font></li></ul><p><font face="华文中宋" size="3">参考:<br>深入理解 JVM<br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">Java 理论与实践:正确使用 Volatile 变量</a><br><a href="https://www.jianshu.com/p/ef8de88b1343" target="_blank" rel="noopener">并发关键字 volatile（重排序和内存屏障）</a><br><a href="https://blog.csdn.net/hqq2023623/article/details/51013468" target="_blank" rel="noopener">JMM——volatile与内存屏障</a></font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]为什么会有重排序?和 happens-before 有啥关系</title>
      <link href="/posts/e3a1cde0.html"/>
      <url>/posts/e3a1cde0.html</url>
      
        <content type="html"><![CDATA[<h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><font face="华文中宋" size="3">举个例子</font></h1><a id="more"></a><p><font face="华文中宋" size="3">在讲重排序之前,先来看一个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> one = a;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> two = b;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">应该不难看出,在上面的例子中,我定义了两个共享变量 a 和 b ,以及两个方法.其中第一个方法是将局部变量 one 赋值为 a ,然后将 b 的值置为 1 .第二个方法则是将局部变量 two 赋值为 b ,然后将 a 的值置为 2 .<br>那么我在这里有个问题,  <code>( one , two )</code> 的值会是什么?</font></p><p><font face="华文中宋" size="3">你可能会不假思索的告诉我,不是 <code>( 0 , 1 )</code> 就是 <code>( 2 , 0 )</code> ,这需要看我的 main 方法先执行哪个 method 方法.<br>不错,如果这个程序跑在了单线程上面,这样回答一点儿毛病都没有.<br>但是,如果是在多线程环境下呢?</font></p><p><font face="华文中宋" size="3">假设,现在 <code>methodOne</code> 和 <code>methodTwo</code> 分别在两个不同的线程上执行,此时 Java 虚拟机在执行了任意一个方法的第一条赋值语句之后就切换线程,这个时候的 <code>( one , two )</code> 的值可能是 <code>( 0 , 0 )</code><br>看到这儿,有没有疑惑?为啥呢,怎么我写的程序好好的,到 Java 虚拟机这里了,它就变了呢?<br>就是因为在执行的过程中,发生了重排序.它可能是即时编译器的重排序,可能是处理器的乱序执行,或者是内存系统的重排序.<br>总之,在程序执行过程中,发生了重排序,然后得到的结果可能是 <code>( 0 , 0 )</code> 这种情况.</font></p><h1 id="为什么会重排序"><a href="#为什么会重排序" class="headerlink" title="为什么会重排序"></a><font face="华文中宋" size="3">为什么会重排序</font></h1><p><font face="华文中宋" size="3">看完上面,你可能会有疑问,为什么会有重排序呢?<br>我的程序按照我自己的逻辑写下来好好的没啥问题, Java 虚拟机为什么动我的程序逻辑?<br>你想想, CPU ,内存这些都是非常宝贵的资源, Java 虚拟机如果在重排序之后没啥效果,肯定也不会做这种费力不讨好的事情.<br>那么,重排序带来了什么好处呢?</font></p><h2 id="重排序使得程序的性能得以提高"><a href="#重排序使得程序的性能得以提高" class="headerlink" title="重排序使得程序的性能得以提高"></a><font face="华文中宋" size="3">重排序使得程序的性能得以提高</font></h2><p><font face="华文中宋" size="3">为了方便理解,我拿生活中的场景来举例子.<br>大早上起来,你会穿衣服,洗漱,做饭,吃饭对吧.那么在你起床之后,你是怎么做的呢?你是不是会在洗漱的时候,先把饭做上(比如让蒸蛋机帮你蒸个鸡蛋),然后呢等你洗漱完毕之后,就可以直接吃早饭了.<br>你为什么要这样做呢?还不是为了省时间,可以多睡那么一分钟,对不对.</font></p><p><font face="华文中宋" size="3">同样的道理, Java 虚拟机之所以要进行重排序就是为了提高程序的性能.你写的程序,简简单单一行代码,到底层可能需要使用不同的硬件,比如一个指令需要同时使用 CPU 和打印机设备,但是此时 CPU 的任务完成了,打印机的任务还没完成,这个时候怎么办呢?不让 CPU 执行接下来的指令吗? CPU 的时间那么宝贵,你不让它工作,确定不是在浪费它的生命?<br>所以为了提高利用率以及程序的性能, Java 虚拟机会在你这个指令还没完全执行完毕的时候,就去执行另外一个指令.这就是流水线技术<br>流水线最怕的是啥?是我执行着命令,执行着命令,突然中断了,恢复中断的成本是很大的,所以就要想尽办法,绞尽脑汁不要让中断的情况发生.</font></p><p><font face="华文中宋" size="3">即时编译器的重排序,处理器的乱序执行,以及内存系统的重排序的存在,都是为了减少中断.<br>到这里,你是不是对于 Java 虚拟机进行重排序这一点有了了解?</font></p><h1 id="重排序带来的问题"><a href="#重排序带来的问题" class="headerlink" title="重排序带来的问题"></a><font face="华文中宋" size="3">重排序带来的问题</font></h1><p><font face="华文中宋" size="3">回到文章刚开始举的那个例子,重排序提高了 CPU 的利用率没错,提高了程序性能没错,但是我的程序得到的结果可能是错误的啊,这是不是就有点儿得不偿失了?<br>因为<strong>重排序可以保证串行语义一致,但是没有义务保证多线程间的语义也一致</strong></font></p><p><font face="华文中宋" size="3">凡是问题,都有办法解决,要是没有,那就再想想.<br>它是怎么解决的呢?这就需要来说说,顺序一致性内存模型和 JMM ( Java Memory Model , Java 内存模型)</font></p><h1 id="顺序一致性内存模型与-JMM"><a href="#顺序一致性内存模型与-JMM" class="headerlink" title="顺序一致性内存模型与 JMM"></a><font face="华文中宋" size="3">顺序一致性内存模型与 JMM</font></h1><p><font face="华文中宋" size="3">要说数据一致性的话,就要说一说,数据竞争.<br>啥是数据竞争呢?在 Java 内存模型规范中给出了定义:</font></p><ul><li><font face="华文中宋" size="3">在一个线程中写一个变量</font></li><li><font face="华文中宋" size="3">在另外一个线程中读同一个变量</font></li><li><font face="华文中宋" size="3">写和读没有通过同步来排序</font></li></ul><p><font face="华文中宋" size="3">当代码中包含数据竞争时,程序的执行结果往往会超出你的想象,比如咱们刚开始说的那个例子,得到的结果可能是 <code>( 0 , 0 )</code> .但是如果一个多线程程序能够正确同步的话,那上面的结果就不会出现了.<br>Java 内存模型对于正确同步多线程程序的内存一致性做了下面的保证:</font></p><blockquote><p><font face="华文中宋" size="3"><strong>如果程序是正确同步的,程序的执行也会具有顺序一致性</strong>即,程序的执行结果与该程序在顺序一致性模型中执行的结果相同</font></p></blockquote><p><font face="华文中宋" size="3">这里面的同步包括了使用 <code>volatile</code> , <code>final</code> , <code>synchronized</code> 等关键字来实现多线程下的同步.那也就是说,如果没有正确使用这些同步, JMM 就不会有内存可见性的保证,这就会导致写的程序出错.</font></p><p><font face="华文中宋" size="3">顺序一致性内存模型是一个<strong>理想状态下的理论参考模型</strong>,它为程序员提供了特别强的内存可见性保证,顺序一致性模型有两大特性:</font></p><ul><li><font face="华文中宋" size="3">一个线程中的所有操作必须按照程序的顺序来执行(也就是按照写的代码的顺序来执行)</font></li><li><font face="华文中宋" size="3">不管程序是否同步,所有线程都只能看到一个单一的操作执行顺序.也就是说,在顺序一致性模型中,每个操作必须是原子性的,而且立刻对所有线程都是可见的.</font></li></ul><p><font face="华文中宋" size="3">上面说了,顺序一致性内存模型是一个理想状态下的理论参考模型,因为顺序一致性内存模型要求操作对所有线程都是可见,只是这一点就会让 Java 虚拟机的性能降低. JMM 就是在顺序一致性内存模型的基础上,做了一些优化:</font></p><ul><li><font face="华文中宋" size="3">针对同步的多线程程序来说,也就是临界区内的代码, JMM 允许发生重排序(但是不允许临界区内的代码”逃逸”到临界区之外,因为如果允许的话,就会破坏锁的内存语义)</font></li><li><font face="华文中宋" size="3">针对未同步的多线程程序来说, JMM 只提供最小安全性:线程读取到的值,要么是之前某个线程写入的值,要么是默认值,不会无中生有.</font></li></ul><p><font face="华文中宋" size="3">应该能够感觉到,相比于顺序一致性内存模型来说, JMM 给了编译器和处理器一些空间,允许它们发生重排序.<br>这时候就有冲突点了:程序员这边需要 JMM 提供一个强的内存模型来编写代码,也就是我代码写的顺序是什么样,那程序执行的时候就要是什么样;但是编译器和处理器则需要 JMM 对它们的约束越少越好,这样它们就可以尽可能多的去做优化,来提高性能<br>作为 JMM 这个中介者来说,既要满足程序员的需求,又要满足编译器和处理器的需求,那就需要在这两者之间找一个平衡点,让程序员写的代码能够产生他期望的结果,同时呢,也让编译器和处理器能够做一些优化<br>JMM 提出的解决方案就是:对于程序员,提供 happens-before 规则,这样就满足了程序员的需求 —&gt; 简单易懂,而且提供了足够强的内存可见性保证;对于编译器和处理器来说,只要不改变程序的执行结果(前提是正确同步了多线程程序),想怎么优化就怎么优化.</font></p><h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a><font face="华文中宋" size="3">happens-before</font></h1><p><font face="华文中宋" size="3">终于讲到了 happens-before .<br>先来看 happens-before 关系的定义:</font></p><ul><li><font face="华文中宋" size="3">如果一个操作 happens-before 另一个操作,那么第一个操作的执行结果就会对第二个操作可见</font></li><li><font face="华文中宋" size="3">两个操作之间如果存在 happens-before 关系,并不意味着 Java 平台的具体实现就必须按照 happens-before 关系指定的顺序来执行.如果重排序之后的执行结果,与按照 happens-before 关系来执行的结果一直,那么 JMM 也允许这样的重排序</font></li></ul><p><font face="华文中宋" size="3">看到这儿,你是不是觉得,这个怎么和 as-if-serial 语义一样呢.没错, happens-before 关系本质上和 as-if-serial 语义是一回事.<br>as-if-serial 语义保证的是单线程内重排序之后的执行结果和程序代码本身应该出现的结果是一致的, happens-before 关系保证的是正确同步的多线程程序的执行结果不会被重排序改变.<br>一句话来总结就是:如果操作 A happens-before 操作 B ,那么操作 A 在内存上所做的操作对操作 B 都是可见的,不管它们在不在一个线程.</font></p><p><font face="华文中宋" size="3">在 Java 中,对于 happens-before 关系,有以下规定:</font></p><ul><li><font face="华文中宋" size="3">程序顺序规则:一个线程中的每一个操作, happens-before 于该线程中的任意后续操作</font></li><li><font face="华文中宋" size="3">监视器锁规则:对一个锁的解锁, happens-before 于随后对这个锁的加锁</font></li><li><font face="华文中宋" size="3">volatile 变量规则:对一个 volatile 域的写, happens-before 与任意后续对这个 volatile 域的读</font></li><li><font face="华文中宋" size="3">传递性:如果 A happens-before B , 且 B happens-before C ,那么 A happens-before C</font></li><li><font face="华文中宋" size="3">start 规则:如果线程 A 执行操作 ThreadB.start() 启动线程 B ,那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作</font></li><li><font face="华文中宋" size="3">join 规则:如果线程 A 执行操作 ThreadB.join() 并成功返回,那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回.</font></li></ul><p><font face="华文中宋" size="3">写到这里,我感觉终于是写完这篇文章了,从为什么要重排序讲到 happens-before .</font></p><ul><li><font face="华文中宋" size="3">参考:<br>Java 并发编程的艺术</font></li></ul><p><font face="华文中宋" size="3">最后,真是太感谢您的阅读了哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Java 并发]带你从源码解读线程组( ThreadGroup )好不好</title>
      <link href="/posts/63ed9e38.html"/>
      <url>/posts/63ed9e38.html</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadGroup-概念"><a href="#ThreadGroup-概念" class="headerlink" title="ThreadGroup 概念"></a><font face="华文中宋" size="3">ThreadGroup 概念</font></h1><a id="more"></a><p><font face="华文中宋" size="3">只是从英文名字上,也能看到这个概念的简单粗暴, ThreadGroup 就是线程组.<br>也就是说,每个 Thread 都能在一个 ThreadGroup 中找到.那么你可能会问了,我不存在于一个 ThreadGroup 不行?自己在程序里面一个人潇洒走天下,岂不是超级爽?<br>抱歉,此路不通.为啥呢?咱们来看源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">我们能够看到,如果 g 为空,会做这样的处理</font></p><ul><li><font face="华文中宋" size="3">首先看 security 是否为空,如果不为空,直接使用 security 的线程组</font></li><li><font face="华文中宋" size="3">如果 security 是空的话,那么这个线程就获取当前线程所属的线程组<br>所以你想脱离组织自己玩?这种事情想都不要想.<br>操作系统怎么可能允许有逃离自己掌控之外的存在呢!</font></li></ul><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><font face="华文中宋" size="3">优先级</font></h1><p><font face="华文中宋" size="3">OK ,咱们接下来谈另外一个问题.<br>一个 Thread 必然存在于一个 ThreadGroup , Thread 有自己的优先级, ThreadGroup 也有优先级,如果 Thread 的优先级大于 ThreadGroup 的优先级了,这个时候咋整呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="comment">// 如果设置的 priority 大于系统设置的最大值,或者小于系统设置的最小值</span></span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置线程的优先级大于线程组的优先级,则重置线程的优先级为线程组的优先级</span></span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">所以啊,优先级冲突了,两位也别吵吵, Thread 踏踏实实跟着 ThreadGroup 走才有肉吃不是~</font></p><h1 id="ThreadGroup-还可以做"><a href="#ThreadGroup-还可以做" class="headerlink" title="ThreadGroup 还可以做"></a><font face="华文中宋" size="3">ThreadGroup 还可以做</font></h1><p><font face="华文中宋" size="3">看完上面,你可能觉得,哦,原来线程组就是管线程的啊<br>你如果真的这么认为的话,我赶紧写写接下来的内容,把你的思绪拉一拉<br>线程组管理的可不单单是线程.<br>咱们看看源码里面,线程组的成员变量都有啥:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent;  <span class="comment">// 父 ThreadGroup</span></span><br><span class="line">    String name;  <span class="comment">// ThreadGroup 名称</span></span><br><span class="line">    <span class="keyword">int</span> maxPriority;  <span class="comment">// 线程最大优先级</span></span><br><span class="line">    <span class="keyword">boolean</span> destroyed;  <span class="comment">// 是否被销毁</span></span><br><span class="line">    <span class="keyword">boolean</span> daemon;  <span class="comment">// 是否守护线程</span></span><br><span class="line">    <span class="keyword">boolean</span> vmAllowSuspension;  <span class="comment">// 是否可以中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nUnstartedThreads = <span class="number">0</span>;  <span class="comment">// 还未启动的线程</span></span><br><span class="line">    <span class="keyword">int</span> nthreads;  <span class="comment">// ThreadGroup 中线程数目</span></span><br><span class="line">    Thread threads[];  <span class="comment">// ThreadGroup 中的线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ngroups;  <span class="comment">// 线程组数目</span></span><br><span class="line">    ThreadGroup groups[];  <span class="comment">// 线程组数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">吼,原来线程组里面还可以有线程组,不单单是有线程,原来还可以控制线程优先级,还可以决定是否销毁线程或者守护线程,或者中断线程.</font></p><p><font face="华文中宋" size="3">到这里,咱们来总结一下:</font></p><ul><li><font face="华文中宋" size="3">线程组是一个父子结构,一个线程组可以属于其他线程组,也可以拥有自己的子线程组,如果你一直向上追溯的话,会发现所有的线程组都在一个根线程组里面— System 线程组</font></li><li><font face="华文中宋" size="3">线程组的出现可不是为耍酷用的,它是为了更方便的管理线程而存在的.比如设置线程最大优先级,销毁线程等等</font></li></ul><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> Java 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]16 你是不是和我一样,不知道图这种数据结构怎么用?</title>
      <link href="/posts/1eb1a8ac.html"/>
      <url>/posts/1eb1a8ac.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">你是不是和我一样,在学习数据结构与算法时,了解了一下图这种数据结构之后,根本不知道它的用武之地在哪里?<br>在我查了资料之后,现在我可以跟你讲讲,图可以这么用!<br><a id="more"></a></font></p><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a><font face="华文中宋" size="3">概念介绍</font></h1><p><font face="华文中宋" size="3">先来了解一下什么是图.<br>图,是一种非线性表数据结构.<br>那么你可能会问了,什么是线性表结构哇,我怎么区别一种数据结构是线性的,还是非线性的呢.<br>哈哈,还好我机智,在这篇文章之前就写了一篇文章来介绍,如果还有疑问,楼上雅座请: <a href="https://www.dynamic-zheng.com/posts/d42777bf.html">[数据结构与算法]14 搞不懂线性结构,非线性结构?</a></font></p><p><font face="华文中宋" size="3">在图中元素叫做顶点( vertex ),图中的一个顶点可以和其他任意顶点建立连接关系,这种建立的关系叫做边( edge )</font></p><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a><font face="华文中宋" size="3">无向图</font></h1><p><img src="/images/2020/undirected-graph.jpg"></p><p><font face="华文中宋" size="3">上面给出的是无向图.看到这里你可能就觉得比较疑惑,这个无向图看起来没啥呀,怎么会有这种数据结构呢?<br>不知道你是怎么想的,我刚开始学的时候就有这种疑问,这是什么神仙数据结构哇,还会有应用场景?<br><img src="/images/2020/真香警告.jpg"></font></p><p><font face="华文中宋" size="3">既然有疑惑,那就给个应用场景:<br>假设,现在你和我是微信好友,那是不是应该你的好友列表里面有我,我的好友里面有你,这样咱们才是好友对不对~<br>那在数据库中如何表示呢?吼~这个时候无向图就登场了<br>你和我是微信好友,那就在咱俩之间来条线,表示咱俩之间有关系,一条线就解决了问题,真是完美至极啊<br>假设,(怎么又是假设,哈哈哈)上图中表示的就是 A,B,C,D,E,F 之间的关系,那你可能就发现问题了,有的顶点线比较多,比如 D 有四条线,有的就相对少一些,比如 B 有两条线.这些线就表示顶点的度( degree ).这个概念有啥用?<br>能一眼看出来谁的好友多!那这个功能有啥用?(好吧,这个功能好像是有点儿鸡肋,不过也算是一个应用场景</font></p><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a><font face="华文中宋" size="3">有向图</font></h1><p><font face="华文中宋" size="3">看到上面的无向图,基础不错的小伙伴肯定会说了,我还知道有向图呢!<br>呦呵,不错,有向图就是下面这个样子:<br><img src="/images/2020/directed-graph.jpg"></font></p><p><font face="华文中宋" size="3">在无向图中,咱们知道一个顶点有多少条边,就说它的度为多少.<br>在有向图中呢,有指向顶点的,也有从顶点指出去的,基于无向图的概念,咱们把从这个顶点指出去的边称为出度,指向该顶点的边称为入度.<br>那么有向图会应用在哪些场景呢?微信好友这个场景是不太可以了<br>那么微博呢?<br>微博和微信有什么不一样呢?微信是你和我是好友,那么咱们的好友列表里一定是要有彼此的,拉黑或者删除彼此了,那就不能互相发送消息了.<br>但是微博呢?你关注了我,并不代表我就要关注你对吧?看到这里有没有一种豁然开朗的感觉~<br>那么我关注了多少人就是出度,多少人关注了我就是入度.<br>这样带入理解是不是会比较好一点儿?(我可真是个天才,哈哈哈</font></p><h1 id="带权图"><a href="#带权图" class="headerlink" title="带权图"></a><font face="华文中宋" size="3">带权图</font></h1><p><font face="华文中宋" size="3">看完了无向图,有向图,相信就有人说,我还见过带权图!(陈独秀给我坐下!<br>带权图长啥样呢?就下面这个样子:<br><img src="/images/2020/weighted-graph.jpg"></font></p><p><font face="华文中宋" size="3">懵逼了,这每条边上的数字是个什么鬼呦<br>别急,咱们来个场景:大家都玩 QQ 嘛?(别跟我说不玩,配合一下嘛…<br>玩 QQ 的话,一定知道有 QQ 空间,然后空间里面有个「谁在意我」「我在意谁」的功能,就是下图:<br><img src="/images/2020/QQ.jpg"></font></p><p><font face="华文中宋" size="3">那么有没有好奇过呢? QQ 怎么知道我在意谁,谁在意我呢?<br>就是通过带权图哇<br>你访问了一个人的空间,这条边的权重就增加一点儿;别人访问了你的空间,那这条边的权重就增加一点儿;这段时间你们两个人聊天聊得比较频繁,来个小火花,顺便在你们两者之间的边权重增加一点儿.然后根据这些边的权重从大到小排序就得出了「谁在意我」「我在意谁」</font></p><p><font face="华文中宋" size="3">到这里,上面的一切理解都还 OK ?<br>那咱们继续.图是怎么表示的呢?<br>图这种数据结构,再怎么画顶点,画边,到最后在物理结构上是怎么存储的呢?<br>别急,你所疑惑的,我都帮你想到了</font></p><h1 id="图的存储方法"><a href="#图的存储方法" class="headerlink" title="图的存储方法"></a><font face="华文中宋" size="3">图的存储方法</font></h1><p><font face="华文中宋" size="3">图的存储方法主要有以下两种:</font></p><ul><li><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a><font face="华文中宋" size="3">邻接矩阵</font></h2><font face="华文中宋" size="3">邻接矩阵的底层依赖一个二维数组.对于无向图来说,如果 i 与 j 之间有边,那就将 A[i][j] 和 A[j][i] 标记为 1 ;对于无向图来说,如果 i 指向 j ,那么 A[i][j] 值为 1 ,如果 j 指向 i ,那么 A[j][i] 值为 1 ;对于带权图来说, A[i][j] 存储的值就不是 1 了,而是对应的权重值.所以这是图最直观的一种存储方法.<br>啥,你跟我说这还不直观?该不会是没有看下图吧:<br><img src="/images/2020/adjacency-matrix.jpg"><br><font face="华文中宋" size="3">但是你发现问题了嘛,这样看起来确实是直观了很多,但是很浪费空间有没有!比如无向图,如果 A[i][j] 为 1 ,那么 A[j][i] 肯定也是 1 ,多存储 A[j][i] 根本没啥必要.就像买东西,明明一块钱能买到的东西,为啥非要花两块钱?<br>所以如果使用邻接矩阵来表示的话,一定要清楚它的缺点.</font></font></li></ul><p><font face="华文中宋" size="3">但这并不是说,使用邻接矩阵来存储就没啥优点.这天底下哪儿有那么绝对的事情呢.<br>首先,邻接矩阵的存储方式简单,直接,所以当我们需要获取两个顶点之间的关系时,相信我没有比这种存储结构更高效的了.<br>还有就是使用邻接矩阵存储图的另外一个优点就是方便计算,因为可以将很多图的运算转换成矩阵之间的运算.</font></p><ul><li><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a><font face="华文中宋" size="3">邻接表</font></h2><font face="华文中宋" size="3">先来看图:<br><img src="/images/2020/adjacency-list.jpg"><br><font face="华文中宋" size="3">乍一看,这不是散列表嘛!每个顶点对应一条链表,链表中存储的是与这个顶点相连接的其他顶点.<br>嘿嘿,直觉超棒!</font></font></li></ul><p><font face="华文中宋" size="3">如果你对散列表熟悉的话,应该知道,在散列表中,如果链太长了,会导致冲突概率增大,复杂度也蹭的一下升高.而且吧,链表的存储方式你也知道,不是连续的,所以相对于数组来说, CPU 读取就会慢一些,相对于邻接矩阵的存储方式,在邻接表中查询两个顶点之间的关系就没那么高效了.<br>所以在实际开发中要注意遇到这种情况该如何处理,或者在刚开始的时候就直接设计好实现方式.比如可以将邻接表中的链表改为平衡二叉树,或者红黑树.</font></p><p><font face="华文中宋" size="3">我觉得对于数据结构来说,没有最好的,只有最合适的~</font></p><p><font face="华文中宋" size="3">参考</font></p><ul><li><font face="华文中宋" size="3">极客时间—&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]15 两行代码就可以搞定求众数,但还有更巧的</title>
      <link href="/posts/de95c539.html"/>
      <url>/posts/de95c539.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">这个周末刷了几道算法题,把其中一个比较不错的分享给你~<br><a id="more"></a></font></p><blockquote><p> 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br> 示例 1:<br> 输入: [3,2,3]<br> 输出: 3<br> 示例 2:<br> 输入: [2,2,1,1,1,2,2]<br> 输出: 2</p></blockquote><p><font face="华文中宋" size="3">哦,原来是求众数,注意一下哈,这里的众数是指”在数组中出现次数大于 ⌊ n/2 ⌋ 的元素”,不要问我为什么要你们注意一下这个条件,因为我钻牛角尖了!</font></p><p><font face="华文中宋" size="3">拿到这个题目,我的第一反应就是,那我给这个数组排个序然后取中间的值不就得了?<br>所以代码就只有两行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line">return nums[nums.length &gt;&gt; 1];</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">写完程序运行,一点儿毛病都没有,简简单单两行代码就搞定,那一刻我觉得我就是个天才!<br>后来梦醒了,冷静分析了一下,我去这样的代码简单是简单,但是时间复杂度是 O(nlogn) ,空间复杂度是 O(logn)<br>所以有没有更好的解决方案呢?能让它的时间复杂度和空间复杂度都降下来<br>必须得有哇!要不然我写这篇文章是为了啥<br>这种比较好的解决方案就是摩尔投票法</font></p><p><font face="华文中宋" size="3">这个方法理解起来有点儿绕,我先来讲讲,这一块儿看懂了,咱们再往下走<br>先回到现实生活中,投票的时候咱们是怎么投的呢?大家每个人都选一个人,然后开始拆开纸团瞅瞅选的是谁,刚开始默认大家都是 0 票,然后纸条上投的是谁,这个人就多一票,最后看谁的票数比较多.<br>回到咱们这个题目,既然是众数,而且出现的次数大于 ⌊ n/2 ⌋ ,那我们可以假设一个数就是要求的众数,同时设置这个数字出现的次数为 0 ,然后和接下来的数字进行比较,如果一样呢,咱们把这个数字出现的次数加上 1 ,如果不一样,就让次数减 1 ,当这个值减到 0 时,说明刚开始假设的数字不是众数,那就换当前的这个数字,继续循环<br>这样最后这个数字出现的次数一定是大于等于 0 的,要不然就不符合 <code>出现的次数大于 ⌊ n/2 ⌋</code> 这个题意了<br>最后,将真正的众数返回即可<br>具体代码可见下面:</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int count = 0 ;</span><br><span class="line">Integer candidate = null;</span><br><span class="line"></span><br><span class="line">    for(int num : nums)&#123;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">        &#125;</span><br><span class="line">        count += ( num == candidate ) ? 1 : -1 ;</span><br><span class="line">    &#125;</span><br><span class="line">return candidate;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">分析一下,这样实现的时间复杂度是 O(n) ,空间复杂度是 O(1)<br>和刚开始使用的方法相比,好了许多</font></p><p><font face="华文中宋" size="3">你有没有更巧妙的方法实现,欢迎评论区和我交流哇<br>最后,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]14 搞不懂线性结构,非线性结构?</title>
      <link href="/posts/d42777bf.html"/>
      <url>/posts/d42777bf.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在前面文章中介绍的数组,栈,队列这种都是线性结构,在接下来的文章中,会介绍图,这是一种非线性结构.<br>朋友,你是不是一脸问号?啥是线性结构,什么又是非线性结构呢?我怎么区别这两者呢.<br>别慌,一点点来看.<br><a id="more"></a></font></p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a><font face="华文中宋" size="3">线性结构</font></h1><p><font face="华文中宋" size="3">我在学习知识的时候,喜欢和以前的知识联系起来.<br>线性结构,我就想到了在学数学的时候,常说的线性相关,或者说这两个变量之间呈线性关系.<br>那么,在数学的定义上,什么是线性关系呢?<br>我就直接把维基百科的定义搬过来了,链接在这儿: <a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E9%97%9C%E4%BF%82" target="_blank" rel="noopener">线性关系</a></font></p><blockquote><p><font face="华文中宋" size="3"> 在现代学术界中，线性关系一词存在 2 种不同的含义。其一，若某数学函数或数量关系的函数图形呈现为一条直线或线段，那么这种关系就是一种线性的关系。其二，在代数学和数学分析学中，如果一种运算同时满足特定的“加性”和“齐性”，则称这种运算是线性的。</font></p></blockquote><p><font face="华文中宋" size="3">咱们着重看第一个含义,和数学上面的定义差不多,大概意思就是 y 和 x 的关系在图中表示为一条直线或线段,比如 y=x ,那么这种关系我们就可以称之为是线性关系.<br>OK ,那 y=x 有什么特殊之处呢?是不是每一个 x 的取值,都唯一对应一个 y 值?<br>Nice !能够想到这一点,就触及到了线性结构的本质,即:数据元素之间存在着”一对一”的线性关系的数据结构就称为 线性结构.</font></p><p><font face="华文中宋" size="3">了解本质之后,咱们应该就很好理解了,像: 线性表,栈,队列,双队列 这种都是线性结构.</font></p><h1 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a><font face="华文中宋" size="3">非线性结构</font></h1><p><font face="华文中宋" size="3">在了解线性结构之后,再来理解非线性结构就好说了.<br>既然线性结构是一对一的关系,那么非线性结构就存在不是一对一的关系了呗,比如一对多?<br>恭喜你,答对了!<br>那么我们常见的: 二维数组,多维数组,树,图 就都是非线性结构了.</font></p><p><font face="华文中宋" size="3">以上就是想要分享的内容了<br>最近感觉自己写文章遇到了瓶颈一般,总是觉得没有写出自己想要的效果<br>关于我的文章,欢迎各位留言和我交流哇</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]13 再来谈散列表</title>
      <link href="/posts/45c48476.html"/>
      <url>/posts/45c48476.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">关于散列表入门级的知识,在这篇文章里面写过一些: <a href="https://blog.csdn.net/zll_0405/article/details/102208638" target="_blank" rel="noopener">[算法]散列表( Hash Table)</a><br>咱们今天再来详细讲一讲散列表.<br><a id="more"></a></font></p><h1 id="散列表与数组"><a href="#散列表与数组" class="headerlink" title="散列表与数组"></a><font face="华文中宋" size="3">散列表与数组</font></h1><p><font face="华文中宋" size="3">散列表最重要的就是,给我一个 key 值,我就能知道对应的 value 值.<br>在基础的数据结构里面,哪儿种数据结构能做到这样?<br>是不是数组?只要你给我一个数组的下标,我就能知道这个下标对应的值.<br>所以,散列表用的是数组支持按照下标随机访问数据的特性,散列表就是数组的一种扩展.<br>可以说,如果没有数组的话,就没有散列表.</font></p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a><font face="华文中宋" size="3">散列函数</font></h1><p><font face="华文中宋" size="3">OK ,在了解散列表与数组关系之后,咱们来说说散列函数.<br>在上面我们已经知道,散列表和数组的关系,也就是散列表利用了数组访问数据时间复杂度为 O( 1 ) 的特性,但是 value 值,是如何生成 key 值的呢?<br>利用的就是散列函数.<br>在构造散列函数时,有三点基本要求:</font></p><ul><li><font face="华文中宋" size="3">散列函数计算得到的散列值是一个非负整数;</font></li><li><font face="华文中宋" size="3">如果 key1 = key2 ,则经过散列函数散列之后得到的值也应该相等</font></li><li><font face="华文中宋" size="3"> 如果 key1 ≠ key2 ,那么经过散列函数散列之后得到的值也不应该相等</font></li></ul><p><font face="华文中宋" size="3">这三点要求应该挺容易理解的.首先数组下标是从 0 开始的,所以散列函数计算得到的散列值不能是一个非负整数;其次, key 值相等的,那么经过散列函数散列之后得到的 value 值也应该是一样的;当然,如果 key 值不相等,那么经过散列函数散列之后得到的 value 值也应该不一样.<br>这三点要求看起来挺少的,满足一下应该不过分吧?<br>不,太过分了!</font></p><p><font face="华文中宋" size="3">你想想呀, key 值不相等,就要有一个不同的 value 值,比如 “散列表” 这可以是一个 key 值吧?那 “散,列,表” 是不是另外一个 key 值?那 “散列,表” 是不是另外一个 key 值.<br>发现问题了嘛?也就是 key 只要稍微不一样,哪怕是多了一个符号,或者一个字母,就是不一样的 key 值,每一个 key 都要对应一个不同的 value 值,如果要满足这个要求,需要耗费很大的空间时间成本.<br>所以,目前为止,还没有一个完美的散列函数,使得散列之后的 value 值不重复.<br>这就引出了,散列冲突.</font></p><h1 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a><font face="华文中宋" size="3">散列冲突</font></h1><p><font face="华文中宋" size="3">既然到目前为止,还没有一个完美的散列函数,无法避免散列冲突,那咱们就曲线救国一下,遇到散列冲突了,该如何解决呢?<br>常用的散列冲突解决方法有两类:</font></p><ul><li><font face="华文中宋" size="3">开放寻址法<br><font face="华文中宋" size="3">开放寻址法的核心思想就是,如果出现了散列冲突,那就重新探测一个空闲位置,插入进来.<br>比如很经典的线性探测法:出现了散列冲突?行嘞,那咱们就从当前位置开始,再往下瞅瞅哪儿个位置是空的呗,有空的就插进去<br>比如很经典的二次探测法:出现了散列冲突?好呀,这次探测的下标序列是 +0 ,接下来看看 +1² 的位置有没有空闲,还是没有?那就 +2² 继续下去,直到找到空闲位置为止.</font></font></li><li><font face="华文中宋" size="3">链表法<br><font face="华文中宋" size="3">散列函数散列之后,存放值不再是一个空闲位置,而是一个链表.<br>一个空闲位置只能存放一个值,咱们不用了,改成一个链表,如果有两个值,很简单,这个链表的 next 指针指向要插入的值就好了.</font></font></li></ul><h1 id="散列冲突解决办法适合哪些应用场景"><a href="#散列冲突解决办法适合哪些应用场景" class="headerlink" title="散列冲突解决办法适合哪些应用场景?"></a><font face="华文中宋" size="3">散列冲突解决办法适合哪些应用场景?</font></h1><p><font face="华文中宋" size="3">散列冲突的两种主要解决办法是:开放寻址法 + 链表法.<br>那为什么在 Java 中 LinkedHashMap 就采用链表法来解决冲突,而 ThreadLocalMap 则是通过线性探测法来解决冲突呢?<br>换句话说,在什么场景下使用开放寻址法比较好,在什么场景下使用链表法比较好?这两者之间又有什么优劣呢?</font></p><ul><li><font face="华文中宋" size="3">开放寻址法<br><font face="华文中宋" size="3">咱们先来看开放寻址法:在开放寻址法中,散列表中的数据都存储在数组中,这样就可以有效利用 CPU 缓存来加快查询速度.此外使用这种方法实现的散列表,序列化起来就比较简单.但是链表法中包含指针,序列化起来就没有那么容易.<br>那么,开放寻址法有什么不足呢?我觉得最重要的一点就是,冲突的代价比较高.当出现冲突时,它不像链表那样,直接修改 next 指针就可以了,而是在空闲的位置中寻找,这样就会导致最后找不到空闲位置.<br>所以,如果我们的数据量比较小,填入表中的元素较少时,使用开放寻址法比较合适.这也是为什么 Java 中 ThreadLocalMap 使用开放寻址法解决散列冲突的原因.</font></font></li><li><font face="华文中宋" size="3">链表法<br><font face="华文中宋" size="3">链表法优点在于对内存的利用率比较高.因为链表节点可以在需要的时候创建,而不是在一开始就申请好.<br>其次,在开放寻址法中,如果有大量的散列冲突,就会导致大量的探测再散列,这样会使得性能下降,但是对于链表法来说,不会出现上述情况,只是会使链表长度变长.但即便如此,查找起来也还是快于开放寻址法的.<br>但是链表法因为要存放指针,所以是很消耗内存的.<br>基于以上,如果数据量较大,那么链表指针的内存消耗在很大数据量面前就可以忽略掉.</font></font></li></ul><p><font face="华文中宋" size="3">以上,就是想要分享的内容了,感谢您的阅读哇~</font></p><ul><li><font face="华文中宋" size="3">参考: 极客时间 — &lt;数据结构与算法之美&gt;</font></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]12 你可能知道二分查找,但你肯定不知道还有这样的二分查找!</title>
      <link href="/posts/d4eedbd.html"/>
      <url>/posts/d4eedbd.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">对于二分查找,应该不是很陌生.<br>比如,我写了一个数字 23 ,让你在 0-99 里面猜,猜大了或者猜小了我会告诉你,直到猜对为止.<br>为了尽快猜对,你是不是会这样猜?<br><a id="more"></a></font></p><table><thead><tr><th style="text-align:center">次数</th><th style="text-align:center">猜测范围</th><th style="text-align:center">中间数</th><th style="text-align:center">对比大小</th></tr></thead><tbody><tr><td style="text-align:center">第 1 次</td><td style="text-align:center">0 - 99</td><td style="text-align:center">49</td><td style="text-align:center">49 &gt; 23</td></tr><tr><td style="text-align:center">第 2 次</td><td style="text-align:center">0 - 48</td><td style="text-align:center">24</td><td style="text-align:center">24 &gt; 23</td></tr><tr><td style="text-align:center">第 3 次</td><td style="text-align:center">0 - 23</td><td style="text-align:center">11</td><td style="text-align:center">11 &lt; 23</td></tr><tr><td style="text-align:center">第 4 次</td><td style="text-align:center">12 - 23</td><td style="text-align:center">17</td><td style="text-align:center">17 &lt; 23</td></tr><tr><td style="text-align:center">第 5 次</td><td style="text-align:center">18 - 23</td><td style="text-align:center">20</td><td style="text-align:center">20 &lt; 23</td></tr><tr><td style="text-align:center">第 6 次</td><td style="text-align:center">21 - 23</td><td style="text-align:center">22</td><td style="text-align:center">22 &lt; 23</td></tr><tr><td style="text-align:center">第 7 次</td><td style="text-align:center">23</td><td style="text-align:center"></td><td style="text-align:center">√</td></tr></tbody></table><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><font face="华文中宋" size="3">代码实现</font></h1><p><font face="华文中宋" size="3">看起来这个过程蛮简单的,代码实现也挺简单的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:01:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binary</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020-3-20 20:03:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (( high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( arr[mid] == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &lt; value)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">27</span>,<span class="number">30</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">66</span>,<span class="number">95</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BinarySearch </span></span><br><span class="line">        <span class="keyword">int</span> binarySearch = binarySearch(arr,arr.length,<span class="number">95</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(binarySearch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在写二分查找时,注意三点写出的代码就差不了多少:</font></p><ul><li><font face="华文中宋" size="3">循环退出条件<br>注意是 low &lt;= high ; 而不是 low &lt; high .</font></li><li><font face="华文中宋" size="3"> mid 的取值<br>这里 mid = low + (( high - low)&gt;&gt;1) 这种方式是将除以 2 的操作转化成了位运算,这样对于计算机来说处理速度会更快一些</font></li><li><font face="华文中宋" size="3"> low 和 high 的更新<br>low = mid + 1;  high = mid - 1; 不要写成 low = mid 或者 high = mid ,因为假设 high = 5 , low = 5 时, arr[5] 可能不等于 value ,这样就会导致程序陷入死循环.</font></li></ul><h1 id="二分查找适用场景"><a href="#二分查找适用场景" class="headerlink" title="二分查找适用场景"></a><font face="华文中宋" size="3">二分查找适用场景</font></h1><p><font face="华文中宋" size="3">二分查找的时间复杂度是 O(log n),查找数据的效率很高,但是不是什么情况下都可以使用二分查找.<br>首先,二分查找依赖的是顺序表结构,也就是数组.<br>它可以依赖其他数据结构嘛?比如链表?答案是不能,因为二分查找算法需要按照下标随机访问元素,而链表不能做到.</font></p><p><font face="华文中宋" size="3">其次,二分查找针对的是已经排好序的数据.<br>如果想要使用二分查找,那么数据必须是有序的.<br>数据无序怎么办?那就先排好序咯~<br>否则的话,有可能导致查找不到你想要的数据(不信可以试试,事实会告诉你真相的~<br>那么,既然要求数据有序,所以如果应用场景是频繁对数据进行插入,删除的话,想都不用想,不适合使用二分查找</font></p><p><font face="华文中宋" size="3">最后,数据量如果太小的话,不适合二分查找.<br>如果要处理的数据量非常小,直接顺序遍历就可以了,完全没有必要使用二分查找.<br>什么都会有个度,所以数据量如果太大的话,也不适合二分查找.</font></p><h1 id="二分查找的一些变形"><a href="#二分查找的一些变形" class="headerlink" title="二分查找的一些变形"></a><font face="华文中宋" size="3">二分查找的一些变形</font></h1><p><font face="华文中宋" size="3"> OK ,在掌握基础的二分查找之后,咱们来对它进行一下变形<br>因为比较简单而且容易理解,我就直接上代码了~</font></p><h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a><font face="华文中宋" size="3">查找第一个值等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:32:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchEqualFirst</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid]&gt;value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果 mid 等于 0 ,说明这个元素是数组的第一个元素</span></span><br><span class="line">            <span class="comment">// 或者 arr[mid-1] 不等于要查找的值,说明此时查找到的元素即为第一个找到等于给定值的元素</span></span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>)|| (arr[mid - <span class="number">1</span>] != value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a><font face="华文中宋" size="3">查找最后一个值等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:39:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchEqualFinal</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n-<span class="number">1</span>) || (arr[mid+<span class="number">1</span>] != value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a><font face="华文中宋" size="3">查找第一个大于等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:47:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (arr[mid - <span class="number">1</span>] &lt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a><font face="华文中宋" size="3">查找最后一个小于等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:54:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchFinal</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; value)&#123;</span><br><span class="line">            high = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n-<span class="number">1</span>) || (arr[mid + <span class="number">1</span>] &gt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font face="华文中宋" size="3">参考<br>极客时间&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]11 单链表反转进阶之递归操作( Java 版)</title>
      <link href="/posts/9cc5c0a0.html"/>
      <url>/posts/9cc5c0a0.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在这一篇文章中,关于单链表反转,在 <a href="https://www.dynamic-zheng.com/posts/745fa732.html">[数据结构与算法]04 Link List (链表)及单链表反转实现</a> 中已经写过了,不是使用递归方法来实现的.因为递归不太容易讲清楚.<br><a id="more"></a><br>但是不能因为害怕讲不清楚就不写了,对不对.<br>所以这篇文章来使用递归来实现一下,并且尝试将里面的细节一一剖出来,不废话.</font></p><p><font face="华文中宋" size="3">首先,咱们要先明确,什么是递归.递归就是自己调用自己对吧.比如:有一个函数为 <code>f(n) = f(n-1) * n</code> ,(注意,我这里是举例子,这个函数没有给出递归的结束条件)给 n 赋值为 5 , 则:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--&gt; f(<span class="number">5</span>)</span><br><span class="line">--&gt; <span class="number">5</span> * f(<span class="number">4</span>)</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * f(<span class="number">3</span>))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * (<span class="number">3</span> * f(<span class="number">2</span>)))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * ( <span class="number">3</span> * ( <span class="number">2</span> * f (<span class="number">1</span>))))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * ( <span class="number">3</span> * ( <span class="number">2</span> * <span class="number">1</span>)))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * ( <span class="number">3</span> * <span class="number">2</span>))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * <span class="number">6</span> )</span><br><span class="line">--&gt; <span class="number">5</span> * <span class="number">24</span></span><br><span class="line">--&gt; <span class="number">120</span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在看完例子之后,咱们接下来不 BB ,直接 show code:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表反转---递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-14 08:47:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseSingleList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">( <span class="keyword">int</span> data , Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  data;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化单链表</span></span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>,node5);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用反转方法</span></span><br><span class="line">        Node recursiveList = recursiveList(node1);</span><br><span class="line">        System.out.println(recursiveList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *递归实现单链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 为传入的单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020-3-14 08:55:45</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">recursiveList</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果链表为空 或者 链表中只有一个节点,直接返回</span></span><br><span class="line">        <span class="comment">// 也是递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.next == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Node recursive = recursiveList(list.next);</span><br><span class="line">        <span class="comment">// 将 list.next.next 指针指向当前链表 list</span></span><br><span class="line">        list.next.next = list ;</span><br><span class="line">        <span class="comment">// 将 list.next 指针指向 null</span></span><br><span class="line">        list.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 返回反转之后的链表 recursive</span></span><br><span class="line">        <span class="keyword">return</span> recursive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">经过上面的代码,应该能够看到核心代码就是,递归实现单链表反转部分的那 5 行代码,别小看了这 5 行代码,想要真正弄清楚还真的挺不容易的.<br>我把这 5 行代码贴在这里,咱们一行行分析,争取看完这篇博客就能懂~(注释我就去掉了,咱们专心看这几行核心代码)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span> || list.next == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">Node recursive = recursiveList(list.next);</span><br><span class="line">list.next.next = list ;</span><br><span class="line">list.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> recursive;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">第一行就是一个判断,条件不满足,那就往下走,第二行是自己调用自己,程序又回到第一行,不满足条件程序向下执行,自己调用自己<br>就这样循环到符合条件为止,那么什么时候符合条件呢?也就是 <code>list == null</code> 或者 <code>list.next == null</code> 时,看一下自己定义的链表是 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,所以符合条件时,此时的链表为 <code>5-&gt;null</code> ,符合条件之后,程序继续向下执行,在执行完 <code>Node recursive = recursiveList(list.next);</code> 这行代码之后,咱们来看一下此时的程序执行结果:<br><img src="/images/2020/oneRecursive.jpg"></font></p><p><font face="华文中宋" size="3">我把上面这个给画出来(画工不好,不要在乎它的美丑~)<br><img src="/images/2020/one.jpg"></font></p><p><font face="华文中宋" size="3">接下来程序该执行 <code>list.next.next = list</code> 执行结束之后,链表大概就是这个样子:<br><img src="/images/2020/two.jpg"></font></p><p><font face="华文中宋" size="3">那是图,下面是程序断点调试程序的结果,发现和上面的图是一样的:<br><img src="/images/2020/twoRecursive.jpg"></font></p><p><font face="华文中宋" size="3">程序继续向下走 <code>list.next = null</code> ,也就是说,将 list 的 next 指针指向 null :<br><img src="/images/2020/three.jpg"></font></p><p><font face="华文中宋" size="3">从图中看到, list 为 <code>4-&gt;null</code> , recursive 为 <code>5-&gt;4-&gt;null</code> ,咱们来看看程序的结果,是不是和图相符:<br><img src="/images/2020/threeRecursive.jpg"></font></p><p><font face="华文中宋" size="3">完全一样有没有!<br>OK ,还记得咱们刚开始的递归函数例子嘛?现在执行完毕,开始执行下一次,咱们继续来看,此时的链表是这个样子的:<br><img src="/images/2020/four.jpg"></font></p><p><font face="华文中宋" size="3">接下来程序执行的代码就是四行了:</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node recursive = recursiveList(list.next);</span><br><span class="line">list.next.next = list ;</span><br><span class="line">list.next = null;</span><br><span class="line">return recursive;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">继续执行程序,咱们来看结果,将 <code>list.next.next = list</code> 运行结束时,此时链表为:<br><img src="/images/2020/five.jpg"></font></p><p><font face="华文中宋" size="3">从图中能够看到,链表 list 为 <code>3-&gt;4-&gt;3-&gt;4</code> 循环中, recursive 为 <code>5-&gt;4-&gt;3-&gt;4-&gt;3</code> 循环,咱们看一下程序是不是也是如此(在这里我截了两个循环作为示例):<br><img src="/images/2020/fiveRecursive.jpg"></font></p><p><font face="华文中宋" size="3">接下来程序执行 <code>list.next = null</code> ,执行完毕之后,就是将 list 的 next 指针指向 null :<br><img src="/images/2020/six.jpg"></font></p><p><font face="华文中宋" size="3">从图中能够看出来, list 为 <code>3-&gt;null</code> , recursive 为 <code>5-&gt;4-&gt;3-&gt;null</code> ,上图看看实际结果和分析的是否一致:<br><img src="/images/2020/sixRecursive.jpg"></font></p><p><font face="华文中宋" size="3">说明什么?!<br>说明咱们上面的分析是正确的~<br>接下来的程序分析,读者就自行研究吧`<br>相信接下来的分析就难不倒你了~</font></p><h1 id="反转单链表的前-N-个节点"><a href="#反转单链表的前-N-个节点" class="headerlink" title="反转单链表的前 N 个节点"></a><font face="华文中宋" size="3">反转单链表的前 N 个节点</font></h1><p><font face="华文中宋" size="3">OK ,咱们趁热打铁一下,刚刚是通过递归实现了整个单链表反转,那如果我只是想反转前 N 个节点呢?<br>比如单链表为 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,现在我只想反转前三个节点,变为 <code>3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;null</code><br>有没有想法?<br>咱们进行整个单链表反转时,可以理解为传递了一个参数 n ,这个 n 就是单链表的长度,然后递归程序不断调用自己,然后实现了整个单链表反转.<br>那么,如果我想要反转前 N 个节点,是不是传递一个参数 n 来解决就好了?<br>咱们就直接上代码了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *反转单链表前 n 个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 为传入的单链表 , n 为要反转的前 n 个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-14 09:13:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListN</span><span class="params">(Node list,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 要进行反转链表时,先将 list 后的节点数据保存到 next 中</span></span><br><span class="line">        next = list.next;</span><br><span class="line">        <span class="keyword">return</span>  list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node reverse = reverseListN(list.next , n-<span class="number">1</span>);</span><br><span class="line">    list.next.next = list;</span><br><span class="line">    <span class="comment">// 将 list.next 的指针指向没有进行反转的链表</span></span><br><span class="line">    list.next = next ;</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h1 id="反转单链表的一部分"><a href="#反转单链表的一部分" class="headerlink" title="反转单链表的一部分"></a><font face="华文中宋" size="3">反转单链表的一部分</font></h1><p><font face="华文中宋" size="3">既然反转整个单链表实现了,反转前 N 个节点实现了,那么如果有个需求是反转其中的一部分数据呢?大概就是这样,原来的链表为 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,反转其中的一部分,使反转后的链表为 <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null</code><br>借用反转前 N 个节点的思路,是不是我传两个参数进来,一个是开始反转的节点,一个是结束反转的节点,然后递归操作就可以了?<br>瞅瞅代码是怎么写的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *反转部分单链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 为传入的单链表, m 为开始反转的节点, n 为结束的反转节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-14 09:32:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseBetween</span><span class="params">(Node list , <span class="keyword">int</span> m , <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseListN(list,n);</span><br><span class="line">    &#125;</span><br><span class="line">    list.next = reverseBetween(list.next,m-<span class="number">1</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">大早上就开始写代码验证 + 写这篇文章,终于给弄清楚了<br>最后两个例子,读者们可以自行研究,我这里因为篇幅的问题就不进行解析了,如果第一个例子自己能够剖析清楚,下面两个也没啥大问题~</font></p><p><font face="华文中宋" size="3">以上,就是这篇文章想要分享的内容啦<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[工具集]介绍一波我常用的小工具</title>
      <link href="/posts/22ced40a.html"/>
      <url>/posts/22ced40a.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">和很多人交流之后,我发现很多我以为大家都知道的小工具,到最后只是我以为.<br>既然这样,这篇文章就分享一波~<br><a id="more"></a><br>如果你那里也有好的小工具,欢迎评论区交流<br>毕竟,你有一个苹果,我有一个梨,咱俩一交流,就有了两种水果可以吃,哈哈哈</font></p><h1 id="技术"><a href="#技术" class="headerlink" title="技术."></a><font face="华文中宋" size="3">技术.</font></h1><p><font face="华文中宋" size="3">技术上,我喜欢有事没事逛逛 github ,这应该是程序员/程序媛们的标配吧?<br>上面开源的项目,很多质量都非常高,能够从里面学习到很多东西.给个传送门:  <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>还有个网站: <a href="https://stackoverflow.com" target="_blank" rel="noopener">stackoverflow</a></font></p><p><font face="华文中宋" size="3">站在巨人的肩膀上,能够走得更快.<br>在编程这个道路上,我特别佩服耗子叔,所以常常有事没事就刷他的网站.<br>每次觉得迷茫了,不知道要做什么了,就去刷一刷大佬的网站,然后收获就很多: <a href="https://coolshell.cn/" target="_blank" rel="noopener">酷 壳 – CoolShell</a></font></p><p><font face="华文中宋" size="3">在学习上,肯定也少不了理论的补充,我喜欢去极客时间: <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></font></p><p><font face="华文中宋" size="3">在写博客的时候,很多情况下都需要画图,而且是很好看的那种,这个时候推荐 ProcessOn : <a href="https://www.processon.com/;jsessionid=198BBBBCD99C1191E9265342EA9F1D95.jvm1" target="_blank" rel="noopener">ProcessOn</a> ,支持将文件导出,也是很方便</font></p><h1 id="提升认知"><a href="#提升认知" class="headerlink" title="提升认知"></a><font face="华文中宋" size="3">提升认知</font></h1><p><font face="华文中宋" size="3">想要提升认知,读书是必不可少的,给一份书单: <a href="https://www.douban.com/note/686630327/" target="_blank" rel="noopener">北京地铁书单：理想的地铁是图书馆的模样（396种+持续更新）</a><br>现在微信读书上面的书籍是挺多的了,特别是出了网页版,很方便,抱个电脑,一天的阅读就都有了: <a href="https://weread.qq.com/" target="_blank" rel="noopener">微信读书</a><br>如果微信读书上没有,也可以来这里搜书看看有没有: <a href="https://obook.cc/" target="_blank" rel="noopener">偶书</a><br>可以这么说,微信读书 + NeatReader 覆盖了我 90% 的阅读需求. NeatReader 是一个 epub 阅读器,花钱买个终身会员,在任何平台都可以看自己存储的书籍,爽的一批,你可以尝试一下</font></p><p><font face="华文中宋" size="3">读完书之后,不能只是读完书对吧?最好还能写写读后感,我比较喜欢用 Notion 来做记录,但是 Notion 对新手很不友好,很多功能都需要你自己去尝试,而且吧,还需要 google 账号,如果你没有 google 账号的话,也不知道怎么注册,那我还是建议你忽略这个推荐好了,因为没有 google 账号也不知道怎么注册,我觉得大概率都是懒得摸索,那这个网站大概率你也不会怎么探索.<br>既然推荐了,还是给个传送门: <a href="https://www.notion.so/?r=a4ce1b04924f4686824c5492db62a3b2" target="_blank" rel="noopener">Notion</a><br>给大家看一下 Notion 界面,我喜欢黑色,酷酷的~<br><img src="/images/2020/notion.jpg"></font></p><p><font face="华文中宋" size="3">最后推荐一位跨境电商的大佬博客: <a href="http://www.guxiaobei.com/history-articles.html" target="_blank" rel="noopener">顾小北的 B2C 博客</a><br>看这个博客,能让你增长很多见识.真的,程序员/程序媛别限制自己.<br>至于这位大佬多厉害呢:大学毕业就已经挣够了百万,现在已经挣够 1 个亿了,重点是,他还年轻啊!!!羡慕的一批<br>所以没事多看看大佬的文章,多瞅瞅人家的思维模式,收获颇丰.</font></p><h1 id="chrome-常用插件"><a href="#chrome-常用插件" class="headerlink" title=" chrome 常用插件"></a><font face="华文中宋" size="3"> chrome 常用插件</font></h1><p><font face="华文中宋" size="3">chrome 插件有很多,但是我这里只推荐 6 个.<br><img src="/images/2020/chrome插件.jpg"></font></p><p><font face="华文中宋" size="3">第一个插件就不用多说了,安装上之后,界面清爽了很多.<br>第二个插件是清空访问网站记录的,我这个人有强迫症,每次浏览器关闭之前,都会将访问的历史记录清空一下,有了这个插件,一键搞定.<br>第三个插件是一个非常漂亮的标签页<br>第四个 + 第六个插件,是在 github 上用的.<br>第五个插件是为了保存网页,不知道你有没有这样一个痛点:我在手机上发现了一个好网站,也想在电脑上访问;同样我在电脑上发现了一个好的网站,也想在手机上访问,这个插件就可以完美解决以上困境.发现一个好的网站,直接鼠标右键将网站保存到这里,然后手机上也装上这个软件就可以在手机上也访问了.</font></p><h1 id="windows-系统下常用插件"><a href="#windows-系统下常用插件" class="headerlink" title="windows 系统下常用插件"></a><font face="华文中宋" size="3">windows 系统下常用插件</font></h1><p><font face="华文中宋" size="3">每次我的电脑重装系统之后,第一件事情就是把下面这 4 个软件装上,要不然会觉得不舒服.<br><img src="/images/2020/windows小工具.jpg"></font></p><p><font face="华文中宋" size="3">第一个软件是 WGestures ,这个软件是鼠标手势.复制粘贴你还在用 Ctrl + c/v 嘛? out 啦~用这个插件,只需要鼠标右键操作即可.<br>还有一点是我常用的:比如和别人聊天,突然发过来一个名字我不知道,想搜索怎么办?你是不是需要打开浏览器,然后输入关键字回车?使用这个软件的话,直接鼠标右键就可以搞定!<br>还有很多很强大的功能,在这里就不多做介绍了,读者可以自行尝试~<br>来个传送门: <a href="http://www.yingdev.com/projects/wgestures" target="_blank" rel="noopener">WGestures 全局鼠标手势</a></font></p><p><font face="华文中宋" size="3">第二个软件是 Listary .<br>这个软件以前写过一篇文章,我就不详细介绍了: <a href="https://blog.csdn.net/zll_0405/article/details/77815032" target="_blank" rel="noopener">Listary 的使用</a></font></p><p><font face="华文中宋" size="3">第三个软件是 Snipaste .这个是一个截图软件.<br>看到这里你可能会说,截图我用微信或者 QQ 截图就可以呀.但是这个截图软件有一个很特殊的功能: 贴图.<br>在码代码的时候,你有没有一种冲动,想把这几行代码固定在屏幕上不动,和正常的代码对比着看,瞅瞅到底哪里有错误.那么,这个软件可能是你需要的.<br>最重要的是,很方便,直接 F1 就将程序调用出来.<br>同样,来个传送门: <a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a></font></p><p><font face="华文中宋" size="3">第四个软件,你熟悉的话就知道怎么用,不熟悉的话,我也就不介绍了.</font></p><p><font face="华文中宋" size="3">以上,就是我比较常用的各种网站 + 软件 + 小工具,是我压箱底的分享了.<br>不知道你有没有想和我分享的?<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 工具集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]10 直接插入排序( Java 版)</title>
      <link href="/posts/df2b73be.html"/>
      <url>/posts/df2b73be.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">直接插入排序,当你看到这几个字的时候,首先第一想法是什么?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我第一想法是在我斗地主的时候,比如我的牌是 5,J,K 下一张牌是 8 ,那我就直接把它放在 5 和 J 之间,此时手里面的牌就是 5,8,J,K 再来一张牌是 4 ,那就放在最前面,此时是 4,5,8,J,K 又来一张牌是 10 ,那就直接把它放在 8 和 J 之间,就是 5,8,10,J,K .(原谅我有点儿强迫症,一定要把牌从大到小码好才觉得顺眼)<br>发现规律了嘛?在我手里面的牌是有序的,没有在我手里面的牌则是无序的,然后我一张一张的从无序的牌里面抽出来,然后和我手里面的牌进行比较,看看抽到的这张牌将它放在哪个位置比较好.<br>如果找到了合适的位置,就直接插入进去就可以了.<br>上面的这个过程,就是直接插入排序的体现.</font></p><p><font face="华文中宋" size="3">上面的描述比较口语化,咱们用术语来说一下原理(显得我比较有文化,哈哈哈):</font></p><ul><li><font face="华文中宋" size="3">将 n 个待排序的元素看成是一个有序表和无序表</font></li><li><font face="华文中宋" size="3">每次从无序表中取出第一个元素,把它插入到有序表的合适位置,使得有序表从整体来看依然有序.</font></li><li><font face="华文中宋" size="3">第一趟比较前两个数,然后把第二个数按照大小插入到有序表中;第二趟将第三个数据与前面两个数据进行比较,将第三个数据插入到有序表合适的位置中</font></li><li><font face="华文中宋" size="3">按照这样的步骤依次进行下去,进行了 n-1 趟扫描以后,就整个待排序列排好了.</font></li></ul><p><font face="华文中宋" size="3">从上面的步骤中,应该能够体会到,直接插入排序有两层嵌套循环.<br>第一层是外循环,标识待比较的数值,也就是从无序表中取出来的那个值.<br>第二层是内循环,是为了确定从无序表中取出的值的最终位置.<br>但是外循环是从第二个数开始比较的,因为直接插入排序是将待比较的数值与它的前一个数值进行比较,如果没有前一个数值,也就没有直接插入排序这一说.</font></p><p><font face="华文中宋" size="3">OK ,理论知识补充完毕了,咱们来看看代码上是如何实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序代码实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-25 11:39:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StraightInsert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">straightInsert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        <span class="keyword">int</span> i , j , insertNote;</span><br><span class="line">        <span class="comment">// 从数组的第二个元素开始循环,将数组中的元素插入</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 第一次循环,假设第 2 个元素为要插入的元素</span></span><br><span class="line">            insertNote = arr[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; insertNote &lt; arr[j])&#123;</span><br><span class="line">                <span class="comment">// 如果要插入的元素小于第 j 个元素,就将第 j 个元素向后移动</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 要插入的元素大于第 j 个元素时,将要插入的数据插入到数组中</span></span><br><span class="line">            arr[j+<span class="number">1</span>] = insertNote;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">95</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">456</span>,<span class="number">741</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">        straightInsert(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容啦~<br>感谢您的阅读哇<br>有什么更好的实现方法更欢迎评论区交流~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]09 冒泡排序( Java 版)</title>
      <link href="/posts/9e1c66c3.html"/>
      <url>/posts/9e1c66c3.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">当你想到冒泡的时候,第一反应是什么?<br>我这个人比较喜欢可口可乐,所以当看到冒泡,我的第一反应就是喝可乐的时候,有一个个的小泡泡冒出来,如果你仔细观察过的话,会看到这个小泡泡刚开始很小,但是等冒上来的时候,就比较大了.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">上面大概就是一个描述,咱们根据上面的描述,详细说说原理:</font></p><ul><li><font face="华文中宋" size="3">1 ,比较相邻的元素.如果第一个比第二个大,就交换他们两个</font></li><li><font face="华文中宋" size="3">2 ,对接下来的每一对相邻元素都做同样的比较,从开始第一对到结尾的最后一对.<br>还记得第 1 条嘛?如果第一个比第二个大,那么就交换他们两个,对不对?所以,这样一轮结束之后,最后一个值是这些数中最大的值.</font></li><li><font face="华文中宋" size="3">3 ,针对所有的元素重复 1,2 的步骤,除了最后一个元素.<br>因为最后一个元素咱们已经确定了是最大的了,所以接下来的排序就不再担心了.</font></li><li><font face="华文中宋" size="3">4 ,持续 1,2,3 直到所有排序完毕.</font></li></ul><p><font face="华文中宋" size="3">看完原理之后,我们就能知道,冒泡排序就是将大的元素向后调,比较发生在两个元素之间,交换也是发生在这两个元素之间,也就是说,假设第一个数小于第二个数,那么接下来第一个数总是在第二个数前面,相对位置总是不变的.<br>所以,我们说冒泡排序是一种稳定的算法.<br>当然了,冒泡排序也可以将小的元素向后调,这些都取决于你怎么制定规则,你最大,你说了算~</font></p><p><font face="华文中宋" size="3">上面介绍完毕了,咱们就直接上代码来看看.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-19 08:49:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         <span class="comment">// 定义变量</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                <span class="comment">// 如果前面的数字,大于后面的数字,则进行交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j-<span class="number">1</span>]&gt;arr[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp;</span><br><span class="line">                    temp = arr[j-<span class="number">1</span>];</span><br><span class="line">                    arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">95</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">456</span>,<span class="number">741</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr,arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">上面的就能实现冒泡排序,但是今天在写这篇博客,看书的时候,发现了一个很巧的方法,我也贴出来:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anomalous.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-2-29 09:36:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 临时变量</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 标识变量,表示是否进行过交换</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果前面的数比后面的数大,则交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 改变标识变量为 true</span></span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在一趟排序中,一次交换都没有发生过</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重置 flag ,进行下次判断</span></span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">95</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">456</span>,<span class="number">741</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr,arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">如果仔细看的话,你会发现引入了一个标识变量.<br>这个标识变量有什么作用呢?如果你感兴趣可以运行一下程序,观察一下比较次数,会发现第二种方法程序的运行次数是比第一次的运行次数少的.<br>为什么呢?你想想,其实最后一趟排序的时候,整体已经排好了,但是第一种方法会再次进行排序,第二种因为有标识变量的存在,如果一次交换都没有发生过,说明此时整个数组已经有序,所以不会再进行排序一次.<br>只是因为多了一个标识变量,就节省了时间,这种思路,很巧妙~</font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容了.<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[操作系统]关于 Windows 文件访问方式,你可能真的不是很了解</title>
      <link href="/posts/34678e11.html"/>
      <url>/posts/34678e11.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在 Windows 操作系统下,想要访问文件时,一般有以下三种方式:</font></p><ul><li><font face="华文中宋" size="3">不使用文件缓存</font></li><li><font face="华文中宋" size="3">使用文件缓存</font></li><li><font face="华文中宋" size="3">异步模式<a id="more"></a><font face="华文中宋" size="3">动动小脑就应该知道,最常用的是「使用文件缓存」这种方式(好吧,小脑是为了保证身体平衡,不是为了思考;<br>接下来就说说,在 Windows 操作系统下,当我们以「使用文件缓存」这种方式来访问文件时,操作系统所做的事情.</font></font></li></ul><p><font face="华文中宋" size="3">使用文件缓存访问:</font></p><ul><li><font face="华文中宋" size="3">由 Windows 的 Cache Manager 实现对缓存的控制,读取数据时,进行预取<ul><li><font face="华文中宋" size="3">如果 Cache 满了怎么办?<br><font face="华文中宋" size="3">Cache Manager 会根据 LRU ( Least Recently Used ,最近最少使用)原则,来清除一些缓存内容<br>同时还需要定期更新磁盘内容,让磁盘内容和 Cache 中保持一致(通常是 1 秒更新一次)</font></font></li></ul></font></li><li><font face="华文中宋" size="3">Write-back 机制:<ul><li><font face="华文中宋" size="3">在对文件进行访问时,会涉及到对文件的一些修改,这就涉及到了对磁盘写数据<br>此时,我们不直接对磁盘进行更改,而是只更改 Cache 中的内容,然后由 Cache Manager 决定什么时候将用户所做的更新反映到磁盘上<ul><li><font face="华文中宋" size="3">为什么不直接对磁盘进行更改?<br>对任何操作系统来说, I/O 的读写速度永远都是硬伤,如果频繁对磁盘进行 I/O 操作,会使得系统性能降低</font></li></ul></font></li></ul></font></li></ul><p><font face="华文中宋" size="3">画一个图,能够更直观的看到(请忽略我的画图水平):<br><img src="/images/2020/file.jpg"></font></p><p><font face="华文中宋" size="3">如上图,阴影部分表示需要访问的数据.<br>数据在磁盘,系统缓存和进程地址空间有 3 份拷贝,通常情况下用户对数据的修改并不直接反映到磁盘上,而是通过 write-back 机制定期更新到磁盘上.</font></p><p><font face="华文中宋" size="3">为了尽可能提高读取速度,我们应该将要存储的数据,尽量放在同一个柱面上.</font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[操作系统]当双击某程序到它显示运行界面时,操作系统做了什么</title>
      <link href="/posts/e6161cda.html"/>
      <url>/posts/e6161cda.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">继<a href="https://www.dynamic-zheng.com/posts/ebb383b9.html#more">[计算机网络]从页面输入网址,回车到显示内容,这中间到底经历了什么</a>这篇文章之后,我突然发现我对计算机网络的一些知识串了起来,它们对我来说不再是一个个的单独个体.<br>基于这个经验,我再来梳理一下当双击某程序到它显示运行界面时,操作系统做了什么,尝试将操作系统的一些东西,也串起来.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">假设:我们现在想要让操作系统运行「微信」,那么首先我们会怎么做?</font></p><ul><li><p><font face="华文中宋" size="3"> 1 ,双击微信图标.<br>但是打开一个程序的方式不止一种,不要限制了自己,比如也可以通过命令行键入命令的方式将它打开(不过一般不会这么做吧;<br>当我们双击了微信图标时,就告诉了操作系统,我希望你能帮我运行「微信」</font></p></li><li><p><font face="华文中宋" size="3"> 2 ,此时操作系统接收到请求之后,就去磁盘上找到「微信」程序的相关信息,检测它的类型是不是可执行文件,同时通过程序首部信息确定代码和数据在可执行文件中的位置并且计算出对应的磁盘块地址.</font></p><ul><li><font face="华文中宋" size="3">看完上面的解释,你有疑问嘛?操作系统怎么检测它是不是可执行文件呢?对于 Windows 系统来说,可执行文件是 <a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E5%8F%AF%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">PE(Portable Executable)</a>,对于 Linux 系统来说,可执行文件是 <a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%9F%B7%E8%A1%8C%E8%88%87%E5%8F%AF%E9%8F%88%E6%8E%A5%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">ELF(Executable and Linkable Format)</a>,对于 Mac 系统来说,可执行文件是<a href="https://zh.wikipedia.org/wiki/Mach-O" target="_blank" rel="noopener">Mach-O(Mach Object)</a></font></li></ul></li><li><p><font face="华文中宋" size="3"> 3 ,操作系统做完第 2 步之后,就会创建一个进程,并且将「微信」的可执行文件映射到该进程结构,意思就是,这个进程负责执行「微信」程序.</font></p></li><li><font face="华文中宋" size="3"> 4 ,接下来操作系统会为「微信」程序设置 CPU 上下文环境,此时我们假设这个调度程序选中了「微信」程序,那么操作系统就会跳到程序开始处</font></li><li><font face="华文中宋" size="3"> 5 ,接下来执行「微信」程序的第一条指令.<br>但是它会发生缺页异常.<ul><li><font face="华文中宋" size="3">为什么会发生缺页异常?<br>因为程序在执行时,要将代码和数据读入内存, CPU 才能执行,但此时因为内存中还没有相关数据,进而触发了硬件机制,捕获到缺页异常,将控制权交给操作系统</font></li></ul></font></li><li><font face="华文中宋" size="3"> 6 ,操作系统此时会分配一页物理内存,同时将代码从磁盘读入内存,然后继续执行「微信」程序.<br>如果程序很大,一页内存不够的话,会在执行过程中重复 5,6 步骤,直至将程序全部读入内存为止</font></li><li><font face="华文中宋" size="3"> 7 ,之后,「微信」程序执行相关函数(系统调用),在显示器上显示「微信」图标</font></li><li><font face="华文中宋" size="3"> 8 ,操作系统接收到这个请求,然后找到显示设备,通常显示设备是由一个进程控制的,所以操作系统将要显示的「微信」图标给该进程</font></li><li><font face="华文中宋" size="3"> 9 ,控制设备的进程告诉设备的窗口系统它要显示「微信」图标,窗口系统在确定这是一个合法的操作之后,会将「微信」图标转换成像素,将像素写入设备的存储映像区</font></li><li><font face="华文中宋" size="3"> 10 ,视频硬件将像素转换成显示器可以接收的一组控制数据信号</font></li><li><font face="华文中宋" size="3"> 11 ,显示器解释数据信号,激发液晶屏<br>此时,我们就能够在屏幕上看到「微信」的登录界面.</font></li></ul><p><font face="华文中宋" size="3">至此,当我们双击某个程序,到显示运行界面时,操作系统做的工作我们就比较清楚了.</font></p><p><font face="华文中宋" size="3">这篇文章的灵感来源于:</font></p><p><font face="华文中宋" size="3"><a href="https://www.bilibili.com/video/av9555596?t=4" target="_blank" rel="noopener">操作系统做了什么?</a></font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]从页面输入网址,回车到显示内容,这中间到底经历了什么</title>
      <link href="/posts/ebb383b9.html"/>
      <url>/posts/ebb383b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><font face="华文中宋" size="3">写在前面</font></h1><p><font face="华文中宋" size="3">在学习计算机网络的内容时,脑子里面突然冒出来一个问题:当我们在一个浏览器界面输入网址,回车到界面显示内容,这中间经历了什么?<br>先不要往下看,你能想到什么?<br>下面是我能想到的过程,有可能不是很准确,如有错误之处,还望指出.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">计算机网络大体上可以分为应用层,传输层,网络层,链路层和物理层.<br>当我们在页面输入网址,然后回车到显示内容时,我通过上面的层次依次来说.</font></p><h1 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a><font face="华文中宋" size="3">详细过程</font></h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><font face="华文中宋" size="3">应用层</font></h2><p><font face="华文中宋" size="3">假设我们现在要访问 google 网站,那么第一步要做的就是打开浏览器,在地址栏中输入 google 的地址,当你点击回车时,浏览器知道你要访问 google 了,但是对于浏览器来说,这只是一个名字,但是具体在哪儿它是不知道的.比如,你知道某位明星的名字,但是他/她具体的地址在哪儿你不清楚,对吧?对于浏览器来说也是这样.<br>比较好的一点是,想要访问网站,不像你想见明星那么难.此时浏览器通过 DNS 找到你要访问的具体网站地址.<br>当然了,如果你想要更准确的找到地址,也可以通过 HTTPDNS 去查找.<br>通过 DNS 或者 HTTPDNS 现在浏览器拿到了具体的 IP 地址,随后它就开始打包你的请求.对于举的例子来说,你只是想要访问一下,一般使用 HTTP 协议就可以了;如果有些请求会涉及到你的账号密码,就会使用 HTTPS 协议来保证你的数据安全.</font></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><font face="华文中宋" size="3">传输层</font></h2><p><font face="华文中宋" size="3">到这里, DNS , HTTP , HTTPS 所在的层称之为应用层.<br>现在应用层的事情做完了,接下来应用层会将以上相关数据进行封装,经过 Socket 编程,将应用层的包发送给传输层.<br>如果这个包是使用 HTTP 或者 HTTPS 协议发送过来的,那传输层就会使用 TCP 协议来将数据进行封装;如果是使用 DNS 协议发送过来的,则会使用 UDP 协议来进行封装.<br>封装完毕之后,浏览器就会将包交给操作系统的网络层.</font></p><h2 id="网络层-链路层-物理层"><a href="#网络层-链路层-物理层" class="headerlink" title="网络层 + 链路层 + 物理层"></a><font face="华文中宋" size="3">网络层 + 链路层 + 物理层</font></h2><p><font face="华文中宋" size="3">这一部分会涉及到网络层 + 链路层 + 物理层,我就不分那么详细了~<br>网络层的协议是 IP 协议,在 IP 协议中会有源 IP 地址和目标 IP 地址.<br>源 IP 地址也就是浏览器所在机器的 IP 地址,说的再白点儿就是,假设你是使用电脑浏览器发出的访问请求,这个源 IP 地址就是你的电脑 IP 地址<br>目标 IP 地址就是你想要访问的网站地址.还记得嘛,在应用层,我们根据 DNS 或 HTTPDNS 已经获取到了想要访问网站的具体 IP 地址.<br>OK ,既然此时操作系统已经知道了目标 IP 地址,接下来它就会想我怎么根据这个目标 IP 地址找到这台机器呢.首先操作系统会看这个 IP 地址是不是在局域网内,如果是的话,从目标 IP 地址就能看出来.但是很明显,想要访问的 google 地址不在本地,在那触不到的远方.</font></p><p><font face="华文中宋" size="3">操作系统知道要访问的地址在远方,但是远方在哪儿它也不知道.所以它就将这个数据包发给网关( gateway ),但是它不知道网关是哪儿台机器,这可咋整.<br>没事儿,反正大家都在一个地方,吼一嗓子不就得了~所以操作系统就大吼了一声:咱们的网关是谁来着.网关就会回答它,我就是,我在这儿呢.<br>上面的那一声吼,就是 ARP 协议,通过 ARP 协议,就知道了网关的具体地址,也就是 MAC 地址.<br>接下来这个数据包就到了网关那里.网关一般就是路由器,到某个 IP 地址怎么走,在一个叫做「路由表」中维护着.<br>出网关就比较复杂了,这里就不详细说了,具体可以看这篇文章: <a href="https://www.dynamic-zheng.com/posts/ff423025.html">[计算机网络]想出网关?你需要懂得这些</a></font></p><p><font face="华文中宋" size="3">出了网关之后,就需要拿出源 IP 地址和目标 IP 地址.因为只要出了网关,那就是在外面肉搏,如果没有源 IP 地址和目标 IP 地址,就不知道这个请求是从哪儿发出的,要往哪儿去.<br>现在这个数据包经过了重重关卡,终于找到了目标 IP 地址所在的服务器.此时服务器会首先发送一个接收请求,然后再将数据包一层层解析,在 TCP 头中含有目标端口号,通过这个端口号,就能够找到哪儿个程序的进程正在监听这个端口号,进而我们就找到了我们想要访问的网页.</font></p><p><font face="华文中宋" size="3">但是我怎么知道从我这里发出的数据包有没有丢失呢?所以此时 TCP 层会隔一段时间发送一次,这并不是说,页面又发送了一次请求,只是 TCP 自己在闷头重试,直到收到了接收请求.</font></p><p><font face="华文中宋" size="3">在我们找到了想要访问的网页之后,接下来就会像来的时候,再原路返回去.</font></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后:"></a><font face="华文中宋" size="3">最后:</font></h1><p><font face="华文中宋" size="3">没想到吧~一个简单的打开界面,竟然涉及到了这么多的知识~<br>当然你会发现在你输入网址之后敲回车,页面几乎是立刻出来了,这就涉及到了缓存,再深入讲的话,这篇文章就很长了.</font></p><p><font face="华文中宋" size="3">这里推荐几篇文章,想深入理解的建议读一下:</font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/a43453ce.html">[计算机网络] DNS 协议</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/4e5d330.html">[计算机网络] HTTPDNS 协议</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/d26db2c7.html">[计算机网络]简单聊聊套接字 Socket</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/e579f21d.html">[计算机网络] IP 地址与 MAC 地址之间的关系</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/ff423025.html">[计算机网络]想出网关?你需要懂得这些</a></font></p><ul><li><font face="华文中宋" size="3">参考:<br>极客时间-趣谈网络协议</font></li></ul><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]在嘛,吱一声.吱...</title>
      <link href="/posts/bded181d.html"/>
      <url>/posts/bded181d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">好吧,题目是来搞笑的<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">如果问我过去的一年,最大的收获是什么?仔细想了想,其中一件事应该是认识了明白老师.<br>去年下半年加入明白老师的星球之后,又得以加入他的社群,进而和他本人有了更近的交流,更重要的是,我能近距离观察他.<br>和这篇文章有什么关系?因为我看了他的这篇文章:<a href="https://mp.weixin.qq.com/s/7FkMPMO_yONc_neEUQROVw" target="_blank" rel="noopener">为什么日更比周更容易？收益更大？</a></font></p><p><font face="华文中宋" size="3">任何事情,最难的就是第一步.当你踏出了第一步,就会踏出第二步,进而第三步第四步.<br>看完明白老师的文章之后,让我很触动.<br>说实话,我的博客更新频率挺低的,一周一篇.而且很多时候,不是没有时间和精力去写,而是自己各种犯懒,不想去写.<br>看到明白老师的这篇文章之后,我突然也想将更新的频率提高一些试试,看看自己的感受如何,成长如何.<br>我应该是做不到日更的.毕竟一篇技术文章,从选材,实践到组织语言形成一篇文章,没有两三天的时间写不出来的.(起码对于我这个渣渣来说是这样;<br>日更做不到,周更的频率高一点儿,努努力还是可以做到的.(也或者,我写着写着,突然就日更了呢,哈哈哈;</font></p><p><font face="华文中宋" size="3">之所以下定要将周更的频率再提高一些,除了这篇受明白老师这篇文章启发之外,还因为早些时候一起做的事情.<br>大概是在去年 8 月份,明白老师在群里问,他想要坚持每天做 3 件事,有没有人和他一起.我自然报名,但是我不知道我每天应该做哪些事情.<br>3 件事,一天很容易做到,两天也很容易,但是做到每天,就很难.<br>既然报名了,牛逼吹出去了,硬着头皮也要做下去.<br>那个时候给自己定的 3 件事是:工作,读书,锻炼.<br>也正是每天的这 3 件事,让我工作的时候,认真对待工作;上下班的路上,好好锻炼身体;晚上到家之后,读读书.<br>让我享受到了,诗和远方.<br>更重要的是,在这个过程中,我获得的掌控感,让我变的更加自信.<br>是啊,我能够每天坚持 3 件重要的事情,还有什么是我不能做到的呢.</font></p><p><font face="华文中宋" size="3">每天 3 件事,不贪多不贪少,这样的习惯保持到现在,受益匪浅.<br>也是基于这样的获益,看到明白老师决定日更,并且阐述了为什么日更比周更更容易,收益更大,也让我决定,提高自己的周更频率.</font></p><p><font face="华文中宋" size="3">最近在准备自考,这次考试科目是计算机网络.还有一直在学数据结构和算法的一些东西,所以接下来的博客更新,应该是这两个大方面:计算机网络 + 数据结构和算法<br>可能中间还会夹杂我的碎碎念,就像这一篇.</font></p><p><font face="华文中宋" size="3">总之,今天受了不少的刺激,在接下来的日子里,要好好努力了.<br>各位,可以一起来监督我呀~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]08 队列( Queue )以及队列实现的三种方式( Java 版)</title>
      <link href="/posts/a433947a.html"/>
      <url>/posts/a433947a.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">年初生了一场大病,博客搁了几周,惭愧.今天来一篇.<br><a id="more"></a></font></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a><font face="华文中宋" size="3">队列</font></h1><p><font face="华文中宋" size="3">说队列的时候,常常会想到栈,因为栈是后进先出,而队列则是先进先出.<br>关于栈,前面已经写过了:<a href="https://www.dynamic-zheng.com/posts/3671c55b.html">[数据结构与算法]05 Stack 经典面试题之判断字符串是否合法( Java 版)</a><br>这篇文章的主要焦点就在队列上了.</font></p><p><font face="华文中宋" size="3">队列,你的第一反应是不是排队?不管是在食堂买饭,还是在银行办理业务,或者进高铁站的时候,都会排队.<br>排队有一个很明显的特点:早来的人,就会早点儿办完事情.<br>这就是队列:先进先出.</font></p><p><font face="华文中宋" size="3">队列可以用数组实现,叫做顺序队列.也可以用链表实现,叫做链式队列.<br>在这里,分别用数组和链表来实现一下.</font></p><h1 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a><font face="华文中宋" size="3">数组实现队列</font></h1><p><font face="华文中宋" size="3">使用数组来实现队列,相对来说还是比较简单的,因为数组和队列一样都是线性表结构.<br>废话不多说,咱们直接看代码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-29 15:51:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       数组：items，数组大小：n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       head表示队头下标，tail表示队尾下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       申请一个大小为capacity的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">        n = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果tail == n 表示队列已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            System.out.print(items[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayQueue queue=<span class="keyword">new</span> ArrayQueue(<span class="number">5</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"1"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"4"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"5"</span>);</span><br><span class="line">        queue.dequeue();</span><br><span class="line">        queue.enqueue(<span class="string">"6"</span>);</span><br><span class="line"></span><br><span class="line">        queue.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">使用数组实现队列有个问题,就是删除不是真的删除,只是在打印的时候将 i 的值指向了 head 而已,但是要删除的数据,仍然在数组中.</font></p><h1 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a><font face="华文中宋" size="3">链表实现队列</font></h1><p><font face="华文中宋" size="3">使用链表实现队列也较为简单:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用链表实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-30 09:20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        队列的队首和队尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node tail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String value = head.data;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(p.data + <span class="string">" "</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkListQueue queue=<span class="keyword">new</span> LinkListQueue();</span><br><span class="line">        queue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        queue.dequeue();</span><br><span class="line">        queue.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a><font face="华文中宋" size="3">栈实现队列</font></h1><p><font face="华文中宋" size="3">除了使用数组和链表实现,还有一种方法就是使用栈来实现队列.<br>使用栈来实现队列,顾名思义就是只能使用栈的操作: pop , push , peek 等,其他操作不允许出现,否则就不是使用栈来实现队列了.<br>使用数组和链表来实现栈都较为简单,因为在读取数据时,只需要按照顺序读取即可.<br>但是对于栈来说,顺序读取行不通,为什么呢?假设我的队列数据为 1,2,3,4 依次存入栈中之后再读取的话,则是 4,3,2,1 因为栈是后进先出.<br>如果使用栈来实现队列的话,需要用到两个栈.一个栈的输出顺序就是 4,3,2,1 在读取之前,我们把读取出来的数据存入到另外一个栈中,然后从后面这个栈读取,那么输出顺序就是 1,2,3,4 和原来队列的数据一致.<br>在这里要注意一点:当后面的栈中有数据,前面的栈中也有数据时,要先将后面的栈中数据读取完毕,再将前面的数据放到后面的数据中.<br>接下来看下代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-30 17:21:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Stack&lt;Integer&gt; stackTemp = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stackQueue = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stackTemp.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 整个队列不为空时</span></span><br><span class="line">        <span class="keyword">if</span> (empty()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果 stackQueue 为空时,则将 stackTemp 中的数据放入 stackQueue 中</span></span><br><span class="line">            <span class="comment">// 如果 stackQueue 不为空,直接输出即可</span></span><br><span class="line">            <span class="keyword">if</span> (stackQueue.isEmpty())&#123;</span><br><span class="line">                backFill();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackQueue.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 整个队列为空,则返回 -1 ,代表队列中没有值</span></span><br><span class="line">            System.out.println(<span class="string">"队列为空"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空,如果返回值为 0 ,则代表队列为空</span></span><br><span class="line">        <span class="comment">// 注意,两个栈均为空时,队列才为空</span></span><br><span class="line">        <span class="keyword">return</span> stackQueue.size() + stackTemp.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        将 stackTemp 中的数据放入 stackQueue 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backFill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stackTemp.isEmpty())&#123;</span><br><span class="line">            stackQueue.push(stackTemp.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StackQueue stack = <span class="keyword">new</span> StackQueue();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[年终总结]愿你在以后的黑暗时刻,都能想起我</title>
      <link href="/posts/99fcee38.html"/>
      <url>/posts/99fcee38.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">今天是新的一年开始.<br>这次的总结,不想像以前那样细数过去的一年发生了什么,经历了什么,我就随便写了,写到哪儿算哪儿(说白了就是碎碎念<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">过去的一年,我一直都觉得自己像是开挂了一样.自从打破了自己的一个认知局限之后,认识到了很多厉害的人,在和这些人的交流中,也慢慢让我变得很自信.<br>因为我看到他们,之所以能够成功,是因为有耐心,相信自己,敢冒险.反观一下我自己,我身上也有这些,那我和他们的差距就在于时间,所以我相信就目前的状态一直下去,有一天我也会变得很厉害,只不过是时间早晚的问题.<br>这样对于很多事情就不纠结了,主要是纠结也没用,还不如拿这些时间读读书,跑跑步.</font></p><p><font face="华文中宋" size="3">我现在想想,都觉得以前的自己真的是太拼了.你能想象我在大年三十那天早上,还写了一篇博客嘛;你能想象我在休息日的时候,还坚持读书和写作嘛.在过去的时间里,我得到了很多,但是也忽略了很多.有很多朋友,本来可以玩的更好的,但是因为我一心扑在工作上,所以很多次的邀约都拒绝了,说真的,以前的我和母亲视频都觉得是在浪费时间.<br>可能是因为在我小的时候,经历了那种无力感,那种痛苦,我到现在想起来都会泪流满面.<br>我特别害怕再经历这种事情,所以我就想要抓住一切时间去努力,因为我想让我成功的速度快过亲人老去的速度.<br>过去的一年改变了我的一些想法.观念转变应该是 6 月份和一位朋友的关系出现危机.我挺在乎她的,对我来说,她对我的意义就和家人一样重要,所以当我们之间的距离越来越远的时候,我很害怕,但是却发现我越是想要靠近,我们之间反而越是疏离,以至于到最后我不知道我该怎么做.<br>那段时间,碰巧亲人去世,工作上需要带领项目上线,我的心态崩溃过很多次,我开始怀疑自己这样做的对不对,不知道我努力的意义是什么.如果是让家人过上更好的生活,那我这样对他们不闻不问,几乎没有陪伴,就是对他们好嘛.<br>从那段时间之后,开始寻找工作和生活的一个平衡点.现在我学会了在休息日跑到北京只是为了找一家咖啡厅坐坐放空自己;学会了花费一天的时间去陪伴重要的人,哪怕只是逛逛街吃吃饭,或者是看看电影;学会了一整天都赖在家里,亲手做饭,或者只是在有阳光的午后躺在沙发上;也或者花一天的时间压马路,各种放空心情.<br>我发现当我这样去做之后,失去的固然有,比如技术上的成长,相对来说慢了一些,但是我却得到了很多.<br>在我难过的时候,会有朋友陪在身边;在我怀疑自己的时候,会有人鼓励我说我很棒;当我一心只是想要飞的更高的时候,总有朋友一直叮嘱我去按摩,照顾好自己的身体.</font></p><p><font face="华文中宋" size="3">慢下来之后,我发现原来生活不光光是工作,努力也不是只有一种方式.<br>就像是开窍一般,对发生的所有事情都心怀感恩,感激当下发生的一切.关于这一点,在一篇文章中其实是说过的:<a href="https://www.dynamic-zheng.com/posts/a353dbe7.html">[碎碎念]不知道该起什么题目的一篇文章</a>.<br>接受自己的平凡,承认自己是一个平凡的人,是一件很难的事情.我庆幸,现在的我就做到了,虽然做的不是很好.</font></p><p><font face="华文中宋" size="3">博客印象中是有一两周的时间没有写,以后再也不能说自己坚持每周写一篇博客了,气哭…<br>但是我可以说,一直在坚持写博客呀,哈哈哈哈哈<br>因为博客,认识了一群优秀的人.<br>反正技术这条路,真的是需要活到老,学到老的.</font></p><p><font face="华文中宋" size="3">过去的一年,我只做好了 4 件事:工作,读书,写作,锻炼.<br>说到这里,我突然想起来,前一段时间有人来问我,说我没办法坚持读书,我没办法坚持写作,我没办法坚持锻炼,问我为什么能够坚持下来.其实秘诀只有一个:我有同伴在和我一起同行.<br>有同伴一起同行,真的是一件超级幸福的事情,特别是相处让你觉得很舒服那种.和晓鸿开始真正熟悉,是当时我们一起在外出差,两个女孩子之间互相照顾,慢慢开始了解对方.后来和晓鸿说,要不要一起学习,一起在技术上做深入研究,她说可以.<br>我觉得我和晓鸿是那种,制定了计划,就一定要完成的那种人.所以在 19 年 10 月份的时候,我才敢说在 19 年结束之前,把计算机网络过一遍.和晓鸿一起学习,我们在 12 月份中旬就结束了,用了将近两个月的时间.<br>我说我想去学算法,她二话没说就和我一起学;我说我想去练字,也是二话没说就一起去练了;有一次我想要学一个资料,挺贵的,问她要不要一起学,也是二话没说就入了.有这样一个朋友一起前行,不可能坚持不下去的.</font></p><p><font face="华文中宋" size="3">过去的一年,影响了一些人.<br>我看到因为我自己坚持写博客,导致身边的人也开始写博客的时候;我看到因为我坚持读书,导致身边的人也开始养成读书习惯的时候;我看到因为我为了吃的更加健康,而不怎么吃主食,导致身边的人也开始慢慢不吃主食的时候,那种成就感很大.<br>有一种,哦,原来我也能影响别人,原来我的做法也能帮助一部分人找到他们热爱的事情,这种感觉想想都满脸骄傲.(以后走路横着走,哈哈哈;</font></p><p><font face="华文中宋" size="3">对于接下来的一年,我还是只想做好 4 件事:工作,读书,写作,锻炼.<br>这 4 件事做好了,其他就是享受当下.这样想想,对于接下来的一年,充满的是憧憬和感恩.</font></p><p><font face="华文中宋" size="3">最后感谢,感谢这一路一直帮助我的人,对我来说,他们都是贵人.<br>我也不知道此时的我能给他们带来什么,把这份感激都放在心底,希望有一天,我能让他们拿我来吹牛逼.</font></p><p><font face="华文中宋" size="3">对于我的父母,我一直都很感激,很感谢他们对于我一直都是舍得的.<br>现在能做的就是没事多和他们视视频,聊聊天.每次和母亲视频的时候,都能感受到她是很开心的.</font></p><p><font face="华文中宋" size="3">愿你在以后的黑暗时刻,都能想起我.因为在你黑暗的时刻,你能够想起我说明我对你来说是重要的,我是被需要的,我觉得很荣幸,能够被你当成这样重要的存在.(好吧,我承认我有些标题党了,挺煽情的一个题目,被我写成了碎碎念,逃;<br>如果让您有所收获,倍感荣幸.<br>就是这样了!<br>还有,新年快乐~<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]07 关于单链表环的操作( Java 版)</title>
      <link href="/posts/9b14f6f8.html"/>
      <url>/posts/9b14f6f8.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">单链表经典操作,第一个是单链表反转,在这篇文章中已经写过了:<a href="https://www.dynamic-zheng.com/posts/745fa732.html">[数据结构与算法]04 Link List (链表)及单链表反转实现</a>,第二个是判断链表中是否有环,也就是今天这篇文章想要说的.<br><a id="more"></a></font></p><h1 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a><font face="华文中宋" size="3">判断链表是否有环</font></h1><p><font face="华文中宋" size="3">如图,我们能够清楚看到,这个链表是有环的.<br><img src="/images/2019/有环链表.jpg"></font></p><p><font face="华文中宋" size="3">咱们一起来分析一下</font></p><blockquote><p><font face="华文中宋" size="3">判断链表中是否有环,可以从头结点开始,依次遍历单链表中的每一个节点.每遍历一个节点,就和前面的所有节点作比较,如果发现新节点和之前的某个节点相同,则说明此节点被遍历过两次,说明链表有环,反之就是没有.</font></p></blockquote><p><font face="华文中宋" size="3">但是仔细看一下这种方法,你会发现这种方法很耗时耗力,因为每遍历一个节点,都要把它和前面所有的节点都比较一遍.<br>还有一个很巧妙的方法,就是使用两个指针.</font></p><blockquote><p><font face="华文中宋" size="3">使用两个指针,一个快指针,一个慢指针.<br>快指针每次走 2 步,慢指针每次走 1 步.<br>如果链表中没有环,则快指针会先指向 null<br>如果链表中有环,则快慢指针一定会相遇</font></p></blockquote><p><font face="华文中宋" size="3">基于这个思路,可以使用代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否有环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-12-28 09:44:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsHasLoop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data,Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化单链表</span></span><br><span class="line">        Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,node5);</span><br><span class="line">        Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">        Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">        Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line">        <span class="comment">// 让 node5 的指针指向 node1 形成一个环</span></span><br><span class="line">        node5.next=node1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag=isHasLoop(node1);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHasLoop</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="comment">// 如果快慢指针相遇,则说明链表中有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 反之链表中没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求环长"><a href="#求环长" class="headerlink" title=" 求环长"></a><font face="华文中宋" size="3"> 求环长</font></h1><p><font face="华文中宋" size="3">现在已经将链表中是否有环判断出来了,接下来扩展一下,求环长.</font></p><p><font face="华文中宋" size="3">先理一下整体思路:<br>当快慢指针第一次相遇时,我们可以记录下此时的位置.<br>接下来让慢指针继续走,每次走 1 步,直到走到第一次相遇的地方,此时慢指针走过的长度即为环长<br>基于这样的思路,就可以将代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义环长初始值为 0</span></span><br><span class="line">        <span class="keyword">int</span> loopLength=<span class="number">0</span>;</span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次相遇时跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fast next 指针首先指向 null 指针,说明该链表没有环,则环长为 0</span></span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有环,使用临时变量保存当前的链表</span></span><br><span class="line">        Node temp = slow;</span><br><span class="line">        <span class="comment">// 让慢指针一直走,直到走到原来位置</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            loopLength++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loopLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求入环点"><a href="#求入环点" class="headerlink" title="求入环点"></a><font face="华文中宋" size="3">求入环点</font></h1><p><font face="华文中宋" size="3">求入环点有点儿绕,咱们先来上一张图:<br><img src="/images/2019/入环点.jpg"><br> <font face="华文中宋" size="3">如上图,假设:<br>入环点距离头结点距离为 D<br> 入环点与首次相遇点较短的距离为 S1<br> 入环点与首次相遇点较长的距离为 S2</font></font></p><blockquote><p><font face="华文中宋" size="3"> 当两个指针首次相遇时,慢指针一次只走 1 步,则它所走的距离为: D+S1<br>快指针每次走 2 步,多走了 n(n&gt;=1) 圈,则它所走的距离为: D+S1+n(S1+S2)<br>快指针速度为慢指针的 2 倍,则: 2(D+S1)=D+S1+n(S1+S2)<br>上面等式,整理可得: D=(n-1)(S1+S2)+S2</font></p></blockquote><p><font face="华文中宋" size="3">如果让 (n-1)(S1+S2) 为 0 ,是不是 D 和 S2 就相等了?也就是说,当两个指针第一次相遇时,只要把其中一个指针放回到头结点位置,另外一个指针保持在首次相遇点,接下来两个指针每次都向前走 1 步,接下来这两个指针相遇说,就是要求的入环点.<br>有点儿像做数学题的感觉~<br>基于这样的思路,可以将代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">entryNodeOfLoop</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次相遇时跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fast next 指针首先指向 null 指针,说明该链表没有环,则入环点为 null</span></span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次相遇之后,让一个指针指向头结点,另外一个指针在相遇位置</span></span><br><span class="line">        <span class="comment">// 两个指针每次走 1 步,相遇为止,此时相遇节点即为入环点</span></span><br><span class="line">        Node head=list; <span class="comment">// 头结点</span></span><br><span class="line">        Node entryNode=slow;    <span class="comment">// 相遇节点</span></span><br><span class="line">        <span class="keyword">while</span> (entryNode != head)&#123;</span><br><span class="line">            entryNode=entryNode.next;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entryNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <font face="华文中宋" size="3">关于链表的一些操作差不多就是这些了.<br> 其实仔细观察能够看到,不管是求环长,还是找到入环点,最关键的是找到第一次相遇时所在的位置,基于这一点,接下来的问题就比较容易解决.</font></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a><font face="华文中宋" size="3">参考:</font></h1><p><font face="华文中宋" size="3"> &lt;漫画算法&gt;-程序员小灰<br> 以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]06 数组( Array )</title>
      <link href="/posts/99ead990.html"/>
      <url>/posts/99ead990.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">什么是数组呢?你的脑海中是不是第一反应是这样的:<br><a id="more"></a></font></p><blockquote><p><font face="华文中宋" size="3"> 数组 ( Array )是一种线性表数据结构,它用一组连续的内存空间,来存储一组具有相同类型的数据.</font></p></blockquote><p><font face="华文中宋" size="3">在定义上,咱们来死扣两个概念.</font></p><ul><li><font face="华文中宋" size="3">线性表.<br><font face="华文中宋" size="3">线性线性,就是数据排成像一条线一样的结构,每个线性表上的数据最多只有前和后两个方向.这样看定义的话,除了数组,链表,队列,栈也是线性表结构.</font></font></li><li><font face="华文中宋" size="3">是一组连续的内存空间,存储一组具有相同类型的数据.<br><font face="华文中宋" size="3">这句话能够看出来,对于数组有两个限制:第一空间必须是连续的,第二,数据需要是相同类型的.<br>也就是说,如果内存空间剩余 1MB 但是不是连续的,此时创建数组就会失败;如果数组内存储的不是相同类型的数据,就会报错</font></font></li></ul><h2 id="数组是如何实现”随机访问”的"><a href="#数组是如何实现”随机访问”的" class="headerlink" title="数组是如何实现”随机访问”的"></a><font face="华文中宋" size="3">数组是如何实现”随机访问”的</font></h2><p><font face="华文中宋" size="3">当我们申请创建一个数组时,比如此时我申请一个数组 <code>int[] a = new int[10]</code> ,计算机会给数组 <code>a[10]</code> 分配一块连续内存空间.<br>计算机会给每个内存单元分配一个地址,通过地址来访问内存中的数据.当计算机需要随机访问数组中的某个元素时,它会首先通过下面的寻址公式,来计算出想要访问元素的存储内存地址:</font></p><blockquote><p>a[i]_address = base_address + i * data_type_size</p></blockquote><p><font face="华文中宋" size="3">根据 CPU 的预读机制,存储的数组就有可能被 CPU 全部读入,在 CPU 中进行访问,那个速度你可以想象~</font></p><h2 id="警惕数组越界问题"><a href="#警惕数组越界问题" class="headerlink" title="警惕数组越界问题"></a><font face="华文中宋" size="3">警惕数组越界问题</font></h2><p><font face="华文中宋" size="3">咱们先来看一段 C 语言代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">arr[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">仔细看,发现问题了嘛?这段代码不会打印 3 行” hello world “,而是会无限打印” hello world “.<br>因为,数组大小为 3 , a[0] , a[1] , a[2] ,实例代码中因为书写错误,导致 for 循环的结束条件错写成了 <code>i&lt;=3</code> ,而不是 <code>i&lt;3</code> ,所以当 <code>i=3</code> 时,会导致数组 <code>a[3]</code> 访问越界.在 C 语言中,只要不是访问受限的内存,那么所有的内存空间都是可以自由访问的.如果 <code>a[3]=0</code> 恰好是 <code>i=0</code> ,循环就会又开始.<br>所以这段代码就陷入了死循环.</font></p><hr><p><font face="华文中宋" size="3">参考:</font></p><ul><li><font face="华文中宋" size="3"> 极客时间&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,感谢您的阅读(这篇文章确实写得有些仓促了,逃;<br>最后,祝您冬至快乐~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]不知道该起什么题目的一篇文章</title>
      <link href="/posts/a353dbe7.html"/>
      <url>/posts/a353dbe7.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">这篇文章我是真的不知道该起一个什么样的题目,因为想要说的东西有些杂.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">在我身边的人应该对我比较清楚,以前的我可以说是「拼命三郎」,就算是休息也能看到我继续在技术上做一些研究,甚至我有时候不想和我母上大人视频聊天,为什么?因为我觉得和她视频聊天的时间,我还不如用来学习呢.<br>所以最近下班回到家,就抱着手机看奇葩说的时候,身边的小伙伴都惊呆了,说我变了,说我以前不是这样的.<br>emmm ,我不知道该怎么去做回应.只是觉得人变了,是一件很正常的事情.组成人身体的每个细胞,每时每刻都在变化,忘记了在哪儿看到的一句话,人全身的细胞每 7 年会换一次,所以只是从生理上来说,人每时每刻都在变化.从思想上说,小时候的你和现在的你,想法应该也是不一样的.<br>不管是从生理上,还是思想上你都在变化,所以我变了,它本身就是一件很正常的事情.<br>我知道我的小伙伴接受不了的是,我以前是一个在技术上深究的人,最近怎么看起了奇葩说.说实话,我没觉得这两者对我来说有什么不一样.因为对我来说,不管是在技术上做一些研究,还是去看视频,都是学习.<br>我是认真的,我真的从看视频这件事情上学到了很多.</font></p><p><font face="华文中宋" size="3">我以前是一个很敏感的人,敏感到如果身边的人不开心,我会想,是不是我哪里做错了,是不是我说的哪句话不得体了,是不是我得罪人家了,所以人家才会不开心,才会给我摆脸色看.可是看到奇葩说之后,我才知道可能仅仅是对方刚好心情不好而已,和我没什么关系,所以现在如果我再陷入那种思维的话,我就会这样提醒自己,然后我发现,现在的我每天都超级开心,是发自内心的那种;<br>我小的时候看事情,就是非黑即白,甚至是现在,有时候对一些事情的看法也会比较偏执,最近看奇葩说,常常会让我惊叹,我去竟然还可以从这个角度去思考,我天竟然还能再提升一个层次,所以现在我意识到我的看法比较偏执的时候,我就会想是不是我的思考角度太单一了,有没有另外的角度去考虑,我能不能再提高一个层次去看这个问题;<br>这是这个节目带给我的一些思考.<br>所以,对我来说,这又何尝不是学习?</font></p><p><font face="华文中宋" size="3">我常常觉得,人生就像做技术一样.做技术的话,你会发现想要继续向上走,你就必须再回到计算机网络,数据结构和算法,计算机组成原理这种底层上面来;人生也是如此,如果想要继续向前走,就必须明白自己的性格是怎样的,如何和自己的情绪对话,弄清楚自己的欲望.<br>当你把自己的底层操作系统弄明白之后,你这个人会很厉害.因为很多人究其一生都不明白,当然这其中也包括我.</font></p><p><font face="华文中宋" size="3">最近在看佛学的一些东西,我觉得佛学真的是一件很神奇的事情,小的时候总觉得佛学挺苦的,一提到佛教我脑袋里面冒出的想法就是:不能吃肉,不能喝酒,要禁欲这种.<br>在明白老师和乔老师的影响下去看佛学,我有些明白,其实佛学想要教的不是禁欲,而是放下我执.<br>仔细想想,为什么我们会常常感到烦恼?因为我们总是觉得,我和别人不一样,我不是一般人,我怎么能被命运这样对待呢.但是想想为什么不应该呢.不要把自己看得太重,烦恼就会少很多.</font></p><p><font face="华文中宋" size="3">有我微信好友的人应该知道,我特别喜欢在朋友圈里面秀.我喜欢秀今天这个朋友约我出去玩,明天那个朋友要带我去哪儿哪儿玩,以至于有的人就以为我的生活每天都挺好的,不是今天计划去那儿,就是明天去那儿.<br>之所以这样以为,是因为你没看到我为了项目熬夜通宵的时候,你没看到我压力大到崩溃的时候,你没看到我痛苦迷茫的时候.<br>每个人都是不容易的,可是如果每天眼睛里面只有这些事情的时候,你的心情很难美丽.如何保持对生命的敬畏,如何保持对生命的好奇?我觉得最重要的一点就是:感恩.<br>当我明白这一点之后,我开始享受和母上大人的视频时间,我开始感恩身边的人对我的善意,现在哪怕一天我什么都不做,就在家赖着躺一天,我的内心第一反应不再是苛责自己怎么可以这样浪费时间,而是感恩给了自己一天的时间去放空自己.<br>当我每天都是这样的感恩心态的时候,我发现了更多生活中的美好,而这又让我特别感恩.<br>这个正循环让我在某种程度上放下了我执.<br>我能清楚感觉到,有时候我还是会控制不住自己的脾气,还是会把自己看得很重,但是那又怎样呢.<br>惯性这种事情,总得慢慢来不是.况且我还这么年轻,一点儿都不着急~</font></p><p><font face="华文中宋" size="3">写这篇文章,纯粹是因为最近一周技术上没什么输入,各种碎碎念.<br>如果对您有所启发,倍感荣幸.</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]想出网关?你需要懂得这些</title>
      <link href="/posts/ff423025.html"/>
      <url>/posts/ff423025.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在学算法之余,也在学习计算机网络方面的东西,就是极客时间上刘超老师的&lt;趣谈网络协议&gt;那门课程,其中有一篇讲得非常有意思,也有些难以理解,我以我的角度来谈谈.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">想要跨网段访问的话,有一关是必须要过的:网关( Gateway )<br>配置好 IP 地址和网关之后,就能够自由访问上网了,想访问哪儿网站就访问哪儿个网站,各种浪.但是在进行跨网访问的时候,会牵扯到 MAC 地址和 IP 地址的变化,所以咱们先来知道一下 MAC 头和 IP 头的细节.</font></p><p><font face="华文中宋" size="3">MAC 头和 IP 头的细节(画的不是太好哈):<br><img src="/images/2019/mac-and-ip.jpg"></font></p><p><font face="华文中宋" size="3">简单来说一下内容:<br>目标 MAC 地址和源 MAC 地址应该不需要说明什么了,协议类型是为了说明里面是 IP 协议<br>版本( Version ):占 4 位,用来表明 IP 协议实现的版本号,目前来说主流还是 IPV4<br>服务类型 TOS ( Type of Service ):占 8 位,其中前 3 位比特为优先权字段,第 8 位保留未用,第 4 至 7 位分别代表延迟,吞吐量,可靠性和花费.<br>总长度:占 16 位,说明整个数据报的长度(以字节为单位),最大长度为 65535 字节<br>标识:占 16 位,用来唯一标识主机发送的每一份数据报,通常每发一份报文,它的值会加 1<br>标志:占 3 位,标志一份数据报是否要求分段<br>片偏移:占 13 位,如果一份数据报要求分段的话,该字段指明该段偏移距原始数据报开始的位置<br>生存期 TTL ( Time to Live ):占 8 位,用来设置数据报最多可以经过的路由器数,由发送数据的源主机设置,通常为 32,64,128 等.没经过一个路由器,它的值减 1,直到 0 时该数据报被丢弃.<br>协议:占 8 位,用来说明 IP 层所封装的上层协议类型,如 ICMP( 1 ), IGMP( 2 ), TCP( 6 ), UDP( 17 )等.<br>首部校验和:占 16 位,根据 IP 头部计算得到的校验和码.<br>源 IP 地址,目标 IP 地址:各占 32 位,用来标明发送 IP 数据报文的源主机地址和接收 IP 报文的目标主机地址.</font></p><p><font face="华文中宋" size="3">在任何一台机器上,如果想要访问另一个 IP 地址时,都会先判断,要访问的目标 IP 地址,与当前机器 IP 地址是否在同一个网段内.<br>如果是同一个网段,这就好说了,直接将源地址和目标地址放入到 IP 头中,然后通过 ARP 得到 MAC 地址,将源 MAC 和目标 MAC 放入 MAC 头中,发出去就 OK 了.<br>但是如果不是同一个网段呢,这就需要发往默认网关 Gateway 了.Gateway 的地址一定是和源 IP 地址是同一个网段的,如果不是第一个,就是第二个.比如, 192.168.1.0/24 这个网段,Gateway 一般就是 192.168.1.1/24 或者 192.168.1.2/24.因为网关和源 IP 地址在同一个网段内,所以发给 Gateway 的过程和上面同一个网段的过程是一样的.网关接收到之后,接下来怎么处理就是它自己的事情了.<br>做了上面那么多的铺垫,终于来到了今天想要说的主要内容:网关是怎么将数据跨网段发送出去的.因为在这里面涉及到了 IP 地址和 MAC 地址的变化.</font></p><p><font face="华文中宋" size="3">MAC 地址是在一个局域网内才有效的地址,所以 MAC 地址只要经过网关,就一定会改变,因为经过网关就意味着换了局域网.主要在于 IP 地址是否改变.如果 IP 地址不改变,那我们就将网关称为转发网关;如果 IP 地址改变,则将网关称为 NAT 网关.<br>先来说一下转发网关:<br><img src="/images/2019/transfor.jpg"></font></p><p><font face="华文中宋" size="3">如图,我们能够看到,服务器 A 的 IP 地址为 192.168.1.101/24 ,服务器 B 的 IP 地址为 192.168.4.101/24 ,现在服务器 A 想要访问服务器 B,不在同一个网段内,怎么办呢?肯定要经过网关的,对吧(因为 IP 头和 MAC 头里面的内容太多了,在这里主要写出 MAC 和 IP 内容)<br>此时,服务器 A 会给路由器 A 发送这样的内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :服务器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 A 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 A 接收到内容之后,发现是想访问 192.168.4.0/24 的,根据配置的路由规则,将要发送的内容通过 192.168.2.1 这个口发送出去,发送给路由器 B 的内容是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 B 接收到了来自路由器 A 的内容,它发现是想访问 192.168.4.0 这个地址,根据配置的路由规则,需要从 192.168.4.1 这个口出去,这样就能发给服务器 B,此时路由器 B 发送的包是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 B 的 MAC</span><br><span class="line">目标 MAC : 服务器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">至此,服务器 A 发送的内容就到达了服务器 B .<br>咱们来总结一下以上内容:在转发网关下,我不 care 其他的,我只知道我要发给哪儿个 IP ,所以在整个过程中,源 IP 和目标 IP 都没有发生改变.</font></p><p><font face="华文中宋" size="3">接下来咱们来说说 NAT 网关.照例,上个图:<br><img src="/images/2019/NAT.jpg"></font></p><p><font face="华文中宋" size="3">有没有发现一个问题,服务器 A 的 IP 地址是 192.168.1.101 ,要访问的服务器 B 的地址也是 192.168.1.101 ,如果只是看 IP 地址的话,是不是饶了一圈发现,这不就是自己访问自己嘛?惊不惊喜.<br>但是实际上服务器 A 在北京,服务器 B 在上海,两个地方有一个相同的 IP 地址罢了.问题就来了,服务器 A 怎么就可以访问到服务器 B 了呢?<br>就像上海人说上海话,北京人说北京话,一个区域内大家都听得懂,但是如果北京人跑到上海去,想要交流怎么办呢?说普通话呗,对不对.在网络中也可以这样做.既然这两个局域网之间没有商量过,各自使用各自的,内部使用的话这都没事儿,但是如果想要在外面也走的开,就需要制定规则.也就是说,路由器 A 和 B 在外网上需要有一个大家都公认的身份.<br>在图中我们能够看到路由器 A 在公网上的身份是 192.168.2.1/24 ,路由器 B 在公网上的身份是 192.168.2.2/24 .有了公认的身份之后,来看看接下来发送的内容:<br>服务器 A 发送给路由器 A 的内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :服务器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 A 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.2.2 (即路由器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 A 接收到内容之后,根据配置的路由规则,通过 192.168.2.1/24 发送给路由器 B ,此时发送的内容为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.2.1 (即路由器 A 的公网 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.2.2 (即路由器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">内容到达路由器 B 之后,根据它的配置规则,发现是想要发送给服务器 B 的,此时:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 B 的 MAC</span><br><span class="line">目标 MAC : 服务器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.2.1 (即路由器 A 的公网 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.1.101 (即服务器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">至此,服务器 A 发送的内容就到达了服务器 B .<br>咱们来总结一下以上内容:在 NAT 网关下, MAC 地址和 IP 地址都是会改变的. MAC 地址还好理解一些,要发送给谁,那么目标 MAC 地址就是要发送的机器 MAC 地址即可.但是 IP 地址如果是跨网段访问,则都需要通过公网 IP 来进行才可以.</font></p><p><font face="华文中宋" size="3">以上就是想要分享的内容,如果有错误之处,还希望指出哇~<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]05 Stack 经典面试题之判断字符串是否合法( Java 版)</title>
      <link href="/posts/3671c55b.html"/>
      <url>/posts/3671c55b.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">Stack (栈): 后进先出( Last In First Out ),也就是说后面进来的,会先出去.<br><a id="more"></a><br>说到这个场景,我就会想起烙饼这件事.每次母上大人烙饼的时候,先烙好的饼会放在最下面,后面烙好的饼会放在上面,还在烙饼的时候,我就想吃所以被我吃到的就是最上面的饼.<br>感觉这个过程是不是和栈这种数据结构很像~</font></p><p><font face="华文中宋" size="3">对于 Stack 来说,经典的面试题莫过于,判断字符串是否合法了.<br>判断字符串是否合法是这样的:有一个字符串,它只包含大中小括号,那么符号 ([)] 这样是不合法的,合法的应该是这样: ([]) ,同样 ([]){ 这样的符号也是不合法的<br>基于以上的共识,咱们先考虑使用数组的方式,来分析一下.</font></p><p><font face="华文中宋" size="3">1.  定义一个初始值,如果刚开始输入的就是 ( 或者 { 或者 [ ,那么我们不能立刻判断到它就是不合法的,因为它需要等待匹配,如果到最后还是没有匹配上,那就是不合法的;如果刚开始输入的是 ) 或者 } 或者 ] ,我们立刻就能知道这是不合法的.</font></p><p><font face="华文中宋" size="3">2.  如果此时输入了 ( 和 [ ,初始值应该 ++ ,接下来输入的是右边的符号的话应该是 ] 而不是 ) ,此时需要进行判断第三个输入的字符是否匹配第二个,只有第二个也匹配之后才需要进行匹配第一个字符.</font></p><p><font face="华文中宋" size="3">3.  如果匹配成功,则初始值应该 - - ,所有字符串匹配完毕之后,需要看初始值是否为最初赋予的值,如果是则说明所有符号都是合法的,否则说明还有符号没有匹配上,则不合法<br>经过这样的分析之后,写代码应该就比较好写了,比如我们可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否合法</span></span><br><span class="line"><span class="comment"> *      比如: "([)]" 不合法, "[()]" 合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-11-24 20:05:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsValidString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义字符串的内容</span></span><br><span class="line">        String symbol=<span class="string">"([])&#123;"</span>;</span><br><span class="line">        <span class="comment">// 调用判断方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result=isValid(symbol);</span><br><span class="line">        System.out.print(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用来接收传入的值</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="comment">// 定义一个数组,用来存放传入的字符串,长度为传入的字符串的值</span></span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="comment">// 定义 stackEnd 为 -1 是为了让第一个元素能够进入数组,即 stackEnd++ 值为 0</span></span><br><span class="line">        <span class="keyword">int</span> stackEnd=-<span class="number">1</span>,length=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果刚开始是左括号,左中括号等符号,则不能直接判断为该符号不合法,而是放入数组,等待匹配</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]==<span class="string">'('</span> || arr[i]==<span class="string">'['</span> || arr[i]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stackEnd++;</span><br><span class="line">                stack[stackEnd]=arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果刚开始就是右括号,右中括号等符号,则不合法,直接返回 false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((arr[i]==<span class="string">']'</span> || arr[i]==<span class="string">')'</span> || arr[i]==<span class="string">'&#125;'</span>) &amp;&amp; stackEnd==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 分情况来进行匹配</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i]==<span class="string">')'</span> &amp;&amp; stack[stackEnd]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">']'</span> &amp;&amp; stack[stackEnd]==<span class="string">'['</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">'&#125;'</span> &amp;&amp; stack[stackEnd]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果都匹配不到,说明该符号不合法,则直接返回 false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stackEnd!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果最后结果不等于 -1 ,说明 stackEnd 中还有符号没有被匹配到,则也是不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">可以明显看到,使用数组的话,会有很多 if , else , else if ,仿佛闻到了坏代码的味道.<br>如果使用栈来实现呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否合法</span></span><br><span class="line"><span class="comment"> *      比如: "([)]" 不合法, "[()]" 合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-11-24 20:05:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsValidString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义字符串的内容</span></span><br><span class="line">        String symbol=<span class="string">"([])&#123;"</span>;</span><br><span class="line">        <span class="comment">// 调用判断方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result=isValid(symbol);</span><br><span class="line">        System.out.print(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个空栈</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义 map ,用来存放匹配的符号</span></span><br><span class="line">        Map&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr=s.toCharArray();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果 map 中不包含进入的符号,说明是左边的符号,直接入栈即可</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                stack.push(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果进入的符号和栈顶的元素不匹配,则说明符号不合法</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(arr[i])!=stack.pop())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断栈是否为空,如果为空,说明所有符号都已匹配完毕,全都合法</span></span><br><span class="line">        <span class="comment">// 如果栈不为空,说明还有符号没有匹配到,则不合法</span></span><br><span class="line">        <span class="keyword">if</span> (stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">嗯,看起来简洁了不少.<br>欢迎评论区交流,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]04 Link List (链表)及单链表反转实现</title>
      <link href="/posts/745fa732.html"/>
      <url>/posts/745fa732.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在说链表的时候,就会常说另外一个概念:数组.<br>数组和链表,常常会拿到一起做比较.这篇文章也是,咱们来说说数组和链表.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">数组最大的一个特点就是,需要一块连续的内存空间.假设现在内存空间剩余了 1MB ,但是它不是连续的,这个时候申请一个大小为 1MB 的数组,会告诉你申请失败,因为这个内存空间不连续.<br>链表最大的一个特点是,不需要一块连续的内存空间.还是上面那个例子,如果申请的不是大小为 1MB 的数组,而是链表,就会申请成功.<br>如果只是理解到了这个层面,你是不是会觉得,我以后一直用链表这种数据结构就可以了?不不不,数组也有它自己的优势.<br>首先数组简单易用,又因为使用的是连续内存空间,就可以借助 CPU 的缓存机制,预读数组中的数据,因而访问效率更高,所以在插入,删除操作比较少,而查询比较多的情况下,使用数组是比较有优势的.<br>链表在内存中不是连续存储,对 CPU 缓存机制不够友好,也就没办法进行有效预读.所以链表适用于在插入,删除操作比较多的情况下使用.</font></p><p><font face="华文中宋" size="3">链表分为单链表,循环链表,和双向链表.<br>对于单链表来说,它的第一个节点也就是头结点记录着链表的基地址,而最后一个节点也就是尾节点则指向一个空地址 NULL ,循环链表也可以理解成特殊的单链表,只不过尾节点由原来指向一个空地址 NULL 改为了指向头结点.<br>单链表:<br><img src="/images/2019/单链表.jpg"></font></p><p><font face="华文中宋" size="3">循环链表:<br><img src="/images/2019/循环链表.jpg"></font></p><p><font face="华文中宋" size="3">但是在实际开发中,更加常用的链表结构是:双向链表.<br>它的结构是这样的:<br><img src="/images/2019/双向链表.jpg"></font></p><p><font face="华文中宋" size="3">我们能够看到它的特点是:占用内存较多,支持双向遍历.因为它有两个指针,所以相对单链表,一个数据就会多占用一些内存.<br>既然它占用内存较多,为什么在实际开发中还比较常用呢,这里面有一个思想在里面,咱们具体来讲讲.<br>我们知道,单链表,双链表在删除的时候,时间复杂度为 O(1) ,但是在实际开发中它的时间复杂度并不是这样,为什么呢?<br>这样想,一般在做数据删除的时候,你的操作是怎样的?<br>首先,查找在节点中「值等于给定某个值」的节点,找到之后再做删除对吧?也就是说在删除之前,是需要做查找这个工作的.而单向链表和双向链表在查找的时候时间复杂度为 O(n) ,因为它为了找到这个要删除的元素,需要将所有的元素都遍历一遍.将上面过程梳理一下就是,查找时间复杂度为 O(n) ,删除时间复杂度为 O(1) ,总的时间复杂度为 O(n) .<br>以上过程在双链表中是怎样的呢?因为双链表支持双向遍历,所以查找这个操作对它来说时间复杂度为 O(1) ,因为它是双向遍历,所以在查找元素时,不需要将所有的元素进行遍历,删除时时间复杂度为 O(1) ,总的时间复杂度为 O(1) .<br>因为双向链表的时间复杂度为 O(1) ,所以在开发中它是比较受欢迎的.而在这其中体现的一个最重要的思想就是:空间换时间.<br>当内存空间相对时间来说不是那么重要的话,那我们是不是就可以忽略次要的因素,着重解决主要矛盾?</font></p><p><font face="华文中宋" size="3">最后来实现一个比较常见的单链表操作—单链表反转<br>首先上代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/16 19:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data , Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化单链表</span></span><br><span class="line">        Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,node5);</span><br><span class="line">        Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">        Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">        Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line">        <span class="comment">// 调用反转方法</span></span><br><span class="line">        Node reverse=reverse(node1);</span><br><span class="line">        System.out.println(reverse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *单链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 为传入的单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019/11/16 19:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        Node current=list, <span class="comment">// 定义 current 为当前链表</span></span><br><span class="line">                afterReverse=<span class="keyword">null</span>;   <span class="comment">// 定义 afterReverse 为转换之后的新链表,初始为 null</span></span><br><span class="line">        <span class="comment">// 当前链表不为空,进行反转操作</span></span><br><span class="line">        <span class="keyword">while</span> (current!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 1. 保存当前节点的 next 指针指向的链表</span></span><br><span class="line">            Node next=current.next;</span><br><span class="line">            <span class="comment">// 2. 将当前节点的 next 指针指向反转之后的新链表</span></span><br><span class="line">            current.next=afterReverse;</span><br><span class="line">            <span class="comment">// 3. 保存当前的链表状态到新链表中</span></span><br><span class="line">            afterReverse=current;</span><br><span class="line">            <span class="comment">// 4. 将当前节点指针后移一位,进行下一次循环</span></span><br><span class="line">            current=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> afterReverse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">接下来断点调试,看看每次结果:<br>初始状态<br><img src="/images/2019/reverseListInit.jpg"></font></p><p><font face="华文中宋" size="3">第一次循环结束<br><img src="/images/2019/reverseListFirst.jpg"></font></p><p><font face="华文中宋" size="3">第二次循环结束<br><img src="/images/2019/reverseListSecond.jpg"></font></p><p><font face="华文中宋" size="3">第三次循环结束<br><img src="/images/2019/reverseListThird.jpg"></font></p><p><font face="华文中宋" size="3">第四次循环结束<br><img src="/images/2019/reverseListFourth.jpg"></font></p><p><font face="华文中宋" size="3">第五次循环结束<br><img src="/images/2019/reverseListFiveth.jpg"></font></p><p><font face="华文中宋" size="3">在写这篇文章的时候,特别是单链表反转那一块,考虑了很久,借鉴网上思路做出来,有的思路真的是很巧妙.<br>以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]03 计算时间和空间复杂度</title>
      <link href="/posts/e9497446.html"/>
      <url>/posts/e9497446.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">学习数据结构与算法的时候,避不开的一个知识点就是:时间复杂度和空间复杂度分析.<br><a id="more"></a></font></p><p><font face="华文中宋" size="5">为什么需要复杂度分析?</font></p><p><font face="华文中宋" size="3">一段代码我写好了,直接上手跑一遍,不就知道算法执行的时间和占用的内存大小了,为什么还要做分析呢?而且直接跑一遍得到的数据,准确的不能再准确了.<br>因为直接跑一遍得到算法执行的时间和占用的内存大小,有一定的局限性.<br>第一,同样一段代码,把它拿到 90 年代的笔记本上面执行,和拿到现在的笔记本上面执行,得到的时间是不一样的,所以直接拿来运行的代码,它的准确度真的够准确嘛?<br>第二,如果数据量不够多,直接运行程序得到的结果可能有失其准确性.比如,对于小规模的数据排序,插入排序可能会比快速排序更快.<br>对于计算时间和空间复杂度,一般是采用大 O 表示法来表示.</font></p><p><font face="华文中宋" size="5">时间复杂度计算:</font></p><p><font face="华文中宋" size="3">什么是时间复杂度呢?是指执行当前算法所消耗的时间.<br>常见的几种时间复杂度:O(1),O($log_2 n$),O(n),O($n^2$),O($2^n$),O(n!)<br>先来看一段简单的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">1000</span>;</span><br><span class="line">System.out.println(<span class="string">"Hi, your input is:"</span>+n);</span><br><span class="line">System.out.println(<span class="string">"Hey, your code is:"</span>+n);</span><br><span class="line">System.out.println(<span class="string">"Hello, your verification code is:"</span>+n);</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">先别往下看,你觉得这段代码的时间复杂度是多少?<br>是 O(1) 对吧?因为这段代码都是常量级的执行时间,所以对于时间复杂度来说,它的复杂度为 O(1).<br>请注意: O(1) 并不是指执行了一行代码,上面的程序执行了 3 行代码,它的时间复杂度也是 O(1).只要代码的执行时间不随 n 的增大而增长,那时间复杂度就都记为 O(1).一般情况下,只要程序中不存在循环语句,递归语句,就算是有上万行的代码,时间复杂度也是 O(1).<br>来看另外一段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">"Hello, your verification code is:"</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">你觉得这段代码的时间复杂度是多少?<br>先来分析一下,这段代码执行了 n 次, 所以它的时间复杂度为 O(n).<br>如果是这样呢:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, your verification code is:"</span>+i+<span class="string">"and"</span>+j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">这段代码的时间复杂度是多少呢?<br>首先它有两个 for 循环,每个循环都会走 n 遍,所以这段代码的时间复杂度为  O($n^2$) .</font></p><p><font face="华文中宋" size="3">如果将以上代码合并在一起,它们的复杂度是多少?是  O(1) + O(n) + O($n^2$) 嘛?<br>不,只是 O($n^2$) .因为当 n 足够大时, O(1) 和 O(n) 对于程序的影响几乎都可以忽略不计,此时我们只需要关注最大量级即可.</font></p><p><font face="华文中宋" size="5">接下来说说,空间复杂度计算:</font></p><p><font face="华文中宋" size="3">什么是空间复杂度呢?是指执行当前算法需要占用的内存空间大小.也就是看使用了几个辅助变量.<br>照样上几段代码来看看.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">3</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">对于这段代码来说,它的空间复杂度是多少?<br>应该比较容易看出来,只使用了一个辅助变量,所以它的空间复杂度为 O(1).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">这段代码,申请了一个大小为 n 的数组,所以它是申请了 n 个辅助变量,所以它的空间复杂度为 O(n).这段代码是申请了一维的,如果是这样呢:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">你一定猜到了,它的空间复杂度是 O($n^2$)</font></p><p><font face="华文中宋" size="3">关于时间和空间复杂度的计算,大概就是这样了,感谢您的阅读哇~<br>我也不知道为什么, O($n^2$) 它不识别为 n 方,(逃;</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]02 什么是数据结构与算法以及我该怎么学</title>
      <link href="/posts/c30d995b.html"/>
      <url>/posts/c30d995b.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">什么是数据结构与算法呢?<br>当你看到这个问题的时候,你脑海中的第一反应是什么?<br><a id="more"></a></font></p><blockquote><p>数据结构就是指一组数据的存储结构,算法是操作数据的一组方法.</p></blockquote><p><font face="华文中宋" size="3">这样的答案是不是让你觉得,我去,这么抽象,所以算法是什么,数据结构是什么?还是一脸懵逼.<br>小时候我的问题可多了,总是问我母上大人,妈妈这个字念什么,那个字念什么.母上大人后来被我烦的不行,索性给了我一本&lt;新华字典&gt;,教我怎么查,从那儿以后再也没烦过她了.</font></p><p><font face="华文中宋" size="3">为什么要说这个事情,因为我觉得这就是一个解释什么是数据结构,什么是算法的例子.新华字典是按照字母的顺序来给汉字进行编号,那么厚的一本字典就是「汉字」的存储结构.接下来我有个字知道它的拼音,但是我不知道它念几声哇,怎么办呢?一种方法是:根据字母顺序定位,然后开始找;另外一种方法是:根据偏旁部首来找到这个字,然后再看看它在几页,定位过去.为了查找这个汉字,所采用的方法,就是常说的算法.</font></p><p><font face="华文中宋" size="3">你有没有发现,只要说数据结构,就一定提到算法,或者提到算法的时候,就会说到数据结构.为什么呢?<br>因为数据结构和算法是相辅相成的,数据结构是为算法服务的,算法主要作用在特定的数据结构之上,如果单独讲,没有什么意义,或者说意义不大.</font></p><p><font face="华文中宋" size="3">现在,我知道了学好数据结构和算法很重要了,但是我该怎么学呢?<br>我现在也是在摸索阶段,根据自己的经验来说说.</font></p><p><font face="华文中宋" size="3">第一,要学会站在巨人的肩膀上.<br>当你打开图灵图书的时候,你会发现这么一句话「站在巨人的肩膀上」,那么好的位置,如果用来放广告,会给它带来多少的效益啊,但是编辑没有这么做,反而是放了这样一句话,说明什么?说明这句话,特别值钱.<br>所以能从这句话里面学到什么?<br>站在巨人的肩膀上,能够少走很多弯路.现在互联网这么发达,只要你想学,课程一大堆,找一个好的课程踏踏实实的从头到尾学一遍,如果你对「知识付费」不排斥的话,我推荐极客时间上的「数据结构与算法之美」这个课程,我也在学习这门课程,给我的帮助很大.如果对付费比较排斥的话,我觉得大学计算机课程上的「数据结构导论」这本书吃透也差不多,不过我看的那个版本的是 C 语言的,对新手可能不太友好.</font></p><p><font face="华文中宋" size="3">第二,就是要多写,多练.<br>展示你实力的从来都是 no BB , show code .<br>想要学好算法也是这样,别说太多,干就完了.<br>一定要多写.前一段时间为了准备考试,把课本上的例子,用各种算法都手写了一遍,冒泡的话,这些顺序是怎么动的,快速排序的话又是如何变化的.<br>我觉得一定要用手写写画画,现在我对于算法思想有了一点儿感受.如果没有这个量,我觉得知道快速排序为什么快这一点是不会有很深刻的体会的.<br>多写,多练,没啥捷径.</font></p><p><font face="华文中宋" size="3">最后一点就是心态的问题了.<br>很多人,也包括我自己,常常是想着今天付出了,明天就要看到回报.<br>明明知道一口吃不成胖子,可是真的在生活中,却总是想着这样的事情.<br>心静,心静,让心沉淀下来.</font></p><p><font face="华文中宋" size="3">感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]说说最近的成果</title>
      <link href="/posts/f43ade7d.html"/>
      <url>/posts/f43ade7d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">继上次写的博客:<a href="https://www.dynamic-zheng.com/posts/a3f84cce.html">[碎碎念]总结一下最近在做的事情</a> ,过去了有一个月了,上次总结中做的一些事情,有的也有了一些转机,这周除了工作,其他时间都给了自考,技术上又没什么输出,所以厚着脸皮来说说最近.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">项目管理目前对我来说,已经没有那么大的挑战了.<br>真的很难想象,一个月之前我还因为带团队有种心有余而力不足的感觉,还害怕没带好团队而有各种愧疚,压力,害怕辜负了老大对我的期待.一个 Sprint 又一个 Sprint 走下来之后,到现在竟然有种游刃有余的感觉.<br>刚开始遇到的各种阻力,在团队拿出成绩之后,再开展其他工作,顺利了很多.所以还是少说话,多做事.<br>项目管理上一切事情应付的得心应手之后,这周除了工作之外,时间都用在了数据结构导论上.一周的时间需要把课本看完,刷题,工作回到家之后还会看书到晚上十一点,说自己很轻松是假的.<br>为了把数据结构拿下,手写了多少页的代码,各种排序算法写了多少遍,感觉都有些记不清了,收获也是有的,考完试之后就觉得自己稳了,在这个过程中,还把我的好奇心给勾出来了.<br>可能是因为手写算法排序的缘故,开始对算法的设计思想有了一个更新的认识.所以上一篇博客立了一个 flag ,说是要把数据结构和算法系统学习一遍,是因为我的好奇心真的被引出来了.<br>在过年之前,把这项目标完成.</font></p><p><font face="华文中宋" size="3">关于自考.<br>我还记得自考毕业答辩的时候,刚好赶上项目线上环境出问题,搞到凌晨两点多,然后开始通宵赶论文.<br>所以当时状态也是比较差的,答辩完之后,我觉得可能需要再来一次了.可能是因为老师看我比较不容易?最后的结果是过了.<br>自己是几斤几两还是有点儿认知的,是老师比较宽容,也是真的特别感激老师.<br>如果今年的数据结构导论过了的话,就差计算机网络这一门了. 17 年 5 月开始考试,到现在感觉终于看到了曙光一样.<br>趁着年轻,多折腾折腾事情,总觉得是好的.</font></p><p><font face="华文中宋" size="3">对于接下来的规划:<br>现在是 10 月 19 日,距离 1 月 1 日其实没有多少时间了.来一个小目标吧,万一实现了呢.<br>首先是工作上,把现在做的产品做出一版,尽快上线,让用户使用使用,看看数据怎样,再快速迭代开发下一版.<br>然后是技术上,把计算机网络协议系统过一遍,越往上走,越发现基础的知识很重要,趁发现的不晚,赶紧再补补.<br>还想着去考一个高级职称,所以这段时间,不管是工作上,还是学习上,都静下心来沉淀沉淀.<br>对于读书,能看够 50 本就行,目前来看这个目标没什么难度,也不打算给自己增加难度了,我知道能做到这件事情本身就已经很棒了,所以就不再给自己压力了.<br>关于身体,最近是要控制一下体重了,主要是新搬了家之后,一起合租的人都超会做饭,导致我 3 天的时间,体重从 90 斤直接飙到 93 斤, emmm ,要控制一下了.搬家之后,距离公司 15 分钟的路程,每天走着去公司上班,一天下来感觉运动量也算是可以.<br>其他好像没什么重要的事情了.要是想起来了,我就再来补充.</font></p><p><font face="华文中宋" size="3">总是让你们看碎碎念,还有点儿不好意思,没啥干货,净是我在这儿瞎扯.<br>去看书了,让肚子里多点儿墨水.<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]01 为什么要学数据结构与算法</title>
      <link href="/posts/5d7a3ce3.html"/>
      <url>/posts/5d7a3ce3.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">从今天起,我打算写一个系列,关于数据结构与算法.这篇文章,算是一个开篇之词吧.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">数据结构与算法,操作系统,计算机组成原理,还有计算机网络,这些内容在实际工作中你用到了多少?是不是除了面试的时候会问到,好像写代码的时候,也没怎么用,对吧?况且就算用到,我只要会调用 Java API ,开发框架用的相当熟练,代码照样 6 的飞起,那我为什么还要学习数据结构与算法呢?<br>Search for meaning ,为自己当下做的事情,寻找一个意义.</font></p><p><font face="华文中宋" size="5">你真的想在工作中一直 CRUD 嘛?</font></p><p><font face="华文中宋" size="3">对于一名业务开发工程师来说,可能每天要做的事情就是对数据库进行 CRUD(增删改查) 操作,更多的是利用已经封装好的接口,类库来把业务实现,很少需要自己去手写实现数据结构和算法.<br>但是一年一年的这样 CRUD 过去,你敢说自己拥有 10 年的工作经验,而不是 1 年的工作经验重复了 10 年?<br>好吧,就算你敢说,每天在工作中,一直 CRUD ,也没有想过去优化自己的代码,没有想过提高性能,你真的愿意一直这么下去吗?</font></p><p><font face="华文中宋" size="5">打造独属于你的能力.</font></p><p><font face="华文中宋" size="3">有人说,对于程序员这个行业来说,就是吃青春饭的,只要超过了 35 岁,再继续走下去就很难了.为什么?因为你拼体力拼不过比你更年轻的,你拼学习也拼不过那些年轻的.<br>这些是事实,但是随着年龄的增长,你也有自己独特的优势,那就是经验.<br>同样一个业务的代码实现,年轻人需要用上千行甚至是上万行代码去实现,而你只用了几百行的代码时(夸张一下);当年轻人写出来的代码,性能一般, bug 不少,扩展性也不强的时候,而你写的代码却没有这些问题,甚至可以到 Github 上让很多人来使用,我觉得这样的你,被公司辞退的可能性很小.<br>算法可以帮你打造这份,独属于你的能力.</font></p><p><font face="华文中宋" size="5">你想进入大厂工作嘛?算法是你必须要经历的一关啊!</font></p><p><font face="华文中宋" size="3">我觉得对于程序员来说,进入阿里,腾讯这些大厂应该是每个人都希望的,那是一个更广阔的平台,有很多成长的机会,能够接触到上亿级的并发.<br>如果想要进入这些大厂,算法是必经之路.<br>曾经看到过一个事情:有一位面试人大学本科是数学系,但是对计算机很感兴趣,去面试一家大厂,虽然其他方面答的都不是很好,但是算法这一关没有难住他,就这样他被录取了.<br>对于大厂来说,相对于短期能力,他们更看重你的长期潜力.就像建立大厦一样,只有地基稳固,上面的高楼大厦才会稳固.<br>算法,就是你向上走的地基.</font></p><p><font face="华文中宋" size="5">人和人之间的差距在哪儿?</font></p><p><font face="华文中宋" size="3">人和人之间的差距到底有多大?我觉得就是一个大脑的距离.一个人的大脑思考能力,从某种程度上来说,直接决定了这个人能够走多远,能够取得多大的成就.<br>值得开心的是:大脑的思考能力是可以被训练出来的.而算法是为数不多,也是最为有效的方法之一.</font></p><p><font face="华文中宋" size="3">如果想要扎实自己的计算机内功,向架构师方面走;想要提升看问题的深度,让自己站在一个更高的层面上;想要提高大脑的思考力,遇到问题能够抓住本质,绕不开数据结构与算法.</font></p><p><font face="华文中宋" size="3">以前也断断续续的学习过数据结构和算法,但是都不够系统.这次打算花上几个月的时间,把算法慢慢磨透.<br>我没有多厉害,只是出于对技术的追求,想要不断精进自己的技能,所以在学习过程中,难免会出现错误,如果您发现,可及时和我反馈.</font></p><p><font face="华文中宋" size="3">以上,如果您对学习数据结构和算法也感兴趣,可以持续关注我的博客(又开始不要脸了)<br>最后,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Jenkins]详细说说 Jenkins 配置那些事</title>
      <link href="/posts/525ce227.html"/>
      <url>/posts/525ce227.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">对于 Jenkins 的操作来说,搭建什么的我觉得没啥难度(如果觉得有难度,我觉得应该是没看我这篇文章:<a href="https://blog.csdn.net/zll_0405/article/details/85163461" target="_blank" rel="noopener">[Jenkins]CentOS7下Jenkins搭建</a>),困难在于配置文件怎么写.这篇文章详细来说说.<br><a id="more"></a><br>先说一下,这些配置只是起参考价值,具体还是需要根据自己的情况来.<br>对于后端来说,配置文件主要在构建之后需要执行的操作( # 后面为注释内容)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">tomcat_path=/usr/local/tomcats/tomcat-test       #定义 tomcat 的位置</span><br><span class="line">project_web=$tomcat_path/test.war #定义项目打包位置</span><br><span class="line">if [ -f $project_web ] ;then </span><br><span class="line">echo -- stop tomcat</span><br><span class="line">#kill tomcat pid</span><br><span class="line">pidlist=`ps -ef | grep tomcat-test | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`#查看是否有进程正在运行</span><br><span class="line">if [ &quot;$pidlist&quot; = &quot;&quot; ]#没有进程在运行,则提示</span><br><span class="line">then</span><br><span class="line"> echo &quot;no tomcat pid alive!&quot;</span><br><span class="line">else#有进程在运行,杀掉</span><br><span class="line">   echo &quot;tomcat Id list :$pidlist&quot;</span><br><span class="line">   kill -9 $pidlist</span><br><span class="line">   echo &quot;KILL $pidlist:&quot;</span><br><span class="line">   echo &quot;tomcat stop success&quot;</span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">    echo -- 正在部署$project_web#将进程杀掉之后,重新进行部署</span><br><span class="line">    if [ -f $tomcat_path/webapps/test.war ] ;then#查看 /webapps 目录下是否有以前的 war 包,如果有,删掉</span><br><span class="line">        rm -f $tomcat_path/webapps/test.war</span><br><span class="line">        rm -rf $tomcat_path/webapps/test</span><br><span class="line">        echo -- 正在删除$project_web</span><br><span class="line">    fi </span><br><span class="line">        cp $project_web $tomcat_path/webapps/test.war#将新生成的 war 包复制到 /webapps 目录下</span><br><span class="line">    # start tomcat</span><br><span class="line">    echo $tomcat_path</span><br><span class="line">    #sleep 5</span><br><span class="line">    export JAVA_HOME=/usr/java/latest</span><br><span class="line">    #$tomcat_path/bin/startup.sh</span><br><span class="line">    $&#123;tomcat_path&#125;/bin/startup.sh </span><br><span class="line">else </span><br><span class="line">echo $BUILD_ID - 未找到$project_web</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">对于前端来说,主要就是需要注意一下前端特有的打包方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --unsafe-perm</span><br><span class="line">ng build --prod --env=test --output-path=typing-dev --base-href ./</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">对于 k8s 来说,需要在构建时创建事件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -l </span><br><span class="line"></span><br><span class="line">examimage_path=reg.zll.com/library/test:1.0.0#定义镜像在 harbor 上的位置</span><br><span class="line"></span><br><span class="line">cp test-web/target/test-web.war test-web/src/profiles/k8s_prod/test-web.war#将 war 复制到目标目录下</span><br><span class="line">cd test-web/src/profiles/k8s_prod#进入目标目录</span><br><span class="line">docker build -t $examimage_path .#开始创建新的镜像,注意后面还有一个&quot;.&quot;,要不然命令是不会生效的</span><br><span class="line">docker push $examimage_path#将构建好的镜像推到 harbor 上面去</span><br><span class="line">echo &apos;推送镜像到harbor&apos;</span><br><span class="line"></span><br><span class="line">#删除本地镜像</span><br><span class="line">docker rmi -f $examimage_path#推送成功之后,将本地镜像删除</span><br><span class="line"></span><br><span class="line">#k8s部署</span><br><span class="line">echo &apos;开始部署&apos;</span><br><span class="line">kubectl delete -f $WORKSPACE/test-web/src/profiles/k8s_prod/.#将本地的都删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo $WORKSPACE</span><br><span class="line">kubectl create -f $WORKSPACE/test-web/src/profiles/k8s_prod/.#部署最新的</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">以上就是我接触到的配置文件常用方法,希望能够帮助到你~<br>感谢您的阅读</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] IP 地址与 MAC 地址之间的关系</title>
      <link href="/posts/e579f21d.html"/>
      <url>/posts/e579f21d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">了解计算机网络的话,逃不过 IP 地址和 MAC 地址.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">MAC ( Media Access Control ,介质访问控制 )地址,也叫硬件地址,长度是 48 比特( 6 字节),由 16 进制数字组成,分为前 24 位和后 24 位.前 24 位叫做组织唯一标志符( Organizationally Unique Identifier , OUI ),这是由 IEEE 的注册管理机构给不同厂家分配的代码,用来区分不同的厂家.后 24 位是厂家自己分配的,称为扩展标识符.对于同一个厂家来说,生产的网卡中 MAC 地址后 24 位是不一样的.<br>这样就保证了 MAC 地址的唯一性.</font></p><p><font face="华文中宋" size="3">MAC 地址应用的场景有很多.<br>1 ,在一个局域网内, IP 地址应该都是动态分配的,假如我在公司局域网内的 IP 地址是: 192.168.1.156 ,现在我不在公司使用了,那么这个 IP 地址就给了别人,让别人使用.<br>也就是说, IP 地址和你正在使用的设备是不对应的,那我发出的请求,就没办法准确无误的到达我这里,在这种情况下,进行通信肯定会出现问题.<br>MAC 地址和设备在全球范围内都是唯一的,所以在局域网内使用 MAC 地址进行通信没什么问题.<br>2 ,在早期的以太网,只有交换机,没有路由器,以太网之间就是通过 MAC 地址来进行通信,后来有了互联网,为了兼容原来还是使用 MAC 地址的模式,采用了 IP+MAC 地址的方式.</font></p><p><font face="华文中宋" size="3">估计看到这里你就有问题了,既然 MAC 地址在全球范围内都是唯一的,那我直接使用 MAC 地址来进行通信不就好了嘛?为什么还要有 IP 地址呢.<br>你想一想,全世界有那么多人,那么多人的 MAC 地址如果想要进行保存的话,是不是需要一张超级超级大 MAC 地址对应表?有了一张这样的对应表,为了寻找一个 MAC 地址,那个效率,想想就会很低.<br>而 IP 地址就可以很好的解决这个问题.<br>因为 IP 地址是网络提供商给你的,所以你在哪里整个网络都是知道的.<br>比如,你现在人在中国北京,那么 IP 地址就标识了你在中国.网络上有个请求需要到达你这里,对于别人来说,只需要将这个请求发送到中国就 OK 了,剩下的就是中国内部再进行处理.但是从全局来看,我只需要维护中国这个地址就够了.</font></p><p><font face="华文中宋" size="3">还有一点,随着设备越来越多,而且还有虚拟化的设备和网卡,有很多工具还可以对 MAC 地址进行修改,就很难保证不冲突了,也就是说, MAC 地址也只是理论上是全球唯一,对于 MAC 地址,最低要求是在一个局域网内, MAC 地址是唯一的.<br>MAC 的设计方式,虽然不能保证绝对唯一(毕竟世界上没有非常绝对的事情),但是能够保证在一个局域网内出现冲突的概率很小.这样的设计,就能够让一台机器启动的时候,在没有 IP 地址的情况下,可以先用 MAC 地址进行通信,获得 IP 地址.<br>如果在局域网内,还能出现 MAC 地址冲突的话,那就让网络工程师采取一定的机制解决冲突就好了,这方面我就不擅长了.</font></p><p><font face="华文中宋" size="3">以上.<br>接下来打算系统总结一下算法方面的知识.<br>最后,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]总结一下最近在做的事情</title>
      <link href="/posts/a3f84cce.html"/>
      <url>/posts/a3f84cce.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近更新频率特别低,我能感受到.因为技术方面的输入比较少了,所以不知道该输出什么有干货的内容给大家.<br>那我就说一下最近在做的几件事情吧,希望这其中的碎碎念,也能给你一些启发.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">1 ,转到项目管理.<br>项目管理对于当下的我来说,挑战特别大.<br>刚被提拔上来的时候,我是很懵逼的,我不知道这件事情到底是不是该我负责,这件事情到底需不需要我去做,不像以前只管开发就行了,上面分配什么我就去做什么就 OK 了.很多事情都需要我去思考,需要我不断的去问为什么,不断的去逼近问题的本质.<br>在这个过程中,慢慢对敏捷开发有了一些认识.刚开始提出来的时候,整个人对流程都是很懵的,到现在对整个流程的熟悉让我有了一种上手的感觉.<br>我开始知道从哪儿能够跟踪到整个团队的进度,知道之所以出现这样的问题是哪儿个环节没有做好,下次要怎么改正,开始能够发现到问题.<br>这段经历,对我来说真的是一个转变,让我不再沉迷于技术,而是抬起头来也看了看天空.<br>当然了,技术还是目前我所需要沉淀的,后期技术深度和广度的涉猎内容,会再提上日程.<br>生命不息,学习不止~</font></p><p><font face="华文中宋" size="3">2 ,准备自考毕设.<br>这是我最近比较头疼的一件事.我对 PB 是很不熟的那种,平时因为各种事情一直在拖,直到现在不能再拖延了,才开始动手. 20 号就要开始答辩,而自己还没怎么做,内心慌得一批.<br>可能是因为自己的运气比较好,每次遇到事情的时候,都有人出来帮助我.超级感谢颖娟,自考毕设的事情,她的功劳占据 70% ,很感谢身边的朋友一直都是这样,无私不求回报的帮助我.<br>这段时间,紧赶慢赶总算是在今天把论文初稿定出来了,邮寄给了自考负责的老师,现在就是等老师的批改意见,然后再进行修改什么的,就等着答辩就 OK 了.<br>等自考答辩完毕之后,准备自学考试.用我朋友的话说就是:我不是在考试,就是在考试的路上.</font></p><p><font face="华文中宋" size="3">3 ,尝试的一些其他事情.<br>对于一个技术人来说,最怕的就是沉迷于自己的技术世界,还不自知.我一直都深知这一点,所以也在尝试不同的事情.<br>第一就是读书.<br>在读各种书籍,刚去看了一下,电子书 + 实体书一共看了 30+ 本书了.今年打算看至少 50 本书的,目前来看这个目标今年达成是没什么问题的.<br>读的书籍很杂,有关于个人发展的,有关于管理方面的,有心理学方面的,最喜欢东野圭吾先生的书,每次读都沉进去出不来.<br>第二就是在尝试打破自己的交际圈.<br>因为身边人都是技术型人才,在一个圈里面,眼光视野难免有所局限,我在逐渐打破自己的交际圈.<br>也算是比较幸运,认识了几位比较厉害的大佬.具体多厉害我就不说了,就是由这件事让我知道,很多东西只要我想去尝试,那么我就能够达到自己的期望,而且如果再积极主动一些,一般都能做得更好一些.<br>第三就是开眼.<br>一个人想要尝试副业赚钱的前提是,知道自己的独特优势.<br>我还不知道,所以目前在看各种赚钱案例,在研究各位巨人是怎么一步步定位自己的.<br>开眼这件事,非常重要,接触不同的人之后,你会知道原来还能这样玩,原来还可以这么去做,还能从这个角度去想.<br>不断的去打破自己的思维局限,不断的挑战自己的认知,是一件很有趣的事情.<br>目前还是在开眼阶段,因为对各种赚钱案例看的还不够多,研究的还不是很深入,等我厚积的差不多了,我就要开始薄发了.</font></p><p><font face="华文中宋" size="3">以上就是最近在折腾的一些事情.<br>一句话,和大家共勉:要记住每个对你好的人,因为他们本可以不这么做的.<br>我几乎每天都会这样去提醒自己,所以每天对我来说都很惊喜.<br>最后,祝大家中秋快乐啊~(这篇碎碎念又有点儿长了,感谢你看到这里)</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]虚拟机中的网卡</title>
      <link href="/posts/5c46b427.html"/>
      <url>/posts/5c46b427.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近在学习极客时间上的一门课程&lt;趣谈网络协议&gt;,里面有涉及到虚拟机网络的一些东西.正好一直在接触,站在巨人的肩膀上,我也来写写.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">为什么需要用虚拟网络呢?我在现实世界中扯网线不可以嘛?其实是完全 OK 的,但是这样做的话,成本会非常高,主要有以下几个方面:</font></p><ul><li><font face="华文中宋" size="3">1 ,客户那边需要一台系统, OK ,自己去购买一台服务器,供客户使用.一台服务器可以使用至少是 10 年,在这期间,客户和你解除了合作关系,这台服务器还要不要?可别忘了,当时买这台服务器,可是花了价钱,还要把服务器放在机柜里,布线等等这些过程.</font></li><li><font face="华文中宋" size="3">2 ,客户那边说,给我的这台系统,内存不够用了,怎么办?用的是真实服务器,还能怎么办?把服务器停机弄下来再把内存条装上去.这个过程,客户那边如果还在用服务器,你就这么给弄下来了?还有一点,这个过程是需要人手动去做的,这个人力成本有算进去嘛?一台需要一个人,如果规模大起来,上万台服务器,其中有 100 台服务器需要更换内存,再用人力去解决问题?</font></li><li><font face="华文中宋" size="3">3 ,资源利用率不高.客户那边只需要一个 4 核 8G 的配置,但是服务器一般没有这么低的配置,所以剩下的资源怎么办?只能闲置.</font></li><li><font face="华文中宋" size="3">4 ,这台服务器我给了这个用户使用,然后使用期限到期了,这位用户没有续费,是不是就需要重装系统之后,才能给下一位客户使用?</font></li></ul><p><font face="华文中宋" size="3">这个需求挺大的,对吧?所以就有了虚拟机的概念.<br>虚拟机想要上网,就需要来聊聊虚拟机中的网络是如何工作的.<br>如果你在自己的笔记本上面倒腾过虚拟机,那你对虚拟机的三种联网方式应该会比较熟悉:仅主机模式,桥接模式和 NAT 模式.<br>下面就一个一个模式的来说说,正好倒腾虚拟机这么久,没有很系统的总结过.</font></p><p><strong><font face="华文中宋" size="3">仅主机( host-only )模式</font></strong></p><p><font face="华文中宋" size="3">这种模式,一般不常用,但是也来介绍一下.<br>这种模式提供的只是,物理机和虚拟机之间的相互访问,只是可以实现物理机和虚拟机之间的数据交换,但是虚拟机是没办法访问 Internet 的.<br>实现物理机和虚拟机之间的数据交换有两种方式:一是动态 IP 地址,另外一种是静态 IP 地址.<br>如果是采用动态 IP 地址的话,那就要多做一步:需要将你的网络共享.<br>如果是采用静态 IP 地址的话,虚拟机的 IP 设置,网关, DNS 设置都要注意和虚拟机网卡中相同.<br>此时,你的虚拟机是可以和物理机进行相互访问的.<br>但是请注意,此时你的虚拟机是访问不了 Internet 的!!!<br>host-only 模式,只是负责让你的虚拟机和物理机之间可以相互访问,并不负责让你的虚拟机联网.所以这种模式,一般都不常用.<br>毕竟你倒腾虚拟机,是为了能够上网搭建个集群什么的,对吧.</font></p><p><strong><font face="华文中宋" size="3">桥接( Bridge )模式</font></strong></p><p><font face="华文中宋" size="3">桥接,桥接,意思就是大家都在一个区域内,只是呢,需要一座桥来连接起来.<br>有前提的:就是大家要在一个区域内,也就是说距离不能太远.要不然你在北极,我在南极,这个桥建不起来,对吧.<br>通过这种方式,让虚拟机联网是最快的.因为它就类似于你在局域网中有另外一台电脑,只要虚拟机所在的物理机可以上网,那么通过桥接模式,也就可以上网了.<br>但有一点要注意,就是要保证虚拟机的 IP 和所在局域网的 IP 没有冲突.<br>如果你的物理机所在局域网 IP 地址没什么限制,用这种方法上网就行了,对新手也比较友好.如果 IP 地址比较稀缺,那就最好不要用这种方法上网.</font></p><p><strong><font face="华文中宋" size="3"> NAT ( Network address translate ) 模式</font></strong></p><p><font face="华文中宋" size="3">其实 NAT 联网这种方式,不单单在虚拟机中有应用,在实际中也有应用.比如:你的公司买了一个公网 IP : 114.114.114.114 ,但是你却发现,公司里面是有很多个 IP 地址的.<br>这就是 NAT 模式.具体工作原理就是:公司里面的一个 IP 地址是 192.168.111.111 这个地址想要访问 Internet ,此时这个 IP 地址所发送的请求会被包装成一个数据包,然后这个数据包会通过一个网关或者路由器,这个网关或者路由器的 IP 地址就是公司买的公网 IP .这样网关或者路由器在要发送数据包时,对数据包的 IP 协议层数据进行更改(也就是 NAT ),这样你就可以很顺利的去访问 Internet .这种方法的存在解决了两个问题: 1 , IP 地址稀缺问题; 2 ,公司的局域网 IP 也可以上网.<br>同样的道理,在虚拟机中 NAT 模式上网,也是如此.所以虚拟机中的网络 IP 地址,就算和物理机所在局域网的 IP 地址不一样,甚至不在一个网段内,也是 OK 的.在这里,物理机的 IP 地址就相当于虚拟机的网关,因而在这种模式下,虚拟机是可以 ping 通物理机的,但是物理机不能 ping 通虚拟机.<br>在这种模式下,联网方式也有两种:一是动态获取 IP 地址,另外一种是设置静态 IP 地址.<br>同样,对于新手来说,虚拟机的联网方式,使用动态获取 IP 地址就好了,具体就是在配置文件中,只需要将 onboot 改为 yes ,然后重启网卡,虚拟机就可以连接到网络上了.<br>如果想要设置静态 IP 地址也可以,就需要修改虚拟机网卡的网关,子网掩码和 DNS .<br>一般来说,使用动态获取 IP 地址这种方式就满足了大部分的需求,另外对于静态 IP 地址这一块,我一直没有实践过,怕误导,就不细说了.如果您感兴趣,可以细细钻研一下.</font></p><p><font face="华文中宋" size="3">以上.</font></p><hr><p><font face="华文中宋" size="3">推荐阅读:<br><a href="https://blog.csdn.net/zll_0405/article/details/88375625" target="_blank" rel="noopener">[Kubernetes]浅谈容器网络</a><br><a href="https://blog.csdn.net/zll_0405/article/details/88380279" target="_blank" rel="noopener">[Kubernetes]谈谈容器跨主机网络</a><br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] HTTPDNS 协议</title>
      <link href="/posts/4e5d330.html"/>
      <url>/posts/4e5d330.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在上篇文章中<a href="https://www.dynamic-zheng.com/posts/a43453ce.html">[计算机网络] DNS 协议</a>,介绍了 DNS 协议,它主要做两个功能:根据名称查到具体的地址;针对多个地址做负载均衡,而且可以在多个地址中选择一个距离我最近的地方,让我访问.<br>看起来这种方式无懈可击,但其实也有些问题.<br><a id="more"></a></font></p><h1 id="传统-DNS-存在的问题"><a href="#传统-DNS-存在的问题" class="headerlink" title="传统 DNS 存在的问题"></a><font face="华文中宋" size="3">传统 DNS 存在的问题</font></h1><p><font face="华文中宋" size="3">1 ,域名缓存问题:<br>客户端想要访问一个网址的时候,其实它首先是去看本地的缓存里面有没有这个地址,如果有就直接访问,如果没有才会去询问上级领导.<br>但是这个时候就会有个问题:比如在你上高中的时候,你知道学校旁边有个超好吃的店,后来你再想吃的时候,想都没想,直接去了那家店,结果发现人家关门了,你会不会非常失望?本地缓存也会出现这个问题,有的时候那个地址已经换掉了,但是因为本地缓存中有原来的地址,所以不会向上一级询问,将你导向原来的地址,结果就是访问不到界面,由此带来的用户体验不是很好.<br>还有个问题:假设我在北京海淀区,淘宝的应用因为某种原因没有在海淀区设置数据中心,然后我访问的时候,一直都是将我的访问请求发送到朝阳区.后来呢,淘宝在海淀区增加了数据中心,但是当我访问的时候,本地缓存依旧会将我的请求,导向到朝阳区那边,这样造成的结果就是: 1 ,对于客户来说,让他绕远路了.明明一个区域就可以解决的事情,偏偏要跨区域.就像明明在这里可以买到东西,偏偏让你跑到另外的地方去买,你开心嘛? 2 ,对于商家来说,也就是淘宝,我设置了新的数据中心,结果呢,客户的请求没能到这里,那我还费钱费力的去做这件事干嘛?又没有提高用户的体验,对不对.</font></p><p><font face="华文中宋" size="3">2 ,出口 NAT 问题:<br>在网关那里,很多机房都会在出口配置 NAT ( Network Address Translation ),即:网络地址转换.<br>也就是说,从这个网关出去的包,都会换成新的 IP 地址,当请求返回的时候,在网关这里,再将 IP 地址转换回去,这样造成的结果就是,权威的 DNS 服务器,没办法通过这个地址,来判断用户到底是来自哪个运营商,而且极有可能因为误判运营商,导致跨运营商访问,从而导致网速极慢.</font></p><p><font face="华文中宋" size="3">3 ,解析延迟问题:<br>DNS 的查询过程,需要递归遍历多个 DNS 服务器,才能得到最终的解析结果,这会带来一定的时延,甚至是解析超时.</font></p><h1 id="HTTPDNS-的工作模式"><a href="#HTTPDNS-的工作模式" class="headerlink" title="HTTPDNS 的工作模式"></a><font face="华文中宋" size="3">HTTPDNS 的工作模式</font></h1><p><font face="华文中宋" size="3">DNS 解析有很多问题,那怎么办呢?再回到最初的起点:直接 IP 地址?显然不合适啊.<br>这就引出了 HTTPDNS .说白了就是,它不走传统的 DNS 解析,而是走自己搭建基于 HTTP 协议的 DNS 服务器集群.这些集群分布在多个地点,当客户端需要 DNS 解析的时候,直接通过 HTTP 协议进行请求这个服务器集群,就可以得到最近的地址.<br>这样做就相当于每个客户端都是基于 HTTP 协议的,自己实现自己的域名解析,自己做一个自己专属的地址簿,而不是使用统一的地址簿.但是默认的域名解析都是走 DNS ,所以如果想要使用 HTTPDNS 的话,就需要绕过默认的 DNS 路径,这样就不能使用默认的客户端.<br>使用 HTTPDNS 的,一般都是手机应用,所以只需要在手机端嵌入支持 HTTPDNS 的客户端 SDK 就 OK 了.这样就可以通过自己的 HTTPDNS 服务器和相关的 SDK ,实现了从依赖别人,到自己上网查询,自己想去哪儿去哪儿,想干什么干什么,岂不是快哉~<br>HTTPDNS 工作模式具体可以描述如下:当手机要访问一个地址的时候,我会先看本地缓存里面有没有,如果有就直接访问,这个缓存是手机应用自己做的,至于如何更新,何时更新,那是手机应用的客户端的事情;如果没有的话呢,就需要请求 HTTPDNS 服务器,在本地 HTTPDNS 服务器的 IP 列表中,选择一个发出 HTTP 的请求,会返回一个要访问的网站的 IP 列表.因为是直接的 HTTP 通信,所以 HTTPDNS 服务器能够准确知道这些信息,所以可以做到精准的全局负载均衡.</font></p><p><font face="华文中宋" size="3">写到这里,这篇文章想要表达的是两点:<br>1 ,传统的 DNS 有很多问题:比如域名缓存问题,出口 NAT 问题,解析延迟问题<br>2 ,为了解决上述问题, HTTPDNS 通过客户端 SDK 和服务端,通过 HTTP 的形式,直接调用解析 DNS 的方式,绕过了传统的 DNS 的这些缺点,从而实现了智能的调度.</font></p><p><font face="华文中宋" size="3">以上是学的极客时间上&lt;趣谈网络协议&gt;这门课程,我已经感觉自己的脑袋有些大了…还有一些内容,我先自己慢慢消化一下…<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPDNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] DNS 协议</title>
      <link href="/posts/a43453ce.html"/>
      <url>/posts/a43453ce.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">大家应该都知道,当我访问一个网址的时候,实际上我是在访问一个 IP 地址.那为什么不记 IP 地址,反而要去访问一个网站名字呢,比如谷歌.<br>你可以想想,现在有多少网站,数不过来对吧?就算数的过来, 直接访问那么多的 IP 地址,恐怕也是记不过来的.不信你就记一串数字试试,是记一串数字容易,还是记一个 google 名字容易.<br><a id="more"></a><br>接下来有没有新的疑问?既然我在访问一个网址的时候,实际上是在访问一个 IP 地址,那浏览器怎么知道会到这个 IP 地址呢?<br>所以这就是 DNS 协议要做的事情:根据一个名称,我就可以访问到具体的 IP 地址.</font></p><h1 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h1><p><font face="华文中宋" size="3">每个人上网,都会访问网址,都会用到 DNS ,所以它是非常重要的,但这也是对它的挑战.因为只要它一旦出现了故障,那么整个互联网都几乎会瘫痪,因为你访问不到网址了嘛.<br>此外,上网的人分布在全世界,如果 DNS 服务器部署在一个地方,那么造成的访问时长会非常长,这样来分析的话, DNS 服务器一定得是高可用,高并发,分布式才能满足需求.<br>基于这样的需求,就有了树状的层次结构.</font></p><h1 id="DNS-解析流程"><a href="#DNS-解析流程" class="headerlink" title="DNS 解析流程"></a>DNS 解析流程</h1><p><font face="华文中宋" size="3">在全世界各地,都需要 DNS 来进行解析,所以为了提高 DNS 的解析性能,很多网络都会就近部署 DNS 缓存服务器,那么它是如何解析的呢?</font></p><ul><li><font face="华文中宋" size="3">1 ,当你想要访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的时候,你的电脑就会发出一个 DNS 请求,询问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 是什么,发给本地域名服务器(本地 DNS ).如果是通过 DHCP 来配置的话,那本地的 DNS 就是由你的网络服务商,比如电信,移动等自动分配.</font></li><li><font face="华文中宋" size="3">2 ,本地 DNS 收到来自客户端的请求之后,就开始找,看看能不能找到 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> ,如果可以的话,那就直接返回这个网址对应的 IP 地址.但是如果没有呢,那它就往上一级问.但是它的老大不直接进行域名解析,而是给出一个解决方案.</font></li><li><font face="华文中宋" size="3"> 3 ,它的老大发现请求是 .com,就说这个网址是由 .com 区域管理的,我帮你介绍一下,你去问问它.</font></li><li><font face="华文中宋" size="3">4 ,本地 DNS 就转向老大帮忙给介绍的那位朋友,说哥们,你能告诉我 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的 IP 地址嘛,但是这个哥们人家负责的是 .com 的所有,你问的是 google.com 的,它这里可能没有,然后就回复说,我这里没有,但是我知道谁负责 google.com 这一块的内容,你问问他可以吧.</font></li><li><font face="华文中宋" size="3">5 ,接下来,本地 DNS 就转向那位负责 google.com 的负责人,向人家询问,您好,请问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的 IP 地址是啥呀?我的小主现在想要访问这个网址.</font></li><li><font face="华文中宋" size="3">6 ,那位负责人在这里经过查询之后,就告诉本地 DNS , <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的 IP 地址是什么,此时本地 DNS 拿到 IP 地址之后,返回给客户端,这样客户端就和目标建立了连接.</font></li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><font face="华文中宋" size="3">在上面的介绍中,那是一次 DNS 递归查询过程,因为本地 DNS 会全权为客户端效劳,所以只需要坐着等结果就行了.其实在这个过程中, DNS 除了可以通过名称映射为 IP 地址之外,还可以做另外一件事情,就是负载均衡.<br>什么意思呢?举个例子哈:我是河南濮阳人,让濮阳人最挂念的就是凉皮了,而凉皮里面最有名的则是「户大姐」这个品牌.现在我想吃户大姐的凉皮,但是我在北京,那我就在北京找一家店就去吃就行了,你在杭州,那你在杭州找家店吃就行.咱们不用非要去濮阳那一家店去吃.这就是负载均衡(我好像暴露了自己吃货的本性…)<br>投射到 DNS 上来,它也可以做成这样.</font></p><p><font face="华文中宋" size="3">DNS 可以做内部的负载均衡:<br>比如一个应用想要访问数据库,其实我们应该给它配置这个数据的 IP 地址才对,但是如果这个数据库因为某种原因,宕机之后,我该怎么办?需要将所有的用到这台数据库的 IP 地址,都进行更换.<br>如果使用域名的话,就比较简单了,这台数据库宕机之后,没问题,我只需要在 DNS 服务器中,将域名映射为新的 IP 地址就可以了.<br>这个过程,极大的降低了人力和时间成本.</font></p><p><font face="华文中宋" size="3">DNS 可以做全局负载均衡:<br>像淘宝, QQ ,微信这种应用,为了保证高可用,肯定会将这些应用部署在多个机房,每个地方都会有自己的 IP 地址.当用户要在淘宝上买东西的时候,那么这个 IP 地址就可以轮询访问多个数据中心.如果在广州的某个数据中心因为某种原因挂掉了,只需要在 DNS 服务器里面,将这个数据中心对应的 IP 地址删除就可以了,接下来就不会再去询问这个数据中心了.<br>此外,为了让客户体验比较好,访问速度比较快,肯定是希望在北京的用户访问北京的数据中心,在上海的用户,访问上海的数据中心.<br>这就是全局负载均衡的概念.</font></p><p><font face="华文中宋" size="3">最后,总结一下:</font></p><ul><li><font face="华文中宋" size="3">DNS 是网络世界的地址簿,可以通过域名查地址,因为域名服务器是按照树状结构来组织的,所以域名查找使用的是递归方法,并且通过缓存的方式来增强性能;</font></li><li><font face="华文中宋" size="3">在域名和 IP 的映射过程中,可以给应用做简单的负载均衡,也可以根据地址来做全局的负载均衡.</font></li></ul><p><font face="华文中宋" size="3">以上,感觉您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[年中总结]一个骄傲而又自卑的人的内心独白</title>
      <link href="/posts/37f969d7.html"/>
      <url>/posts/37f969d7.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">距离上次总结<a href="https://blog.csdn.net/zll_0405/article/details/83415343" target="_blank" rel="noopener">[年终总结]愿你永远清澈明朗,眼里有光</a>,过去了差不多有半年的时间,来回顾一下这半年的得与失.<br>我先以时间为节点,然后再说说碎碎念.<br><a id="more"></a></font></p><hr><p><font face="华文中宋" size="3">这一回顾,可能就要从 18 年 12 月份开始说了,当时井朝老大找我说项目要用 k8s ,让我找几个人一起研究研究.还记得当时我是推了所有的项目来专攻 k8s 的,钻进去了一个月,最后总算是钻出来了一些东西.</font></p><p><font face="华文中宋" size="3">19 年 1 月初,接到消息,让我去广州那边出差,当时第一反应是庆幸,还好把这边的事情弄完了,可以放心去.<br>到了广州那边,熟悉项目开发环境,适应新环境.<br>我总觉得实践完 k8s 之后,一定要去补充理论知识,否则就只是停留在会用的程度上,不会有什么深度.所以在广州出差的时候,白天工作,晚上到宾馆继续学习补充 k8s 的理论知识.但是没想到知识竟然那么多,从 1 月份断断续续学到了 4 月份(主要是拖延症太厉害).</font></p><p><font face="华文中宋" size="3">2 月份,项目转战到宜昌,一直到我回来之前,都是在这个地方度过的.<br>真的是体会到了南方多雨,几乎是没有看到过太阳.刚去各种不适应,最不习惯的地方就是吃了.南方吃的都偏辣,而我偏偏是有些不能碰辣的,脸上频繁爆痘,也没什么食欲,常常是需要刺激着胃才能吃的下去东西,相应的工作状态也不是太好,不过还好,算是挺过来了.<br>但是宾馆的老板娘很好,特别好说话.刚去的时候,我是觉得有些冷的,南方的冷是阴冷.</font></p><p><font face="华文中宋" size="3">3 月份,白天工作,晚上回去开始弄学院论文,因为 4 月份就要开始答辩,而自己的论文还没开始.<br>那段时间压力的确很大,项目,论文,自考,读书,各种事情赶在一起,有种心有余而力不足的感觉.而那一阵,总是头疼,可能真的是因为压力大的缘故.内心一度到过崩溃的地步,有时候真的特想破罐子破摔,什么都不管了,可是如果就那样轻易放弃,内心里却又有不甘.就这样,跌跌撞撞的挺了过来.</font></p><p><font face="华文中宋" size="3">4 月份,学院答辩,出人意料很顺利.还记得四月份答辩完之后,再往回看的时候,觉得挺过去之后原来也不过如此.现在再回忆,竟然觉得有点儿充实.<br>这个月也经历了自考,那段时间每天晚上回到家还会再学一会儿,一家人一起努力的感觉真的是超棒.<br>月底的时候,来了一场分享,对我来说是一种锻炼,第一次在那么大的舞台上展示自己.还好,我还能 hold 住.<br>4 月对我来说,是一个很忙的岁月,每天头疼到爆炸,当时心态都要崩了,最后总算是熬过来了.嗯,真的是熬过来了.</font></p><p><font face="华文中宋" size="3">5 月份,印象最深刻的就是,在线上给将近一千人进行了一场分享,在分享之前,我是有些怂的,因为里面大佬很多,而我只是一个小白而已.但是没想到能够得到那么多人的认可,也因此认识了很多优秀的人,深入交流了很多.也更加深刻的体会到了「分享」的好处.<br>还有一个挑战就是,将近月底的时候,项目上需要我在几天之内做出来一个界面.对我来说之所以是个挑战,是因为用的 Ionic ,这个我不太熟悉,相当于从 0 开始做.还好有前人的经验,加加班,最后在期限之前做了出来.<br>接任了项目总组长的职位,这个职位我感觉有很大一部分的幸运成分在里面,感谢吧,感谢如此信任我.<br>这一个月还忍痛放弃了一个赚钱的项目.真的是忍痛,没办法,我的时间精力在这儿,不可能每件事都做好,所以只能放弃.详细就不说了,说多了都是泪.</font></p><p><font face="华文中宋" size="3">6 月份,怎么说呢,是一个超级忙碌的月份.担任了考试负责人,月底就要项目带着上线,一个毫无经验的人,到了这个位置,很多东西都逼着我去做,去成长.面临的各种问题,各种难题,真的,如果你没经历真的体会不到.<br>这个月也在慢慢和别人磨合,尝试更好的去沟通.很多问题都是因为没有沟通,而产生的问题,所以如果能够沟通好,那些所谓的问题就不再是问题了.<br>因为各种原因,考评这边人手不够,我就去拉人.当时找到了玉彬和金颖,我和他们说,考评这边需要你们,就这一句话,他们放弃了自己手头的工作,二话不说就加入了进来.当时都被他们暖到了,真的特别感激这份信任和帮助.<br>还有很多其他小伙伴,这一说要感谢的人就很多了,所以就不说了<br>也是毕业的一个月,我彻底失去了学生这个身份.对于大学,感觉不算遗憾吧,各种滋味都体验了一遍,也不后悔,如果时光倒流,我依旧会选择这里,依旧选择这样生活.<br>当下,对我来说就是最好.</font></p><p><font face="华文中宋" size="3">7 月份,项目正式上线,其实出现了很多问题,但是因为有很多人的帮助,所以到最后都有惊无险,终于算是上线成功了吧.写了一个复盘,感兴趣可以瞅瞅:<a href="https://blog.csdn.net/zll_0405/article/details/94194270" target="_blank" rel="noopener">[复盘]记录一次带项目上线的经历</a><br>项目上线成功之后,就回家了.一直在准备项目上线的事情,真的是累坏了,所以回到家之后,开始了吃了睡,睡了吃的生活.我只有在家的时候,才会这么放松,可以全身心,什么都不想.和家人在一起,总是能让我收获很多力量.<br>呆了一周,又回到了工作岗位. 7 月份对我来说,是转型的一个月,开始从开发转到管理的一个月.<br>啊,对了,把运维负责人交接出去了~带新人带了有一年了,看到他也能够成长起来,很开心,交接给他,也可以很放心.</font></p><p><font face="华文中宋" size="3">8 月份到现在,开始慢慢适应「管理」的角色.<br>其实就我个人来说的话,我是感觉我是不适合担任「管理」的角色,但是当你主动去承担一些东西的时候,你会发现慢慢地开始把你往管理上推.<br>在其位,谋其政.既然在这个位置上,那就好好干,对自己负责,也是对别人负责.<br>前期也就是现在,觉得很吃力,但是我知道这也是我成长的地方,所以就慢慢磨吧.<br>什么事情都是慢慢来的.</font></p><p><font face="华文中宋" size="3">这半年的收获,说起来是很多的.<br>接下来说说这半年的碎碎念,毕竟除了上面的几件大事,我也思考了很多东西.</font></p><hr><p><font face="华文中宋" size="3">在外出差的那几个月,特别是过年那段时间,白天还在家,晚上就到了北京,第二天就到了廊坊,下午又到了北京,晚上睡了一觉醒来就在广州了,过了几天又到了宜昌.那段时间一直都觉得像是在做梦一般,不真实.<br>反正这半年的多数时间,不是在出差,就是在去出差的路上.火车,高铁,动卧,飞机,各种交通工具算是做了个遍.光是交通费,可以说也是一个收获了.</font></p><p><font face="华文中宋" size="3">有时候越想,越觉得自己很是幸运.当初想换个地方工作,结果就有机会来到南方看看.在南方浪完了,想回到北方,刚好又有机会可以回去.真的,有时候越想,对于发生的一切,就越感到感恩.<br>遇到的人,经历的事情,一切都刚刚好.<br>在广州的时候,唯一的遗憾就是还没好好玩,就撤了.期间经理请大家一起吃了顿饭,算是看了看那里的山,后来又去市中心一起嗨歌.这是在广州玩的印象.<br>后来去宜昌,三峡在那儿,还有别的风景区.因为在宜昌呆的时间比较长,所以周末休息的时候,会一起约着玩.<br>想到家豪哥,还有胡哥,内心的感激之情真的是不知道该怎么表达.身为男孩子的他们,一直对我和晓鸿照顾有加,而且两位都是很负责任的小哥哥,反正和他们在一起出差,什么事情都不需要操心的.也很庆幸,在出差的那段时间,一直都有晓鸿陪着我,喜怒哀乐都有她陪着.<br>南方以后有机会,还是会再去的.</font></p><hr><p><font face="华文中宋" size="3">如果你有出差在外的经历的话,应该能体会到在外面还能坚持学习的可贵.我在外面出差的那段时间,还能做到每周一篇博客,质量我也是敢打保证的.<br>之所以能够做到这样,是因为有人督促着我,带着我一起学.我很感激身边有这样的人带我,自考的时候,佳兴,小哲哲在晚上回家之后,还带着我学 1 个小时;恩君小姐姐有时候会给我分享一些我没有接触到的知识.<br>可能他们觉得带我学是一件双赢的事情,但是目前为止我感觉我没给对方带来什么,反而是我从对方那里,学到了很多.<br>是真的心存感激.</font></p><p><font face="华文中宋" size="3">说到朋友,真的是一件值得庆幸和骄傲的事情.庆幸交到的朋友每个人都是真诚的,都是善良的,而且每个人都是积极向上的.骄傲的是,交到的朋友对我都超级超级好.<br>哈哈哈,不要太羡慕我,我就是这么一个幸运儿~<br>感激这一路,一直陪伴的朋友们</font></p><hr><p><font face="华文中宋" size="3">在担任项目负责人的时候吧,有好几次真的是想撂挑子就不干了那种,压力大到有时候晚上都睡不着觉.害怕如果上线出各种问题怎么办,如果学生不能考试怎么办,虽然有别人顶着,但是你是这个项目的负责人,如果追责,我肯定是第一个要顶上去.<br>后来强迫自己早上 5 点半就起,中午也不允许自己休息,让自己保持这样的状态,晚上才能睡着那么一会儿.压力再大的话,就自己一个人在人民公园一圈一圈跑步.<br>现在往回看,我很感激这段经历.这段经历确实给我带来的压力很大,但也是我成长最快的一个月.<br>感谢那段时间所有同事的付出,如果没有他们的配合,项目是不可能上线的.</font></p><hr><p><font face="华文中宋" size="3">一个人如果能够想明白自己是谁,自己是怎样一个人,自己需要的是什么,那么他就会通透许多.而这半年来的经历,有很多时间都属于自己,再加上在外地出差的缘故,和自己关系好的朋友都没在身边,就使得我自己开始和自己对话.<br>接受自己的不完美,接受自己的平凡.尝试着接受自己,和自己和解,这一点说难也难,说简单也简单.我天生有些愚笨,到现在才肯些许接受当下的这个自己.<br>我感觉我以前做过许多错事,可能在别人看来那不是错事,反而是一段很美好的经历,但是对于我这样的性格来说,我还是有些不能接受的,所以我多少还是有些自卑的.这半年,开始慢慢接受自己,接受自己的不完美.<br>当我开始慢慢接受这个真实的自己时,我发现以前的迷茫,痛苦减轻了许多.<br>对我来说,最难的一件事,就是接受我自己.嗯,我在努力.</font></p><p><font face="华文中宋" size="3">很难想象,我这样一个喜欢热闹,喜欢和别人聊天的人,竟然也可以很长时间,悠然自得的和自己独处,我觉得现在如果再让我随意去一个地方,一个人呆很长的时间,我也是可以的.因为我很享受自己一个人的时候.可以看看书,听听歌,或者什么都不做,静静发呆,都觉得很好.<br>但是我这个人又是有些矛盾的,从某种程度上,我还是有些依赖人.特别是刚到一个新的地方,我会特别特别依赖别人.其实说到底,我还是没能好好和自己相处.<br>也不急,慢慢来吧,一个人想要达到自己的内心深处,是需要时间的. </font></p><p><font face="华文中宋" size="3">还有我这个人,身上毛病挺多的.比如脾气暴躁易怒,控制不住自己的情绪,也不会处理和别人的关系,闹了矛盾也不知道该怎么去解释.还特别容易敏感.</font></p><p><font face="华文中宋" size="3">如果你认识之前的我,就会知道我身上的戾气,知道其实我有多偏执.<br>读书,经历,这些真的会让你看透很多东西.</font></p><hr><p><font face="华文中宋" size="3">每次的总结,年中也好,年终也罢,都会提到我的父母.因为他们为我付出的,牺牲的东西真的是太多太多了.<br>我感恩我的父母为我付出的一切,感恩他们对于我一直都是舍得的,他们一直都是我想要变得更好的动力.</font></p><p><font face="华文中宋" size="3">上半年,经历的事情,思考的内容算是挺多的了,读书也是一直在做的.因为我清楚的知道,同样都是技术人员的话,那么拉开你和其他技术人员的差距,就在于你另外 20% 的思考与输出.所以这半年,书看了很多,也持续输出了一些内容.</font></p><p><font face="华文中宋" size="3">对于接下来的半年,继续技术沉淀,更加的踏实做事,积极主动,死不要脸,在成就自己的同时,也尽力成就他人.<br>以上,就是来自一个骄傲而又自卑的人的内心独白.</font></p><p><font face="华文中宋" size="3">最后,我特别感谢一直在阅读我文章的你们.是你们一直给我评论,给我鼓励,让我能够坚持到现在.<br>真的,特别感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年中总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] P2P 协议</title>
      <link href="/posts/1269457e.html"/>
      <url>/posts/1269457e.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在上篇文章中说过<a href="https://www.dynamic-zheng.com/posts/17a04cff.html#more">[计算机网络] FTP 协议</a>,要写写 P2P 协议的,嗯,来写写,虽然写的不是太好.<br><a id="more"></a></font></p><h1 id="P2P-是什么"><a href="#P2P-是什么" class="headerlink" title=" P2P 是什么?"></a><font face="华文中宋" size="3"> P2P 是什么?</font></h1><p><font face="华文中宋" size="3">还是要回到这个场景:<br>如果想要下载一个电影,一般都是通过什么方式呢?<br>我希望这次你的答案,除了 HTTP 方式,还有 FTP 方式(要不上篇文章岂不是白写了?)<br>但是你发现了嘛,不管是 HTTP 的方式,还是 FTP 的方式,都有一个比较大的缺点,就是难以解决单一服务器的带宽压力,因为它们使用的都是传统的客户端服务器的方式.<br>这个时候,一种创新的, P2P 协议就开始流行起来. P2P 就是 peer-to-peer .<br>传统的方式不是把资源都集中地存储在某些设备上了嘛,那我就创新一下,我不让这些资源都集中在某些设备上了,我让这些资源都分散的存储在多台设备上面去.这些设备,为了理解方便,我们称为 “ peer “</font></p><p><font face="华文中宋" size="3">那么,当我想要下载一个文件的时候,我只要得到那些已经存在了文件的 peer ,和这些 peer 建立点对点的连接,而不需要到中心服务器上面去,我就可以就近下载文件了.<br>一旦下载了文件,你也就成为了 peer 中的一员,你旁边的那些机器,也可能会选择从你这里下载文件.<br>所以当你使用 P2P 软件的时候,往往能够看到,它既有下载的流量,也有上传的流量,也就是说,你自己也加入了这个 P2P 的网络,自己从别人那里下载,同时也提供给其他人下载.<br>你可以想一下,这种方式,是不是参与的人越多,下载速度就越快,一起简直是完美啊~</font></p><h1 id="种子-torrent-文件"><a href="#种子-torrent-文件" class="headerlink" title="种子 (.torrent )文件"></a><font face="华文中宋" size="3">种子 (.torrent )文件</font></h1><p><font face="华文中宋" size="3">这里其实是有一个问题的,当我想要下载一个文件的时候,我怎么知道哪儿些 peer 有这个文件呢?<br>这就是种子文件,也就是「 torrent」文件.它由两部分组成: announce ( tracker URL )和文件信息.</font></p><ul><li><font face="华文中宋" size="3">文件信息里面有这些内容:<ul><li>info 区:这里指定的是该种子有几个文件,文件有多长,目录结构,以及目录和文件的名字;</li><li>Name 字段:指定顶层目录名字;</li><li>每个段的大小: BitTorrent ( 简称 BT )协议把一个文件分成很多个小段,然后分段下载;</li><li>段哈希值:将整个种子中,每个段的 SHA-1 哈希值拼在一起.</li></ul></font></li></ul><p><font face="华文中宋" size="3">下载时, BT 客户端首先解析 .torrent 文件,得到 tracker 地址,然后连接 tracker 服务器. tracker 服务器回应下载者的请求,将其他下载者(包括发布者)的 IP 提供给下载者.下载者再连接其他下载者,根据 .torrent 文件,两者分别告诉对方自己已经有的数据,然后交换对方没有的数据.这个时候,就不需要其他服务器的参与,就分散了单个线路上的数据流量,从而减轻了服务器的负担.</font></p><p><font face="华文中宋" size="3">从上面的过程,我们能够看出, P2P 这种方式特别依赖 tracker . tracker 需要收集下载者信息的服务器,并且将这些信息提供给其他下载者,使得下载者们相互之间能够连接起来,传输数据.虽然说,在整个下载的过程中,是非中心化的,但是加入这个 P2P 网络的时候,都需要借助 tracker 中心服务器,因为 tracker 服务器是用来登记有哪些用户在请求哪些资源.<br>到这里你可能就会比较清楚了,这种方式的限制就是 tracker 服务器.只要它出现故障或者线路遭到屏蔽, BT 工具就没办法再正常工作了.</font></p><h1 id="去中心化网络-DHT"><a href="#去中心化网络-DHT" class="headerlink" title=" 去中心化网络( DHT )"></a><font face="华文中宋" size="3"> 去中心化网络( DHT )</font></h1><p><font face="华文中宋" size="3">在整个下载的过程中,是非中心化的,但是它还是受限制的.那到底能不能做到彻底非中心化呢?<br>所以就有了 DHT ( Distributed Hash Table )的去中心化网络.每一个加入这个 DHT 网络的人,都要负责存储这个网络中的资源信息和其他成员的联系信息,相当于所有人一起构成了一个庞大的分布式存储数据库.<br>在这里有一种著名的 DHT 协议,叫 Kademlia 协议.</font></p><h1 id="Kademlia-协议详解"><a href="#Kademlia-协议详解" class="headerlink" title=" Kademlia 协议详解"></a><font face="华文中宋" size="3"> Kademlia 协议详解</font></h1><p><font face="华文中宋" size="3">在 Kademlia 协议中,任何一个 BitTorrent 启动之后,它都有两个角色.一个是 peer ,监听一个 TCP 端口,用来上传和下载文件,这个角色就是为了说明,我这里有某个文件.另一个角色 DHT node ,监听一个 UDP 的端口,通过这个角色,这个节点加入了一个 DHT 的网络.<br>在 DHT 网络中,每一个 DHT node 都有一个 ID .这个 ID 是一个很长的串.每个 DHT node 都有责任掌握一些知识,也就是<strong>文件索引</strong>,也就是说,它应该知道某些文件是保存在哪些节点上.它只需要知道这些东西就行了,不一定就是保存这个文件的节点.<br>这样我想要实现去中心化就好实现了.</font></p><p><font face="华文中宋" size="3"> 以上就是想要分享的内容了,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P2P </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] FTP 协议</title>
      <link href="/posts/17a04cff.html"/>
      <url>/posts/17a04cff.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">其实这篇文章本来打算写 P2P 协议的,结果发现写 P2P 协议的时候,需要写 FTP 协议,然后写完之后发现已经写了很多了.<br>好吧,这篇文章就先来写 FTP 协议,下篇文章再写 P2P 协议.<br><a id="more"></a></font></p><h1 id="先来一个场景"><a href="#先来一个场景" class="headerlink" title="先来一个场景:"></a><font face="华文中宋" size="3">先来一个场景:</font></h1><p><font face="华文中宋" size="3">如果想要下载一个电影,一般都是通过什么方式呢?<br>能想到的,或者最先想到的就是通过 HTTP 来下载对吧?但是你有没有过这样的体验,就是通过浏览器下载的时候,只要这个文件稍微大一些,下载的速度就会特别慢,特别是下载自己最想要看的电影的时候,你会觉得,我的天啊,怎么这么慢啊~<br>还有一种下载文件的方式,就是通过 FTP ( File Transfer Protocol ,文件传输协议).</font></p><ul><li><font face="华文中宋" size="3">FTP 有两个端口,一个是 20 ,一个是 21 ,所以 FTP 会采用两个 TCP 连接来传输一个文件.<ul><li><font face="华文中宋" size="3">控制连接:服务器以被动的方式,打开众所周知用于 FTP 的端口 21 ,客户端则主动发起连接.该连接将命令从客户端传给服务器,并传回服务器的应答.常用的命令有: list -获取文件目录; reter -取一个文件; store -存一个文件.</font></li><li><font face="华文中宋" size="3">数据连接:每当一个文件在客户端与服务器之间传输时,就创建一个数据连接</font></li></ul></font></li></ul><h1 id="FTP-的两种工作模式-详细讲讲这部分"><a href="#FTP-的两种工作模式-详细讲讲这部分" class="headerlink" title="FTP 的两种工作模式(详细讲讲这部分)"></a><font face="华文中宋" size="3">FTP 的两种工作模式(详细讲讲这部分)</font></h1><ul><li><font face="华文中宋" size="3">每传输一个文件,都要建立一个全新的数据连接. FTP 有两种工作模式,分别是主动模式( PORT )和被动模式( PASV ),这些都是站在 FTP 服务器的角度来说的.<ul><li><font face="华文中宋" size="3">主动模式:客户端随机打开一个大于 1024 的端口 N ,向服务器的命令端口 21 发起连接,同时开放 N+1 端口监听,并向服务器发出 “port N+1 “命令,由服务器从自己的数据端口 20 ,主动连接到客户端指定的数据端口 N+1 .</font></li><li><font face="华文中宋" size="3">被动模式:当开始一个 FTP 连接时,客户端打开两个任意的本地端口 N (大于 1024)</font></li></ul></font></li></ul><h1 id="主动模式-PORT-下-FTP-连接步骤"><a href="#主动模式-PORT-下-FTP-连接步骤" class="headerlink" title="主动模式( PORT )下, FTP 连接步骤:"></a><font face="华文中宋" size="3">主动模式( PORT )下, FTP 连接步骤:</font></h1><p><font face="华文中宋" size="3">1 ,客户端随机打开一个大于 1024 的端口 N ,同时一个 FTP 进程连接至服务器的 21 的命令端口.此时,我们来梳理一下,源端口为客户端的随机端口 N ,远程端口为服务器端的端口 21 ;<br>2 ,客户端开始监听端口 ( N + 1 ),同时向服务器发送一个端口命令(通过服务器的 21 命令端口),这条命令就是为了告诉服务器客户端正在监听的端口号并且已准备好从这个端口接收数据;<br>3 ,服务器打开 20 端口,并且建立和客户端数据端口的连接,然后向服务器发送一个应答,告诉服务器,已经建立好了一个连接.<br>看似完美,但是其实是有个问题的,比如客户端的数据端口,防火墙并没有开放,那么你就没办法完成数据的传输.<br>这也是被动模式( PASV )想要解决的问题.</font></p><h1 id="被动模式-PASV-下-FTP-连接步骤"><a href="#被动模式-PASV-下-FTP-连接步骤" class="headerlink" title="被动模式( PASV )下, FTP 连接步骤:"></a><font face="华文中宋" size="3">被动模式( PASV )下, FTP 连接步骤:</font></h1><p><font face="华文中宋" size="3">这种模式,是在客户端通知服务器,它处于被动模式时才启用.<br>在被动方式 FTP 中,命令连接和数据连接都由客户端发起,这样就可以解决从服务器到客户端的数据端口的连接被防火墙过滤掉的问题.<br>1 ,当开启一个 FTP 连接时,客户端打开两个任意的非特权本地端口( N&gt;1024 和 N+1 );<br>2 ,打开两个端口之后,第一个端口连接服务器的 21 端口,与主动方式的 FTP 不同,客户端不会提交 PORT 命令并允许服务器来回连它的数据端口,而是提交  PASV 命令;<br>3 ,此时,服务器会开启一个任意的非特权端口 (P &gt; 1024)并发送 PORT P 命令给客户端.然后客户端发起从本地端口 N+1 到服务器的端口 P 的连接用来传送数据.<br>对于服务器端的防火墙来说,必须允许下面的通讯才能支持被动方式的 FTP ：<br>1 ,从任何大于 1024 的端口到服务器的 21 端口(客户端的初始化连接);<br>2 ,服务器的 21 端口到任何大于 1024 的端口(服务器响应到客户端的控制端口的连接);<br>3 ,从任何大于 1024 端口到服务器的大于 1024 端口(客户端初始化数据连接到服务器指定的任意端口);<br>4 ,服务器的大于 1024 端口到远程的大于 1024 的端口(服务器发送 ACK 响应和数据到客户端的数据端口)</font></p><p><font face="华文中宋" size="3">总结一下,上面所说的那些.<br>在网络传输中,如果想要使用 FTP 协议,如果不是大神,玩的不是很 6 ,建议选择被动模式,一般情况下,能满足需求;<br>如果您是大神,玩的超级 6 ,当我上面什么都没说~</font></p><p><font face="华文中宋" size="3">感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]简单聊聊套接字 Socket</title>
      <link href="/posts/d26db2c7.html"/>
      <url>/posts/d26db2c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Socket-由来"><a href="#Socket-由来" class="headerlink" title=" Socket 由来:"></a><font face="华文中宋" size="5"> Socket 由来:</font></h1><p><font face="华文中宋" size="3">在学习一个新知识之前,要去想它为什么会出现,它的出现解决了什么问题.这样印象才会深刻一些.<br><a id="more"></a><br>在同一个主机下,两个进程间的通讯是很容易,直接把各种通讯细节交给操作系统去做就 OK 了.但是如果两个进程是处于不同主机下呢?该如何进行通讯呢?而且在实际的应用场景中,是很复杂的,有的使用 TCP 协议,有的使用 UDP 协议,那么当我们使用不同的协议进行通信时,是不是就要使用不同的接口?同时还要处理不同协议的各种通讯细节,这样一来,是不是就增加了开发的难度,同时软件不容易进行扩展.<br>编程思想之一就是「面向对象」,同样,在遇到这种问题时,我能不能把不同协议的通信细节抽出来,这样程序员在使用的时候,直接调用,就不需要再关注协议本身了.而这就是 Socket 的由来.<br>它提供接口,来进行互联的不同主机之间的进程通信.你想要让不同主机之间通信? OK ,你直接调用我就行,至于我怎么实现,程序员不需要 care .</font></p><p><font face="华文中宋" size="3">在上面的基础上,我们能够达成一个共识:如果一个应用,需要在客户端和服务端之间进行通信,那就需要创建一个 Socket 实例.<br>那么问题来了,我如何使用?<br>Socket 进行的是端到端的通信,中间经过多少局域网,路过多少路由器,我是不清晰的,所以能够设置的参数,也只是端到端协议之上的网络层和传输层.<br>在网络层, Socket 函数需要指定使用到的协议到底是 IPv4 还是 IPv6 ,分别对应设置为 AF_INET 和 AF_INET6 .此外,还需要说明你是使用 TCP 协议,还是 UDP 协议. TCP 协议是基于数据流的,所以设置为 SOCK_STREAM , UDP 是基于数据报的,因而设置为 SOCK_DGRAM .</font></p><h1 id="基于-TCP-协议的-Socket-程序函数调用过程"><a href="#基于-TCP-协议的-Socket-程序函数调用过程" class="headerlink" title=" 基于 TCP 协议的 Socket 程序函数调用过程"></a><font face="华文中宋" size="5"> 基于 TCP 协议的 Socket 程序函数调用过程</font></h1><p><font face="华文中宋" size="3">客户端和服务端创建 Socket 之后, TCP 的服务端要先监听一个端口,一般是先调用 bind 函数,给这个 Socket 赋予一个 IP 地址和端口.为什么需要 IP 地址呢?有时候一台机器会有多个网卡,相应的就会有多个 IP 地址,可以选择监听所有的网卡,也可以选择监听一个网卡,这样只有发给这个网卡的包,才会给你.那我为什么还需要端口呢?你要知道,你写的是一个应用程序,当一个网络包来的时候,内核是需要通过 TCP 头里面的这个端口,来定位到你这个应用程序的.<br> 此时,当服务端有了 IP 和端口号,就可以调用 listen 函数进行监听.在 TCP 的状态图中,有一个 listen 状态,当调用这个函数之后,服务端就进入了这个状态,这个时候客户端那边就可以发起连接了.</font></p><p><font face="华文中宋" size="3">在内核中,为每个 Socket 维护了两个队列,一个是已经建立了连接的队列,说明此时三次握手已经完毕,处于 established 状态;一个是还没有完全建立连接的队列,也就是说这个时候三次握手还没完成,处于 syn_rcvd 的状态.<br>接下来,服务端调用 accept 函数,拿出一个已经完成的连接进行处理.如果客户端还没有完全建立连接,没别的办法,就等着咯.</font></p><p><font face="华文中宋" size="3">在服务端等待的时候,客户端可以通过 connect 函数发起连接.现在参数中指明要连接的 IP 地址和端口号,然后开始发起三次握手.内核会给客户端分配一个临时的端口,一旦握手成功,服务端的 accept 就会返回另一个 Socket .<br>注意一下,在这里有一个经常考察的知识点,就是监听的 Socket 和真正用来传数据的 Socket 是两个,一个叫做「监听 Socket 」,一个叫做「已连接 Socket 」.<br>连接建立成功之后,双方就开始通过 read 和 write 函数来读写数据,就像往一个文件流里面写东西一样.之所以把 TCP 的 Socket 描述成一个文件流,是因为 Socket 在 Linux 中就是以文件的形式存在的.</font></p><p><font face="华文中宋" size="3">在内核中, Socket 是一个文件,那对应就有文件描述符.每一个进程都有一个数据结构 task_struct ,里面指向一个文件描述符数组,来列出这个进程打开的所有文件的文件描述符.文件描述符是一个整数,是这个数组的下标.<br>这个数组中的内容是一个指针,指向内核中所有打开的文件的列表.既然是一个文件,就会有一个 inode ,只不过 Socket 对应的 inode 不像真正的文件系统一样,保存在硬盘上,而是在内存中.在这个 inode 中,指向了 Socket 在内核中的 Socket 结构.<br>在这个结构中,主要的是两个队列,一个是发送队列,一个是接收队列.在这两个队列里面保存的是一个缓存 sk_buff .这个缓存中能够看到完整的包的结构.</font></p><p><font face="华文中宋" size="3">以上,就是基于 TCP 协议的 Socket 程序函数调用过程的一个描述.<br>接下来说说基于 UDP 协议的 Socket 程序函数调用过程.</font></p><h1 id="基于-UDP-协议的-Socket-程序函数调用过程"><a href="#基于-UDP-协议的-Socket-程序函数调用过程" class="headerlink" title="基于 UDP 协议的 Socket 程序函数调用过程"></a><font face="华文中宋" size="5">基于 UDP 协议的 Socket 程序函数调用过程</font></h1><p><font face="华文中宋" size="3">对于 UDP 来说,和 TCP 还是有些不一样的.首先, UDP 是没有连接的,也就不需要三次握手,也不需要调用 listen 和 connect ,但是 UDP 的交互仍然需要 IP 和端口号,那就需要 bind .<br>UDP 是没有维护连接状态的,也就不需要对每对连接建立一组 Socket ,而是只要有一个 Socket 就可以和多个客户端通信.也是因为没有连接状态,所以每次通信的时候,都调用 sendto 和 recvfrom ,这样才可以传入 IP 地址和端口.</font></p><p><font face="华文中宋" size="3">写完这篇文章,我觉得我得去把&lt; TCP/IP 协议详解&gt; 这本书看看了~<br>以上就是想分享的一些内容了,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[读书]软技能:代码之外的生存指南</title>
      <link href="/posts/94c2433f.html"/>
      <url>/posts/94c2433f.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">前几天在家休息,把这本书看完了,收获颇多.<br>内容很丰富,我在这里说一下对我来说比较受启发的几点.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">1 ,如何构建自己的影响力,如何推销自己.<br>世界上没有一种快速成功的方法,如果有,那就是想要割你的韭菜.<br>那么如何构建自己的影响力,如何推销自己呢?<br>好好写博客,如果可以的话,录制视频,或者参加演讲大会.这些都是提升自己的影响力,向别人推销自己的方法.<br>但无一例外,都需要你坚持去做,都需要时间上的积累.<br>另外,我是真的建议好好读一读这篇文章<a href="https://www.dynamic-zheng.com/posts/cb0264f.html">[碎碎念]来谈谈写作这件事</a><br>这篇文章,被微笑大佬赞赏过,所以我觉得,它其实还是值得去读一读的.</font></p><p><font face="华文中宋" size="3">2 ,你是如何对待你的工作的?<br>我不太清楚别人是如何看待工作的,我先说一下我的看法.<br>在公司工作,就像在学校上学一样,但是也有点儿不一样,哪里不一样呢?就是我在上初中,高中,大学的时候,我为了学习知识,需要向学校交钱.但是我在公司呢,也是在学习知识,也是在让我成长,但是我不仅不需要向公司交学费,公司还给我发钱.<br>我每次想到这里的时候,我都开心到飞起.所以每次在公司的时候,我都精神满满.<br>为什么说到这一点,是因为书里面有一句话我很认同:你所能犯的最大错误就是相信自己是在为别人工作,这样一来你对工作的安全感已然尽失.职业发展的驱动力一定是个体本身,记住:工作是属于公司的,而职业生涯却是属于你自己的.<br>工作是属于公司的,但是你如何对待工作,如何对待这一切,由此对你的职业生涯的影响,都是你自己的.</font></p><p><font face="华文中宋" size="3">3 ,关于「学习」<br>这里说的「学习」是说自学.<br>我们上了很多年的学,但是场景都是老师在上面讲,学生在下面听那种模式.(如果你不是,那您是大佬)<br>这种模式,是别人灌输给你的,而不是你自己学习的.如果一直依赖别人来教你,在相当大的程度上,会限制住你的发展.<br>怎么理解呢.如果遇到一个你没有遇到的问题,我觉得相当有一部分人都会直接拿着这个问题,向前辈请教.但是这样的方法,并不是一个特别好的方法.<br>好的方法是:你先自己研究一下,大多数情况下你会发现,谷歌一下, 80% 的问题都是可以解决的.如果还是没解决,你可以去向前辈请教,但是这和你刚开始不会就向前辈请教可不一样,这个时候的你,带着自己的思考,带着自己的钻研去向前辈请教,你会给前辈留下一个很好的印象.<br>这是自学的一个好处,遇到问题,你不依赖别人就能够解决掉,会让你下次遇到问题的时候,依旧可以快速定位,慢慢地这种解决问题的能力,就被培养起来了.<br>这本书的作者,提出了一种「十步学习法」,我觉得也是不错的一种方法,恕我愚笨,我没办法完整描述出来,如果您也感兴趣,可以去读一读.<br>「自学」的核心在于:发动自己的主观能动性,去学习知识.这种知识,会让你印象更加深刻.<br>而最好的「自学」方式,则是把知识交给别人.<br>好吧,我又想往写作方面扯了</font></p><p><font face="华文中宋" size="3">4 ,说说「理财」<br>你不理财,财不理你.这是特别简单的一件事.<br>那么对于理财这件事,我的观点是,越早开始越好.<br>这一块的内容,我目前也在尝试,还是小白,不说太多了.<br>这本书中的有些内容,可能是写的比较早了,感觉有些内容不太符合,但是读一读开阔一下眼界也还是不错的.<br>另外再推荐两本书&lt;小狗钱钱&gt;和&lt;富爸爸,穷爸爸&gt;,这是两本挺不错的启蒙书.</font></p><p><font face="华文中宋" size="3">5 ,你的身体是 1 ,你的技能是 0 .如果没有 1 ,后面有再多的 0 也是白搭.<br>对于软件行业的从业人员来说,一般一做就是一整天.一天两天还好,如果长久下去,你觉得你的身体会怎样?<br>在这里,借用明白大大的一句话:体能是事业的上限.<br>你的身体有多健康,你就能走多远.<br>另外,建议去看一看李开复先生写的&lt;向死而生:我修的死亡学分&gt;这本书.</font></p><p><font face="华文中宋" size="3">以上就是我读到这本书之后的一些感悟.最重要的就是最后一条,要不也不会把它放在最后来讲.<br>我相信这本书每个人读都会有不一样的感受,建议你也去读一下,开卷有益,特别是这样一本好书.<br>另外,建议这本书,越早开始读越好.如果你不是程序员,也可以读一读,有很多内容,我觉得对于其他行业的人来说,都是通用的.<br>希望这篇文章能够给你一些启发~<br>PS: 怎么感觉回家一趟,回来之后自己的文字表达能力不怎么好了?感觉有很多东西都没写出来.唉,惭愧惭愧</font></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[复盘]记录一次带项目上线的经历</title>
      <link href="/posts/7bc85a67.html"/>
      <url>/posts/7bc85a67.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">好久没来写博客了,因为这一段时间在忙着带领项目上线,现在已经整体结束,来复盘一下.<br><a id="more"></a><br>先说一下带领上线的系统:主要是负责某所高校的上机考试,那么为了保证学生能够考试,就需要和老师沟通,找老师要题库,核对题库,核对考生名单,安排考务等,在这整个过程中的所有事情.<br>学校那边机考是 6 月 27,28 号和 7 月 5,6,7,8,9 号,也就是说在这几天,学校那天会使用我们做的系统.<br>想想凭我一个人是不可能的,所以就找了马莹老大,让他负责系统的内容,找了玉彬和金颖,来负责和老师联系这一部分.我就是负责在这之外的所有事情以及提醒各负责人要做的事情.<br>背景交待完了,以下就是对这次带项目上线经历的一个复盘.</font></p><p><font face="华文中宋" size="3">首先,我肯定先说比较好的地方,毕竟这整个系统能够支撑起将近 1 万人的考试,我觉得还是很牛的一件事情.<br>1 ,各个负责人都超给力,各位同事也都很认真负责.<br>我还记得,当时让我负责这个项目上线的时候,我去别的项目组拉人,和彬彬还有金颖说,我这边需要你们的帮助,需要你们帮我一起做这件事情,他们二话没说,就加入进来了.我到现在对他们都觉得感激.在整个过程中,如果不是彬彬带着我熟悉整个业务流程,不是金颖一直督促我做各种事情,我真的会忙到死.<br>还有组内的其他同事,只要我这边有事情需要大家做的时候,每个人都积极主动,及时给我反馈.我记得有人为了让项目上线,几个中午没有休息,忙碌到晚上凌晨也有,每个人都没有去抱怨,只是想着如何把事情做得更好,怎么把问题解决掉.<br>有这样一群人一起共事,是一件非常幸福的事情.<br>2 ,在整个考试过程中,系统没出什么特别大的问题.<br>没出什么大的问题,是说基本上没有,如果非要 100% 没问题,就有些抬杠了.<br>出的问题其实也是小问题,因为网速比较慢,导致试题加载慢;因为网络延迟原因,导致时间跳转比较快等.这些问题,考务那边都可以自己解决.<br>我印象中特别深刻的就是,有一天早上有考试,结果开考了好几分钟,都没有进行反馈情况,我们这边都以为现场遇到了很大的问题,解决不了,急忙打电话过去询问,结果是现场非常顺利,没什么大的问题.当时就感觉,嗯,接下来的考试就稳了.事实证明想的没错,接下来的几场考试,几乎都没有问题.<br>稳~</font></p><p><font face="华文中宋" size="3">接下来说一下,还需要提高的地方.正确认识自己,才能更好地进步不是<br>1 ,前期测试不够充分.<br>就我的计划而言的话,我是希望在上线前两三天就进行测试的,但是实际上在上线的当天上午测试了一下,下午就这么上线了.就我而言,我是觉得很心虚,因为它没有经历过很充分的测试就上线了,所以第一场考试我去了一趟学校,到现场去看看有没有什么问题出现.如果系统第一场考试能够撑下来,那么接下来就没什么大的问题.<br>还好,没什么特别大的问题出现.出现的问题,严格来说,算不上系统的问题,是因为学校网络的网速问题,导致学生访问时比较慢,试题加载比较慢.<br>2 ,事情没有安排太好,时间上太仓促了.<br>就比如说,第二天学生那边有考试,今天晚上我们这边才把考试配置好.太仓促了,第一次打的我们真的是有些措手不及,不过还好接下来赶紧调整方向,接下来的几场考试,特别是最后两天的时候,我感觉是轻松许多的.</font></p><p><font face="华文中宋" size="3">说说对这个系统以后的规划吧,毕竟我也是带过这个项目的人了.<br>首先,要把时间成本,人力成本控制下来.<br>这次的时间成本,人力成本真的是太大了,就我来说,我将近一个月的时间都投入了进去,中午几乎没有睡过,晚上也是走的最晚的那个.<br>现在想想,其实没有必要,如果前期做好相关准备,后期会是相当轻松的一件事情.<br>其次就是,这个系统还有很多冗余的功能,等迭代开发的时候,没必要的功能,我觉得该砍掉就可以砍掉了.</font></p><p><font face="华文中宋" size="3">在以上整个过程中,我有些地方做的也是不太好.<br>1 ,压力大的时候,就有些控制不住自己的脾气.<br>对同事发过脾气,还好同事不和我计较,后期道歉的时候,同事说竟然没觉得我在发脾气.还好同事大人有大量,不和我一般计较.<br>但是这并不代表,自己就可以随意发脾气.唉,这个毛病,一直在改,接下来的日子,我再继续慢慢改<br>2 ,没有充分授权.<br>这个前期我没有意识到,很多事情都是自己做,后来彬彬跟我说,这些事情,其实你都应该分出去的,别把自己陷进去了,你就看不到全局了.<br>后面我就放手让别人去做.犯错误是肯定的,但是我允许别人去犯错误,而且犯的错误都在我的解决范围之内.<br>这样其实很好,既很好的锻炼了他们,也在某种程度上释放了自己.<br>我以后要忍住这样的冲动.</font></p><p><font face="华文中宋" size="3">真的特别感谢这段时间还陪在我身边的朋友们,谢谢你们,一直容忍着我的坏脾气,一起把这件事情做好了.<br>我觉得,带领了这次的项目上线之后,经历了这次的压力之后,以后就没什么能够难得到我了,哈哈哈~<br>但凡经历,便都是成长.</font></p><p><font face="华文中宋" size="3">最后,这一个月都没怎么好好读书,既然忙过去了,就该重启读书了,毕竟生命不息,学习不止,还有很长的路要走~<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Docker]关于 Docker 入门,这一篇就够了</title>
      <link href="/posts/cc3d9aaa.html"/>
      <url>/posts/cc3d9aaa.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">关于 Docker 的一些概念和操作,我争取这一篇博客说完.<br>下面正文开始.<br><a id="more"></a></font></p><h1 id="Docker-镜像与容器"><a href="#Docker-镜像与容器" class="headerlink" title="Docker 镜像与容器"></a><font face="华文中宋" size="5">Docker 镜像与容器</font></h1><p><font face="华文中宋" size="3">说到 Docker ,你会常遇到两个内容: image 和 container (即镜像和容器)<br>关于镜像和容器,你可以这样来理解:镜像是构建 Docker 的基石,用户基于镜像来运行自己的容器.或者说,镜像是 Docker 生命周期中的构建或打包阶段,而容器则是启动或是执行阶段.<br>好吧,说的再明白点儿,就是有了镜像,才有的容器.容器是在镜像的基础上,才有的.</font></p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a><font face="华文中宋" size="5">Docker 安装</font></h1><p><font face="华文中宋" size="3">以前写过,这里就不赘述了,直接上链接:<br>需要科学上网的安装方法:<a href="https://blog.csdn.net/zll_0405/article/details/84890806" target="_blank" rel="noopener">[Docker]CentOS7下Docker安装教程</a><br>不需要科学上网的安装方法:<a href="https://blog.csdn.net/zll_0405/article/details/85092766" target="_blank" rel="noopener">[Docker]CentOS7通过rpm包安装Docker</a></font></p><h1 id="Docker-相关命令"><a href="#Docker-相关命令" class="headerlink" title="Docker 相关命令"></a><font face="华文中宋" size="5">Docker 相关命令</font></h1><h2 id="Docker-操作相关命令"><a href="#Docker-操作相关命令" class="headerlink" title="Docker 操作相关命令:"></a><font face="华文中宋" size="3">Docker 操作相关命令:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker启动 docker</span><br><span class="line">systemctl status docker查看 docker 状态</span><br><span class="line">systemctl stop docker停止 docker</span><br><span class="line">systemctl enable docker开机自启</span><br><span class="line">docker info 查看 docker 概要信息</span><br><span class="line">docker --help查看 docker 帮助文档</span><br></pre></td></tr></table></figure><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令:"></a><font face="华文中宋" size="3">镜像相关命令:</font></h2><p><font face="华文中宋" size="3">查看镜像命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">搜索镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">拉取镜像:<a href="https://blog.csdn.net/zll_0405/article/details/85124404" target="_blank" rel="noopener">[Docker]Docker拉取,上传镜像到Harbor仓库</a></font></p><p><font face="华文中宋" size="3">删除镜像:<a href="https://blog.csdn.net/zll_0405/article/details/85217839" target="_blank" rel="noopener">[Docker]如何批量删除镜像</a></font></p><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令:"></a><font face="华文中宋" size="3">容器相关命令:</font></h2><p><font face="华文中宋" size="3"><strong>查看容器:</strong></font></p><p><font face="华文中宋" size="3">查看正在运行的容器:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看所有容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看最后一次运行的容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看停止的容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f status=exited</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3"><strong>创建容器:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">可以在 run 后面加参数.其中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-i   表示运行容器</span><br><span class="line">-t   表示容器启动后进入其命令行</span><br><span class="line">--name  为创建的容器命名</span><br><span class="line">-v     表示目录映射关系(前者是宿主机目录,后者是映射到宿主机上的目录)</span><br><span class="line">-d     在 run 后面加上 -d 参数,则会创建一个守护式容器在后台运行</span><br><span class="line">-p     表示端口映射,前者是宿主机端口,后者是容器内的映射端口</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">交互式方式创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=容器名称 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">守护式方式创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">登录守护式容器方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名称(或容器 ID) /bin/bash</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3"><strong>启动容器:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称(或容器 ID)</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3"><strong>停止容器:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称(或容器 ID)</span><br></pre></td></tr></table></figure></font></p><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝:"></a><font face="华文中宋" size="3">文件拷贝:</font></h2><p><font face="华文中宋" size="3">将文件拷贝到容器内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录  容器名称:容器目录</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">将文件从容器内拷贝出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名称:容器目录需要拷贝的文件或目录</span><br></pre></td></tr></table></figure></font></p><h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载:"></a><font face="华文中宋" size="3">目录挂载:</font></h2><p><font face="华文中宋" size="3">在创建容器时,将宿主机的目录与容器内的目录进行映射,这样可以通过修改宿主机某个目录的文件从而去影响容器<br>创建容器 添加 -v 参数 后边为 宿主机目录:容器目录,完整命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -v 宿主机目录:容器目录</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">如果共享的是多级目录,可能会出现权限不足的情况<br>可以通过添加参数 –privileged=true 来解决,因为 CentOS7 中安全模块将 selinux 权限禁掉了,添加此参数,可以将问题解决.</font></p><h2 id="查看容器-IP"><a href="#查看容器-IP" class="headerlink" title="查看容器 IP:"></a><font face="华文中宋" size="3">查看容器 IP:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名称(容器 ID )</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">也可以直接输出 IP 地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&apos;&#123;&#123;NetworkSetting.IPAddress&#125;&#125;&apos; 容器名称(容器 ID)</span><br></pre></td></tr></table></figure></font></p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a><font face="华文中宋" size="3">删除容器</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称(容器 ID)</span><br></pre></td></tr></table></figure><h1 id="常见的应用部署"><a href="#常见的应用部署" class="headerlink" title="常见的应用部署"></a><font face="华文中宋" size="5">常见的应用部署</font></h1><h2 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署:"></a><font face="华文中宋" size="3">MySQL 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos/mysql-57-centos7</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">其中: -p 代表端口映射,格式为 宿主机映射端口:容器运行端口<br>-e 代表添加环境变量<br>MYSQL_ROOT_PASSWORD 是 root 用户的登录密码<br>3 ,进入 mysql 容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">4 ,登录 mysql :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></font></p><h2 id="tomcat-部署"><a href="#tomcat-部署" class="headerlink" title="tomcat 部署:"></a><font face="华文中宋" size="3">tomcat 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure></font></p><h2 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署:"></a><font face="华文中宋" size="3">Nginx 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建 nginx 容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure></font></p><h2 id="Redis-部署"><a href="#Redis-部署" class="headerlink" title="Redis 部署:"></a><font face="华文中宋" size="3">Redis 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建 redis 容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></font></p><h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a><font face="华文中宋" size="5">迁移与备份</font></h1><p><font face="华文中宋" size="3">容器保存为镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名称 镜像名称</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">将镜像保存为 tar 文件,例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">镜像恢复与迁移: -i 输入的文件,例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure></font></p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><font face="华文中宋" size="5">Dockerfile</font></h1><p><font face="华文中宋" size="3">Dockerfile 是由一系列命令和参数构成的脚本,基于基础镜像,最终创建一个新的镜像,常用命令有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM image_name:tag  定义了使用哪儿个基础镜像启动构建流程</span><br><span class="line">MAINTAINER user_name声明镜像的创建者</span><br><span class="line">ENV key value设置环境变量(可以写多条)</span><br><span class="line">RUN command 是 Dockerfile 的核心部分(可以写多条)</span><br><span class="line">ADD source_dir/file dest_dir/file  将宿主机的文件复制到容器内,如果是一个压缩文件,将会在复制后自动解压</span><br><span class="line">COPY source_dir/file dest_dir/file   和 ADD 相似,但是如果有压缩文件并不能解压</span><br><span class="line">WORDIR path_dir 设置工作目录</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">需要注意一下,如果要使用 Dockerfile 文件,名字必须为「Dockerfile」,否则里面的命令不会有效.</font></p><h1 id="镜像上传下载到镜像仓库"><a href="#镜像上传下载到镜像仓库" class="headerlink" title="镜像上传下载到镜像仓库"></a><font face="华文中宋" size="5">镜像上传下载到镜像仓库</font></h1><p><font face="华文中宋" size="3">以前写过博客,感觉还是比较详细的:<a href="https://blog.csdn.net/zll_0405/article/details/85124404" target="_blank" rel="noopener">[Docker]Docker拉取,上传镜像到Harbor仓库</a>(在上面应该也看到过了,再放一次)</font></p><p><font face="华文中宋" size="3">关于 Docker 入门,我只能帮你到这儿了~</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[回顾]说说我这大学四年</title>
      <link href="/posts/2b9683dd.html"/>
      <url>/posts/2b9683dd.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近更新频率有些低,因为最近在忙着学校毕业的事情.今天有时间,爬上来说几句,关于我这大学四年.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">前几天是高考,当时还单一和母亲视频,和她说,四年之前的这个时候,考试完之后我没想到会经历这么多,四年之前的那个选择,从某种程度上,可以说对我的影响很大.<br>我还记得报志愿的那个夏天,我把自己关在屋子里,选了几个我想要去的学校,相当一部分的原因是因为我想要去那个城市.我很早就和父母说了,我要出省,他们心理也有准备,但是当我和他们说,我要去桂林,要去吉林的时候,还是被吓到了.<br>父亲后来一直和我交流,说不反对我出省,但是我一个女孩子,能不能不去那么远,后来父亲又说,你报吉林,报桂林也行,能不能让我也给你选一个学校,你把它放在最后面,如果你被前面的学校录取了,我也认.<br>好吧,最后我屈服了,然后父亲超级开心的去地图上,找他想要让我去的城市.<br>离河南比较近的,就是河北,安徽,山西那些周围的地方.<br>记得特别清楚,当时我在和父亲说以后要怎样怎样,父亲突然扭过头和我说,你觉得「廊坊」这个城市怎么样,离北京也近,离天津也近,到时候你想去哪儿玩去哪儿玩,然后去看了一下,有这么一个学校可以供我选择,就那样报上了.</font></p><p><font face="华文中宋" size="3">说实话,当时来这个学校,只是为了应付一下父亲,没想到真的会被它录取.桂林,吉林那两所大学差了一两分,然后就被这所学校录取了,工程管理专业.<br>大一来的时候,舅舅,舅妈,爸爸,妈妈都来送我.当时室友还说,你家人怎么那么宠你,上个大学,还单一开车跑到学校来送你.<br>大一其实想想,没干啥.正常上课,好好准备考试.唯一和别人不一样的就是没有参加学生会,没参加什么社团,所以时间多了很多,没事打打篮球,读读书.当时是要求自己一周要读一本书的(现在做不到了).<br>打篮球的那一帮人,真的是我在大学里遇到的很好的人.我特别感激我的前辈们,一直都在照顾我,现在有困难的时候,只要和她们说,就会帮你.因为一起经历过很多事情,也因为大家的脾性都很相近.<br>大二决定转行去做编程,然后在学习自己专业课的同时,还在自学编程.和别人相比,少了很多玩乐的时间,我其实是有些乐在其中的,从编程里面获得了很大的成就感.后来觉得只是自己在看着视频学,这些东西,在公司到底能不能用得上.<br>所以在大二暑假去找了一份实习工作,也是那个时候,开始在 CSDN 上写博客,没想到,一写就写到了现在.<br>我算是比较幸运的,当时能够找到一份实习工作,老大对我也不错,后来大三开学要辞职走的时候,老大说其实你可以边工作边学习的,当然了一切都以你学校那边事情为重,上完课了就可以过来工作.然后就答应下来,就这样以这样的节奏,一直在这家公司呆到了现在.</font></p><p><font face="华文中宋" size="3">现在回过头来看,这大学四年,做的最正确的决定就是,选择来这所学校就读,选择早点儿到社会上历练自己.<br>前几天还在和老友聊天,他们说,感觉和我聊天,就像是在和前辈聊天一样,不论是从思考方式,还是思考角度,都和他们不一样.<br>这大概就是我这四年经历的一个反映吧.</font></p><p><font face="华文中宋" size="3">我这个月就要毕业了,彻底失去了学生这个身份.<br>如果是要失去的身份,尽早失去是好的.这样你会知道,失去身份之后的你,还有什么资本.</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java] J2EE 之 13 个规范总结</title>
      <link href="/posts/888348b8.html"/>
      <url>/posts/888348b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="J2EE-Java-2-Platform-Enterprise-Edition"><a href="#J2EE-Java-2-Platform-Enterprise-Edition" class="headerlink" title="J2EE( Java 2 Platform Enterprise Edition )"></a><font face="华文中宋" size="5">J2EE( Java 2 Platform Enterprise Edition )</font></h1><p><font face="华文中宋" size="3">在说 13 个规范之前,我们需要先来谈谈 J2EE ,它产生的背景是什么,解决了什么问题,这样清楚之后,再来谈 13 个规范,不至于觉得太突兀.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">产生的背景:<br>在企业级应用中,都有一些通用企业需求模块,比如数据库连接,邮件服务,事务处理等等.<br>既然很多企业级应用都需要这些模块,一些大公司便开发了自己的通用模块服务,也就是我们说的中间件.这样做的好处,就是可以解决重复开发,开发周期长和代码可靠性差等问题.<br>但是,这个时候就有一个问题,我的公司有我自己的标准,你的公司有你独自的一套标准,那是不是两家公司的中间件不兼容的问题就出现了?这样当用户使用的时候,就没办法将它们组装在一起为自己服务了,对吧?<br>这个时候怎么办呢?你可以想想实际生活中,为什么插排买回来,插上就能用,为什么我知道空调要买特定的插排,而我买回来就能插上使用.因为有「标准」对吧?所以我们才不用管这个插排买回来能不能用的问题.制定好标准之后,大家都去遵守,然后统一生产,对用户来说也方便.<br>同样的道理和想法, J2EE 就诞生了. J2EE 就是基于 Java 技术的一系列标准.<br>既然是标准,那么它的核心就是:一组技术规范与指南,其中包含的各类组件,服务架构和技术层次都有共同的标准及规格,这样就能够让依循 J2EE 架构的不同平台之间,存在良好的兼容性,这样不就解决了上面那种问题了~</font></p><h1 id="13-种规范"><a href="#13-种规范" class="headerlink" title="13 种规范"></a><font face="华文中宋" size="5">13 种规范</font></h1><p> <font face="华文中宋" size="3">在理解 J2EE 之后,就应该有这样的认识:这 13 种规范,是我们应该去遵循的.问题就来了,我需要遵循哪儿些呢?接下来一个一个说(这个排名不分先后~)</font></p><p><font face="华文中宋" size="3">1 , JDBC ( JavaDatabase Connectivity )<br>JDBC 是以统一方式访问数据库的 API .<br>它提供了独立于平台的数据库访问,也就是说,当我有了 JDBC API 的时候,就不必再为访问 Oracle 数据库专门写一个程序,为访问 Sybase 数据库又专门写一个程序等等,只需要用 JDBC API 写一个程序就够了,它可以向相应数据库发送 SQL 调用. JDBC 是 Java 应用程序与各种不同数据库之间进行对话的方法的机制.简单地说,它做了三件事:与数据库建立连接–发送操作数据库的语句–处理结果.<br>说到这里,有没有想起来 ODBC ?<br>如果想起来了,有没有想起来我写过一篇文章?<a href="https://www.dynamic-zheng.com/posts/7f1c23b6.html">[java]说说 JDBC ,再聊聊 ODBC</a></font></p><p><font face="华文中宋" size="3">2 , JNDI ( JavaName and Directory Interface )<br>JNDI 是一组在 Java 应用中访问命名和目录服务的 API .<br>JNDI 为开发人员提供了查找和访问各种命名和目录服务的通用,统一的接口,利用 JNDI 的命名与服务功能可满足企业级 API 对命名与服务的访问,诸如 EJB , JMS , JDBC 2.0 以及 IIOP 上的 RMI 通过 JNDI 来使用 CORBA 的命名服务.<br>在这儿,想多说一点: JNDI 和 JDBC 类似,都是构建在抽象层上.因为它提供了标准的独立于命名系统的 API ,这些 API 构建在命名系统之上.这一层有助于将应用与实际数据源分离,因此不管是访问的 LDAP , RMI 还是 DNS .也就是说, JNDI 独立于目录服务的具体实现,只要有目录的服务提供接口或驱动,就可以使用目录.</font></p><p><font face="华文中宋" size="3">3 , EJB ( Enterprise JavaBean )<br>J2EE 将业务逻辑从客户端软件中抽取出来,封装在一个组件中.这个组件运行在一个独立的服务器上,客户端软件通过网络调用组件提供的服务以实现业务逻辑,而客户端软件的功能只是负责发送调用请求和显示处理结果.<br>在 J2EE 中,这个运行在一个独立的服务器上,并封装了业务逻辑的组件就是 EJB 组件.其实就是把原来放到客户端实现的代码放到服务器端,并依靠 RMI 进行通信.</font></p><p><font face="华文中宋" size="3">4 , RMI ( Remote MethodInvoke )<br>是一组用户开发分布式应用程序的 API .<br>这一协议调用远程对象上的方法使用了序列化的方式在客户端和服务器之间传递数据,使得原先的程序在同一操作系统的方法调用,变成了不同操作系统之间程序的方法调用,即 RMI 机制实现了程序组件在不同操作系统之间的通信.它是一种被 EJB 使用的更底层的协议.<br>RMI/JNI : RMI 可利用标准 Java 本机方法接口与现有的和原有的系统相连接<br>RMI/JDBC : RMI 利用标准 JDBC 包与现有的关系数据库连接<br>就实现了与非 Java 语言的现有服务器进行通信.</font></p><p><font face="华文中宋" size="3">5 , JavaIDL/CORBA ( Common Object Request BrokerArchitecture )<br>Java 接口定义语言/公用对象请求代理程序体系结构<br>在 JavaIDL 的支持下,开发人员可以将 Java 和 CORBA 集成在一起.他们可以创建 Java 对象并使之可以在 CORBA ORB 中展开,或者他们还可以创建 Java 类并作为和其它 ORB 一起展开的 CORBA 对象的客户.后一种方法提供了另外一种途径,通过 Java 可以被用于将新的应用和旧的系统相集成.<br>CORBA 是面向对象标准的第一步,有了这个标准,软件的实现与工作环境对用户和开发者不再重要,可以把精力更多地放在本地系统的实现与优化上.</font></p><p><font face="华文中宋" size="3">6 , JSP ( Java Server Pages )<br>JSP 页面 = HTML + Java ,其根本是一个简化的 Servlet 设计.<br>服务器在页面被客户端请求后,对这些 Java 代码进行处理,然后将执行结果连同原 HTML 代码生成的新 HTML 页面返回给客户端浏览器.</font></p><p><font face="华文中宋" size="3">7 , Java Servlet<br>Servlet 是一种小型的 Java 程序,扩展了 Web 服务器的功能,作为一种服务器的应用,当被请求时开始执行. Servlet 提供的功能大多和 JSP 类似,不过, JSP 通常是大多数的 HTML 代码中嵌入少量的 Java 代码,而 Servlet 全部由 Java 写成并生成 HTML .</font></p><p><font face="华文中宋" size="3">8 , XML<br>XML 是一个用来定义其它标记语言的语言,可用作数据共享. XML 的发展和 Java 是相互独立的.不过,它和 Java 具有的相同目标就是跨平台.通过将 Java 与 XML 结合,我们可以得到一个完全与平台无关的解决方案.<br>突然想起来,以前写过一篇博客,感兴趣可以看看:<a href="https://blog.csdn.net/zll_0405/article/details/82950037" target="_blank" rel="noopener">【XML】快速了解XML</a></font></p><p><font face="华文中宋" size="3">9 , JMS ( JavaMessage Service )<br>它是一种与厂商无关的 API ,用来访问消息收发系统消息.它类似于 JDBC . JDBC 是可以用来访问不同关系数据库的 API ,而 JMS 则提供同样与厂商无关的访问消息收发服务的方法,这样就可以通过消息收发服务实现从一个 JMS 客户机向另一个 JMS 客户机发送消息,所需要的是厂商支持 JMS .<br>换句话说, JMS 是 Java 平台上有关面向消息中间件的技术规范.</font></p><p><font face="华文中宋" size="3">10 , JTA ( JavaTransaction API )<br>定义了一种标准 API ,应用程序由此可以访问各种事务监控.它允许应用程序执行分布式事务处理–在两个或多个网络计算机资源上访问并且更新数据. JTA 和 JTS 为 J2EE 平台提供了分布式事务服务.<br>JTA 事务比 JDBC 事务更强大,一个 JTA 事务可以有多个参与者,而一个 JDBC 事务则被限定在一个单一的数据库连接.</font></p><p><font face="华文中宋" size="3">11 , JTS ( JavaTransaction Service )<br>JTS 是 CORBA OTS 事务监控器的一个基本实现. JTS 指定了一个事务管理器的实现（ Transaction Manager ）,这个管理器在一个高级别上支持 JTA 规范,并且在一个低级别上实现了 OMGOTS 规范的 Java 映射.一个 JTS 事务管理器为应用服务器,资源管理器, standalone 应用和通信资源管理器提供事务服务.</font></p><p><font face="华文中宋" size="3">12 , JavaMail<br>用于访问邮件服务器的 API ,提供了一套邮件服务器的抽象类.</font></p><p><font face="华文中宋" size="3">13 , JAF ( JavaBeansActivation Framework )<br>JAF 是一个专用的数据处理框架,它用于封装数据,并为应用程序提供访问和操作数据的接口.也就是说, JAF 让 Java 程序知道怎么对一个数据源进行查看,编辑,打印等.<br>JavaMail 利用 JAF 来处理 MIME 编码的邮件附件.</font></p><p><font face="华文中宋" size="3">在学习过程中,找到了一篇文章,总结的非常棒(我这篇文章,几乎都是借鉴着写过来的),推荐大家看看,特别是最后一张图,感觉很形象:<a href="https://blog.csdn.net/zhuanzhe117/article/details/38763483" target="_blank" rel="noopener">J2EE 的 13 个规范总结</a><br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]来谈谈写作这件事</title>
      <link href="/posts/cb0264f.html"/>
      <url>/posts/cb0264f.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">写作这件事,很多大佬都谈过,但我还是想从自己的角度去谈谈.<br><a id="more"></a></font></p><h1 id="说到写作-我们就需要来说-我为什么要去写作-或者说-写作带给了我什么"><a href="#说到写作-我们就需要来说-我为什么要去写作-或者说-写作带给了我什么" class="headerlink" title="说到写作,我们就需要来说,我为什么要去写作,或者说,写作带给了我什么."></a><font face="华文中宋" size="3">说到写作,我们就需要来说,我为什么要去写作,或者说,写作带给了我什么.</font></h1><p><font face="华文中宋" size="3">1 ,可以系统性的思考.<br>我觉得你肯定有这样的感受,就是一个知识点我明明懂了,可是给别人讲的时候,却总是讲不明白.知道为什么嘛?因为你只是以为你自己懂了,实际上你并没有懂.<br>而写作就相当于你在给别人讲,那么你为了写明白一个知识点,为了让别人读懂你这篇文章,你会怎么做?<br>就拿这篇文章来说,为了向别人说明写作的重要性,你会怎么展开?起码会从是什么,为什么,怎么做,这三点去展开说,对吧.<br>那么,当你这样去写的时候,你发现,我好像对是什么不太清楚,所以你就会去查资料;我为什么要去用这个呢,想不明白,再去查资料;我怎么用这个知识呢,再去查资料或者实践.<br>这样做一次两次三次…当你坚持这样写完 100 篇文章的时候,你的思考角度,思维模式,绝对和写作之前不一样.</font></p><p><font face="华文中宋" size="3">2 ,构建影响力.<br>对于一个人来说,最重要的是什么?是有自己的「影响力」.<br>当你有自己的影响力时,你就能够在整个行业里面脱颖而出,从而能够有机会结识更加优秀的人.<br>但是影响力很轻松就能构建?只想说,别做梦了.<br>那么,我怎么构建影响力?</font></p><ul><li><font face="华文中宋" size="3"> 高质量的内容<br><font face="华文中宋" size="3">一件事情,你一定要想清楚,就是你和我都互相不认识,那么我凭什么信任你,我凭什么受你的影响,对吧.靠的就是高质量的内容.<br>我写博客,特别是需要实操的内容,比如安装 mysql , keepalived 这些文章的时候,都是自己操作一遍之后,确实是成功了,才敢发表出来.自己没有实践就写出来,我觉得是对读者的不负责任,那自然也就没有信任这一说.</font></font></li><li><font face="华文中宋" size="3">交给时间<br><font face="华文中宋" size="3">只要保证自己的内容是高质量的,剩下的交给时间就行了.<br>因为时间会告诉你,这一切是值得还是不值得.</font></font></li></ul><h1 id="既然写作给我带来了以上好处-那我该怎么做"><a href="#既然写作给我带来了以上好处-那我该怎么做" class="headerlink" title="既然写作给我带来了以上好处,那我该怎么做?"></a><font face="华文中宋" size="3">既然写作给我带来了以上好处,那我该怎么做?</font></h1><p><font face="华文中宋" size="3">1 ,找到你擅长的内容,不断细分,细分再细分,然后锤炼,锤炼再锤炼.<br>关于你擅长的内容,这一点需要你自己去寻找.<br>比如我,对于前端,运维,后端,等等都有一些学习和钻研,那我就开始写这方面的内容.<br>但是前端,运维,后端每一个都是很大的方向,我怎么着手去写?一个办法:细分.细分到什么程度呢?比如说,我今天遇到了一个前端的问题,我写下来记录一下,可不可以?完全 OK 啊!<br>但是写完了就没事了?不是的,还需要再锤炼.<br>我一般是写完之后,就发表出来.如果有人给我评论一下,指出我哪里做的不是太好,我真是太开心了,又是一个可以成长的机会.<br>然后我过一段时间之后,会再来看之前写的文章,这里写的不太好,改改.那里排版看着不太舒服,再改改.<br>所以如果你感兴趣的话,可以看看我最近写的内容,和刚开始写的内容,不管是内容,深度,还是排版,我打保证,绝对是不一样的.<br>而这,都是因为我找到了擅长的内容,不断细分,然后一直锤炼的结果.</font></p><p><font face="华文中宋" size="3">2 ,站在巨人的肩膀上.<br>站在巨人的肩膀上,能够走得更远.写作这件事也不例外,你也可以站在巨人的肩膀上,或者更准确的说,模仿.<br>到底怎么做呢?这么多年了,肯定有一篇文章,能够打动你,或者你认为写得很好.那么这篇文章就是巨人的肩膀.不断地去剖析这篇文章的组织架构,不断地去思考为什么作者这样写.<br>思考完了你以为就可以了?不不不,还差得远.思考完了,你觉得把这篇文章理解的差不多了对吧,尝试着不看文章,就把这篇文章写下来.结果你发现跟原文还是不一样的,对吧?然后再思考,这里作者为什么要用这个词语呢,作者的构思在这里和我不太一样,他这样写是出于什么思考呢?然后觉得自己思考的差不多了,再尝试不看文章,就把这篇文章写下来.上面这个过程,重复,重复再重复,直到你真的写出来了原文.<br>这个时候,你以为没事了?不不不,然后你需要再寻找下一篇你觉得好的文章,再重复上面的内容,等你重复这样做几十遍之后,当你再自己写文章的时候,你会惊讶的.<br>啊?你跟我说,你没有欣赏的文章?那你可以去读一读阅读量 10W+ 的文章,一篇文章如果能够有 10W+ 的阅读量,说明这篇文章可圈可点的内容有很多,可以去分析,模仿,站在巨人的肩膀上,走的更快,也更远.</font></p><h1 id="既然写作有这么多的好处-为什么写作的人不多"><a href="#既然写作有这么多的好处-为什么写作的人不多" class="headerlink" title="既然写作有这么多的好处,为什么写作的人不多?"></a><font face="华文中宋" size="3">既然写作有这么多的好处,为什么写作的人不多?</font></h1><p><font face="华文中宋" size="3">我觉得相当一部分的原因是因为,大多数人还没开始写作,就自己被自己吓死了.<br>怎么讲?你有没有这样的忧虑,当你想要开始写作的时候,突然有压力了,我如果写不好怎么办,我如果写的非常差劲怎么办,我还没搜集好相关素材…然后写作这件事就一直被放在了一边.<br>有这样的想法再正常不过,因为我刚开始在 CSDN 上写博客的时候也是这样,一想要在 CSDN 上写博客,心里就犯怵,我的天啊, CSDN 上牛人那么多,人家写的那么好,我再打磨打磨自己,我再深入学习学习,巴啦啦各种借口.后来就是破罐子破摔了,写的烂就写的烂了,先写出来再说吧.就这么逼着自己,先做起来.<br>结果呢,写出来之后发现,哎,这件事也没自己想象中那么难嘛~然后就这么一路写了下来.</font></p><p><font face="华文中宋" size="3">写作的人不多,我觉得可能还有一个原因就是,我写了但是没有人看,没有人跟我互动,让我突然没有了坚持下去的动力.<br>对于这一点,我只想说「将欲取之,必先予之」.<br>你想让别人来看你的博客,想让别人评论你的博客,给你动力或者提意见,让你写的更好,凭什么?<br>有一段时间我就挺鸡贼的,就是跑到各个博主下面去评论博客,因为别人评论我博客的时候,我会顺手点到对方博客里面去,看一眼别人写的内容,感兴趣的话,我就评论一下.这种心态,我觉得每个人可能都有,所以呢,我就跑到各个博主下面去评论人家的博客,有的博主就礼尚往来一下,也评论一下我的博客.<br>然后我一看,哇塞,有人评论我的博客了,不行我得再给对方评论回去.就这么一来二去,博客评论竟然也不少了,还连带着骗了很多粉丝,然后给我的动力就更大了,这样就形成了一个正反馈的闭环,直到现在写作对我来说成为了习惯.<br>所以呢,遇到问题,先从自身想想,别人凭什么要给你评论博客,这样问题就比较好解决了.</font></p><h1 id="「写作」和「笔记」的区别"><a href="#「写作」和「笔记」的区别" class="headerlink" title="「写作」和「笔记」的区别"></a><font face="华文中宋" size="3">「写作」和「笔记」的区别</font></h1><p><font face="华文中宋" size="3">我是一直建议身边的朋友写作的,但是几乎每次建议的时候,他们都会说,我有写啊,你看我都有记笔记.<br>所以这里说一下,「写作」和「笔记」的区别.<br>写作就是你需要发表出来,让别人看.如果写的太差劲了,你肯定不好意思发表出来,对吧?所以为了写一篇文章,你可能要花上两三个小时去写,我现在写一篇文章,都是先写一点儿东西,然后放在一边,过几天再回来看,再进行修改,然后再放在一边,过几天再来看,然后再修改.就这么一来一回,一篇文章从开始写,到它发表出来,至少有 5 天的时间.我写年终总结的时候,都是花费一周两周甚至是一个月的时间去写的,因为怕自己没写好,就把自己好不容易建立起来的信任给弄没了.<br>但是笔记呢,就是自己看,不需要发表出来,也不用担心写的好不好,遣词造句这些都不需要考虑,所以就写的比较随意,一个笔记,可能一分钟两分钟就完事了.结果呢?<br>我自己记的笔记,有时候过一段时间再回来看,我这儿写的啥,这上下文啥意思,一脸懵逼.嗯,就是随意到这种程度.<br>所以「写作」和「笔记」不一样,受众不一样,花费的时间不一样,质量也就不一样,而且留给自己的印象也不一样.<br>如果可以,还是尽可能的「写作」吧.</font></p><h1 id="什么人最适合写作"><a href="#什么人最适合写作" class="headerlink" title="什么人最适合写作"></a><font face="华文中宋" size="3">什么人最适合写作</font></h1><p><font face="华文中宋" size="3">请注意一下,我这里说的是「最适合」,并不是说不是这类型的人就不适合写作,而且这是我个人的观点,你可以不赞同.<br>我觉得大学生最适合写作.之所以这样认为,是有以下几点:</font></p><p><font face="华文中宋" size="3">1 ,有时间.<br>在大学里面的自由时间真的是太多了.一天除了上课之外,其余的时间都是自己的,最爽的是还有周六日.<br>工作之后就不一样了,首先工作之后,每天的 8 个小时是肯定要给公司的,等到公司这边忙完了,下班了,上司叫你去一个饭局;男/女朋友想让你陪她溜达溜达…你发现了嘛,等你工作之后,你的时间就已经不是你的时间了.<br>好,就算下班之后,你什么事情都没有,工作了一天,觉得很累吧?自制力差点儿的,想放松放松,刷刷抖音吧?所以就算下班之后,什么事情都没有,还能有人逼着自己去学习,去思考,去写作,不能说没有,但是很少.<br>对了,上面的情况,还没算加班.这样一对比,就能发现在大学,能够利用的时间,真的是太多太多了.</font></p><p><font face="华文中宋" size="3">2 ,没有压力.<br>大学生有什么压力呢?不用买房;不需要考虑父母年纪大的问题;还没成家,不需要考虑孩子的问题,不需要考虑婆媳关系.没钱了,给父母打个电话,上一秒还穷的不行,下一秒就富得流油.<br>所以写作这件事,对于大学生来说,是一件毫无压力的事情.我今天有灵感,就多写点儿,明天心情不开心,就不写了.也不用刻意的去追求,这篇文章要达到多少多少的阅读量,随心而动,率性而为.<br>但是工作了的人,你跟他说,好好写作吧,写作给你带来了很多很多的好处,他们都听不进去的.<br>也可能听得进去,也可能想要去做,但是一篇文章需要耗费好几个小时,还需要写很长时间才能有效果,他们就熬不下去了.</font></p><p><font face="华文中宋" size="3">3 ,写作这件事情,肯定是越早开始越好.<br>什么?你还想问问我为什么这件事越早开始越好?建议你再翻到上面,看看写作给你带来了什么好处.<br>系统性的思考,这种能力,越早锻炼自己,在以后越能少走弯路.通过写作,让自己的思考慢慢变的严谨,想法慢慢变得成熟,知识慢慢变得系统.<br>这种能力,动动小脑就应该知道,越早培养越好,对吧!</font></p><p><font face="华文中宋" size="3">所以写作这件事,对大学生来说,真的是再适合不过了.(不要脸的说一句,我就是活生生的一个例子)</font></p><h1 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a><font face="华文中宋" size="3">最后说几句</font></h1><p><font face="华文中宋" size="3">写作这件事情,如果认认真真去做,坚持下来,直到成为习惯,真的可以给你带来很多东西,但是这些东西都是无形的,就像前面说到的,系统性的思考,影响力,这些都没办法去量化.<br>但是如果因为看不到写作的意义,就不去写作,我觉得是一件非常可惜的事情.<br>生活中很多事情,其实我们都看不到它的意义,但是正因为这样,生活才充满了无限可能和乐趣,对不对?</font></p><p><font face="华文中宋" size="3">以上.<br>非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java]说说 JDBC ,再聊聊 ODBC</title>
      <link href="/posts/7f1c23b6.html"/>
      <url>/posts/7f1c23b6.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果要了解 J2EE 的知识,就不可避免的接触到 13 种规范.作为规范之一的 JDBC 吸引起了我的注意,因为我比较了解 ODBC .<br>所以这篇文章,就先说说 JDBC ,然后咱们再聊聊 ODBC ,最后再对比说一下,这样印象更深刻一些.<br><a id="more"></a></font></p><h1 id="JDBC"><a href="#JDBC" class="headerlink" title=" JDBC"></a><font face="华文中宋" size="3"> JDBC</font></h1><p><font face="华文中宋" size="3">JDBC ( Java DataBase Connectivity , Java 数据库连接)是一种用于执行 SQL 语句的 Java API ,可以为多种关系数据库提供统一访问,由一组用 Java 语言编写的类和接口组成.<br>使用 JDBC 的步骤:加载 JDBC 驱动程序 –&gt;建立数据库连接 Connection –&gt;创建执行 SQL 的语句 Statement –&gt;处理执行结果 ResultSet –&gt;释放资源<br>既然是和数据库相关,就不可避免谈谈 JDBC 常用接口:</font></p><ul><li><font face="华文中宋" size="3">1 , Driver 接口<br><font face="华文中宋" size="3">Driver 接口由数据库厂家提供,作为java开发人员,只需要使用 Driver 接口就可以了.在编程中要连接数据库,必须先装载特定厂商的数据库驱动程序,不同的数据库有不同的装载方法.</font></font></li><li><p><font face="华文中宋" size="3">2 , Connection 接口<br><font face="华文中宋" size="3">connection 与特定数据库的连接,在连接上下文中执行 sql 语句并返回结果. DriverManager.getConnection(url, user, password) 方法建立在 JDBC URL 中定义的数据库 Connection 连接上.<br>常用方法:</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createStatement() :创建向数据库发送 sql 的 statement 对象</span><br><span class="line">prepareStatement(sql) :创建向数据库发送预编译 sql 的 PrepareSatement 对象</span><br><span class="line">prepareCall(sql) :创建执行存储过程的 callableStatement 对象</span><br><span class="line">setAutoCommit(boolean autoCommit) :设置事务是否自动提交</span><br><span class="line">commit() :在链接上提交事务</span><br><span class="line">rollback() :在此链接上回滚事务</span><br></pre></td></tr></table></figure></li><li><p><font face="华文中宋" size="3">3 , Statement 接口<br><font face="华文中宋" size="3">用于执行静态 SQL 语句并返回它所生成结果的对象<br>常用的 Statement 方法：</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute(String sql) :运行语句,返回是否有结果集</span><br><span class="line">executeQuery(String sql) :运行 select 语句,返回 ResultSet 结果集</span><br><span class="line">executeUpdate(String sql) :运行 insert/update/delete 操作,返回更新的行数</span><br><span class="line">addBatch(String sql) :把多条 sql 语句放到一个批处理中</span><br><span class="line">executeBatch() :向数据库发送一批 sql 语句执行</span><br></pre></td></tr></table></figure></li><li><p><font face="华文中宋" size="3">4 , ResultSet 接口<br><font face="华文中宋" size="3">ResultSet 提供检索不同类型字段的方法,常用的有:</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getString(int index),getString(String columnName) :获得在数据库里是 varchar,char 等类型的数据对象</span><br><span class="line">getFloat(int index),getFloat(String columnName) :获得在数据库里是 Float 类型的数据对象</span><br><span class="line">getDate(int index),getDate(String columnName) :获得在数据库里是 Date 类型的数据</span><br><span class="line">getBoolean(int index),getBoolean(String columnName) :获得在数据库里是 Boolean 类型的数据</span><br><span class="line">getObject(int index),getObject(String columnName) :获取在数据库里任意类型的数据</span><br></pre></td></tr></table></figure></li></ul><p><font face="华文中宋" size="3">使用之后,依次关闭的对象及连接为: ResultSet –&gt; Statement –&gt; Connection</font></p><h1 id="ODBC"><a href="#ODBC" class="headerlink" title=" ODBC"></a><font face="华文中宋" size="3"> ODBC</font></h1><p><font face="华文中宋" size="3">在上面说了 JDBC ,我觉得看到 JDBC ,应该能够想到 ODBC ,所以接下来咱们聊聊 ODBC .<br>ODBC ( Open Database Connectivity )开放数据库连接,是为了解决异构数据库间的数据共享而产生的,用于对数据库的访问.<br>ODBC 实际上是一个数据库访问函数库,这样可以使得程序可以直接操纵数据库中的数据. ODBC 是基于 SQL 语言的,是一种在 SQL 和应用界面之间的标准接口,这样就免除了应用软件随着数据库的改变而进行改变的麻烦.<br>所以 ODBC 的一个显著优点就是:它生成的程序与数据库或数据库引擎是无关的,这样就为数据库用户和开发人员屏蔽了异构环境的复杂性,提供了数据库访问的一个统一接口,也就使得应用程序实现与平台的无关性和可移植性成为了可能.</font></p><li> <font face="华文中宋" size="3">ODBC 主要由四部分构成:应用程序,驱动程序管理器,驱动程序,数据源.<br><ul><br>     <li><font face="华文中宋" size="3">应用程序( Application ),主要任务有:连接数据库,提交 SQL 语句给数据库,检索结果并处理错误,提交或者回滚 SQL 语句的事务,与数据库断开连接<br>     <li><font face="华文中宋" size="3">驱动程序管理器 ( Driver Manager ):每种数据库引擎都需要向 ODBC 驱动程序管理器注册自己的 ODBC 驱动程序,这种驱动程序对于不同的数据库引擎是不同的. ODBC 驱动程序管理器能将与 ODBC 兼容的 SQL 请求从应用程序传给驱动程序,随后由驱动程序把对数据库的操作翻译成相应数据库引擎所提供的固有调用,对数据库实现访问操作.<br>     <li><font face="华文中宋" size="3">驱动程序:驱动程序是一个用于支持 ODBC 函数调用的模块,应用程序调用驱动程序所支持的函数来操纵数据库.若想使应用程序操作不同类型的数据库,就要动态连接到不同的驱动程序上. ODBC 驱动程序处理 ODBC 函数调用,将应用程序的 SQL 请求提交给指定的数据源,接受由数据源返回的结果,传回给应用程序.<br>     <li><font face="华文中宋" size="3">数据源:是用户,应用程序要访问的数据文件或数据库,以及访问他们需要的有关信息.它定义了数据库服务器的名称,登录名和密码等选项<br></font></li></font></li></font></li></font></li></ul></font></li> <h1 id="JDBC-与-ODBC"><a href="#JDBC-与-ODBC" class="headerlink" title=" JDBC 与 ODBC"></a><font face="华文中宋" size="3"> JDBC 与 ODBC</font></h1><p><font face="华文中宋" size="3">先说说 JDBC 和 ODBC 的联系.<br>JDBC 和 ODBC 都是用来连接数据库的启动程序, JDBC 和 ODBC 由于具有数据库独立性甚至平台无关性,因而对 Internet 上异构数据库的访问提供了很好的支持.</font></p><p><font face="华文中宋" size="3">接下来,说说 JDBC 与 ODBC 的区别(参考自:<a href="https://www.geeksforgeeks.org/difference-odbc-jdbc/" target="_blank" rel="noopener">Difference between ODBC and JDBC</a>):</font></p><table><thead><tr><th style="text-align:center">ODBC</th><th style="text-align:center">JDBC</th></tr></thead><tbody><tr><td style="text-align:center">ODBC Stands for Open Database Connectivity.</td><td style="text-align:center">JDBC Stands for java database connectivity.</td></tr><tr><td style="text-align:center">Introduced by Microsoft in 1992.</td><td style="text-align:center">Introduced by SUN Micro Systems in 1997.</td></tr><tr><td style="text-align:center">We can use ODBC for any language like C,C++,Java etc.</td><td style="text-align:center">We can use JDBC only for Java languages.</td></tr><tr><td style="text-align:center">We can choose ODBC only windows platform.</td><td style="text-align:center">We can Use JDBC in any platform.</td></tr><tr><td style="text-align:center">Mostly ODBC Driver developed in native languages like C,C++.</td><td style="text-align:center">JDBC Stands for java database connectivity.</td></tr><tr><td style="text-align:center">For Java applications it is not recommended to use ODBC because performance will be down due to internal conversion and applications will become platform Dependent.</td><td style="text-align:center">For Java application it is highly recommended to use JDBC because there we no performance &amp; platform dependent problem.</td></tr><tr><td style="text-align:center">ODBC is procedural.</td><td style="text-align:center">JDBC is object oriented.</td></tr></tbody></table><p><font face="华文中宋" size="3">你如果跟我说,看不明白,那就踏实学英语去吧!<br>以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[mysql]修改 mysql 数据库端口</title>
      <link href="/posts/ade78a36.html"/>
      <url>/posts/ade78a36.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">背景:在一台 Linux 服务器上,安装了两个 mysql ,那么为了我能够同时连接到 mysql ,就需要对另外一个 mysql 修改连接端口.<br><a id="more"></a><br>修改 mysql 数据库之前,查看一下当前使用端口,命令(需要进入到 mysql 中进行操作),命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &apos;port&apos;;</span><br></pre></td></tr></table></figure></font></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3235nfvcaj30be036glo.jpg"></p><p><font face="华文中宋" size="3">可以看到,当前使用端口为 3306<br>接下来进入到 /etc 找到 my.cnf 文件,修改内容如下:<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g32369loe4j30di044q37.jpg"></font></p><p><font face="华文中宋" size="3">修改完成之后,重新启动 mysql 数据库,命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure></font></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3236vi7l6j30bl0403ym.jpg"></p><p><font face="华文中宋" size="3">此时,我们看到,已经修改成功.<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g323aigqywj30bg035t8t.jpg"></font></p><p><font face="华文中宋" size="3">端口已经修改成功了,如果 Navicat 连接不上 mysql 的话,就需要看看防火墙有没有打开相应的端口.想要打开特定端口,查看这篇文章吧,实在是懒得写了:<a href="https://blog.csdn.net/zll_0405/article/details/81208606" target="_blank" rel="noopener">CentOS7 开启防火墙及特定端口</a></font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[运维] proxmox ve 与 vSphere 对比</title>
      <link href="/posts/f77b1752.html"/>
      <url>/posts/f77b1752.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">一直关注我的博友,应该知道我曾经捣鼓过 vSphere 相关的内容,写过一个专栏: <a href="https://blog.csdn.net/zll_0405/column/info/21107" target="_blank" rel="noopener">VMware vSphere</a> ,起码有些许的成绩了,支撑起了公司大大小小的项目,虽然出过问题,但最后都有惊无险的熬了过来.<br><a id="more"></a><br>也算是基于兴趣,对这方面一直都有关注.前几天,贺信找到我,说发现了一个可以尝试的系统软件: proxmox ve (为了方便,下面我就写 proxmox 系统了).<br>在了解它之后,发现这个系统软件还真的不错,后期看看能不能推进一下这个方案,争取把这个方案落地.</font></p><p><font face="华文中宋" size="3">为什么想要推进这个方案,让它落地呢.我主要有以下几点考虑:<br>1 , proxmox ve 是开源的,而 vSphere 是收费的.<br>开源和收费,我觉得都没多大关系,只要符合自己公司当前发展的需求,我觉得付费也是 OK 的.但是开源的在于,它的氛围很不错,而且我看了一下,遇到的问题都有人写出过解决方案,这一点我是很看好的.(不过大部分解决方案都是英文,说明了英语的重要性)<br>vSphere 产品遇到问题的时候,一般查找不到相关解决资料,都是自己各种尝试,不知道哪儿懵对了,机器就好了,排查问题的时候,真的是靠个人经验.这一点,从我博客里面就能看出来,访问量最多的就是写 vSphere 的那几篇文章.说明在这方面沉淀的人少,所以搜索引擎把我的文章推出来.<br>而 proxmox ve 是开源的,这样就比较能够放心让别人大胆尝试,不至于遇到问题的时候,总是那几个人上,每个人都有锻炼的机会.<br>当然了,如果你真的比较土豪,购买 proxmox ve 系统也是 OK 的.</font></p><p><font face="华文中宋" size="3">2 , proxmox 虚拟机使用的是 kvm ,容器则使用的是 LXC( Linux Container ),也就是说,容器这方面相当于原生的,对于各类常见的应用软件容器,就不用再单独创建 Linux 虚拟机,可以直接在虚拟机上安装相关容器即可.<br>但是 proxmox 对物理服务器的限制是设定在 32 台物理主机,所以如果物理主机比较多的话,而且还需要统一集中在一个集群管理,它可能就不是最好的解决方案了.<br>但是就目前公司的需求来说,我觉得使用 proxmox 还是能够满足需求的.</font></p><p><font face="华文中宋" size="3">3 ,proxmox 支持市面上几乎所有的主流存储协议,特别是对 ceph 分布式存储的支持.这意味着,通过 ceph 可以实现虚拟机的 HA 功能,虚拟机动态迁移等高级特性,而且我觉得在以后,大数据是一个趋势,所以能够支持分布式存储的话,这一个优点无疑是比较吸引人的.</font></p><p><font face="华文中宋" size="3">4 , vSphere 出于商业收费和 license 的考虑,将很多功能进行了拆分,安装完 ESXi 之后,只能使用基本功能,如果想要使用高级功能,必须安装 vcenter 来进行相关操作才可以.<br>相比较之下, proxmox 就友好很多,安装完成之后,所有集群的物理节点都是平等的,通过每个物理节点都可以管理整个集群.<br>如果只是从稳定性来看的话, proxmox ve 和 vSphere 可以说是旗鼓相当,但是硬件兼容性则没有 proxmox 好,而且在 proxmox 中没有主次节点之分,所以它能够最大化的提高硬件的使用效率.</font></p><p><font face="华文中宋" size="3">5 ,这是最重要的一个原因: proxmox 相对于 vSphere 来说,它少了一层.<br>vSphere 的架构是:在服务器上安装 ESXi 系统,然后通过 vcenter 去管理,通过 vcenter 来创建虚拟机,管理集群等.<br>而 proxmox 架构是:在服务器上安装 proxmox 系统之后,就可以在上面创建虚拟机,随便访问一台物理节点,都可以来管理整个集群.<br>发现不同了嘛?好吧,我觉得你可能没发现.<br>proxmox 不需要经过 vcenter 这一层的管理,也就是少了一层通信.这一层通信少了之后,就可能将整个集群的读取速度,反应速度提升一个层次.<br>如果非要举个例子来说明的话(这个例子可能不太恰当,但是想不起来合适的了),就相当于你的笔记本从原来用机械硬盘,到后来改用固态,那种速度之间的差别,你可以想想.</font></p><p><font face="华文中宋" size="3">基于以上吧,我个人是觉得这个方案可以尝试去做.<br>后期看时间和精力,看看能不能弄起来.</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxmox ve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java]说说 JRE , JDK , JVM 三者之间的区别与联系</title>
      <link href="/posts/dfd14d26.html"/>
      <url>/posts/dfd14d26.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在写了很多代码之后,如果问 jre 和 jdk 之间有什么关系, jvm 又是什么,估计有相当一部分人不知道在说什么.所以这篇文章,就尝试解释一下这三者之间的区别和联系.<br><a id="more"></a></font></p><table><tr><td bgcolor="#1E90FF"><font face="楷体" color="white" size="5">基本概念</font></td></tr></table><p><font face="华文中宋" size="3">咱们先来说说, jvm , jre , jdk 都是什么.</font></p><p><font face="华文中宋" size="5">JVM ( Java Virtual Machine ):</font></p><p><font face="华文中宋" size="3">就是常说的 java 虚拟机,顾名思义,它就是一个虚拟出来的计算机,通过在实际的计算机上模拟各种计算机功能来实现.<br>JVM 是 java 实现跨平台最核心的部分,所有的 java 程序,首先会被编译成 .class 的类文件, JVM 的主要工作是解释自己的指令集(即字节码)并映射到本地的 CPU 的指令集或 OS 的系统调用. java 面对不同操作系统使用不同的虚拟机,这样实现了跨平台.<br>因为 JVM 对上层的 java 源文件怎样是不关心的,它关心的是由源文件生成的类文件.</font></p><p><font face="华文中宋" size="5">JRE ( Java Runtime Environment ):</font></p><p><font face="华文中宋" size="3">java 运行时环境.<br>它主要包括两部分: jvm 的标准实现和 java 的一些基本类库还有一些模块等.<br>在 java 平台下,所有的 java 程序都需要在 JRE 下才能运行,这是因为在解释 class 时, JVM 需要调用解释所需要的类库 lib .<br>可以看看自己下载的 jre ,里面有 bin 和 lib , 在这里可以认为 bin 就是 JVM , lib 就是 JVM 所需要的类库. JVM 和 lib 合起来就称为 JRE .</font></p><p><font face="华文中宋" size="5">JDK (Java Development Kit ):</font></p><p><font face="华文中宋" size="3"> java 开发工具包.<br>jdk 是整个 java 开发的核心,包括了 java 的运行环境,一堆 java 工具和 java 基础的类库.你可以将 JDK 看成是 JRE 的一个超集.<br>由上,我们能够看出来,这三者之间的关系是层层嵌套的:<strong> JDK 包含 JRE , 而 JRE 包含 JVM .</strong></font></p><table><tr><td bgcolor="#1E90FF"><font face="楷体" color="white" size="5">Q &amp; A</font></td></tr></table><p><font face="华文中宋" size="3">在以上基础上,面试的时候,就有的问了.<br>比如:<br>Q : java 为什么能够跨平台,实现” write once , run anywhere “<br>A : java 能够跨平台运行的核心在于 jvm ,所以并不是 java 能够跨平台,而是它的 jvm 可以做到跨平台.<br>java 引入了字节码的概念, jvm 只认识字节码,并将它们解释到系统的 API 调用.不同的系统有不同的 jvm 实现,有 Linux 版本的 jvm 实现,也有 Windows 版本的 jvm 实现,但是同一段代码在编译后的字节码是一样的.<br>也就是说,我想要实现的功能,因为编译生成的字节码是唯一的,所以和系统无关,因为在不同的 jvm 实现上会映射到不同系统的 API 调用,从而实现了代码不做任何修改,就可以跨平台运行.</font></p><p><font face="华文中宋" size="3">Q : jdk 和 jre 有什么区别<br>A : 把&lt;基本概念&gt;里面的内容说说,然后再说一下在实际中:如果只是想跑 java 程序,只安装 jre 就可以了,如果想要写 java 程序并且运行,就需要 jdk .</font></p><p><font face="华文中宋" size="3">如果能够玩转 jre  , jdk , jvm ,你就可以骄傲的说,你有扎实的 java 基础了.<br>在这里推荐两篇博客,好好阅读,会有很多收获.<br><a href="http://www.cnblogs.com/zuoxiaolong/p/life51.html" target="_blank" rel="noopener">回答阿里社招面试如何准备，顺便谈谈对于Java程序猿学习当中各个阶段的建议</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/life53.html" target="_blank" rel="noopener">万能的林萧说：一篇文章教会你，如何做到招聘要求中的“要有扎实的Java基础”。</a></font></p><p><font face="华文中宋" size="3">感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Linux]时间同步设置 + 防火墙设置 + SELinux 设置</title>
      <link href="/posts/d1d9f7bd.html"/>
      <url>/posts/d1d9f7bd.html</url>
      
        <content type="html"><![CDATA[<table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> 时间同步设置</font></td></tr></table><p><font face="华文中宋" size="3">在大数据集群环境中，要求每台集群的时间必须是同步的，这样我们就会要求每台集群的时间必须和一台服务的时间是同步的。接下来介绍一下步骤：<br><a id="more"></a><br>1，设置ntp客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp 安装ntp时间同步软件</span><br><span class="line">systemctl enable ntpd 使软件可用</span><br><span class="line">systemctl start ntpd 启动ntp软件</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2，编辑/etc/ntp.conf文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ntp.conf</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">重点修改以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Use public servers from the pool.ntp.org project.</span><br><span class="line"># Please consider joining the pool (http://www.pool.ntp.org/join.html).</span><br><span class="line">#server 0.centos.pool.ntp.org iburst</span><br><span class="line"> </span><br><span class="line">server 192.168.243.133   -------&gt;（此处需要修改，以哪台为准就写那台的IP）</span><br><span class="line"> </span><br><span class="line">restrict 192.168.243.133 nomodify notrap noquery-------&gt;（此处需要修改，以哪台为准就写那台的IP）</span><br><span class="line"> </span><br><span class="line">server 192.168.243.***     -------&gt;（本机IP是多少就写多少）</span><br><span class="line">fudge 192.168.243.*** -------&gt;（本机IP是多少就写多少） stratum 10</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">3，重启ntpd服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ntpd</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">4，启动后，查看同步情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpq -p</span><br><span class="line">ntpstat</span><br></pre></td></tr></table></figure></font></p><table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> 防火墙设置</font></td></tr></table><p><font face="华文中宋" size="3">关闭firewall：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时关闭防火墙: systemctl stop firewalld </span><br><span class="line">永久关闭防火墙： systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">关闭iptables：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭命令： service iptables stop </span><br><span class="line">永久关闭防火墙：chkconfig iptables off </span><br><span class="line">检查防火墙状态：service iptables status</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看防火墙状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">检查firewall的状态：systemctl status firewalld.service</span><br><span class="line">检查iptables状态：service iptables status</span><br></pre></td></tr></table></figure></font></p><table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> SELinux设置</font></td></tr></table><p><font face="华文中宋" size="3">1，临时关闭SELinux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2，永久关闭SELinux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line">将配置文件中SELINUX=enforcing改为SELINUX=disabled</span><br><span class="line">注：修改配置文件需要重启机器，但我们已临时关闭SELinux，等下次机器重启后，配置文件自动生效</span><br></pre></td></tr></table></figure></font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
