<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[数据结构与算法]08 队列( Queue )以及队列实现的三种方式( Java 版)</title>
      <link href="/posts/a433947a.html"/>
      <url>/posts/a433947a.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">年初生了一场大病,博客搁了几周,惭愧.今天来一篇.<br><a id="more"></a></font></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a><font face="华文中宋" size="3">队列</font></h1><p><font face="华文中宋" size="3">说队列的时候,常常会想到栈,因为栈是后进先出,而队列则是先进先出.<br>关于栈,前面已经写过了:<a href="https://www.dynamic-zheng.com/posts/3671c55b.html">[数据结构与算法]05 Stack 经典面试题之判断字符串是否合法( Java 版)</a><br>这篇文章的主要焦点就在队列上了.</font></p><p><font face="华文中宋" size="3">队列,你的第一反应是不是排队?不管是在食堂买饭,还是在银行办理业务,或者进高铁站的时候,都会排队.<br>排队有一个很明显的特点:早来的人,就会早点儿办完事情.<br>这就是队列:先进先出.</font></p><p><font face="华文中宋" size="3">队列可以用数组实现,叫做顺序队列.也可以用链表实现,叫做链式队列.<br>在这里,分别用数组和链表来实现一下.</font></p><h1 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a><font face="华文中宋" size="3">数组实现队列</font></h1><p><font face="华文中宋" size="3">使用数组来实现队列,相对来说还是比较简单的,因为数组和队列一样都是线性表结构.<br>废话不多说,咱们直接看代码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-29 15:51:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       数组：items，数组大小：n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       head表示队头下标，tail表示队尾下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       申请一个大小为capacity的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">        n = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果tail == n 表示队列已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            System.out.print(items[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayQueue queue=<span class="keyword">new</span> ArrayQueue(<span class="number">5</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"1"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"4"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"5"</span>);</span><br><span class="line">        queue.dequeue();</span><br><span class="line">        queue.enqueue(<span class="string">"6"</span>);</span><br><span class="line"></span><br><span class="line">        queue.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">使用数组实现队列有个问题,就是删除不是真的删除,只是在打印的时候将 i 的值指向了 head 而已,但是要删除的数据,仍然在数组中.</font></p><h1 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a><font face="华文中宋" size="3">链表实现队列</font></h1><p><font face="华文中宋" size="3">使用链表实现队列也较为简单:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用链表实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-30 09:20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        队列的队首和队尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node tail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String value = head.data;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(p.data + <span class="string">" "</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkListQueue queue=<span class="keyword">new</span> LinkListQueue();</span><br><span class="line">        queue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        queue.dequeue();</span><br><span class="line">        queue.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a><font face="华文中宋" size="3">栈实现队列</font></h1><p><font face="华文中宋" size="3">除了使用数组和链表实现,还有一种方法就是使用栈来实现队列.<br>使用栈来实现队列,顾名思义就是只能使用栈的操作: pop , push , peek 等,其他操作不允许出现,否则就不是使用栈来实现队列了.<br>使用数组和链表来实现栈都较为简单,因为在读取数据时,只需要按照顺序读取即可.<br>但是对于栈来说,顺序读取行不通,为什么呢?假设我的队列数据为 1,2,3,4 依次存入栈中之后再读取的话,则是 4,3,2,1 因为栈是后进先出.<br>如果使用栈来实现队列的话,需要用到两个栈.一个栈的输出顺序就是 4,3,2,1 在读取之前,我们把读取出来的数据存入到另外一个栈中,然后从后面这个栈读取,那么输出顺序就是 1,2,3,4 和原来队列的数据一致.<br>在这里要注意一点:当后面的栈中有数据,前面的栈中也有数据时,要先将后面的栈中数据读取完毕,再将前面的数据放到后面的数据中.<br>接下来看下代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-30 17:21:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Stack&lt;Integer&gt; stackTemp = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stackQueue = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stackTemp.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 整个队列不为空时</span></span><br><span class="line">        <span class="keyword">if</span> (empty()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果 stackQueue 为空时,则将 stackTemp 中的数据放入 stackQueue 中</span></span><br><span class="line">            <span class="comment">// 如果 stackQueue 不为空,直接输出即可</span></span><br><span class="line">            <span class="keyword">if</span> (stackQueue.isEmpty())&#123;</span><br><span class="line">                backFill();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackQueue.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 整个队列为空,则返回 -1 ,代表队列中没有值</span></span><br><span class="line">            System.out.println(<span class="string">"队列为空"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空,如果返回值为 0 ,则代表队列为空</span></span><br><span class="line">        <span class="comment">// 注意,两个栈均为空时,队列才为空</span></span><br><span class="line">        <span class="keyword">return</span> stackQueue.size() + stackTemp.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        将 stackTemp 中的数据放入 stackQueue 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backFill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stackTemp.isEmpty())&#123;</span><br><span class="line">            stackQueue.push(stackTemp.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StackQueue stack = <span class="keyword">new</span> StackQueue();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[年终总结]愿你在以后的黑暗时刻,都能想起我</title>
      <link href="/posts/99fcee38.html"/>
      <url>/posts/99fcee38.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">今天是新的一年开始.<br>这次的总结,不想像以前那样细数过去的一年发生了什么,经历了什么,我就随便写了,写到哪儿算哪儿(说白了就是碎碎念<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">过去的一年,我一直都觉得自己像是开挂了一样.自从打破了自己的一个认知局限之后,认识到了很多厉害的人,在和这些人的交流中,也慢慢让我变得很自信.<br>因为我看到他们,之所以能够成功,是因为有耐心,相信自己,敢冒险.反观一下我自己,我身上也有这些,那我和他们的差距就在于时间,所以我相信就目前的状态一直下去,有一天我也会变得很厉害,只不过是时间早晚的问题.<br>这样对于很多事情就不纠结了,主要是纠结也没用,还不如拿这些时间读读书,跑跑步.</font></p><p><font face="华文中宋" size="3">我现在想想,都觉得以前的自己真的是太拼了.你能想象我在大年三十那天早上,还写了一篇博客嘛;你能想象我在休息日的时候,还坚持读书和写作嘛.在过去的时间里,我得到了很多,但是也忽略了很多.有很多朋友,本来可以玩的更好的,但是因为我一心扑在工作上,所以很多次的邀约都拒绝了,说真的,以前的我和母亲视频都觉得是在浪费时间.<br>可能是因为在我小的时候,经历了那种无力感,那种痛苦,我到现在想起来都会泪流满面.<br>我特别害怕再经历这种事情,所以我就想要抓住一切时间去努力,因为我想让我成功的速度快过亲人老去的速度.<br>过去的一年改变了我的一些想法.观念转变应该是 6 月份和一位朋友的关系出现危机.我挺在乎她的,对我来说,她对我的意义就和家人一样重要,所以当我们之间的距离越来越远的时候,我很害怕,但是却发现我越是想要靠近,我们之间反而越是疏离,以至于到最后我不知道我该怎么做.<br>那段时间,碰巧亲人去世,工作上需要带领项目上线,我的心态崩溃过很多次,我开始怀疑自己这样做的对不对,不知道我努力的意义是什么.如果是让家人过上更好的生活,那我这样对他们不闻不问,几乎没有陪伴,就是对他们好嘛.<br>从那段时间之后,开始寻找工作和生活的一个平衡点.现在我学会了在休息日跑到北京只是为了找一家咖啡厅坐坐放空自己;学会了花费一天的时间去陪伴重要的人,哪怕只是逛逛街吃吃饭,或者是看看电影;学会了一整天都赖在家里,亲手做饭,或者只是在有阳光的午后躺在沙发上;也或者花一天的时间压马路,各种放空心情.<br>我发现当我这样去做之后,失去的固然有,比如技术上的成长,相对来说慢了一些,但是我却得到了很多.<br>在我难过的时候,会有朋友陪在身边;在我怀疑自己的时候,会有人鼓励我说我很棒;当我一心只是想要飞的更高的时候,总有朋友一直叮嘱我去按摩,照顾好自己的身体.</font></p><p><font face="华文中宋" size="3">慢下来之后,我发现原来生活不光光是工作,努力也不是只有一种方式.<br>就像是开窍一般,对发生的所有事情都心怀感恩,感激当下发生的一切.关于这一点,在一篇文章中其实是说过的:<a href="https://www.dynamic-zheng.com/posts/a353dbe7.html">[碎碎念]不知道该起什么题目的一篇文章</a>.<br>接受自己的平凡,承认自己是一个平凡的人,是一件很难的事情.我庆幸,现在的我就做到了,虽然做的不是很好.</font></p><p><font face="华文中宋" size="3">博客印象中是有一两周的时间没有写,以后再也不能说自己坚持每周写一篇博客了,气哭…<br>但是我可以说,一直在坚持写博客呀,哈哈哈哈哈<br>因为博客,认识了一群优秀的人.<br>反正技术这条路,真的是需要活到老,学到老的.</font></p><p><font face="华文中宋" size="3">过去的一年,我只做好了 4 件事:工作,读书,写作,锻炼.<br>说到这里,我突然想起来,前一段时间有人来问我,说我没办法坚持读书,我没办法坚持写作,我没办法坚持锻炼,问我为什么能够坚持下来.其实秘诀只有一个:我有同伴在和我一起同行.<br>有同伴一起同行,真的是一件超级幸福的事情,特别是相处让你觉得很舒服那种.和晓鸿开始真正熟悉,是当时我们一起在外出差,两个女孩子之间互相照顾,慢慢开始了解对方.后来和晓鸿说,要不要一起学习,一起在技术上做深入研究,她说可以.<br>我觉得我和晓鸿是那种,制定了计划,就一定要完成的那种人.所以在 19 年 10 月份的时候,我才敢说在 19 年结束之前,把计算机网络过一遍.和晓鸿一起学习,我们在 12 月份中旬就结束了,用了将近两个月的时间.<br>我说我想去学算法,她二话没说就和我一起学;我说我想去练字,也是二话没说就一起去练了;有一次我想要学一个资料,挺贵的,问她要不要一起学,也是二话没说就入了.有这样一个朋友一起前行,不可能坚持不下去的.</font></p><p><font face="华文中宋" size="3">过去的一年,影响了一些人.<br>我看到因为我自己坚持写博客,导致身边的人也开始写博客的时候;我看到因为我坚持读书,导致身边的人也开始养成读书习惯的时候;我看到因为我为了吃的更加健康,而不怎么吃主食,导致身边的人也开始慢慢不吃主食的时候,那种成就感很大.<br>有一种,哦,原来我也能影响别人,原来我的做法也能帮助一部分人找到他们热爱的事情,这种感觉想想都满脸骄傲.(以后走路横着走,哈哈哈;</font></p><p><font face="华文中宋" size="3">对于接下来的一年,我还是只想做好 4 件事:工作,读书,写作,锻炼.<br>这 4 件事做好了,其他就是享受当下.这样想想,对于接下来的一年,充满的是憧憬和感恩.</font></p><p><font face="华文中宋" size="3">最后感谢,感谢这一路一直帮助我的人,对我来说,他们都是贵人.<br>我也不知道此时的我能给他们带来什么,把这份感激都放在心底,希望有一天,我能让他们拿我来吹牛逼.</font></p><p><font face="华文中宋" size="3">对于我的父母,我一直都很感激,很感谢他们对于我一直都是舍得的.<br>现在能做的就是没事多和他们视视频,聊聊天.每次和母亲视频的时候,都能感受到她是很开心的.</font></p><p><font face="华文中宋" size="3">愿你在以后的黑暗时刻,都能想起我.因为在你黑暗的时刻,你能够想起我说明我对你来说是重要的,我是被需要的,我觉得很荣幸,能够被你当成这样重要的存在.(好吧,我承认我有些标题党了,挺煽情的一个题目,被我写成了碎碎念,逃;<br>如果让您有所收获,倍感荣幸.<br>就是这样了!<br>还有,新年快乐~<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年终总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]07 关于单链表环的操作( Java 版)</title>
      <link href="/posts/9b14f6f8.html"/>
      <url>/posts/9b14f6f8.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">单链表经典操作,第一个是单链表反转,在这篇文章中已经写过了:<a href="https://www.dynamic-zheng.com/posts/745fa732.html">[数据结构与算法]04 Link List (链表)及单链表反转实现</a>,第二个是判断链表中是否有环,也就是今天这篇文章想要说的.<br><a id="more"></a></font></p><h1 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a><font face="华文中宋" size="3">判断链表是否有环</font></h1><p><font face="华文中宋" size="3">如图,我们能够清楚看到,这个链表是有环的.<br><img src="/images/2019/有环链表.jpg"></font></p><p><font face="华文中宋" size="3">咱们一起来分析一下</font></p><blockquote><p><font face="华文中宋" size="3">判断链表中是否有环,可以从头结点开始,依次遍历单链表中的每一个节点.每遍历一个节点,就和前面的所有节点作比较,如果发现新节点和之前的某个节点相同,则说明此节点被遍历过两次,说明链表有环,反之就是没有.</font></p></blockquote><p><font face="华文中宋" size="3">但是仔细看一下这种方法,你会发现这种方法很耗时耗力,因为每遍历一个节点,都要把它和前面所有的节点都比较一遍.<br>还有一个很巧妙的方法,就是使用两个指针.</font></p><blockquote><p><font face="华文中宋" size="3">使用两个指针,一个快指针,一个慢指针.<br>快指针每次走 2 步,慢指针每次走 1 步.<br>如果链表中没有环,则快指针会先指向 null<br>如果链表中有环,则快慢指针一定会相遇</font></p></blockquote><p><font face="华文中宋" size="3">基于这个思路,可以使用代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否有环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-12-28 09:44:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsHasLoop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data,Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化单链表</span></span><br><span class="line">        Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,node5);</span><br><span class="line">        Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">        Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">        Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line">        <span class="comment">// 让 node5 的指针指向 node1 形成一个环</span></span><br><span class="line">        node5.next=node1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag=isHasLoop(node1);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHasLoop</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="comment">// 如果快慢指针相遇,则说明链表中有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 反之链表中没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求环长"><a href="#求环长" class="headerlink" title=" 求环长"></a><font face="华文中宋" size="3"> 求环长</font></h1><p><font face="华文中宋" size="3">现在已经将链表中是否有环判断出来了,接下来扩展一下,求环长.</font></p><p><font face="华文中宋" size="3">先理一下整体思路:<br>当快慢指针第一次相遇时,我们可以记录下此时的位置.<br>接下来让慢指针继续走,每次走 1 步,直到走到第一次相遇的地方,此时慢指针走过的长度即为环长<br>基于这样的思路,就可以将代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义环长初始值为 0</span></span><br><span class="line">        <span class="keyword">int</span> loopLength=<span class="number">0</span>;</span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次相遇时跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fast next 指针首先指向 null 指针,说明该链表没有环,则环长为 0</span></span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有环,使用临时变量保存当前的链表</span></span><br><span class="line">        Node temp = slow;</span><br><span class="line">        <span class="comment">// 让慢指针一直走,直到走到原来位置</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            loopLength++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loopLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求入环点"><a href="#求入环点" class="headerlink" title="求入环点"></a><font face="华文中宋" size="3">求入环点</font></h1><p><font face="华文中宋" size="3">求入环点有点儿绕,咱们先来上一张图:<br><img src="/images/2019/入环点.jpg"><br> <font face="华文中宋" size="3">如上图,假设:<br>入环点距离头结点距离为 D<br> 入环点与首次相遇点较短的距离为 S1<br> 入环点与首次相遇点较长的距离为 S2</font></font></p><blockquote><p><font face="华文中宋" size="3"> 当两个指针首次相遇时,慢指针一次只走 1 步,则它所走的距离为: D+S1<br>快指针每次走 2 步,多走了 n(n&gt;=1) 圈,则它所走的距离为: D+S1+n(S1+S2)<br>快指针速度为慢指针的 2 倍,则: 2(D+S1)=D+S1+n(S1+S2)<br>上面等式,整理可得: D=(n-1)(S1+S2)+S2</font></p></blockquote><p><font face="华文中宋" size="3">如果让 (n-1)(S1+S2) 为 0 ,是不是 D 和 S2 就相等了?也就是说,当两个指针第一次相遇时,只要把其中一个指针放回到头结点位置,另外一个指针保持在首次相遇点,接下来两个指针每次都向前走 1 步,接下来这两个指针相遇说,就是要求的入环点.<br>有点儿像做数学题的感觉~<br>基于这样的思路,可以将代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">entryNodeOfLoop</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次相遇时跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fast next 指针首先指向 null 指针,说明该链表没有环,则入环点为 null</span></span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次相遇之后,让一个指针指向头结点,另外一个指针在相遇位置</span></span><br><span class="line">        <span class="comment">// 两个指针每次走 1 步,相遇为止,此时相遇节点即为入环点</span></span><br><span class="line">        Node head=list; <span class="comment">// 头结点</span></span><br><span class="line">        Node entryNode=slow;    <span class="comment">// 相遇节点</span></span><br><span class="line">        <span class="keyword">while</span> (entryNode != head)&#123;</span><br><span class="line">            entryNode=entryNode.next;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entryNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <font face="华文中宋" size="3">关于链表的一些操作差不多就是这些了.<br> 其实仔细观察能够看到,不管是求环长,还是找到入环点,最关键的是找到第一次相遇时所在的位置,基于这一点,接下来的问题就比较容易解决.</font></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a><font face="华文中宋" size="3">参考:</font></h1><p><font face="华文中宋" size="3"> &lt;漫画算法&gt;-程序员小灰<br> 以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]06 数组( Array )</title>
      <link href="/posts/99ead990.html"/>
      <url>/posts/99ead990.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">什么是数组呢?你的脑海中是不是第一反应是这样的:<br><a id="more"></a></font></p><blockquote><p><font face="华文中宋" size="3"> 数组 ( Array )是一种线性表数据结构,它用一组连续的内存空间,来存储一组具有相同类型的数据.</font></p></blockquote><p><font face="华文中宋" size="3">在定义上,咱们来死扣两个概念.</font></p><ul><li><font face="华文中宋" size="3">线性表.<br><font face="华文中宋" size="3">线性线性,就是数据排成像一条线一样的结构,每个线性表上的数据最多只有前和后两个方向.这样看定义的话,除了数组,链表,队列,栈也是线性表结构.</font></font></li><li><font face="华文中宋" size="3">是一组连续的内存空间,存储一组具有相同类型的数据.<br><font face="华文中宋" size="3">这句话能够看出来,对于数组有两个限制:第一空间必须是连续的,第二,数据需要是相同类型的.<br>也就是说,如果内存空间剩余 1MB 但是不是连续的,此时创建数组就会失败;如果数组内存储的不是相同类型的数据,就会报错</font></font></li></ul><h2 id="数组是如何实现”随机访问”的"><a href="#数组是如何实现”随机访问”的" class="headerlink" title="数组是如何实现”随机访问”的"></a><font face="华文中宋" size="3">数组是如何实现”随机访问”的</font></h2><p><font face="华文中宋" size="3">当我们申请创建一个数组时,比如此时我申请一个数组 <code>int[] a = new int[10]</code> ,计算机会给数组 <code>a[10]</code> 分配一块连续内存空间.<br>计算机会给每个内存单元分配一个地址,通过地址来访问内存中的数据.当计算机需要随机访问数组中的某个元素时,它会首先通过下面的寻址公式,来计算出想要访问元素的存储内存地址:</font></p><blockquote><p>a[i]_address = base_address + i * data_type_size</p></blockquote><p><font face="华文中宋" size="3">根据 CPU 的预读机制,存储的数组就有可能被 CPU 全部读入,在 CPU 中进行访问,那个速度你可以想象~</font></p><h2 id="警惕数组越界问题"><a href="#警惕数组越界问题" class="headerlink" title="警惕数组越界问题"></a><font face="华文中宋" size="3">警惕数组越界问题</font></h2><p><font face="华文中宋" size="3">咱们先来看一段 C 语言代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">arr[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">仔细看,发现问题了嘛?这段代码不会打印 3 行” hello world “,而是会无限打印” hello world “.<br>因为,数组大小为 3 , a[0] , a[1] , a[2] ,实例代码中因为书写错误,导致 for 循环的结束条件错写成了 <code>i&lt;=3</code> ,而不是 <code>i&lt;3</code> ,所以当 <code>i=3</code> 时,会导致数组 <code>a[3]</code> 访问越界.在 C 语言中,只要不是访问受限的内存,那么所有的内存空间都是可以自由访问的.如果 <code>a[3]=0</code> 恰好是 <code>i=0</code> ,循环就会又开始.<br>所以这段代码就陷入了死循环.</font></p><hr><p><font face="华文中宋" size="3">参考:</font></p><ul><li><font face="华文中宋" size="3"> 极客时间&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,感谢您的阅读(这篇文章确实写得有些仓促了,逃;<br>最后,祝您冬至快乐~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]不知道该起什么题目的一篇文章</title>
      <link href="/posts/a353dbe7.html"/>
      <url>/posts/a353dbe7.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">这篇文章我是真的不知道该起一个什么样的题目,因为想要说的东西有些杂.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">在我身边的人应该对我比较清楚,以前的我可以说是「拼命三郎」,就算是休息也能看到我继续在技术上做一些研究,甚至我有时候不想和我母上大人视频聊天,为什么?因为我觉得和她视频聊天的时间,我还不如用来学习呢.<br>所以最近下班回到家,就抱着手机看奇葩说的时候,身边的小伙伴都惊呆了,说我变了,说我以前不是这样的.<br>emmm ,我不知道该怎么去做回应.只是觉得人变了,是一件很正常的事情.组成人身体的每个细胞,每时每刻都在变化,忘记了在哪儿看到的一句话,人全身的细胞每 7 年会换一次,所以只是从生理上来说,人每时每刻都在变化.从思想上说,小时候的你和现在的你,想法应该也是不一样的.<br>不管是从生理上,还是思想上你都在变化,所以我变了,它本身就是一件很正常的事情.<br>我知道我的小伙伴接受不了的是,我以前是一个在技术上深究的人,最近怎么看起了奇葩说.说实话,我没觉得这两者对我来说有什么不一样.因为对我来说,不管是在技术上做一些研究,还是去看视频,都是学习.<br>我是认真的,我真的从看视频这件事情上学到了很多.</font></p><p><font face="华文中宋" size="3">我以前是一个很敏感的人,敏感到如果身边的人不开心,我会想,是不是我哪里做错了,是不是我说的哪句话不得体了,是不是我得罪人家了,所以人家才会不开心,才会给我摆脸色看.可是看到奇葩说之后,我才知道可能仅仅是对方刚好心情不好而已,和我没什么关系,所以现在如果我再陷入那种思维的话,我就会这样提醒自己,然后我发现,现在的我每天都超级开心,是发自内心的那种;<br>我小的时候看事情,就是非黑即白,甚至是现在,有时候对一些事情的看法也会比较偏执,最近看奇葩说,常常会让我惊叹,我去竟然还可以从这个角度去思考,我天竟然还能再提升一个层次,所以现在我意识到我的看法比较偏执的时候,我就会想是不是我的思考角度太单一了,有没有另外的角度去考虑,我能不能再提高一个层次去看这个问题;<br>这是这个节目带给我的一些思考.<br>所以,对我来说,这又何尝不是学习?</font></p><p><font face="华文中宋" size="3">我常常觉得,人生就像做技术一样.做技术的话,你会发现想要继续向上走,你就必须再回到计算机网络,数据结构和算法,计算机组成原理这种底层上面来;人生也是如此,如果想要继续向前走,就必须明白自己的性格是怎样的,如何和自己的情绪对话,弄清楚自己的欲望.<br>当你把自己的底层操作系统弄明白之后,你这个人会很厉害.因为很多人究其一生都不明白,当然这其中也包括我.</font></p><p><font face="华文中宋" size="3">最近在看佛学的一些东西,我觉得佛学真的是一件很神奇的事情,小的时候总觉得佛学挺苦的,一提到佛教我脑袋里面冒出的想法就是:不能吃肉,不能喝酒,要禁欲这种.<br>在明白老师和乔老师的影响下去看佛学,我有些明白,其实佛学想要教的不是禁欲,而是放下我执.<br>仔细想想,为什么我们会常常感到烦恼?因为我们总是觉得,我和别人不一样,我不是一般人,我怎么能被命运这样对待呢.但是想想为什么不应该呢.不要把自己看得太重,烦恼就会少很多.</font></p><p><font face="华文中宋" size="3">有我微信好友的人应该知道,我特别喜欢在朋友圈里面秀.我喜欢秀今天这个朋友约我出去玩,明天那个朋友要带我去哪儿哪儿玩,以至于有的人就以为我的生活每天都挺好的,不是今天计划去那儿,就是明天去那儿.<br>之所以这样以为,是因为你没看到我为了项目熬夜通宵的时候,你没看到我压力大到崩溃的时候,你没看到我痛苦迷茫的时候.<br>每个人都是不容易的,可是如果每天眼睛里面只有这些事情的时候,你的心情很难美丽.如何保持对生命的敬畏,如何保持对生命的好奇?我觉得最重要的一点就是:感恩.<br>当我明白这一点之后,我开始享受和母上大人的视频时间,我开始感恩身边的人对我的善意,现在哪怕一天我什么都不做,就在家赖着躺一天,我的内心第一反应不再是苛责自己怎么可以这样浪费时间,而是感恩给了自己一天的时间去放空自己.<br>当我每天都是这样的感恩心态的时候,我发现了更多生活中的美好,而这又让我特别感恩.<br>这个正循环让我在某种程度上放下了我执.<br>我能清楚感觉到,有时候我还是会控制不住自己的脾气,还是会把自己看得很重,但是那又怎样呢.<br>惯性这种事情,总得慢慢来不是.况且我还这么年轻,一点儿都不着急~</font></p><p><font face="华文中宋" size="3">写这篇文章,纯粹是因为最近一周技术上没什么输入,各种碎碎念.<br>如果对您有所启发,倍感荣幸.</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]想出网关?你需要懂得这些</title>
      <link href="/posts/ff423025.html"/>
      <url>/posts/ff423025.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在学算法之余,也在学习计算机网络方面的东西,就是极客时间上刘超老师的&lt;趣谈网络协议&gt;那门课程,其中有一篇讲得非常有意思,也有些难以理解,我以我的角度来谈谈.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">想要跨网段访问的话,有一关是必须要过的:网关( Gateway )<br>配置好 IP 地址和网关之后,就能够自由访问上网了,想访问哪儿网站就访问哪儿个网站,各种浪.但是在进行跨网访问的时候,会牵扯到 MAC 地址和 IP 地址的变化,所以咱们先来知道一下 MAC 头和 IP 头的细节.</font></p><p><font face="华文中宋" size="3">MAC 头和 IP 头的细节(画的不是太好哈):<br><img src="/images/2019/mac-and-ip.jpg"></font></p><p><font face="华文中宋" size="3">简单来说一下内容:<br>目标 MAC 地址和源 MAC 地址应该不需要说明什么了,协议类型是为了说明里面是 IP 协议<br>版本( Version ):占 4 位,用来表明 IP 协议实现的版本号,目前来说主流还是 IPV4<br>服务类型 TOS ( Type of Service ):占 8 位,其中前 3 位比特为优先权字段,第 8 位保留未用,第 4 至 7 位分别代表延迟,吞吐量,可靠性和花费.<br>总长度:占 16 位,说明整个数据报的长度(以字节为单位),最大长度为 65535 字节<br>标识:占 16 位,用来唯一标识主机发送的每一份数据报,通常每发一份报文,它的值会加 1<br>标志:占 3 位,标志一份数据报是否要求分段<br>片偏移:占 13 位,如果一份数据报要求分段的话,该字段指明该段偏移距原始数据报开始的位置<br>生存期 TTL ( Time to Live ):占 8 位,用来设置数据报最多可以经过的路由器数,由发送数据的源主机设置,通常为 32,64,128 等.没经过一个路由器,它的值减 1,直到 0 时该数据报被丢弃.<br>协议:占 8 位,用来说明 IP 层所封装的上层协议类型,如 ICMP( 1 ), IGMP( 2 ), TCP( 6 ), UDP( 17 )等.<br>首部校验和:占 16 位,根据 IP 头部计算得到的校验和码.<br>源 IP 地址,目标 IP 地址:各占 32 位,用来标明发送 IP 数据报文的源主机地址和接收 IP 报文的目标主机地址.</font></p><p><font face="华文中宋" size="3">在任何一台机器上,如果想要访问另一个 IP 地址时,都会先判断,要访问的目标 IP 地址,与当前机器 IP 地址是否在同一个网段内.<br>如果是同一个网段,这就好说了,直接将源地址和目标地址放入到 IP 头中,然后通过 ARP 得到 MAC 地址,将源 MAC 和目标 MAC 放入 MAC 头中,发出去就 OK 了.<br>但是如果不是同一个网段呢,这就需要发往默认网关 Gateway 了.Gateway 的地址一定是和源 IP 地址是同一个网段的,如果不是第一个,就是第二个.比如, 192.168.1.0/24 这个网段,Gateway 一般就是 192.168.1.1/24 或者 192.168.1.2/24.因为网关和源 IP 地址在同一个网段内,所以发给 Gateway 的过程和上面同一个网段的过程是一样的.网关接收到之后,接下来怎么处理就是它自己的事情了.<br>做了上面那么多的铺垫,终于来到了今天想要说的主要内容:网关是怎么将数据跨网段发送出去的.因为在这里面涉及到了 IP 地址和 MAC 地址的变化.</font></p><p><font face="华文中宋" size="3">MAC 地址是在一个局域网内才有效的地址,所以 MAC 地址只要经过网关,就一定会改变,因为经过网关就意味着换了局域网.主要在于 IP 地址是否改变.如果 IP 地址不改变,那我们就将网关称为转发网关;如果 IP 地址改变,则将网关称为 NAT 网关.<br>先来说一下转发网关:<br><img src="/images/2019/transfor.jpg"></font></p><p><font face="华文中宋" size="3">如图,我们能够看到,服务器 A 的 IP 地址为 192.168.1.101/24 ,服务器 B 的 IP 地址为 192.168.4.101/24 ,现在服务器 A 想要访问服务器 B,不在同一个网段内,怎么办呢?肯定要经过网关的,对吧(因为 IP 头和 MAC 头里面的内容太多了,在这里主要写出 MAC 和 IP 内容)<br>此时,服务器 A 会给路由器 A 发送这样的内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :服务器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 A 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 A 接收到内容之后,发现是想访问 192.168.4.0/24 的,根据配置的路由规则,将要发送的内容通过 192.168.2.1 这个口发送出去,发送给路由器 B 的内容是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 B 接收到了来自路由器 A 的内容,它发现是想访问 192.168.4.0 这个地址,根据配置的路由规则,需要从 192.168.4.1 这个口出去,这样就能发给服务器 B,此时路由器 B 发送的包是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 B 的 MAC</span><br><span class="line">目标 MAC : 服务器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">至此,服务器 A 发送的内容就到达了服务器 B .<br>咱们来总结一下以上内容:在转发网关下,我不 care 其他的,我只知道我要发给哪儿个 IP ,所以在整个过程中,源 IP 和目标 IP 都没有发生改变.</font></p><p><font face="华文中宋" size="3">接下来咱们来说说 NAT 网关.照例,上个图:<br><img src="/images/2019/NAT.jpg"></font></p><p><font face="华文中宋" size="3">有没有发现一个问题,服务器 A 的 IP 地址是 192.168.1.101 ,要访问的服务器 B 的地址也是 192.168.1.101 ,如果只是看 IP 地址的话,是不是饶了一圈发现,这不就是自己访问自己嘛?惊不惊喜.<br>但是实际上服务器 A 在北京,服务器 B 在上海,两个地方有一个相同的 IP 地址罢了.问题就来了,服务器 A 怎么就可以访问到服务器 B 了呢?<br>就像上海人说上海话,北京人说北京话,一个区域内大家都听得懂,但是如果北京人跑到上海去,想要交流怎么办呢?说普通话呗,对不对.在网络中也可以这样做.既然这两个局域网之间没有商量过,各自使用各自的,内部使用的话这都没事儿,但是如果想要在外面也走的开,就需要制定规则.也就是说,路由器 A 和 B 在外网上需要有一个大家都公认的身份.<br>在图中我们能够看到路由器 A 在公网上的身份是 192.168.2.1/24 ,路由器 B 在公网上的身份是 192.168.2.2/24 .有了公认的身份之后,来看看接下来发送的内容:<br>服务器 A 发送给路由器 A 的内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :服务器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 A 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.2.2 (即路由器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 A 接收到内容之后,根据配置的路由规则,通过 192.168.2.1/24 发送给路由器 B ,此时发送的内容为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.2.1 (即路由器 A 的公网 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.2.2 (即路由器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">内容到达路由器 B 之后,根据它的配置规则,发现是想要发送给服务器 B 的,此时:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 B 的 MAC</span><br><span class="line">目标 MAC : 服务器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.2.1 (即路由器 A 的公网 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.1.101 (即服务器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">至此,服务器 A 发送的内容就到达了服务器 B .<br>咱们来总结一下以上内容:在 NAT 网关下, MAC 地址和 IP 地址都是会改变的. MAC 地址还好理解一些,要发送给谁,那么目标 MAC 地址就是要发送的机器 MAC 地址即可.但是 IP 地址如果是跨网段访问,则都需要通过公网 IP 来进行才可以.</font></p><p><font face="华文中宋" size="3">以上就是想要分享的内容,如果有错误之处,还希望指出哇~<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]05 Stack 经典面试题之判断字符串是否合法( Java 版)</title>
      <link href="/posts/3671c55b.html"/>
      <url>/posts/3671c55b.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">Stack (栈): 后进先出( Last In First Out ),也就是说后面进来的,会先出去.<br><a id="more"></a><br>说到这个场景,我就会想起烙饼这件事.每次母上大人烙饼的时候,先烙好的饼会放在最下面,后面烙好的饼会放在上面,还在烙饼的时候,我就想吃所以被我吃到的就是最上面的饼.<br>感觉这个过程是不是和栈这种数据结构很像~</font></p><p><font face="华文中宋" size="3">对于 Stack 来说,经典的面试题莫过于,判断字符串是否合法了.<br>判断字符串是否合法是这样的:有一个字符串,它只包含大中小括号,那么符号 ([)] 这样是不合法的,合法的应该是这样: ([]) ,同样 ([]){ 这样的符号也是不合法的<br>基于以上的共识,咱们先考虑使用数组的方式,来分析一下.</font></p><p><font face="华文中宋" size="3">1.  定义一个初始值,如果刚开始输入的就是 ( 或者 { 或者 [ ,那么我们不能立刻判断到它就是不合法的,因为它需要等待匹配,如果到最后还是没有匹配上,那就是不合法的;如果刚开始输入的是 ) 或者 } 或者 ] ,我们立刻就能知道这是不合法的.</font></p><p><font face="华文中宋" size="3">2.  如果此时输入了 ( 和 [ ,初始值应该 ++ ,接下来输入的是右边的符号的话应该是 ] 而不是 ) ,此时需要进行判断第三个输入的字符是否匹配第二个,只有第二个也匹配之后才需要进行匹配第一个字符.</font></p><p><font face="华文中宋" size="3">3.  如果匹配成功,则初始值应该 - - ,所有字符串匹配完毕之后,需要看初始值是否为最初赋予的值,如果是则说明所有符号都是合法的,否则说明还有符号没有匹配上,则不合法<br>经过这样的分析之后,写代码应该就比较好写了,比如我们可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否合法</span></span><br><span class="line"><span class="comment"> *      比如: "([)]" 不合法, "[()]" 合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-11-24 20:05:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsValidString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义字符串的内容</span></span><br><span class="line">        String symbol=<span class="string">"([])&#123;"</span>;</span><br><span class="line">        <span class="comment">// 调用判断方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result=isValid(symbol);</span><br><span class="line">        System.out.print(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用来接收传入的值</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="comment">// 定义一个数组,用来存放传入的字符串,长度为传入的字符串的值</span></span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="comment">// 定义 stackEnd 为 -1 是为了让第一个元素能够进入数组,即 stackEnd++ 值为 0</span></span><br><span class="line">        <span class="keyword">int</span> stackEnd=-<span class="number">1</span>,length=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果刚开始是左括号,左中括号等符号,则不能直接判断为该符号不合法,而是放入数组,等待匹配</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]==<span class="string">'('</span> || arr[i]==<span class="string">'['</span> || arr[i]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stackEnd++;</span><br><span class="line">                stack[stackEnd]=arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果刚开始就是右括号,右中括号等符号,则不合法,直接返回 false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((arr[i]==<span class="string">']'</span> || arr[i]==<span class="string">')'</span> || arr[i]==<span class="string">'&#125;'</span>) &amp;&amp; stackEnd==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 分情况来进行匹配</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i]==<span class="string">')'</span> &amp;&amp; stack[stackEnd]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">']'</span> &amp;&amp; stack[stackEnd]==<span class="string">'['</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">'&#125;'</span> &amp;&amp; stack[stackEnd]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果都匹配不到,说明该符号不合法,则直接返回 false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stackEnd!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果最后结果不等于 -1 ,说明 stackEnd 中还有符号没有被匹配到,则也是不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">可以明显看到,使用数组的话,会有很多 if , else , else if ,仿佛闻到了坏代码的味道.<br>如果使用栈来实现呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否合法</span></span><br><span class="line"><span class="comment"> *      比如: "([)]" 不合法, "[()]" 合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-11-24 20:05:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsValidString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义字符串的内容</span></span><br><span class="line">        String symbol=<span class="string">"([])&#123;"</span>;</span><br><span class="line">        <span class="comment">// 调用判断方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result=isValid(symbol);</span><br><span class="line">        System.out.print(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个空栈</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义 map ,用来存放匹配的符号</span></span><br><span class="line">        Map&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr=s.toCharArray();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果 map 中不包含进入的符号,说明是左边的符号,直接入栈即可</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                stack.push(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果进入的符号和栈顶的元素不匹配,则说明符号不合法</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(arr[i])!=stack.pop())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断栈是否为空,如果为空,说明所有符号都已匹配完毕,全都合法</span></span><br><span class="line">        <span class="comment">// 如果栈不为空,说明还有符号没有匹配到,则不合法</span></span><br><span class="line">        <span class="keyword">if</span> (stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">嗯,看起来简洁了不少.<br>欢迎评论区交流,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]04 Link List (链表)及单链表反转实现</title>
      <link href="/posts/745fa732.html"/>
      <url>/posts/745fa732.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在说链表的时候,就会常说另外一个概念:数组.<br>数组和链表,常常会拿到一起做比较.这篇文章也是,咱们来说说数组和链表.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">数组最大的一个特点就是,需要一块连续的内存空间.假设现在内存空间剩余了 1MB ,但是它不是连续的,这个时候申请一个大小为 1MB 的数组,会告诉你申请失败,因为这个内存空间不连续.<br>链表最大的一个特点是,不需要一块连续的内存空间.还是上面那个例子,如果申请的不是大小为 1MB 的数组,而是链表,就会申请成功.<br>如果只是理解到了这个层面,你是不是会觉得,我以后一直用链表这种数据结构就可以了?不不不,数组也有它自己的优势.<br>首先数组简单易用,又因为使用的是连续内存空间,就可以借助 CPU 的缓存机制,预读数组中的数据,因而访问效率更高,所以在插入,删除操作比较少,而查询比较多的情况下,使用数组是比较有优势的.<br>链表在内存中不是连续存储,对 CPU 缓存机制不够友好,也就没办法进行有效预读.所以链表适用于在插入,删除操作比较多的情况下使用.</font></p><p><font face="华文中宋" size="3">链表分为单链表,循环链表,和双向链表.<br>对于单链表来说,它的第一个节点也就是头结点记录着链表的基地址,而最后一个节点也就是尾节点则指向一个空地址 NULL ,循环链表也可以理解成特殊的单链表,只不过尾节点由原来指向一个空地址 NULL 改为了指向头结点.<br>单链表:<br><img src="/images/2019/单链表.jpg"></font></p><p><font face="华文中宋" size="3">循环链表:<br><img src="/images/2019/循环链表.jpg"></font></p><p><font face="华文中宋" size="3">但是在实际开发中,更加常用的链表结构是:双向链表.<br>它的结构是这样的:<br><img src="/images/2019/双向链表.jpg"></font></p><p><font face="华文中宋" size="3">我们能够看到它的特点是:占用内存较多,支持双向遍历.因为它有两个指针,所以相对单链表,一个数据就会多占用一些内存.<br>既然它占用内存较多,为什么在实际开发中还比较常用呢,这里面有一个思想在里面,咱们具体来讲讲.<br>我们知道,单链表,双链表在删除的时候,时间复杂度为 O(1) ,但是在实际开发中它的时间复杂度并不是这样,为什么呢?<br>这样想,一般在做数据删除的时候,你的操作是怎样的?<br>首先,查找在节点中「值等于给定某个值」的节点,找到之后再做删除对吧?也就是说在删除之前,是需要做查找这个工作的.而单向链表和双向链表在查找的时候时间复杂度为 O(n) ,因为它为了找到这个要删除的元素,需要将所有的元素都遍历一遍.将上面过程梳理一下就是,查找时间复杂度为 O(n) ,删除时间复杂度为 O(1) ,总的时间复杂度为 O(n) .<br>以上过程在双链表中是怎样的呢?因为双链表支持双向遍历,所以查找这个操作对它来说时间复杂度为 O(1) ,因为它是双向遍历,所以在查找元素时,不需要将所有的元素进行遍历,删除时时间复杂度为 O(1) ,总的时间复杂度为 O(1) .<br>因为双向链表的时间复杂度为 O(1) ,所以在开发中它是比较受欢迎的.而在这其中体现的一个最重要的思想就是:空间换时间.<br>当内存空间相对时间来说不是那么重要的话,那我们是不是就可以忽略次要的因素,着重解决主要矛盾?</font></p><p><font face="华文中宋" size="3">最后来实现一个比较常见的单链表操作—单链表反转<br>首先上代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表反转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/16 19:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data , Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化单链表</span></span><br><span class="line">        Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,node5);</span><br><span class="line">        Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">        Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">        Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line">        <span class="comment">// 调用反转方法</span></span><br><span class="line">        Node reverse=reverse(node1);</span><br><span class="line">        System.out.println(reverse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *单链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 为传入的单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019/11/16 19:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverse</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        Node current=list, <span class="comment">// 定义 current 为当前链表</span></span><br><span class="line">                afterReverse=<span class="keyword">null</span>;   <span class="comment">// 定义 afterReverse 为转换之后的新链表,初始为 null</span></span><br><span class="line">        <span class="comment">// 当前链表不为空,进行反转操作</span></span><br><span class="line">        <span class="keyword">while</span> (current!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 1. 保存当前节点的 next 指针指向的链表</span></span><br><span class="line">            Node next=current.next;</span><br><span class="line">            <span class="comment">// 2. 将当前节点的 next 指针指向反转之后的新链表</span></span><br><span class="line">            current.next=afterReverse;</span><br><span class="line">            <span class="comment">// 3. 保存当前的链表状态到新链表中</span></span><br><span class="line">            afterReverse=current;</span><br><span class="line">            <span class="comment">// 4. 将当前节点指针后移一位,进行下一次循环</span></span><br><span class="line">            current=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> afterReverse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">接下来断点调试,看看每次结果:<br>初始状态<br><img src="/images/2019/reverseListInit.jpg"></font></p><p><font face="华文中宋" size="3">第一次循环结束<br><img src="/images/2019/reverseListFirst.jpg"></font></p><p><font face="华文中宋" size="3">第二次循环结束<br><img src="/images/2019/reverseListSecond.jpg"></font></p><p><font face="华文中宋" size="3">第三次循环结束<br><img src="/images/2019/reverseListThird.jpg"></font></p><p><font face="华文中宋" size="3">第四次循环结束<br><img src="/images/2019/reverseListFourth.jpg"></font></p><p><font face="华文中宋" size="3">第五次循环结束<br><img src="/images/2019/reverseListFiveth.jpg"></font></p><p><font face="华文中宋" size="3">在写这篇文章的时候,特别是单链表反转那一块,考虑了很久,借鉴网上思路做出来,有的思路真的是很巧妙.<br>以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]03 计算时间和空间复杂度</title>
      <link href="/posts/e9497446.html"/>
      <url>/posts/e9497446.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">学习数据结构与算法的时候,避不开的一个知识点就是:时间复杂度和空间复杂度分析.<br><a id="more"></a></font></p><p><font face="华文中宋" size="5">为什么需要复杂度分析?</font></p><p><font face="华文中宋" size="3">一段代码我写好了,直接上手跑一遍,不就知道算法执行的时间和占用的内存大小了,为什么还要做分析呢?而且直接跑一遍得到的数据,准确的不能再准确了.<br>因为直接跑一遍得到算法执行的时间和占用的内存大小,有一定的局限性.<br>第一,同样一段代码,把它拿到 90 年代的笔记本上面执行,和拿到现在的笔记本上面执行,得到的时间是不一样的,所以直接拿来运行的代码,它的准确度真的够准确嘛?<br>第二,如果数据量不够多,直接运行程序得到的结果可能有失其准确性.比如,对于小规模的数据排序,插入排序可能会比快速排序更快.<br>对于计算时间和空间复杂度,一般是采用大 O 表示法来表示.</font></p><p><font face="华文中宋" size="5">时间复杂度计算:</font></p><p><font face="华文中宋" size="3">什么是时间复杂度呢?是指执行当前算法所消耗的时间.<br>常见的几种时间复杂度:O(1),O($log_2 n$),O(n),O($n^2$),O($2^n$),O(n!)<br>先来看一段简单的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">1000</span>;</span><br><span class="line">System.out.println(<span class="string">"Hi, your input is:"</span>+n);</span><br><span class="line">System.out.println(<span class="string">"Hey, your code is:"</span>+n);</span><br><span class="line">System.out.println(<span class="string">"Hello, your verification code is:"</span>+n);</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">先别往下看,你觉得这段代码的时间复杂度是多少?<br>是 O(1) 对吧?因为这段代码都是常量级的执行时间,所以对于时间复杂度来说,它的复杂度为 O(1).<br>请注意: O(1) 并不是指执行了一行代码,上面的程序执行了 3 行代码,它的时间复杂度也是 O(1).只要代码的执行时间不随 n 的增大而增长,那时间复杂度就都记为 O(1).一般情况下,只要程序中不存在循环语句,递归语句,就算是有上万行的代码,时间复杂度也是 O(1).<br>来看另外一段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">"Hello, your verification code is:"</span>+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">你觉得这段代码的时间复杂度是多少?<br>先来分析一下,这段代码执行了 n 次, 所以它的时间复杂度为 O(n).<br>如果是这样呢:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, your verification code is:"</span>+i+<span class="string">"and"</span>+j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">这段代码的时间复杂度是多少呢?<br>首先它有两个 for 循环,每个循环都会走 n 遍,所以这段代码的时间复杂度为  O($n^2$) .</font></p><p><font face="华文中宋" size="3">如果将以上代码合并在一起,它们的复杂度是多少?是  O(1) + O(n) + O($n^2$) 嘛?<br>不,只是 O($n^2$) .因为当 n 足够大时, O(1) 和 O(n) 对于程序的影响几乎都可以忽略不计,此时我们只需要关注最大量级即可.</font></p><p><font face="华文中宋" size="5">接下来说说,空间复杂度计算:</font></p><p><font face="华文中宋" size="3">什么是空间复杂度呢?是指执行当前算法需要占用的内存空间大小.也就是看使用了几个辅助变量.<br>照样上几段代码来看看.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">3</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">对于这段代码来说,它的空间复杂度是多少?<br>应该比较容易看出来,只使用了一个辅助变量,所以它的空间复杂度为 O(1).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">这段代码,申请了一个大小为 n 的数组,所以它是申请了 n 个辅助变量,所以它的空间复杂度为 O(n).这段代码是申请了一维的,如果是这样呢:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">你一定猜到了,它的空间复杂度是 O($n^2$)</font></p><p><font face="华文中宋" size="3">关于时间和空间复杂度的计算,大概就是这样了,感谢您的阅读哇~<br>我也不知道为什么, O($n^2$) 它不识别为 n 方,(逃;</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]02 什么是数据结构与算法以及我该怎么学</title>
      <link href="/posts/c30d995b.html"/>
      <url>/posts/c30d995b.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">什么是数据结构与算法呢?<br>当你看到这个问题的时候,你脑海中的第一反应是什么?<br><a id="more"></a></font></p><blockquote><p>数据结构就是指一组数据的存储结构,算法是操作数据的一组方法.</p></blockquote><p><font face="华文中宋" size="3">这样的答案是不是让你觉得,我去,这么抽象,所以算法是什么,数据结构是什么?还是一脸懵逼.<br>小时候我的问题可多了,总是问我母上大人,妈妈这个字念什么,那个字念什么.母上大人后来被我烦的不行,索性给了我一本&lt;新华字典&gt;,教我怎么查,从那儿以后再也没烦过她了.</font></p><p><font face="华文中宋" size="3">为什么要说这个事情,因为我觉得这就是一个解释什么是数据结构,什么是算法的例子.新华字典是按照字母的顺序来给汉字进行编号,那么厚的一本字典就是「汉字」的存储结构.接下来我有个字知道它的拼音,但是我不知道它念几声哇,怎么办呢?一种方法是:根据字母顺序定位,然后开始找;另外一种方法是:根据偏旁部首来找到这个字,然后再看看它在几页,定位过去.为了查找这个汉字,所采用的方法,就是常说的算法.</font></p><p><font face="华文中宋" size="3">你有没有发现,只要说数据结构,就一定提到算法,或者提到算法的时候,就会说到数据结构.为什么呢?<br>因为数据结构和算法是相辅相成的,数据结构是为算法服务的,算法主要作用在特定的数据结构之上,如果单独讲,没有什么意义,或者说意义不大.</font></p><p><font face="华文中宋" size="3">现在,我知道了学好数据结构和算法很重要了,但是我该怎么学呢?<br>我现在也是在摸索阶段,根据自己的经验来说说.</font></p><p><font face="华文中宋" size="3">第一,要学会站在巨人的肩膀上.<br>当你打开图灵图书的时候,你会发现这么一句话「站在巨人的肩膀上」,那么好的位置,如果用来放广告,会给它带来多少的效益啊,但是编辑没有这么做,反而是放了这样一句话,说明什么?说明这句话,特别值钱.<br>所以能从这句话里面学到什么?<br>站在巨人的肩膀上,能够少走很多弯路.现在互联网这么发达,只要你想学,课程一大堆,找一个好的课程踏踏实实的从头到尾学一遍,如果你对「知识付费」不排斥的话,我推荐极客时间上的「数据结构与算法之美」这个课程,我也在学习这门课程,给我的帮助很大.如果对付费比较排斥的话,我觉得大学计算机课程上的「数据结构导论」这本书吃透也差不多,不过我看的那个版本的是 C 语言的,对新手可能不太友好.</font></p><p><font face="华文中宋" size="3">第二,就是要多写,多练.<br>展示你实力的从来都是 no BB , show code .<br>想要学好算法也是这样,别说太多,干就完了.<br>一定要多写.前一段时间为了准备考试,把课本上的例子,用各种算法都手写了一遍,冒泡的话,这些顺序是怎么动的,快速排序的话又是如何变化的.<br>我觉得一定要用手写写画画,现在我对于算法思想有了一点儿感受.如果没有这个量,我觉得知道快速排序为什么快这一点是不会有很深刻的体会的.<br>多写,多练,没啥捷径.</font></p><p><font face="华文中宋" size="3">最后一点就是心态的问题了.<br>很多人,也包括我自己,常常是想着今天付出了,明天就要看到回报.<br>明明知道一口吃不成胖子,可是真的在生活中,却总是想着这样的事情.<br>心静,心静,让心沉淀下来.</font></p><p><font face="华文中宋" size="3">感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]说说最近的成果</title>
      <link href="/posts/f43ade7d.html"/>
      <url>/posts/f43ade7d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">继上次写的博客:<a href="https://www.dynamic-zheng.com/posts/a3f84cce.html">[碎碎念]总结一下最近在做的事情</a> ,过去了有一个月了,上次总结中做的一些事情,有的也有了一些转机,这周除了工作,其他时间都给了自考,技术上又没什么输出,所以厚着脸皮来说说最近.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">项目管理目前对我来说,已经没有那么大的挑战了.<br>真的很难想象,一个月之前我还因为带团队有种心有余而力不足的感觉,还害怕没带好团队而有各种愧疚,压力,害怕辜负了老大对我的期待.一个 Sprint 又一个 Sprint 走下来之后,到现在竟然有种游刃有余的感觉.<br>刚开始遇到的各种阻力,在团队拿出成绩之后,再开展其他工作,顺利了很多.所以还是少说话,多做事.<br>项目管理上一切事情应付的得心应手之后,这周除了工作之外,时间都用在了数据结构导论上.一周的时间需要把课本看完,刷题,工作回到家之后还会看书到晚上十一点,说自己很轻松是假的.<br>为了把数据结构拿下,手写了多少页的代码,各种排序算法写了多少遍,感觉都有些记不清了,收获也是有的,考完试之后就觉得自己稳了,在这个过程中,还把我的好奇心给勾出来了.<br>可能是因为手写算法排序的缘故,开始对算法的设计思想有了一个更新的认识.所以上一篇博客立了一个 flag ,说是要把数据结构和算法系统学习一遍,是因为我的好奇心真的被引出来了.<br>在过年之前,把这项目标完成.</font></p><p><font face="华文中宋" size="3">关于自考.<br>我还记得自考毕业答辩的时候,刚好赶上项目线上环境出问题,搞到凌晨两点多,然后开始通宵赶论文.<br>所以当时状态也是比较差的,答辩完之后,我觉得可能需要再来一次了.可能是因为老师看我比较不容易?最后的结果是过了.<br>自己是几斤几两还是有点儿认知的,是老师比较宽容,也是真的特别感激老师.<br>如果今年的数据结构导论过了的话,就差计算机网络这一门了. 17 年 5 月开始考试,到现在感觉终于看到了曙光一样.<br>趁着年轻,多折腾折腾事情,总觉得是好的.</font></p><p><font face="华文中宋" size="3">对于接下来的规划:<br>现在是 10 月 19 日,距离 1 月 1 日其实没有多少时间了.来一个小目标吧,万一实现了呢.<br>首先是工作上,把现在做的产品做出一版,尽快上线,让用户使用使用,看看数据怎样,再快速迭代开发下一版.<br>然后是技术上,把计算机网络协议系统过一遍,越往上走,越发现基础的知识很重要,趁发现的不晚,赶紧再补补.<br>还想着去考一个高级职称,所以这段时间,不管是工作上,还是学习上,都静下心来沉淀沉淀.<br>对于读书,能看够 50 本就行,目前来看这个目标没什么难度,也不打算给自己增加难度了,我知道能做到这件事情本身就已经很棒了,所以就不再给自己压力了.<br>关于身体,最近是要控制一下体重了,主要是新搬了家之后,一起合租的人都超会做饭,导致我 3 天的时间,体重从 90 斤直接飙到 93 斤, emmm ,要控制一下了.搬家之后,距离公司 15 分钟的路程,每天走着去公司上班,一天下来感觉运动量也算是可以.<br>其他好像没什么重要的事情了.要是想起来了,我就再来补充.</font></p><p><font face="华文中宋" size="3">总是让你们看碎碎念,还有点儿不好意思,没啥干货,净是我在这儿瞎扯.<br>去看书了,让肚子里多点儿墨水.<br>感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[数据结构与算法]01 为什么要学数据结构与算法</title>
      <link href="/posts/5d7a3ce3.html"/>
      <url>/posts/5d7a3ce3.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">从今天起,我打算写一个系列,关于数据结构与算法.这篇文章,算是一个开篇之词吧.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">数据结构与算法,操作系统,计算机组成原理,还有计算机网络,这些内容在实际工作中你用到了多少?是不是除了面试的时候会问到,好像写代码的时候,也没怎么用,对吧?况且就算用到,我只要会调用 Java API ,开发框架用的相当熟练,代码照样 6 的飞起,那我为什么还要学习数据结构与算法呢?<br>Search for meaning ,为自己当下做的事情,寻找一个意义.</font></p><p><font face="华文中宋" size="5">你真的想在工作中一直 CRUD 嘛?</font></p><p><font face="华文中宋" size="3">对于一名业务开发工程师来说,可能每天要做的事情就是对数据库进行 CRUD(增删改查) 操作,更多的是利用已经封装好的接口,类库来把业务实现,很少需要自己去手写实现数据结构和算法.<br>但是一年一年的这样 CRUD 过去,你敢说自己拥有 10 年的工作经验,而不是 1 年的工作经验重复了 10 年?<br>好吧,就算你敢说,每天在工作中,一直 CRUD ,也没有想过去优化自己的代码,没有想过提高性能,你真的愿意一直这么下去吗?</font></p><p><font face="华文中宋" size="5">打造独属于你的能力.</font></p><p><font face="华文中宋" size="3">有人说,对于程序员这个行业来说,就是吃青春饭的,只要超过了 35 岁,再继续走下去就很难了.为什么?因为你拼体力拼不过比你更年轻的,你拼学习也拼不过那些年轻的.<br>这些是事实,但是随着年龄的增长,你也有自己独特的优势,那就是经验.<br>同样一个业务的代码实现,年轻人需要用上千行甚至是上万行代码去实现,而你只用了几百行的代码时(夸张一下);当年轻人写出来的代码,性能一般, bug 不少,扩展性也不强的时候,而你写的代码却没有这些问题,甚至可以到 Github 上让很多人来使用,我觉得这样的你,被公司辞退的可能性很小.<br>算法可以帮你打造这份,独属于你的能力.</font></p><p><font face="华文中宋" size="5">你想进入大厂工作嘛?算法是你必须要经历的一关啊!</font></p><p><font face="华文中宋" size="3">我觉得对于程序员来说,进入阿里,腾讯这些大厂应该是每个人都希望的,那是一个更广阔的平台,有很多成长的机会,能够接触到上亿级的并发.<br>如果想要进入这些大厂,算法是必经之路.<br>曾经看到过一个事情:有一位面试人大学本科是数学系,但是对计算机很感兴趣,去面试一家大厂,虽然其他方面答的都不是很好,但是算法这一关没有难住他,就这样他被录取了.<br>对于大厂来说,相对于短期能力,他们更看重你的长期潜力.就像建立大厦一样,只有地基稳固,上面的高楼大厦才会稳固.<br>算法,就是你向上走的地基.</font></p><p><font face="华文中宋" size="5">人和人之间的差距在哪儿?</font></p><p><font face="华文中宋" size="3">人和人之间的差距到底有多大?我觉得就是一个大脑的距离.一个人的大脑思考能力,从某种程度上来说,直接决定了这个人能够走多远,能够取得多大的成就.<br>值得开心的是:大脑的思考能力是可以被训练出来的.而算法是为数不多,也是最为有效的方法之一.</font></p><p><font face="华文中宋" size="3">如果想要扎实自己的计算机内功,向架构师方面走;想要提升看问题的深度,让自己站在一个更高的层面上;想要提高大脑的思考力,遇到问题能够抓住本质,绕不开数据结构与算法.</font></p><p><font face="华文中宋" size="3">以前也断断续续的学习过数据结构和算法,但是都不够系统.这次打算花上几个月的时间,把算法慢慢磨透.<br>我没有多厉害,只是出于对技术的追求,想要不断精进自己的技能,所以在学习过程中,难免会出现错误,如果您发现,可及时和我反馈.</font></p><p><font face="华文中宋" size="3">以上,如果您对学习数据结构和算法也感兴趣,可以持续关注我的博客(又开始不要脸了)<br>最后,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Jenkins]详细说说 Jenkins 配置那些事</title>
      <link href="/posts/525ce227.html"/>
      <url>/posts/525ce227.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">对于 Jenkins 的操作来说,搭建什么的我觉得没啥难度(如果觉得有难度,我觉得应该是没看我这篇文章:<a href="https://blog.csdn.net/zll_0405/article/details/85163461" target="_blank" rel="noopener">[Jenkins]CentOS7下Jenkins搭建</a>),困难在于配置文件怎么写.这篇文章详细来说说.<br><a id="more"></a><br>先说一下,这些配置只是起参考价值,具体还是需要根据自己的情况来.<br>对于后端来说,配置文件主要在构建之后需要执行的操作( # 后面为注释内容)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">tomcat_path=/usr/local/tomcats/tomcat-test       #定义 tomcat 的位置</span><br><span class="line">project_web=$tomcat_path/test.war #定义项目打包位置</span><br><span class="line">if [ -f $project_web ] ;then </span><br><span class="line">echo -- stop tomcat</span><br><span class="line">#kill tomcat pid</span><br><span class="line">pidlist=`ps -ef | grep tomcat-test | grep -v grep | awk &apos;&#123;print $2&#125;&apos;`#查看是否有进程正在运行</span><br><span class="line">if [ &quot;$pidlist&quot; = &quot;&quot; ]#没有进程在运行,则提示</span><br><span class="line">then</span><br><span class="line"> echo &quot;no tomcat pid alive!&quot;</span><br><span class="line">else#有进程在运行,杀掉</span><br><span class="line">   echo &quot;tomcat Id list :$pidlist&quot;</span><br><span class="line">   kill -9 $pidlist</span><br><span class="line">   echo &quot;KILL $pidlist:&quot;</span><br><span class="line">   echo &quot;tomcat stop success&quot;</span><br><span class="line">fi </span><br><span class="line"></span><br><span class="line">    echo -- 正在部署$project_web#将进程杀掉之后,重新进行部署</span><br><span class="line">    if [ -f $tomcat_path/webapps/test.war ] ;then#查看 /webapps 目录下是否有以前的 war 包,如果有,删掉</span><br><span class="line">        rm -f $tomcat_path/webapps/test.war</span><br><span class="line">        rm -rf $tomcat_path/webapps/test</span><br><span class="line">        echo -- 正在删除$project_web</span><br><span class="line">    fi </span><br><span class="line">        cp $project_web $tomcat_path/webapps/test.war#将新生成的 war 包复制到 /webapps 目录下</span><br><span class="line">    # start tomcat</span><br><span class="line">    echo $tomcat_path</span><br><span class="line">    #sleep 5</span><br><span class="line">    export JAVA_HOME=/usr/java/latest</span><br><span class="line">    #$tomcat_path/bin/startup.sh</span><br><span class="line">    $&#123;tomcat_path&#125;/bin/startup.sh </span><br><span class="line">else </span><br><span class="line">echo $BUILD_ID - 未找到$project_web</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">对于前端来说,主要就是需要注意一下前端特有的打包方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --unsafe-perm</span><br><span class="line">ng build --prod --env=test --output-path=typing-dev --base-href ./</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">对于 k8s 来说,需要在构建时创建事件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh -l </span><br><span class="line"></span><br><span class="line">examimage_path=reg.zll.com/library/test:1.0.0#定义镜像在 harbor 上的位置</span><br><span class="line"></span><br><span class="line">cp test-web/target/test-web.war test-web/src/profiles/k8s_prod/test-web.war#将 war 复制到目标目录下</span><br><span class="line">cd test-web/src/profiles/k8s_prod#进入目标目录</span><br><span class="line">docker build -t $examimage_path .#开始创建新的镜像,注意后面还有一个&quot;.&quot;,要不然命令是不会生效的</span><br><span class="line">docker push $examimage_path#将构建好的镜像推到 harbor 上面去</span><br><span class="line">echo &apos;推送镜像到harbor&apos;</span><br><span class="line"></span><br><span class="line">#删除本地镜像</span><br><span class="line">docker rmi -f $examimage_path#推送成功之后,将本地镜像删除</span><br><span class="line"></span><br><span class="line">#k8s部署</span><br><span class="line">echo &apos;开始部署&apos;</span><br><span class="line">kubectl delete -f $WORKSPACE/test-web/src/profiles/k8s_prod/.#将本地的都删除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo $WORKSPACE</span><br><span class="line">kubectl create -f $WORKSPACE/test-web/src/profiles/k8s_prod/.#部署最新的</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">以上就是我接触到的配置文件常用方法,希望能够帮助到你~<br>感谢您的阅读</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] IP 地址与 MAC 地址之间的关系</title>
      <link href="/posts/e579f21d.html"/>
      <url>/posts/e579f21d.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">了解计算机网络的话,逃不过 IP 地址和 MAC 地址.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">MAC ( Media Access Control ,介质访问控制 )地址,也叫硬件地址,长度是 48 比特( 6 字节),由 16 进制数字组成,分为前 24 位和后 24 位.前 24 位叫做组织唯一标志符( Organizationally Unique Identifier , OUI ),这是由 IEEE 的注册管理机构给不同厂家分配的代码,用来区分不同的厂家.后 24 位是厂家自己分配的,称为扩展标识符.对于同一个厂家来说,生产的网卡中 MAC 地址后 24 位是不一样的.<br>这样就保证了 MAC 地址的唯一性.</font></p><p><font face="华文中宋" size="3">MAC 地址应用的场景有很多.<br>1 ,在一个局域网内, IP 地址应该都是动态分配的,假如我在公司局域网内的 IP 地址是: 192.168.1.156 ,现在我不在公司使用了,那么这个 IP 地址就给了别人,让别人使用.<br>也就是说, IP 地址和你正在使用的设备是不对应的,那我发出的请求,就没办法准确无误的到达我这里,在这种情况下,进行通信肯定会出现问题.<br>MAC 地址和设备在全球范围内都是唯一的,所以在局域网内使用 MAC 地址进行通信没什么问题.<br>2 ,在早期的以太网,只有交换机,没有路由器,以太网之间就是通过 MAC 地址来进行通信,后来有了互联网,为了兼容原来还是使用 MAC 地址的模式,采用了 IP+MAC 地址的方式.</font></p><p><font face="华文中宋" size="3">估计看到这里你就有问题了,既然 MAC 地址在全球范围内都是唯一的,那我直接使用 MAC 地址来进行通信不就好了嘛?为什么还要有 IP 地址呢.<br>你想一想,全世界有那么多人,那么多人的 MAC 地址如果想要进行保存的话,是不是需要一张超级超级大 MAC 地址对应表?有了一张这样的对应表,为了寻找一个 MAC 地址,那个效率,想想就会很低.<br>而 IP 地址就可以很好的解决这个问题.<br>因为 IP 地址是网络提供商给你的,所以你在哪里整个网络都是知道的.<br>比如,你现在人在中国北京,那么 IP 地址就标识了你在中国.网络上有个请求需要到达你这里,对于别人来说,只需要将这个请求发送到中国就 OK 了,剩下的就是中国内部再进行处理.但是从全局来看,我只需要维护中国这个地址就够了.</font></p><p><font face="华文中宋" size="3">还有一点,随着设备越来越多,而且还有虚拟化的设备和网卡,有很多工具还可以对 MAC 地址进行修改,就很难保证不冲突了,也就是说, MAC 地址也只是理论上是全球唯一,对于 MAC 地址,最低要求是在一个局域网内, MAC 地址是唯一的.<br>MAC 的设计方式,虽然不能保证绝对唯一(毕竟世界上没有非常绝对的事情),但是能够保证在一个局域网内出现冲突的概率很小.这样的设计,就能够让一台机器启动的时候,在没有 IP 地址的情况下,可以先用 MAC 地址进行通信,获得 IP 地址.<br>如果在局域网内,还能出现 MAC 地址冲突的话,那就让网络工程师采取一定的机制解决冲突就好了,这方面我就不擅长了.</font></p><p><font face="华文中宋" size="3">以上.<br>接下来打算系统总结一下算法方面的知识.<br>最后,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]总结一下最近在做的事情</title>
      <link href="/posts/a3f84cce.html"/>
      <url>/posts/a3f84cce.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近更新频率特别低,我能感受到.因为技术方面的输入比较少了,所以不知道该输出什么有干货的内容给大家.<br>那我就说一下最近在做的几件事情吧,希望这其中的碎碎念,也能给你一些启发.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">1 ,转到项目管理.<br>项目管理对于当下的我来说,挑战特别大.<br>刚被提拔上来的时候,我是很懵逼的,我不知道这件事情到底是不是该我负责,这件事情到底需不需要我去做,不像以前只管开发就行了,上面分配什么我就去做什么就 OK 了.很多事情都需要我去思考,需要我不断的去问为什么,不断的去逼近问题的本质.<br>在这个过程中,慢慢对敏捷开发有了一些认识.刚开始提出来的时候,整个人对流程都是很懵的,到现在对整个流程的熟悉让我有了一种上手的感觉.<br>我开始知道从哪儿能够跟踪到整个团队的进度,知道之所以出现这样的问题是哪儿个环节没有做好,下次要怎么改正,开始能够发现到问题.<br>这段经历,对我来说真的是一个转变,让我不再沉迷于技术,而是抬起头来也看了看天空.<br>当然了,技术还是目前我所需要沉淀的,后期技术深度和广度的涉猎内容,会再提上日程.<br>生命不息,学习不止~</font></p><p><font face="华文中宋" size="3">2 ,准备自考毕设.<br>这是我最近比较头疼的一件事.我对 PB 是很不熟的那种,平时因为各种事情一直在拖,直到现在不能再拖延了,才开始动手. 20 号就要开始答辩,而自己还没怎么做,内心慌得一批.<br>可能是因为自己的运气比较好,每次遇到事情的时候,都有人出来帮助我.超级感谢颖娟,自考毕设的事情,她的功劳占据 70% ,很感谢身边的朋友一直都是这样,无私不求回报的帮助我.<br>这段时间,紧赶慢赶总算是在今天把论文初稿定出来了,邮寄给了自考负责的老师,现在就是等老师的批改意见,然后再进行修改什么的,就等着答辩就 OK 了.<br>等自考答辩完毕之后,准备自学考试.用我朋友的话说就是:我不是在考试,就是在考试的路上.</font></p><p><font face="华文中宋" size="3">3 ,尝试的一些其他事情.<br>对于一个技术人来说,最怕的就是沉迷于自己的技术世界,还不自知.我一直都深知这一点,所以也在尝试不同的事情.<br>第一就是读书.<br>在读各种书籍,刚去看了一下,电子书 + 实体书一共看了 30+ 本书了.今年打算看至少 50 本书的,目前来看这个目标今年达成是没什么问题的.<br>读的书籍很杂,有关于个人发展的,有关于管理方面的,有心理学方面的,最喜欢东野圭吾先生的书,每次读都沉进去出不来.<br>第二就是在尝试打破自己的交际圈.<br>因为身边人都是技术型人才,在一个圈里面,眼光视野难免有所局限,我在逐渐打破自己的交际圈.<br>也算是比较幸运,认识了几位比较厉害的大佬.具体多厉害我就不说了,就是由这件事让我知道,很多东西只要我想去尝试,那么我就能够达到自己的期望,而且如果再积极主动一些,一般都能做得更好一些.<br>第三就是开眼.<br>一个人想要尝试副业赚钱的前提是,知道自己的独特优势.<br>我还不知道,所以目前在看各种赚钱案例,在研究各位巨人是怎么一步步定位自己的.<br>开眼这件事,非常重要,接触不同的人之后,你会知道原来还能这样玩,原来还可以这么去做,还能从这个角度去想.<br>不断的去打破自己的思维局限,不断的挑战自己的认知,是一件很有趣的事情.<br>目前还是在开眼阶段,因为对各种赚钱案例看的还不够多,研究的还不是很深入,等我厚积的差不多了,我就要开始薄发了.</font></p><p><font face="华文中宋" size="3">以上就是最近在折腾的一些事情.<br>一句话,和大家共勉:要记住每个对你好的人,因为他们本可以不这么做的.<br>我几乎每天都会这样去提醒自己,所以每天对我来说都很惊喜.<br>最后,祝大家中秋快乐啊~(这篇碎碎念又有点儿长了,感谢你看到这里)</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]虚拟机中的网卡</title>
      <link href="/posts/5c46b427.html"/>
      <url>/posts/5c46b427.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近在学习极客时间上的一门课程&lt;趣谈网络协议&gt;,里面有涉及到虚拟机网络的一些东西.正好一直在接触,站在巨人的肩膀上,我也来写写.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">为什么需要用虚拟网络呢?我在现实世界中扯网线不可以嘛?其实是完全 OK 的,但是这样做的话,成本会非常高,主要有以下几个方面:</font></p><ul><li><font face="华文中宋" size="3">1 ,客户那边需要一台系统, OK ,自己去购买一台服务器,供客户使用.一台服务器可以使用至少是 10 年,在这期间,客户和你解除了合作关系,这台服务器还要不要?可别忘了,当时买这台服务器,可是花了价钱,还要把服务器放在机柜里,布线等等这些过程.</font></li><li><font face="华文中宋" size="3">2 ,客户那边说,给我的这台系统,内存不够用了,怎么办?用的是真实服务器,还能怎么办?把服务器停机弄下来再把内存条装上去.这个过程,客户那边如果还在用服务器,你就这么给弄下来了?还有一点,这个过程是需要人手动去做的,这个人力成本有算进去嘛?一台需要一个人,如果规模大起来,上万台服务器,其中有 100 台服务器需要更换内存,再用人力去解决问题?</font></li><li><font face="华文中宋" size="3">3 ,资源利用率不高.客户那边只需要一个 4 核 8G 的配置,但是服务器一般没有这么低的配置,所以剩下的资源怎么办?只能闲置.</font></li><li><font face="华文中宋" size="3">4 ,这台服务器我给了这个用户使用,然后使用期限到期了,这位用户没有续费,是不是就需要重装系统之后,才能给下一位客户使用?</font></li></ul><p><font face="华文中宋" size="3">这个需求挺大的,对吧?所以就有了虚拟机的概念.<br>虚拟机想要上网,就需要来聊聊虚拟机中的网络是如何工作的.<br>如果你在自己的笔记本上面倒腾过虚拟机,那你对虚拟机的三种联网方式应该会比较熟悉:仅主机模式,桥接模式和 NAT 模式.<br>下面就一个一个模式的来说说,正好倒腾虚拟机这么久,没有很系统的总结过.</font></p><p><strong><font face="华文中宋" size="3">仅主机( host-only )模式</font></strong></p><p><font face="华文中宋" size="3">这种模式,一般不常用,但是也来介绍一下.<br>这种模式提供的只是,物理机和虚拟机之间的相互访问,只是可以实现物理机和虚拟机之间的数据交换,但是虚拟机是没办法访问 Internet 的.<br>实现物理机和虚拟机之间的数据交换有两种方式:一是动态 IP 地址,另外一种是静态 IP 地址.<br>如果是采用动态 IP 地址的话,那就要多做一步:需要将你的网络共享.<br>如果是采用静态 IP 地址的话,虚拟机的 IP 设置,网关, DNS 设置都要注意和虚拟机网卡中相同.<br>此时,你的虚拟机是可以和物理机进行相互访问的.<br>但是请注意,此时你的虚拟机是访问不了 Internet 的!!!<br>host-only 模式,只是负责让你的虚拟机和物理机之间可以相互访问,并不负责让你的虚拟机联网.所以这种模式,一般都不常用.<br>毕竟你倒腾虚拟机,是为了能够上网搭建个集群什么的,对吧.</font></p><p><strong><font face="华文中宋" size="3">桥接( Bridge )模式</font></strong></p><p><font face="华文中宋" size="3">桥接,桥接,意思就是大家都在一个区域内,只是呢,需要一座桥来连接起来.<br>有前提的:就是大家要在一个区域内,也就是说距离不能太远.要不然你在北极,我在南极,这个桥建不起来,对吧.<br>通过这种方式,让虚拟机联网是最快的.因为它就类似于你在局域网中有另外一台电脑,只要虚拟机所在的物理机可以上网,那么通过桥接模式,也就可以上网了.<br>但有一点要注意,就是要保证虚拟机的 IP 和所在局域网的 IP 没有冲突.<br>如果你的物理机所在局域网 IP 地址没什么限制,用这种方法上网就行了,对新手也比较友好.如果 IP 地址比较稀缺,那就最好不要用这种方法上网.</font></p><p><strong><font face="华文中宋" size="3"> NAT ( Network address translate ) 模式</font></strong></p><p><font face="华文中宋" size="3">其实 NAT 联网这种方式,不单单在虚拟机中有应用,在实际中也有应用.比如:你的公司买了一个公网 IP : 114.114.114.114 ,但是你却发现,公司里面是有很多个 IP 地址的.<br>这就是 NAT 模式.具体工作原理就是:公司里面的一个 IP 地址是 192.168.111.111 这个地址想要访问 Internet ,此时这个 IP 地址所发送的请求会被包装成一个数据包,然后这个数据包会通过一个网关或者路由器,这个网关或者路由器的 IP 地址就是公司买的公网 IP .这样网关或者路由器在要发送数据包时,对数据包的 IP 协议层数据进行更改(也就是 NAT ),这样你就可以很顺利的去访问 Internet .这种方法的存在解决了两个问题: 1 , IP 地址稀缺问题; 2 ,公司的局域网 IP 也可以上网.<br>同样的道理,在虚拟机中 NAT 模式上网,也是如此.所以虚拟机中的网络 IP 地址,就算和物理机所在局域网的 IP 地址不一样,甚至不在一个网段内,也是 OK 的.在这里,物理机的 IP 地址就相当于虚拟机的网关,因而在这种模式下,虚拟机是可以 ping 通物理机的,但是物理机不能 ping 通虚拟机.<br>在这种模式下,联网方式也有两种:一是动态获取 IP 地址,另外一种是设置静态 IP 地址.<br>同样,对于新手来说,虚拟机的联网方式,使用动态获取 IP 地址就好了,具体就是在配置文件中,只需要将 onboot 改为 yes ,然后重启网卡,虚拟机就可以连接到网络上了.<br>如果想要设置静态 IP 地址也可以,就需要修改虚拟机网卡的网关,子网掩码和 DNS .<br>一般来说,使用动态获取 IP 地址这种方式就满足了大部分的需求,另外对于静态 IP 地址这一块,我一直没有实践过,怕误导,就不细说了.如果您感兴趣,可以细细钻研一下.</font></p><p><font face="华文中宋" size="3">以上.</font></p><hr><p><font face="华文中宋" size="3">推荐阅读:<br><a href="https://blog.csdn.net/zll_0405/article/details/88375625" target="_blank" rel="noopener">[Kubernetes]浅谈容器网络</a><br><a href="https://blog.csdn.net/zll_0405/article/details/88380279" target="_blank" rel="noopener">[Kubernetes]谈谈容器跨主机网络</a><br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] HTTPDNS 协议</title>
      <link href="/posts/4e5d330.html"/>
      <url>/posts/4e5d330.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在上篇文章中<a href="https://www.dynamic-zheng.com/posts/a43453ce.html">[计算机网络] DNS 协议</a>,介绍了 DNS 协议,它主要做两个功能:根据名称查到具体的地址;针对多个地址做负载均衡,而且可以在多个地址中选择一个距离我最近的地方,让我访问.<br>看起来这种方式无懈可击,但其实也有些问题.<br><a id="more"></a></font></p><h1 id="传统-DNS-存在的问题"><a href="#传统-DNS-存在的问题" class="headerlink" title="传统 DNS 存在的问题"></a><font face="华文中宋" size="3">传统 DNS 存在的问题</font></h1><p><font face="华文中宋" size="3">1 ,域名缓存问题:<br>客户端想要访问一个网址的时候,其实它首先是去看本地的缓存里面有没有这个地址,如果有就直接访问,如果没有才会去询问上级领导.<br>但是这个时候就会有个问题:比如在你上高中的时候,你知道学校旁边有个超好吃的店,后来你再想吃的时候,想都没想,直接去了那家店,结果发现人家关门了,你会不会非常失望?本地缓存也会出现这个问题,有的时候那个地址已经换掉了,但是因为本地缓存中有原来的地址,所以不会向上一级询问,将你导向原来的地址,结果就是访问不到界面,由此带来的用户体验不是很好.<br>还有个问题:假设我在北京海淀区,淘宝的应用因为某种原因没有在海淀区设置数据中心,然后我访问的时候,一直都是将我的访问请求发送到朝阳区.后来呢,淘宝在海淀区增加了数据中心,但是当我访问的时候,本地缓存依旧会将我的请求,导向到朝阳区那边,这样造成的结果就是: 1 ,对于客户来说,让他绕远路了.明明一个区域就可以解决的事情,偏偏要跨区域.就像明明在这里可以买到东西,偏偏让你跑到另外的地方去买,你开心嘛? 2 ,对于商家来说,也就是淘宝,我设置了新的数据中心,结果呢,客户的请求没能到这里,那我还费钱费力的去做这件事干嘛?又没有提高用户的体验,对不对.</font></p><p><font face="华文中宋" size="3">2 ,出口 NAT 问题:<br>在网关那里,很多机房都会在出口配置 NAT ( Network Address Translation ),即:网络地址转换.<br>也就是说,从这个网关出去的包,都会换成新的 IP 地址,当请求返回的时候,在网关这里,再将 IP 地址转换回去,这样造成的结果就是,权威的 DNS 服务器,没办法通过这个地址,来判断用户到底是来自哪个运营商,而且极有可能因为误判运营商,导致跨运营商访问,从而导致网速极慢.</font></p><p><font face="华文中宋" size="3">3 ,解析延迟问题:<br>DNS 的查询过程,需要递归遍历多个 DNS 服务器,才能得到最终的解析结果,这会带来一定的时延,甚至是解析超时.</font></p><h1 id="HTTPDNS-的工作模式"><a href="#HTTPDNS-的工作模式" class="headerlink" title="HTTPDNS 的工作模式"></a><font face="华文中宋" size="3">HTTPDNS 的工作模式</font></h1><p><font face="华文中宋" size="3">DNS 解析有很多问题,那怎么办呢?再回到最初的起点:直接 IP 地址?显然不合适啊.<br>这就引出了 HTTPDNS .说白了就是,它不走传统的 DNS 解析,而是走自己搭建基于 HTTP 协议的 DNS 服务器集群.这些集群分布在多个地点,当客户端需要 DNS 解析的时候,直接通过 HTTP 协议进行请求这个服务器集群,就可以得到最近的地址.<br>这样做就相当于每个客户端都是基于 HTTP 协议的,自己实现自己的域名解析,自己做一个自己专属的地址簿,而不是使用统一的地址簿.但是默认的域名解析都是走 DNS ,所以如果想要使用 HTTPDNS 的话,就需要绕过默认的 DNS 路径,这样就不能使用默认的客户端.<br>使用 HTTPDNS 的,一般都是手机应用,所以只需要在手机端嵌入支持 HTTPDNS 的客户端 SDK 就 OK 了.这样就可以通过自己的 HTTPDNS 服务器和相关的 SDK ,实现了从依赖别人,到自己上网查询,自己想去哪儿去哪儿,想干什么干什么,岂不是快哉~<br>HTTPDNS 工作模式具体可以描述如下:当手机要访问一个地址的时候,我会先看本地缓存里面有没有,如果有就直接访问,这个缓存是手机应用自己做的,至于如何更新,何时更新,那是手机应用的客户端的事情;如果没有的话呢,就需要请求 HTTPDNS 服务器,在本地 HTTPDNS 服务器的 IP 列表中,选择一个发出 HTTP 的请求,会返回一个要访问的网站的 IP 列表.因为是直接的 HTTP 通信,所以 HTTPDNS 服务器能够准确知道这些信息,所以可以做到精准的全局负载均衡.</font></p><p><font face="华文中宋" size="3">写到这里,这篇文章想要表达的是两点:<br>1 ,传统的 DNS 有很多问题:比如域名缓存问题,出口 NAT 问题,解析延迟问题<br>2 ,为了解决上述问题, HTTPDNS 通过客户端 SDK 和服务端,通过 HTTP 的形式,直接调用解析 DNS 的方式,绕过了传统的 DNS 的这些缺点,从而实现了智能的调度.</font></p><p><font face="华文中宋" size="3">以上是学的极客时间上&lt;趣谈网络协议&gt;这门课程,我已经感觉自己的脑袋有些大了…还有一些内容,我先自己慢慢消化一下…<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPDNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] DNS 协议</title>
      <link href="/posts/a43453ce.html"/>
      <url>/posts/a43453ce.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">大家应该都知道,当我访问一个网址的时候,实际上我是在访问一个 IP 地址.那为什么不记 IP 地址,反而要去访问一个网站名字呢,比如谷歌.<br>你可以想想,现在有多少网站,数不过来对吧?就算数的过来, 直接访问那么多的 IP 地址,恐怕也是记不过来的.不信你就记一串数字试试,是记一串数字容易,还是记一个 google 名字容易.<br><a id="more"></a><br>接下来有没有新的疑问?既然我在访问一个网址的时候,实际上是在访问一个 IP 地址,那浏览器怎么知道会到这个 IP 地址呢?<br>所以这就是 DNS 协议要做的事情:根据一个名称,我就可以访问到具体的 IP 地址.</font></p><h1 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h1><p><font face="华文中宋" size="3">每个人上网,都会访问网址,都会用到 DNS ,所以它是非常重要的,但这也是对它的挑战.因为只要它一旦出现了故障,那么整个互联网都几乎会瘫痪,因为你访问不到网址了嘛.<br>此外,上网的人分布在全世界,如果 DNS 服务器部署在一个地方,那么造成的访问时长会非常长,这样来分析的话, DNS 服务器一定得是高可用,高并发,分布式才能满足需求.<br>基于这样的需求,就有了树状的层次结构.</font></p><h1 id="DNS-解析流程"><a href="#DNS-解析流程" class="headerlink" title="DNS 解析流程"></a>DNS 解析流程</h1><p><font face="华文中宋" size="3">在全世界各地,都需要 DNS 来进行解析,所以为了提高 DNS 的解析性能,很多网络都会就近部署 DNS 缓存服务器,那么它是如何解析的呢?</font></p><ul><li><font face="华文中宋" size="3">1 ,当你想要访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的时候,你的电脑就会发出一个 DNS 请求,询问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 是什么,发给本地域名服务器(本地 DNS ).如果是通过 DHCP 来配置的话,那本地的 DNS 就是由你的网络服务商,比如电信,移动等自动分配.</font></li><li><font face="华文中宋" size="3">2 ,本地 DNS 收到来自客户端的请求之后,就开始找,看看能不能找到 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> ,如果可以的话,那就直接返回这个网址对应的 IP 地址.但是如果没有呢,那它就往上一级问.但是它的老大不直接进行域名解析,而是给出一个解决方案.</font></li><li><font face="华文中宋" size="3"> 3 ,它的老大发现请求是 .com,就说这个网址是由 .com 区域管理的,我帮你介绍一下,你去问问它.</font></li><li><font face="华文中宋" size="3">4 ,本地 DNS 就转向老大帮忙给介绍的那位朋友,说哥们,你能告诉我 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的 IP 地址嘛,但是这个哥们人家负责的是 .com 的所有,你问的是 google.com 的,它这里可能没有,然后就回复说,我这里没有,但是我知道谁负责 google.com 这一块的内容,你问问他可以吧.</font></li><li><font face="华文中宋" size="3">5 ,接下来,本地 DNS 就转向那位负责 google.com 的负责人,向人家询问,您好,请问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 对应的 IP 地址是啥呀?我的小主现在想要访问这个网址.</font></li><li><font face="华文中宋" size="3">6 ,那位负责人在这里经过查询之后,就告诉本地 DNS , <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 的 IP 地址是什么,此时本地 DNS 拿到 IP 地址之后,返回给客户端,这样客户端就和目标建立了连接.</font></li></ul><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p><font face="华文中宋" size="3">在上面的介绍中,那是一次 DNS 递归查询过程,因为本地 DNS 会全权为客户端效劳,所以只需要坐着等结果就行了.其实在这个过程中, DNS 除了可以通过名称映射为 IP 地址之外,还可以做另外一件事情,就是负载均衡.<br>什么意思呢?举个例子哈:我是河南濮阳人,让濮阳人最挂念的就是凉皮了,而凉皮里面最有名的则是「户大姐」这个品牌.现在我想吃户大姐的凉皮,但是我在北京,那我就在北京找一家店就去吃就行了,你在杭州,那你在杭州找家店吃就行.咱们不用非要去濮阳那一家店去吃.这就是负载均衡(我好像暴露了自己吃货的本性…)<br>投射到 DNS 上来,它也可以做成这样.</font></p><p><font face="华文中宋" size="3">DNS 可以做内部的负载均衡:<br>比如一个应用想要访问数据库,其实我们应该给它配置这个数据的 IP 地址才对,但是如果这个数据库因为某种原因,宕机之后,我该怎么办?需要将所有的用到这台数据库的 IP 地址,都进行更换.<br>如果使用域名的话,就比较简单了,这台数据库宕机之后,没问题,我只需要在 DNS 服务器中,将域名映射为新的 IP 地址就可以了.<br>这个过程,极大的降低了人力和时间成本.</font></p><p><font face="华文中宋" size="3">DNS 可以做全局负载均衡:<br>像淘宝, QQ ,微信这种应用,为了保证高可用,肯定会将这些应用部署在多个机房,每个地方都会有自己的 IP 地址.当用户要在淘宝上买东西的时候,那么这个 IP 地址就可以轮询访问多个数据中心.如果在广州的某个数据中心因为某种原因挂掉了,只需要在 DNS 服务器里面,将这个数据中心对应的 IP 地址删除就可以了,接下来就不会再去询问这个数据中心了.<br>此外,为了让客户体验比较好,访问速度比较快,肯定是希望在北京的用户访问北京的数据中心,在上海的用户,访问上海的数据中心.<br>这就是全局负载均衡的概念.</font></p><p><font face="华文中宋" size="3">最后,总结一下:</font></p><ul><li><font face="华文中宋" size="3">DNS 是网络世界的地址簿,可以通过域名查地址,因为域名服务器是按照树状结构来组织的,所以域名查找使用的是递归方法,并且通过缓存的方式来增强性能;</font></li><li><font face="华文中宋" size="3">在域名和 IP 的映射过程中,可以给应用做简单的负载均衡,也可以根据地址来做全局的负载均衡.</font></li></ul><p><font face="华文中宋" size="3">以上,感觉您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[年中总结]一个骄傲而又自卑的人的内心独白</title>
      <link href="/posts/37f969d7.html"/>
      <url>/posts/37f969d7.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">距离上次总结<a href="https://blog.csdn.net/zll_0405/article/details/83415343" target="_blank" rel="noopener">[年终总结]愿你永远清澈明朗,眼里有光</a>,过去了差不多有半年的时间,来回顾一下这半年的得与失.<br>我先以时间为节点,然后再说说碎碎念.<br><a id="more"></a></font></p><hr><p><font face="华文中宋" size="3">这一回顾,可能就要从 18 年 12 月份开始说了,当时井朝老大找我说项目要用 k8s ,让我找几个人一起研究研究.还记得当时我是推了所有的项目来专攻 k8s 的,钻进去了一个月,最后总算是钻出来了一些东西.</font></p><p><font face="华文中宋" size="3">19 年 1 月初,接到消息,让我去广州那边出差,当时第一反应是庆幸,还好把这边的事情弄完了,可以放心去.<br>到了广州那边,熟悉项目开发环境,适应新环境.<br>我总觉得实践完 k8s 之后,一定要去补充理论知识,否则就只是停留在会用的程度上,不会有什么深度.所以在广州出差的时候,白天工作,晚上到宾馆继续学习补充 k8s 的理论知识.但是没想到知识竟然那么多,从 1 月份断断续续学到了 4 月份(主要是拖延症太厉害).</font></p><p><font face="华文中宋" size="3">2 月份,项目转战到宜昌,一直到我回来之前,都是在这个地方度过的.<br>真的是体会到了南方多雨,几乎是没有看到过太阳.刚去各种不适应,最不习惯的地方就是吃了.南方吃的都偏辣,而我偏偏是有些不能碰辣的,脸上频繁爆痘,也没什么食欲,常常是需要刺激着胃才能吃的下去东西,相应的工作状态也不是太好,不过还好,算是挺过来了.<br>但是宾馆的老板娘很好,特别好说话.刚去的时候,我是觉得有些冷的,南方的冷是阴冷.</font></p><p><font face="华文中宋" size="3">3 月份,白天工作,晚上回去开始弄学院论文,因为 4 月份就要开始答辩,而自己的论文还没开始.<br>那段时间压力的确很大,项目,论文,自考,读书,各种事情赶在一起,有种心有余而力不足的感觉.而那一阵,总是头疼,可能真的是因为压力大的缘故.内心一度到过崩溃的地步,有时候真的特想破罐子破摔,什么都不管了,可是如果就那样轻易放弃,内心里却又有不甘.就这样,跌跌撞撞的挺了过来.</font></p><p><font face="华文中宋" size="3">4 月份,学院答辩,出人意料很顺利.还记得四月份答辩完之后,再往回看的时候,觉得挺过去之后原来也不过如此.现在再回忆,竟然觉得有点儿充实.<br>这个月也经历了自考,那段时间每天晚上回到家还会再学一会儿,一家人一起努力的感觉真的是超棒.<br>月底的时候,来了一场分享,对我来说是一种锻炼,第一次在那么大的舞台上展示自己.还好,我还能 hold 住.<br>4 月对我来说,是一个很忙的岁月,每天头疼到爆炸,当时心态都要崩了,最后总算是熬过来了.嗯,真的是熬过来了.</font></p><p><font face="华文中宋" size="3">5 月份,印象最深刻的就是,在线上给将近一千人进行了一场分享,在分享之前,我是有些怂的,因为里面大佬很多,而我只是一个小白而已.但是没想到能够得到那么多人的认可,也因此认识了很多优秀的人,深入交流了很多.也更加深刻的体会到了「分享」的好处.<br>还有一个挑战就是,将近月底的时候,项目上需要我在几天之内做出来一个界面.对我来说之所以是个挑战,是因为用的 Ionic ,这个我不太熟悉,相当于从 0 开始做.还好有前人的经验,加加班,最后在期限之前做了出来.<br>接任了项目总组长的职位,这个职位我感觉有很大一部分的幸运成分在里面,感谢吧,感谢如此信任我.<br>这一个月还忍痛放弃了一个赚钱的项目.真的是忍痛,没办法,我的时间精力在这儿,不可能每件事都做好,所以只能放弃.详细就不说了,说多了都是泪.</font></p><p><font face="华文中宋" size="3">6 月份,怎么说呢,是一个超级忙碌的月份.担任了考试负责人,月底就要项目带着上线,一个毫无经验的人,到了这个位置,很多东西都逼着我去做,去成长.面临的各种问题,各种难题,真的,如果你没经历真的体会不到.<br>这个月也在慢慢和别人磨合,尝试更好的去沟通.很多问题都是因为没有沟通,而产生的问题,所以如果能够沟通好,那些所谓的问题就不再是问题了.<br>因为各种原因,考评这边人手不够,我就去拉人.当时找到了玉彬和金颖,我和他们说,考评这边需要你们,就这一句话,他们放弃了自己手头的工作,二话不说就加入了进来.当时都被他们暖到了,真的特别感激这份信任和帮助.<br>还有很多其他小伙伴,这一说要感谢的人就很多了,所以就不说了<br>也是毕业的一个月,我彻底失去了学生这个身份.对于大学,感觉不算遗憾吧,各种滋味都体验了一遍,也不后悔,如果时光倒流,我依旧会选择这里,依旧选择这样生活.<br>当下,对我来说就是最好.</font></p><p><font face="华文中宋" size="3">7 月份,项目正式上线,其实出现了很多问题,但是因为有很多人的帮助,所以到最后都有惊无险,终于算是上线成功了吧.写了一个复盘,感兴趣可以瞅瞅:<a href="https://blog.csdn.net/zll_0405/article/details/94194270" target="_blank" rel="noopener">[复盘]记录一次带项目上线的经历</a><br>项目上线成功之后,就回家了.一直在准备项目上线的事情,真的是累坏了,所以回到家之后,开始了吃了睡,睡了吃的生活.我只有在家的时候,才会这么放松,可以全身心,什么都不想.和家人在一起,总是能让我收获很多力量.<br>呆了一周,又回到了工作岗位. 7 月份对我来说,是转型的一个月,开始从开发转到管理的一个月.<br>啊,对了,把运维负责人交接出去了~带新人带了有一年了,看到他也能够成长起来,很开心,交接给他,也可以很放心.</font></p><p><font face="华文中宋" size="3">8 月份到现在,开始慢慢适应「管理」的角色.<br>其实就我个人来说的话,我是感觉我是不适合担任「管理」的角色,但是当你主动去承担一些东西的时候,你会发现慢慢地开始把你往管理上推.<br>在其位,谋其政.既然在这个位置上,那就好好干,对自己负责,也是对别人负责.<br>前期也就是现在,觉得很吃力,但是我知道这也是我成长的地方,所以就慢慢磨吧.<br>什么事情都是慢慢来的.</font></p><p><font face="华文中宋" size="3">这半年的收获,说起来是很多的.<br>接下来说说这半年的碎碎念,毕竟除了上面的几件大事,我也思考了很多东西.</font></p><hr><p><font face="华文中宋" size="3">在外出差的那几个月,特别是过年那段时间,白天还在家,晚上就到了北京,第二天就到了廊坊,下午又到了北京,晚上睡了一觉醒来就在广州了,过了几天又到了宜昌.那段时间一直都觉得像是在做梦一般,不真实.<br>反正这半年的多数时间,不是在出差,就是在去出差的路上.火车,高铁,动卧,飞机,各种交通工具算是做了个遍.光是交通费,可以说也是一个收获了.</font></p><p><font face="华文中宋" size="3">有时候越想,越觉得自己很是幸运.当初想换个地方工作,结果就有机会来到南方看看.在南方浪完了,想回到北方,刚好又有机会可以回去.真的,有时候越想,对于发生的一切,就越感到感恩.<br>遇到的人,经历的事情,一切都刚刚好.<br>在广州的时候,唯一的遗憾就是还没好好玩,就撤了.期间经理请大家一起吃了顿饭,算是看了看那里的山,后来又去市中心一起嗨歌.这是在广州玩的印象.<br>后来去宜昌,三峡在那儿,还有别的风景区.因为在宜昌呆的时间比较长,所以周末休息的时候,会一起约着玩.<br>想到家豪哥,还有胡哥,内心的感激之情真的是不知道该怎么表达.身为男孩子的他们,一直对我和晓鸿照顾有加,而且两位都是很负责任的小哥哥,反正和他们在一起出差,什么事情都不需要操心的.也很庆幸,在出差的那段时间,一直都有晓鸿陪着我,喜怒哀乐都有她陪着.<br>南方以后有机会,还是会再去的.</font></p><hr><p><font face="华文中宋" size="3">如果你有出差在外的经历的话,应该能体会到在外面还能坚持学习的可贵.我在外面出差的那段时间,还能做到每周一篇博客,质量我也是敢打保证的.<br>之所以能够做到这样,是因为有人督促着我,带着我一起学.我很感激身边有这样的人带我,自考的时候,佳兴,小哲哲在晚上回家之后,还带着我学 1 个小时;恩君小姐姐有时候会给我分享一些我没有接触到的知识.<br>可能他们觉得带我学是一件双赢的事情,但是目前为止我感觉我没给对方带来什么,反而是我从对方那里,学到了很多.<br>是真的心存感激.</font></p><p><font face="华文中宋" size="3">说到朋友,真的是一件值得庆幸和骄傲的事情.庆幸交到的朋友每个人都是真诚的,都是善良的,而且每个人都是积极向上的.骄傲的是,交到的朋友对我都超级超级好.<br>哈哈哈,不要太羡慕我,我就是这么一个幸运儿~<br>感激这一路,一直陪伴的朋友们</font></p><hr><p><font face="华文中宋" size="3">在担任项目负责人的时候吧,有好几次真的是想撂挑子就不干了那种,压力大到有时候晚上都睡不着觉.害怕如果上线出各种问题怎么办,如果学生不能考试怎么办,虽然有别人顶着,但是你是这个项目的负责人,如果追责,我肯定是第一个要顶上去.<br>后来强迫自己早上 5 点半就起,中午也不允许自己休息,让自己保持这样的状态,晚上才能睡着那么一会儿.压力再大的话,就自己一个人在人民公园一圈一圈跑步.<br>现在往回看,我很感激这段经历.这段经历确实给我带来的压力很大,但也是我成长最快的一个月.<br>感谢那段时间所有同事的付出,如果没有他们的配合,项目是不可能上线的.</font></p><hr><p><font face="华文中宋" size="3">一个人如果能够想明白自己是谁,自己是怎样一个人,自己需要的是什么,那么他就会通透许多.而这半年来的经历,有很多时间都属于自己,再加上在外地出差的缘故,和自己关系好的朋友都没在身边,就使得我自己开始和自己对话.<br>接受自己的不完美,接受自己的平凡.尝试着接受自己,和自己和解,这一点说难也难,说简单也简单.我天生有些愚笨,到现在才肯些许接受当下的这个自己.<br>我感觉我以前做过许多错事,可能在别人看来那不是错事,反而是一段很美好的经历,但是对于我这样的性格来说,我还是有些不能接受的,所以我多少还是有些自卑的.这半年,开始慢慢接受自己,接受自己的不完美.<br>当我开始慢慢接受这个真实的自己时,我发现以前的迷茫,痛苦减轻了许多.<br>对我来说,最难的一件事,就是接受我自己.嗯,我在努力.</font></p><p><font face="华文中宋" size="3">很难想象,我这样一个喜欢热闹,喜欢和别人聊天的人,竟然也可以很长时间,悠然自得的和自己独处,我觉得现在如果再让我随意去一个地方,一个人呆很长的时间,我也是可以的.因为我很享受自己一个人的时候.可以看看书,听听歌,或者什么都不做,静静发呆,都觉得很好.<br>但是我这个人又是有些矛盾的,从某种程度上,我还是有些依赖人.特别是刚到一个新的地方,我会特别特别依赖别人.其实说到底,我还是没能好好和自己相处.<br>也不急,慢慢来吧,一个人想要达到自己的内心深处,是需要时间的. </font></p><p><font face="华文中宋" size="3">还有我这个人,身上毛病挺多的.比如脾气暴躁易怒,控制不住自己的情绪,也不会处理和别人的关系,闹了矛盾也不知道该怎么去解释.还特别容易敏感.</font></p><p><font face="华文中宋" size="3">如果你认识之前的我,就会知道我身上的戾气,知道其实我有多偏执.<br>读书,经历,这些真的会让你看透很多东西.</font></p><hr><p><font face="华文中宋" size="3">每次的总结,年中也好,年终也罢,都会提到我的父母.因为他们为我付出的,牺牲的东西真的是太多太多了.<br>我感恩我的父母为我付出的一切,感恩他们对于我一直都是舍得的,他们一直都是我想要变得更好的动力.</font></p><p><font face="华文中宋" size="3">上半年,经历的事情,思考的内容算是挺多的了,读书也是一直在做的.因为我清楚的知道,同样都是技术人员的话,那么拉开你和其他技术人员的差距,就在于你另外 20% 的思考与输出.所以这半年,书看了很多,也持续输出了一些内容.</font></p><p><font face="华文中宋" size="3">对于接下来的半年,继续技术沉淀,更加的踏实做事,积极主动,死不要脸,在成就自己的同时,也尽力成就他人.<br>以上,就是来自一个骄傲而又自卑的人的内心独白.</font></p><p><font face="华文中宋" size="3">最后,我特别感谢一直在阅读我文章的你们.是你们一直给我评论,给我鼓励,让我能够坚持到现在.<br>真的,特别感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年中总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] P2P 协议</title>
      <link href="/posts/1269457e.html"/>
      <url>/posts/1269457e.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在上篇文章中说过<a href="https://www.dynamic-zheng.com/posts/17a04cff.html#more">[计算机网络] FTP 协议</a>,要写写 P2P 协议的,嗯,来写写,虽然写的不是太好.<br><a id="more"></a></font></p><h1 id="P2P-是什么"><a href="#P2P-是什么" class="headerlink" title=" P2P 是什么?"></a><font face="华文中宋" size="3"> P2P 是什么?</font></h1><p><font face="华文中宋" size="3">还是要回到这个场景:<br>如果想要下载一个电影,一般都是通过什么方式呢?<br>我希望这次你的答案,除了 HTTP 方式,还有 FTP 方式(要不上篇文章岂不是白写了?)<br>但是你发现了嘛,不管是 HTTP 的方式,还是 FTP 的方式,都有一个比较大的缺点,就是难以解决单一服务器的带宽压力,因为它们使用的都是传统的客户端服务器的方式.<br>这个时候,一种创新的, P2P 协议就开始流行起来. P2P 就是 peer-to-peer .<br>传统的方式不是把资源都集中地存储在某些设备上了嘛,那我就创新一下,我不让这些资源都集中在某些设备上了,我让这些资源都分散的存储在多台设备上面去.这些设备,为了理解方便,我们称为 “ peer “</font></p><p><font face="华文中宋" size="3">那么,当我想要下载一个文件的时候,我只要得到那些已经存在了文件的 peer ,和这些 peer 建立点对点的连接,而不需要到中心服务器上面去,我就可以就近下载文件了.<br>一旦下载了文件,你也就成为了 peer 中的一员,你旁边的那些机器,也可能会选择从你这里下载文件.<br>所以当你使用 P2P 软件的时候,往往能够看到,它既有下载的流量,也有上传的流量,也就是说,你自己也加入了这个 P2P 的网络,自己从别人那里下载,同时也提供给其他人下载.<br>你可以想一下,这种方式,是不是参与的人越多,下载速度就越快,一起简直是完美啊~</font></p><h1 id="种子-torrent-文件"><a href="#种子-torrent-文件" class="headerlink" title="种子 (.torrent )文件"></a><font face="华文中宋" size="3">种子 (.torrent )文件</font></h1><p><font face="华文中宋" size="3">这里其实是有一个问题的,当我想要下载一个文件的时候,我怎么知道哪儿些 peer 有这个文件呢?<br>这就是种子文件,也就是「 torrent」文件.它由两部分组成: announce ( tracker URL )和文件信息.</font></p><ul><li><font face="华文中宋" size="3">文件信息里面有这些内容:<ul><li>info 区:这里指定的是该种子有几个文件,文件有多长,目录结构,以及目录和文件的名字;</li><li>Name 字段:指定顶层目录名字;</li><li>每个段的大小: BitTorrent ( 简称 BT )协议把一个文件分成很多个小段,然后分段下载;</li><li>段哈希值:将整个种子中,每个段的 SHA-1 哈希值拼在一起.</li></ul></font></li></ul><p><font face="华文中宋" size="3">下载时, BT 客户端首先解析 .torrent 文件,得到 tracker 地址,然后连接 tracker 服务器. tracker 服务器回应下载者的请求,将其他下载者(包括发布者)的 IP 提供给下载者.下载者再连接其他下载者,根据 .torrent 文件,两者分别告诉对方自己已经有的数据,然后交换对方没有的数据.这个时候,就不需要其他服务器的参与,就分散了单个线路上的数据流量,从而减轻了服务器的负担.</font></p><p><font face="华文中宋" size="3">从上面的过程,我们能够看出, P2P 这种方式特别依赖 tracker . tracker 需要收集下载者信息的服务器,并且将这些信息提供给其他下载者,使得下载者们相互之间能够连接起来,传输数据.虽然说,在整个下载的过程中,是非中心化的,但是加入这个 P2P 网络的时候,都需要借助 tracker 中心服务器,因为 tracker 服务器是用来登记有哪些用户在请求哪些资源.<br>到这里你可能就会比较清楚了,这种方式的限制就是 tracker 服务器.只要它出现故障或者线路遭到屏蔽, BT 工具就没办法再正常工作了.</font></p><h1 id="去中心化网络-DHT"><a href="#去中心化网络-DHT" class="headerlink" title=" 去中心化网络( DHT )"></a><font face="华文中宋" size="3"> 去中心化网络( DHT )</font></h1><p><font face="华文中宋" size="3">在整个下载的过程中,是非中心化的,但是它还是受限制的.那到底能不能做到彻底非中心化呢?<br>所以就有了 DHT ( Distributed Hash Table )的去中心化网络.每一个加入这个 DHT 网络的人,都要负责存储这个网络中的资源信息和其他成员的联系信息,相当于所有人一起构成了一个庞大的分布式存储数据库.<br>在这里有一种著名的 DHT 协议,叫 Kademlia 协议.</font></p><h1 id="Kademlia-协议详解"><a href="#Kademlia-协议详解" class="headerlink" title=" Kademlia 协议详解"></a><font face="华文中宋" size="3"> Kademlia 协议详解</font></h1><p><font face="华文中宋" size="3">在 Kademlia 协议中,任何一个 BitTorrent 启动之后,它都有两个角色.一个是 peer ,监听一个 TCP 端口,用来上传和下载文件,这个角色就是为了说明,我这里有某个文件.另一个角色 DHT node ,监听一个 UDP 的端口,通过这个角色,这个节点加入了一个 DHT 的网络.<br>在 DHT 网络中,每一个 DHT node 都有一个 ID .这个 ID 是一个很长的串.每个 DHT node 都有责任掌握一些知识,也就是<strong>文件索引</strong>,也就是说,它应该知道某些文件是保存在哪些节点上.它只需要知道这些东西就行了,不一定就是保存这个文件的节点.<br>这样我想要实现去中心化就好实现了.</font></p><p><font face="华文中宋" size="3"> 以上就是想要分享的内容了,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> P2P </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络] FTP 协议</title>
      <link href="/posts/17a04cff.html"/>
      <url>/posts/17a04cff.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">其实这篇文章本来打算写 P2P 协议的,结果发现写 P2P 协议的时候,需要写 FTP 协议,然后写完之后发现已经写了很多了.<br>好吧,这篇文章就先来写 FTP 协议,下篇文章再写 P2P 协议.<br><a id="more"></a></font></p><h1 id="先来一个场景"><a href="#先来一个场景" class="headerlink" title="先来一个场景:"></a><font face="华文中宋" size="3">先来一个场景:</font></h1><p><font face="华文中宋" size="3">如果想要下载一个电影,一般都是通过什么方式呢?<br>能想到的,或者最先想到的就是通过 HTTP 来下载对吧?但是你有没有过这样的体验,就是通过浏览器下载的时候,只要这个文件稍微大一些,下载的速度就会特别慢,特别是下载自己最想要看的电影的时候,你会觉得,我的天啊,怎么这么慢啊~<br>还有一种下载文件的方式,就是通过 FTP ( File Transfer Protocol ,文件传输协议).</font></p><ul><li><font face="华文中宋" size="3">FTP 有两个端口,一个是 20 ,一个是 21 ,所以 FTP 会采用两个 TCP 连接来传输一个文件.<ul><li><font face="华文中宋" size="3">控制连接:服务器以被动的方式,打开众所周知用于 FTP 的端口 21 ,客户端则主动发起连接.该连接将命令从客户端传给服务器,并传回服务器的应答.常用的命令有: list -获取文件目录; reter -取一个文件; store -存一个文件.</font></li><li><font face="华文中宋" size="3">数据连接:每当一个文件在客户端与服务器之间传输时,就创建一个数据连接</font></li></ul></font></li></ul><h1 id="FTP-的两种工作模式-详细讲讲这部分"><a href="#FTP-的两种工作模式-详细讲讲这部分" class="headerlink" title="FTP 的两种工作模式(详细讲讲这部分)"></a><font face="华文中宋" size="3">FTP 的两种工作模式(详细讲讲这部分)</font></h1><ul><li><font face="华文中宋" size="3">每传输一个文件,都要建立一个全新的数据连接. FTP 有两种工作模式,分别是主动模式( PORT )和被动模式( PASV ),这些都是站在 FTP 服务器的角度来说的.<ul><li><font face="华文中宋" size="3">主动模式:客户端随机打开一个大于 1024 的端口 N ,向服务器的命令端口 21 发起连接,同时开放 N+1 端口监听,并向服务器发出 “port N+1 “命令,由服务器从自己的数据端口 20 ,主动连接到客户端指定的数据端口 N+1 .</font></li><li><font face="华文中宋" size="3">被动模式:当开始一个 FTP 连接时,客户端打开两个任意的本地端口 N (大于 1024)</font></li></ul></font></li></ul><h1 id="主动模式-PORT-下-FTP-连接步骤"><a href="#主动模式-PORT-下-FTP-连接步骤" class="headerlink" title="主动模式( PORT )下, FTP 连接步骤:"></a><font face="华文中宋" size="3">主动模式( PORT )下, FTP 连接步骤:</font></h1><p><font face="华文中宋" size="3">1 ,客户端随机打开一个大于 1024 的端口 N ,同时一个 FTP 进程连接至服务器的 21 的命令端口.此时,我们来梳理一下,源端口为客户端的随机端口 N ,远程端口为服务器端的端口 21 ;<br>2 ,客户端开始监听端口 ( N + 1 ),同时向服务器发送一个端口命令(通过服务器的 21 命令端口),这条命令就是为了告诉服务器客户端正在监听的端口号并且已准备好从这个端口接收数据;<br>3 ,服务器打开 20 端口,并且建立和客户端数据端口的连接,然后向服务器发送一个应答,告诉服务器,已经建立好了一个连接.<br>看似完美,但是其实是有个问题的,比如客户端的数据端口,防火墙并没有开放,那么你就没办法完成数据的传输.<br>这也是被动模式( PASV )想要解决的问题.</font></p><h1 id="被动模式-PASV-下-FTP-连接步骤"><a href="#被动模式-PASV-下-FTP-连接步骤" class="headerlink" title="被动模式( PASV )下, FTP 连接步骤:"></a><font face="华文中宋" size="3">被动模式( PASV )下, FTP 连接步骤:</font></h1><p><font face="华文中宋" size="3">这种模式,是在客户端通知服务器,它处于被动模式时才启用.<br>在被动方式 FTP 中,命令连接和数据连接都由客户端发起,这样就可以解决从服务器到客户端的数据端口的连接被防火墙过滤掉的问题.<br>1 ,当开启一个 FTP 连接时,客户端打开两个任意的非特权本地端口( N&gt;1024 和 N+1 );<br>2 ,打开两个端口之后,第一个端口连接服务器的 21 端口,与主动方式的 FTP 不同,客户端不会提交 PORT 命令并允许服务器来回连它的数据端口,而是提交  PASV 命令;<br>3 ,此时,服务器会开启一个任意的非特权端口 (P &gt; 1024)并发送 PORT P 命令给客户端.然后客户端发起从本地端口 N+1 到服务器的端口 P 的连接用来传送数据.<br>对于服务器端的防火墙来说,必须允许下面的通讯才能支持被动方式的 FTP ：<br>1 ,从任何大于 1024 的端口到服务器的 21 端口(客户端的初始化连接);<br>2 ,服务器的 21 端口到任何大于 1024 的端口(服务器响应到客户端的控制端口的连接);<br>3 ,从任何大于 1024 端口到服务器的大于 1024 端口(客户端初始化数据连接到服务器指定的任意端口);<br>4 ,服务器的大于 1024 端口到远程的大于 1024 的端口(服务器发送 ACK 响应和数据到客户端的数据端口)</font></p><p><font face="华文中宋" size="3">总结一下,上面所说的那些.<br>在网络传输中,如果想要使用 FTP 协议,如果不是大神,玩的不是很 6 ,建议选择被动模式,一般情况下,能满足需求;<br>如果您是大神,玩的超级 6 ,当我上面什么都没说~</font></p><p><font face="华文中宋" size="3">感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机网络]简单聊聊套接字 Socket</title>
      <link href="/posts/d26db2c7.html"/>
      <url>/posts/d26db2c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="Socket-由来"><a href="#Socket-由来" class="headerlink" title=" Socket 由来:"></a><font face="华文中宋" size="5"> Socket 由来:</font></h1><p><font face="华文中宋" size="3">在学习一个新知识之前,要去想它为什么会出现,它的出现解决了什么问题.这样印象才会深刻一些.<br><a id="more"></a><br>在同一个主机下,两个进程间的通讯是很容易,直接把各种通讯细节交给操作系统去做就 OK 了.但是如果两个进程是处于不同主机下呢?该如何进行通讯呢?而且在实际的应用场景中,是很复杂的,有的使用 TCP 协议,有的使用 UDP 协议,那么当我们使用不同的协议进行通信时,是不是就要使用不同的接口?同时还要处理不同协议的各种通讯细节,这样一来,是不是就增加了开发的难度,同时软件不容易进行扩展.<br>编程思想之一就是「面向对象」,同样,在遇到这种问题时,我能不能把不同协议的通信细节抽出来,这样程序员在使用的时候,直接调用,就不需要再关注协议本身了.而这就是 Socket 的由来.<br>它提供接口,来进行互联的不同主机之间的进程通信.你想要让不同主机之间通信? OK ,你直接调用我就行,至于我怎么实现,程序员不需要 care .</font></p><p><font face="华文中宋" size="3">在上面的基础上,我们能够达成一个共识:如果一个应用,需要在客户端和服务端之间进行通信,那就需要创建一个 Socket 实例.<br>那么问题来了,我如何使用?<br>Socket 进行的是端到端的通信,中间经过多少局域网,路过多少路由器,我是不清晰的,所以能够设置的参数,也只是端到端协议之上的网络层和传输层.<br>在网络层, Socket 函数需要指定使用到的协议到底是 IPv4 还是 IPv6 ,分别对应设置为 AF_INET 和 AF_INET6 .此外,还需要说明你是使用 TCP 协议,还是 UDP 协议. TCP 协议是基于数据流的,所以设置为 SOCK_STREAM , UDP 是基于数据报的,因而设置为 SOCK_DGRAM .</font></p><h1 id="基于-TCP-协议的-Socket-程序函数调用过程"><a href="#基于-TCP-协议的-Socket-程序函数调用过程" class="headerlink" title=" 基于 TCP 协议的 Socket 程序函数调用过程"></a><font face="华文中宋" size="5"> 基于 TCP 协议的 Socket 程序函数调用过程</font></h1><p><font face="华文中宋" size="3">客户端和服务端创建 Socket 之后, TCP 的服务端要先监听一个端口,一般是先调用 bind 函数,给这个 Socket 赋予一个 IP 地址和端口.为什么需要 IP 地址呢?有时候一台机器会有多个网卡,相应的就会有多个 IP 地址,可以选择监听所有的网卡,也可以选择监听一个网卡,这样只有发给这个网卡的包,才会给你.那我为什么还需要端口呢?你要知道,你写的是一个应用程序,当一个网络包来的时候,内核是需要通过 TCP 头里面的这个端口,来定位到你这个应用程序的.<br> 此时,当服务端有了 IP 和端口号,就可以调用 listen 函数进行监听.在 TCP 的状态图中,有一个 listen 状态,当调用这个函数之后,服务端就进入了这个状态,这个时候客户端那边就可以发起连接了.</font></p><p><font face="华文中宋" size="3">在内核中,为每个 Socket 维护了两个队列,一个是已经建立了连接的队列,说明此时三次握手已经完毕,处于 established 状态;一个是还没有完全建立连接的队列,也就是说这个时候三次握手还没完成,处于 syn_rcvd 的状态.<br>接下来,服务端调用 accept 函数,拿出一个已经完成的连接进行处理.如果客户端还没有完全建立连接,没别的办法,就等着咯.</font></p><p><font face="华文中宋" size="3">在服务端等待的时候,客户端可以通过 connect 函数发起连接.现在参数中指明要连接的 IP 地址和端口号,然后开始发起三次握手.内核会给客户端分配一个临时的端口,一旦握手成功,服务端的 accept 就会返回另一个 Socket .<br>注意一下,在这里有一个经常考察的知识点,就是监听的 Socket 和真正用来传数据的 Socket 是两个,一个叫做「监听 Socket 」,一个叫做「已连接 Socket 」.<br>连接建立成功之后,双方就开始通过 read 和 write 函数来读写数据,就像往一个文件流里面写东西一样.之所以把 TCP 的 Socket 描述成一个文件流,是因为 Socket 在 Linux 中就是以文件的形式存在的.</font></p><p><font face="华文中宋" size="3">在内核中, Socket 是一个文件,那对应就有文件描述符.每一个进程都有一个数据结构 task_struct ,里面指向一个文件描述符数组,来列出这个进程打开的所有文件的文件描述符.文件描述符是一个整数,是这个数组的下标.<br>这个数组中的内容是一个指针,指向内核中所有打开的文件的列表.既然是一个文件,就会有一个 inode ,只不过 Socket 对应的 inode 不像真正的文件系统一样,保存在硬盘上,而是在内存中.在这个 inode 中,指向了 Socket 在内核中的 Socket 结构.<br>在这个结构中,主要的是两个队列,一个是发送队列,一个是接收队列.在这两个队列里面保存的是一个缓存 sk_buff .这个缓存中能够看到完整的包的结构.</font></p><p><font face="华文中宋" size="3">以上,就是基于 TCP 协议的 Socket 程序函数调用过程的一个描述.<br>接下来说说基于 UDP 协议的 Socket 程序函数调用过程.</font></p><h1 id="基于-UDP-协议的-Socket-程序函数调用过程"><a href="#基于-UDP-协议的-Socket-程序函数调用过程" class="headerlink" title="基于 UDP 协议的 Socket 程序函数调用过程"></a><font face="华文中宋" size="5">基于 UDP 协议的 Socket 程序函数调用过程</font></h1><p><font face="华文中宋" size="3">对于 UDP 来说,和 TCP 还是有些不一样的.首先, UDP 是没有连接的,也就不需要三次握手,也不需要调用 listen 和 connect ,但是 UDP 的交互仍然需要 IP 和端口号,那就需要 bind .<br>UDP 是没有维护连接状态的,也就不需要对每对连接建立一组 Socket ,而是只要有一个 Socket 就可以和多个客户端通信.也是因为没有连接状态,所以每次通信的时候,都调用 sendto 和 recvfrom ,这样才可以传入 IP 地址和端口.</font></p><p><font face="华文中宋" size="3">写完这篇文章,我觉得我得去把&lt; TCP/IP 协议详解&gt; 这本书看看了~<br>以上就是想分享的一些内容了,感谢您的阅读哇~</font></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[读书]软技能:代码之外的生存指南</title>
      <link href="/posts/94c2433f.html"/>
      <url>/posts/94c2433f.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">前几天在家休息,把这本书看完了,收获颇多.<br>内容很丰富,我在这里说一下对我来说比较受启发的几点.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">1 ,如何构建自己的影响力,如何推销自己.<br>世界上没有一种快速成功的方法,如果有,那就是想要割你的韭菜.<br>那么如何构建自己的影响力,如何推销自己呢?<br>好好写博客,如果可以的话,录制视频,或者参加演讲大会.这些都是提升自己的影响力,向别人推销自己的方法.<br>但无一例外,都需要你坚持去做,都需要时间上的积累.<br>另外,我是真的建议好好读一读这篇文章<a href="https://www.dynamic-zheng.com/posts/cb0264f.html">[碎碎念]来谈谈写作这件事</a><br>这篇文章,被微笑大佬赞赏过,所以我觉得,它其实还是值得去读一读的.</font></p><p><font face="华文中宋" size="3">2 ,你是如何对待你的工作的?<br>我不太清楚别人是如何看待工作的,我先说一下我的看法.<br>在公司工作,就像在学校上学一样,但是也有点儿不一样,哪里不一样呢?就是我在上初中,高中,大学的时候,我为了学习知识,需要向学校交钱.但是我在公司呢,也是在学习知识,也是在让我成长,但是我不仅不需要向公司交学费,公司还给我发钱.<br>我每次想到这里的时候,我都开心到飞起.所以每次在公司的时候,我都精神满满.<br>为什么说到这一点,是因为书里面有一句话我很认同:你所能犯的最大错误就是相信自己是在为别人工作,这样一来你对工作的安全感已然尽失.职业发展的驱动力一定是个体本身,记住:工作是属于公司的,而职业生涯却是属于你自己的.<br>工作是属于公司的,但是你如何对待工作,如何对待这一切,由此对你的职业生涯的影响,都是你自己的.</font></p><p><font face="华文中宋" size="3">3 ,关于「学习」<br>这里说的「学习」是说自学.<br>我们上了很多年的学,但是场景都是老师在上面讲,学生在下面听那种模式.(如果你不是,那您是大佬)<br>这种模式,是别人灌输给你的,而不是你自己学习的.如果一直依赖别人来教你,在相当大的程度上,会限制住你的发展.<br>怎么理解呢.如果遇到一个你没有遇到的问题,我觉得相当有一部分人都会直接拿着这个问题,向前辈请教.但是这样的方法,并不是一个特别好的方法.<br>好的方法是:你先自己研究一下,大多数情况下你会发现,谷歌一下, 80% 的问题都是可以解决的.如果还是没解决,你可以去向前辈请教,但是这和你刚开始不会就向前辈请教可不一样,这个时候的你,带着自己的思考,带着自己的钻研去向前辈请教,你会给前辈留下一个很好的印象.<br>这是自学的一个好处,遇到问题,你不依赖别人就能够解决掉,会让你下次遇到问题的时候,依旧可以快速定位,慢慢地这种解决问题的能力,就被培养起来了.<br>这本书的作者,提出了一种「十步学习法」,我觉得也是不错的一种方法,恕我愚笨,我没办法完整描述出来,如果您也感兴趣,可以去读一读.<br>「自学」的核心在于:发动自己的主观能动性,去学习知识.这种知识,会让你印象更加深刻.<br>而最好的「自学」方式,则是把知识交给别人.<br>好吧,我又想往写作方面扯了</font></p><p><font face="华文中宋" size="3">4 ,说说「理财」<br>你不理财,财不理你.这是特别简单的一件事.<br>那么对于理财这件事,我的观点是,越早开始越好.<br>这一块的内容,我目前也在尝试,还是小白,不说太多了.<br>这本书中的有些内容,可能是写的比较早了,感觉有些内容不太符合,但是读一读开阔一下眼界也还是不错的.<br>另外再推荐两本书&lt;小狗钱钱&gt;和&lt;富爸爸,穷爸爸&gt;,这是两本挺不错的启蒙书.</font></p><p><font face="华文中宋" size="3">5 ,你的身体是 1 ,你的技能是 0 .如果没有 1 ,后面有再多的 0 也是白搭.<br>对于软件行业的从业人员来说,一般一做就是一整天.一天两天还好,如果长久下去,你觉得你的身体会怎样?<br>在这里,借用明白大大的一句话:体能是事业的上限.<br>你的身体有多健康,你就能走多远.<br>另外,建议去看一看李开复先生写的&lt;向死而生:我修的死亡学分&gt;这本书.</font></p><p><font face="华文中宋" size="3">以上就是我读到这本书之后的一些感悟.最重要的就是最后一条,要不也不会把它放在最后来讲.<br>我相信这本书每个人读都会有不一样的感受,建议你也去读一下,开卷有益,特别是这样一本好书.<br>另外,建议这本书,越早开始读越好.如果你不是程序员,也可以读一读,有很多内容,我觉得对于其他行业的人来说,都是通用的.<br>希望这篇文章能够给你一些启发~<br>PS: 怎么感觉回家一趟,回来之后自己的文字表达能力不怎么好了?感觉有很多东西都没写出来.唉,惭愧惭愧</font></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[复盘]记录一次带项目上线的经历</title>
      <link href="/posts/7bc85a67.html"/>
      <url>/posts/7bc85a67.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">好久没来写博客了,因为这一段时间在忙着带领项目上线,现在已经整体结束,来复盘一下.<br><a id="more"></a><br>先说一下带领上线的系统:主要是负责某所高校的上机考试,那么为了保证学生能够考试,就需要和老师沟通,找老师要题库,核对题库,核对考生名单,安排考务等,在这整个过程中的所有事情.<br>学校那边机考是 6 月 27,28 号和 7 月 5,6,7,8,9 号,也就是说在这几天,学校那天会使用我们做的系统.<br>想想凭我一个人是不可能的,所以就找了马莹老大,让他负责系统的内容,找了玉彬和金颖,来负责和老师联系这一部分.我就是负责在这之外的所有事情以及提醒各负责人要做的事情.<br>背景交待完了,以下就是对这次带项目上线经历的一个复盘.</font></p><p><font face="华文中宋" size="3">首先,我肯定先说比较好的地方,毕竟这整个系统能够支撑起将近 1 万人的考试,我觉得还是很牛的一件事情.<br>1 ,各个负责人都超给力,各位同事也都很认真负责.<br>我还记得,当时让我负责这个项目上线的时候,我去别的项目组拉人,和彬彬还有金颖说,我这边需要你们的帮助,需要你们帮我一起做这件事情,他们二话没说,就加入进来了.我到现在对他们都觉得感激.在整个过程中,如果不是彬彬带着我熟悉整个业务流程,不是金颖一直督促我做各种事情,我真的会忙到死.<br>还有组内的其他同事,只要我这边有事情需要大家做的时候,每个人都积极主动,及时给我反馈.我记得有人为了让项目上线,几个中午没有休息,忙碌到晚上凌晨也有,每个人都没有去抱怨,只是想着如何把事情做得更好,怎么把问题解决掉.<br>有这样一群人一起共事,是一件非常幸福的事情.<br>2 ,在整个考试过程中,系统没出什么特别大的问题.<br>没出什么大的问题,是说基本上没有,如果非要 100% 没问题,就有些抬杠了.<br>出的问题其实也是小问题,因为网速比较慢,导致试题加载慢;因为网络延迟原因,导致时间跳转比较快等.这些问题,考务那边都可以自己解决.<br>我印象中特别深刻的就是,有一天早上有考试,结果开考了好几分钟,都没有进行反馈情况,我们这边都以为现场遇到了很大的问题,解决不了,急忙打电话过去询问,结果是现场非常顺利,没什么大的问题.当时就感觉,嗯,接下来的考试就稳了.事实证明想的没错,接下来的几场考试,几乎都没有问题.<br>稳~</font></p><p><font face="华文中宋" size="3">接下来说一下,还需要提高的地方.正确认识自己,才能更好地进步不是<br>1 ,前期测试不够充分.<br>就我的计划而言的话,我是希望在上线前两三天就进行测试的,但是实际上在上线的当天上午测试了一下,下午就这么上线了.就我而言,我是觉得很心虚,因为它没有经历过很充分的测试就上线了,所以第一场考试我去了一趟学校,到现场去看看有没有什么问题出现.如果系统第一场考试能够撑下来,那么接下来就没什么大的问题.<br>还好,没什么特别大的问题出现.出现的问题,严格来说,算不上系统的问题,是因为学校网络的网速问题,导致学生访问时比较慢,试题加载比较慢.<br>2 ,事情没有安排太好,时间上太仓促了.<br>就比如说,第二天学生那边有考试,今天晚上我们这边才把考试配置好.太仓促了,第一次打的我们真的是有些措手不及,不过还好接下来赶紧调整方向,接下来的几场考试,特别是最后两天的时候,我感觉是轻松许多的.</font></p><p><font face="华文中宋" size="3">说说对这个系统以后的规划吧,毕竟我也是带过这个项目的人了.<br>首先,要把时间成本,人力成本控制下来.<br>这次的时间成本,人力成本真的是太大了,就我来说,我将近一个月的时间都投入了进去,中午几乎没有睡过,晚上也是走的最晚的那个.<br>现在想想,其实没有必要,如果前期做好相关准备,后期会是相当轻松的一件事情.<br>其次就是,这个系统还有很多冗余的功能,等迭代开发的时候,没必要的功能,我觉得该砍掉就可以砍掉了.</font></p><p><font face="华文中宋" size="3">在以上整个过程中,我有些地方做的也是不太好.<br>1 ,压力大的时候,就有些控制不住自己的脾气.<br>对同事发过脾气,还好同事不和我计较,后期道歉的时候,同事说竟然没觉得我在发脾气.还好同事大人有大量,不和我一般计较.<br>但是这并不代表,自己就可以随意发脾气.唉,这个毛病,一直在改,接下来的日子,我再继续慢慢改<br>2 ,没有充分授权.<br>这个前期我没有意识到,很多事情都是自己做,后来彬彬跟我说,这些事情,其实你都应该分出去的,别把自己陷进去了,你就看不到全局了.<br>后面我就放手让别人去做.犯错误是肯定的,但是我允许别人去犯错误,而且犯的错误都在我的解决范围之内.<br>这样其实很好,既很好的锻炼了他们,也在某种程度上释放了自己.<br>我以后要忍住这样的冲动.</font></p><p><font face="华文中宋" size="3">真的特别感谢这段时间还陪在我身边的朋友们,谢谢你们,一直容忍着我的坏脾气,一起把这件事情做好了.<br>我觉得,带领了这次的项目上线之后,经历了这次的压力之后,以后就没什么能够难得到我了,哈哈哈~<br>但凡经历,便都是成长.</font></p><p><font face="华文中宋" size="3">最后,这一个月都没怎么好好读书,既然忙过去了,就该重启读书了,毕竟生命不息,学习不止,还有很长的路要走~<br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Docker]关于 Docker 入门,这一篇就够了</title>
      <link href="/posts/cc3d9aaa.html"/>
      <url>/posts/cc3d9aaa.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">关于 Docker 的一些概念和操作,我争取这一篇博客说完.<br>下面正文开始.<br><a id="more"></a></font></p><h1 id="Docker-镜像与容器"><a href="#Docker-镜像与容器" class="headerlink" title="Docker 镜像与容器"></a><font face="华文中宋" size="5">Docker 镜像与容器</font></h1><p><font face="华文中宋" size="3">说到 Docker ,你会常遇到两个内容: image 和 container (即镜像和容器)<br>关于镜像和容器,你可以这样来理解:镜像是构建 Docker 的基石,用户基于镜像来运行自己的容器.或者说,镜像是 Docker 生命周期中的构建或打包阶段,而容器则是启动或是执行阶段.<br>好吧,说的再明白点儿,就是有了镜像,才有的容器.容器是在镜像的基础上,才有的.</font></p><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a><font face="华文中宋" size="5">Docker 安装</font></h1><p><font face="华文中宋" size="3">以前写过,这里就不赘述了,直接上链接:<br>需要科学上网的安装方法:<a href="https://blog.csdn.net/zll_0405/article/details/84890806" target="_blank" rel="noopener">[Docker]CentOS7下Docker安装教程</a><br>不需要科学上网的安装方法:<a href="https://blog.csdn.net/zll_0405/article/details/85092766" target="_blank" rel="noopener">[Docker]CentOS7通过rpm包安装Docker</a></font></p><h1 id="Docker-相关命令"><a href="#Docker-相关命令" class="headerlink" title="Docker 相关命令"></a><font face="华文中宋" size="5">Docker 相关命令</font></h1><h2 id="Docker-操作相关命令"><a href="#Docker-操作相关命令" class="headerlink" title="Docker 操作相关命令:"></a><font face="华文中宋" size="3">Docker 操作相关命令:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker启动 docker</span><br><span class="line">systemctl status docker查看 docker 状态</span><br><span class="line">systemctl stop docker停止 docker</span><br><span class="line">systemctl enable docker开机自启</span><br><span class="line">docker info 查看 docker 概要信息</span><br><span class="line">docker --help查看 docker 帮助文档</span><br></pre></td></tr></table></figure><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令:"></a><font face="华文中宋" size="3">镜像相关命令:</font></h2><p><font face="华文中宋" size="3">查看镜像命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">搜索镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">拉取镜像:<a href="https://blog.csdn.net/zll_0405/article/details/85124404" target="_blank" rel="noopener">[Docker]Docker拉取,上传镜像到Harbor仓库</a></font></p><p><font face="华文中宋" size="3">删除镜像:<a href="https://blog.csdn.net/zll_0405/article/details/85217839" target="_blank" rel="noopener">[Docker]如何批量删除镜像</a></font></p><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令:"></a><font face="华文中宋" size="3">容器相关命令:</font></h2><p><font face="华文中宋" size="3"><strong>查看容器:</strong></font></p><p><font face="华文中宋" size="3">查看正在运行的容器:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看所有容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看最后一次运行的容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看停止的容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -f status=exited</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3"><strong>创建容器:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">可以在 run 后面加参数.其中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-i   表示运行容器</span><br><span class="line">-t   表示容器启动后进入其命令行</span><br><span class="line">--name  为创建的容器命名</span><br><span class="line">-v     表示目录映射关系(前者是宿主机目录,后者是映射到宿主机上的目录)</span><br><span class="line">-d     在 run 后面加上 -d 参数,则会创建一个守护式容器在后台运行</span><br><span class="line">-p     表示端口映射,前者是宿主机端口,后者是容器内的映射端口</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">交互式方式创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name=容器名称 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">守护式方式创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=容器名称 镜像名称:标签</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">登录守护式容器方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名称(或容器 ID) /bin/bash</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3"><strong>启动容器:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器名称(或容器 ID)</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3"><strong>停止容器:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名称(或容器 ID)</span><br></pre></td></tr></table></figure></font></p><h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝:"></a><font face="华文中宋" size="3">文件拷贝:</font></h2><p><font face="华文中宋" size="3">将文件拷贝到容器内<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 需要拷贝的文件或目录  容器名称:容器目录</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">将文件从容器内拷贝出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器名称:容器目录需要拷贝的文件或目录</span><br></pre></td></tr></table></figure></font></p><h2 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载:"></a><font face="华文中宋" size="3">目录挂载:</font></h2><p><font face="华文中宋" size="3">在创建容器时,将宿主机的目录与容器内的目录进行映射,这样可以通过修改宿主机某个目录的文件从而去影响容器<br>创建容器 添加 -v 参数 后边为 宿主机目录:容器目录,完整命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -v 宿主机目录:容器目录</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">如果共享的是多级目录,可能会出现权限不足的情况<br>可以通过添加参数 –privileged=true 来解决,因为 CentOS7 中安全模块将 selinux 权限禁掉了,添加此参数,可以将问题解决.</font></p><h2 id="查看容器-IP"><a href="#查看容器-IP" class="headerlink" title="查看容器 IP:"></a><font face="华文中宋" size="3">查看容器 IP:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器名称(容器 ID )</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">也可以直接输出 IP 地址:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&apos;&#123;&#123;NetworkSetting.IPAddress&#125;&#125;&apos; 容器名称(容器 ID)</span><br></pre></td></tr></table></figure></font></p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a><font face="华文中宋" size="3">删除容器</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器名称(容器 ID)</span><br></pre></td></tr></table></figure><h1 id="常见的应用部署"><a href="#常见的应用部署" class="headerlink" title="常见的应用部署"></a><font face="华文中宋" size="5">常见的应用部署</font></h1><h2 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署:"></a><font face="华文中宋" size="3">MySQL 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos/mysql-57-centos7</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">其中: -p 代表端口映射,格式为 宿主机映射端口:容器运行端口<br>-e 代表添加环境变量<br>MYSQL_ROOT_PASSWORD 是 root 用户的登录密码<br>3 ,进入 mysql 容器:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql /bin/bash</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">4 ,登录 mysql :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></font></p><h2 id="tomcat-部署"><a href="#tomcat-部署" class="headerlink" title="tomcat 部署:"></a><font face="华文中宋" size="3">tomcat 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat:7-jre7</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure></font></p><h2 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署:"></a><font face="华文中宋" size="3">Nginx 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建 nginx 容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure></font></p><h2 id="Redis-部署"><a href="#Redis-部署" class="headerlink" title="Redis 部署:"></a><font face="华文中宋" size="3">Redis 部署:</font></h2><p><font face="华文中宋" size="3">1 ,拉取镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2 ,创建 redis 容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure></font></p><h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a><font face="华文中宋" size="5">迁移与备份</font></h1><p><font face="华文中宋" size="3">容器保存为镜像:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit 容器名称 镜像名称</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">将镜像保存为 tar 文件,例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">镜像恢复与迁移: -i 输入的文件,例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure></font></p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a><font face="华文中宋" size="5">Dockerfile</font></h1><p><font face="华文中宋" size="3">Dockerfile 是由一系列命令和参数构成的脚本,基于基础镜像,最终创建一个新的镜像,常用命令有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM image_name:tag  定义了使用哪儿个基础镜像启动构建流程</span><br><span class="line">MAINTAINER user_name声明镜像的创建者</span><br><span class="line">ENV key value设置环境变量(可以写多条)</span><br><span class="line">RUN command 是 Dockerfile 的核心部分(可以写多条)</span><br><span class="line">ADD source_dir/file dest_dir/file  将宿主机的文件复制到容器内,如果是一个压缩文件,将会在复制后自动解压</span><br><span class="line">COPY source_dir/file dest_dir/file   和 ADD 相似,但是如果有压缩文件并不能解压</span><br><span class="line">WORDIR path_dir 设置工作目录</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">需要注意一下,如果要使用 Dockerfile 文件,名字必须为「Dockerfile」,否则里面的命令不会有效.</font></p><h1 id="镜像上传下载到镜像仓库"><a href="#镜像上传下载到镜像仓库" class="headerlink" title="镜像上传下载到镜像仓库"></a><font face="华文中宋" size="5">镜像上传下载到镜像仓库</font></h1><p><font face="华文中宋" size="3">以前写过博客,感觉还是比较详细的:<a href="https://blog.csdn.net/zll_0405/article/details/85124404" target="_blank" rel="noopener">[Docker]Docker拉取,上传镜像到Harbor仓库</a>(在上面应该也看到过了,再放一次)</font></p><p><font face="华文中宋" size="3">关于 Docker 入门,我只能帮你到这儿了~</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[回顾]说说我这大学四年</title>
      <link href="/posts/2b9683dd.html"/>
      <url>/posts/2b9683dd.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近更新频率有些低,因为最近在忙着学校毕业的事情.今天有时间,爬上来说几句,关于我这大学四年.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">前几天是高考,当时还单一和母亲视频,和她说,四年之前的这个时候,考试完之后我没想到会经历这么多,四年之前的那个选择,从某种程度上,可以说对我的影响很大.<br>我还记得报志愿的那个夏天,我把自己关在屋子里,选了几个我想要去的学校,相当一部分的原因是因为我想要去那个城市.我很早就和父母说了,我要出省,他们心理也有准备,但是当我和他们说,我要去桂林,要去吉林的时候,还是被吓到了.<br>父亲后来一直和我交流,说不反对我出省,但是我一个女孩子,能不能不去那么远,后来父亲又说,你报吉林,报桂林也行,能不能让我也给你选一个学校,你把它放在最后面,如果你被前面的学校录取了,我也认.<br>好吧,最后我屈服了,然后父亲超级开心的去地图上,找他想要让我去的城市.<br>离河南比较近的,就是河北,安徽,山西那些周围的地方.<br>记得特别清楚,当时我在和父亲说以后要怎样怎样,父亲突然扭过头和我说,你觉得「廊坊」这个城市怎么样,离北京也近,离天津也近,到时候你想去哪儿玩去哪儿玩,然后去看了一下,有这么一个学校可以供我选择,就那样报上了.</font></p><p><font face="华文中宋" size="3">说实话,当时来这个学校,只是为了应付一下父亲,没想到真的会被它录取.桂林,吉林那两所大学差了一两分,然后就被这所学校录取了,工程管理专业.<br>大一来的时候,舅舅,舅妈,爸爸,妈妈都来送我.当时室友还说,你家人怎么那么宠你,上个大学,还单一开车跑到学校来送你.<br>大一其实想想,没干啥.正常上课,好好准备考试.唯一和别人不一样的就是没有参加学生会,没参加什么社团,所以时间多了很多,没事打打篮球,读读书.当时是要求自己一周要读一本书的(现在做不到了).<br>打篮球的那一帮人,真的是我在大学里遇到的很好的人.我特别感激我的前辈们,一直都在照顾我,现在有困难的时候,只要和她们说,就会帮你.因为一起经历过很多事情,也因为大家的脾性都很相近.<br>大二决定转行去做编程,然后在学习自己专业课的同时,还在自学编程.和别人相比,少了很多玩乐的时间,我其实是有些乐在其中的,从编程里面获得了很大的成就感.后来觉得只是自己在看着视频学,这些东西,在公司到底能不能用得上.<br>所以在大二暑假去找了一份实习工作,也是那个时候,开始在 CSDN 上写博客,没想到,一写就写到了现在.<br>我算是比较幸运的,当时能够找到一份实习工作,老大对我也不错,后来大三开学要辞职走的时候,老大说其实你可以边工作边学习的,当然了一切都以你学校那边事情为重,上完课了就可以过来工作.然后就答应下来,就这样以这样的节奏,一直在这家公司呆到了现在.</font></p><p><font face="华文中宋" size="3">现在回过头来看,这大学四年,做的最正确的决定就是,选择来这所学校就读,选择早点儿到社会上历练自己.<br>前几天还在和老友聊天,他们说,感觉和我聊天,就像是在和前辈聊天一样,不论是从思考方式,还是思考角度,都和他们不一样.<br>这大概就是我这四年经历的一个反映吧.</font></p><p><font face="华文中宋" size="3">我这个月就要毕业了,彻底失去了学生这个身份.<br>如果是要失去的身份,尽早失去是好的.这样你会知道,失去身份之后的你,还有什么资本.</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java] J2EE 之 13 个规范总结</title>
      <link href="/posts/888348b8.html"/>
      <url>/posts/888348b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="J2EE-Java-2-Platform-Enterprise-Edition"><a href="#J2EE-Java-2-Platform-Enterprise-Edition" class="headerlink" title="J2EE( Java 2 Platform Enterprise Edition )"></a><font face="华文中宋" size="5">J2EE( Java 2 Platform Enterprise Edition )</font></h1><p><font face="华文中宋" size="3">在说 13 个规范之前,我们需要先来谈谈 J2EE ,它产生的背景是什么,解决了什么问题,这样清楚之后,再来谈 13 个规范,不至于觉得太突兀.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">产生的背景:<br>在企业级应用中,都有一些通用企业需求模块,比如数据库连接,邮件服务,事务处理等等.<br>既然很多企业级应用都需要这些模块,一些大公司便开发了自己的通用模块服务,也就是我们说的中间件.这样做的好处,就是可以解决重复开发,开发周期长和代码可靠性差等问题.<br>但是,这个时候就有一个问题,我的公司有我自己的标准,你的公司有你独自的一套标准,那是不是两家公司的中间件不兼容的问题就出现了?这样当用户使用的时候,就没办法将它们组装在一起为自己服务了,对吧?<br>这个时候怎么办呢?你可以想想实际生活中,为什么插排买回来,插上就能用,为什么我知道空调要买特定的插排,而我买回来就能插上使用.因为有「标准」对吧?所以我们才不用管这个插排买回来能不能用的问题.制定好标准之后,大家都去遵守,然后统一生产,对用户来说也方便.<br>同样的道理和想法, J2EE 就诞生了. J2EE 就是基于 Java 技术的一系列标准.<br>既然是标准,那么它的核心就是:一组技术规范与指南,其中包含的各类组件,服务架构和技术层次都有共同的标准及规格,这样就能够让依循 J2EE 架构的不同平台之间,存在良好的兼容性,这样不就解决了上面那种问题了~</font></p><h1 id="13-种规范"><a href="#13-种规范" class="headerlink" title="13 种规范"></a><font face="华文中宋" size="5">13 种规范</font></h1><p> <font face="华文中宋" size="3">在理解 J2EE 之后,就应该有这样的认识:这 13 种规范,是我们应该去遵循的.问题就来了,我需要遵循哪儿些呢?接下来一个一个说(这个排名不分先后~)</font></p><p><font face="华文中宋" size="3">1 , JDBC ( JavaDatabase Connectivity )<br>JDBC 是以统一方式访问数据库的 API .<br>它提供了独立于平台的数据库访问,也就是说,当我有了 JDBC API 的时候,就不必再为访问 Oracle 数据库专门写一个程序,为访问 Sybase 数据库又专门写一个程序等等,只需要用 JDBC API 写一个程序就够了,它可以向相应数据库发送 SQL 调用. JDBC 是 Java 应用程序与各种不同数据库之间进行对话的方法的机制.简单地说,它做了三件事:与数据库建立连接–发送操作数据库的语句–处理结果.<br>说到这里,有没有想起来 ODBC ?<br>如果想起来了,有没有想起来我写过一篇文章?<a href="https://www.dynamic-zheng.com/posts/7f1c23b6.html">[java]说说 JDBC ,再聊聊 ODBC</a></font></p><p><font face="华文中宋" size="3">2 , JNDI ( JavaName and Directory Interface )<br>JNDI 是一组在 Java 应用中访问命名和目录服务的 API .<br>JNDI 为开发人员提供了查找和访问各种命名和目录服务的通用,统一的接口,利用 JNDI 的命名与服务功能可满足企业级 API 对命名与服务的访问,诸如 EJB , JMS , JDBC 2.0 以及 IIOP 上的 RMI 通过 JNDI 来使用 CORBA 的命名服务.<br>在这儿,想多说一点: JNDI 和 JDBC 类似,都是构建在抽象层上.因为它提供了标准的独立于命名系统的 API ,这些 API 构建在命名系统之上.这一层有助于将应用与实际数据源分离,因此不管是访问的 LDAP , RMI 还是 DNS .也就是说, JNDI 独立于目录服务的具体实现,只要有目录的服务提供接口或驱动,就可以使用目录.</font></p><p><font face="华文中宋" size="3">3 , EJB ( Enterprise JavaBean )<br>J2EE 将业务逻辑从客户端软件中抽取出来,封装在一个组件中.这个组件运行在一个独立的服务器上,客户端软件通过网络调用组件提供的服务以实现业务逻辑,而客户端软件的功能只是负责发送调用请求和显示处理结果.<br>在 J2EE 中,这个运行在一个独立的服务器上,并封装了业务逻辑的组件就是 EJB 组件.其实就是把原来放到客户端实现的代码放到服务器端,并依靠 RMI 进行通信.</font></p><p><font face="华文中宋" size="3">4 , RMI ( Remote MethodInvoke )<br>是一组用户开发分布式应用程序的 API .<br>这一协议调用远程对象上的方法使用了序列化的方式在客户端和服务器之间传递数据,使得原先的程序在同一操作系统的方法调用,变成了不同操作系统之间程序的方法调用,即 RMI 机制实现了程序组件在不同操作系统之间的通信.它是一种被 EJB 使用的更底层的协议.<br>RMI/JNI : RMI 可利用标准 Java 本机方法接口与现有的和原有的系统相连接<br>RMI/JDBC : RMI 利用标准 JDBC 包与现有的关系数据库连接<br>就实现了与非 Java 语言的现有服务器进行通信.</font></p><p><font face="华文中宋" size="3">5 , JavaIDL/CORBA ( Common Object Request BrokerArchitecture )<br>Java 接口定义语言/公用对象请求代理程序体系结构<br>在 JavaIDL 的支持下,开发人员可以将 Java 和 CORBA 集成在一起.他们可以创建 Java 对象并使之可以在 CORBA ORB 中展开,或者他们还可以创建 Java 类并作为和其它 ORB 一起展开的 CORBA 对象的客户.后一种方法提供了另外一种途径,通过 Java 可以被用于将新的应用和旧的系统相集成.<br>CORBA 是面向对象标准的第一步,有了这个标准,软件的实现与工作环境对用户和开发者不再重要,可以把精力更多地放在本地系统的实现与优化上.</font></p><p><font face="华文中宋" size="3">6 , JSP ( Java Server Pages )<br>JSP 页面 = HTML + Java ,其根本是一个简化的 Servlet 设计.<br>服务器在页面被客户端请求后,对这些 Java 代码进行处理,然后将执行结果连同原 HTML 代码生成的新 HTML 页面返回给客户端浏览器.</font></p><p><font face="华文中宋" size="3">7 , Java Servlet<br>Servlet 是一种小型的 Java 程序,扩展了 Web 服务器的功能,作为一种服务器的应用,当被请求时开始执行. Servlet 提供的功能大多和 JSP 类似,不过, JSP 通常是大多数的 HTML 代码中嵌入少量的 Java 代码,而 Servlet 全部由 Java 写成并生成 HTML .</font></p><p><font face="华文中宋" size="3">8 , XML<br>XML 是一个用来定义其它标记语言的语言,可用作数据共享. XML 的发展和 Java 是相互独立的.不过,它和 Java 具有的相同目标就是跨平台.通过将 Java 与 XML 结合,我们可以得到一个完全与平台无关的解决方案.<br>突然想起来,以前写过一篇博客,感兴趣可以看看:<a href="https://blog.csdn.net/zll_0405/article/details/82950037" target="_blank" rel="noopener">【XML】快速了解XML</a></font></p><p><font face="华文中宋" size="3">9 , JMS ( JavaMessage Service )<br>它是一种与厂商无关的 API ,用来访问消息收发系统消息.它类似于 JDBC . JDBC 是可以用来访问不同关系数据库的 API ,而 JMS 则提供同样与厂商无关的访问消息收发服务的方法,这样就可以通过消息收发服务实现从一个 JMS 客户机向另一个 JMS 客户机发送消息,所需要的是厂商支持 JMS .<br>换句话说, JMS 是 Java 平台上有关面向消息中间件的技术规范.</font></p><p><font face="华文中宋" size="3">10 , JTA ( JavaTransaction API )<br>定义了一种标准 API ,应用程序由此可以访问各种事务监控.它允许应用程序执行分布式事务处理–在两个或多个网络计算机资源上访问并且更新数据. JTA 和 JTS 为 J2EE 平台提供了分布式事务服务.<br>JTA 事务比 JDBC 事务更强大,一个 JTA 事务可以有多个参与者,而一个 JDBC 事务则被限定在一个单一的数据库连接.</font></p><p><font face="华文中宋" size="3">11 , JTS ( JavaTransaction Service )<br>JTS 是 CORBA OTS 事务监控器的一个基本实现. JTS 指定了一个事务管理器的实现（ Transaction Manager ）,这个管理器在一个高级别上支持 JTA 规范,并且在一个低级别上实现了 OMGOTS 规范的 Java 映射.一个 JTS 事务管理器为应用服务器,资源管理器, standalone 应用和通信资源管理器提供事务服务.</font></p><p><font face="华文中宋" size="3">12 , JavaMail<br>用于访问邮件服务器的 API ,提供了一套邮件服务器的抽象类.</font></p><p><font face="华文中宋" size="3">13 , JAF ( JavaBeansActivation Framework )<br>JAF 是一个专用的数据处理框架,它用于封装数据,并为应用程序提供访问和操作数据的接口.也就是说, JAF 让 Java 程序知道怎么对一个数据源进行查看,编辑,打印等.<br>JavaMail 利用 JAF 来处理 MIME 编码的邮件附件.</font></p><p><font face="华文中宋" size="3">在学习过程中,找到了一篇文章,总结的非常棒(我这篇文章,几乎都是借鉴着写过来的),推荐大家看看,特别是最后一张图,感觉很形象:<a href="https://blog.csdn.net/zhuanzhe117/article/details/38763483" target="_blank" rel="noopener">J2EE 的 13 个规范总结</a><br>感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[碎碎念]来谈谈写作这件事</title>
      <link href="/posts/cb0264f.html"/>
      <url>/posts/cb0264f.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">写作这件事,很多大佬都谈过,但我还是想从自己的角度去谈谈.<br><a id="more"></a></font></p><h1 id="说到写作-我们就需要来说-我为什么要去写作-或者说-写作带给了我什么"><a href="#说到写作-我们就需要来说-我为什么要去写作-或者说-写作带给了我什么" class="headerlink" title="说到写作,我们就需要来说,我为什么要去写作,或者说,写作带给了我什么."></a><font face="华文中宋" size="3">说到写作,我们就需要来说,我为什么要去写作,或者说,写作带给了我什么.</font></h1><p><font face="华文中宋" size="3">1 ,可以系统性的思考.<br>我觉得你肯定有这样的感受,就是一个知识点我明明懂了,可是给别人讲的时候,却总是讲不明白.知道为什么嘛?因为你只是以为你自己懂了,实际上你并没有懂.<br>而写作就相当于你在给别人讲,那么你为了写明白一个知识点,为了让别人读懂你这篇文章,你会怎么做?<br>就拿这篇文章来说,为了向别人说明写作的重要性,你会怎么展开?起码会从是什么,为什么,怎么做,这三点去展开说,对吧.<br>那么,当你这样去写的时候,你发现,我好像对是什么不太清楚,所以你就会去查资料;我为什么要去用这个呢,想不明白,再去查资料;我怎么用这个知识呢,再去查资料或者实践.<br>这样做一次两次三次…当你坚持这样写完 100 篇文章的时候,你的思考角度,思维模式,绝对和写作之前不一样.</font></p><p><font face="华文中宋" size="3">2 ,构建影响力.<br>对于一个人来说,最重要的是什么?是有自己的「影响力」.<br>当你有自己的影响力时,你就能够在整个行业里面脱颖而出,从而能够有机会结识更加优秀的人.<br>但是影响力很轻松就能构建?只想说,别做梦了.<br>那么,我怎么构建影响力?</font></p><ul><li><font face="华文中宋" size="3"> 高质量的内容<br><font face="华文中宋" size="3">一件事情,你一定要想清楚,就是你和我都互相不认识,那么我凭什么信任你,我凭什么受你的影响,对吧.靠的就是高质量的内容.<br>我写博客,特别是需要实操的内容,比如安装 mysql , keepalived 这些文章的时候,都是自己操作一遍之后,确实是成功了,才敢发表出来.自己没有实践就写出来,我觉得是对读者的不负责任,那自然也就没有信任这一说.</font></font></li><li><font face="华文中宋" size="3">交给时间<br><font face="华文中宋" size="3">只要保证自己的内容是高质量的,剩下的交给时间就行了.<br>因为时间会告诉你,这一切是值得还是不值得.</font></font></li></ul><h1 id="既然写作给我带来了以上好处-那我该怎么做"><a href="#既然写作给我带来了以上好处-那我该怎么做" class="headerlink" title="既然写作给我带来了以上好处,那我该怎么做?"></a><font face="华文中宋" size="3">既然写作给我带来了以上好处,那我该怎么做?</font></h1><p><font face="华文中宋" size="3">1 ,找到你擅长的内容,不断细分,细分再细分,然后锤炼,锤炼再锤炼.<br>关于你擅长的内容,这一点需要你自己去寻找.<br>比如我,对于前端,运维,后端,等等都有一些学习和钻研,那我就开始写这方面的内容.<br>但是前端,运维,后端每一个都是很大的方向,我怎么着手去写?一个办法:细分.细分到什么程度呢?比如说,我今天遇到了一个前端的问题,我写下来记录一下,可不可以?完全 OK 啊!<br>但是写完了就没事了?不是的,还需要再锤炼.<br>我一般是写完之后,就发表出来.如果有人给我评论一下,指出我哪里做的不是太好,我真是太开心了,又是一个可以成长的机会.<br>然后我过一段时间之后,会再来看之前写的文章,这里写的不太好,改改.那里排版看着不太舒服,再改改.<br>所以如果你感兴趣的话,可以看看我最近写的内容,和刚开始写的内容,不管是内容,深度,还是排版,我打保证,绝对是不一样的.<br>而这,都是因为我找到了擅长的内容,不断细分,然后一直锤炼的结果.</font></p><p><font face="华文中宋" size="3">2 ,站在巨人的肩膀上.<br>站在巨人的肩膀上,能够走得更远.写作这件事也不例外,你也可以站在巨人的肩膀上,或者更准确的说,模仿.<br>到底怎么做呢?这么多年了,肯定有一篇文章,能够打动你,或者你认为写得很好.那么这篇文章就是巨人的肩膀.不断地去剖析这篇文章的组织架构,不断地去思考为什么作者这样写.<br>思考完了你以为就可以了?不不不,还差得远.思考完了,你觉得把这篇文章理解的差不多了对吧,尝试着不看文章,就把这篇文章写下来.结果你发现跟原文还是不一样的,对吧?然后再思考,这里作者为什么要用这个词语呢,作者的构思在这里和我不太一样,他这样写是出于什么思考呢?然后觉得自己思考的差不多了,再尝试不看文章,就把这篇文章写下来.上面这个过程,重复,重复再重复,直到你真的写出来了原文.<br>这个时候,你以为没事了?不不不,然后你需要再寻找下一篇你觉得好的文章,再重复上面的内容,等你重复这样做几十遍之后,当你再自己写文章的时候,你会惊讶的.<br>啊?你跟我说,你没有欣赏的文章?那你可以去读一读阅读量 10W+ 的文章,一篇文章如果能够有 10W+ 的阅读量,说明这篇文章可圈可点的内容有很多,可以去分析,模仿,站在巨人的肩膀上,走的更快,也更远.</font></p><h1 id="既然写作有这么多的好处-为什么写作的人不多"><a href="#既然写作有这么多的好处-为什么写作的人不多" class="headerlink" title="既然写作有这么多的好处,为什么写作的人不多?"></a><font face="华文中宋" size="3">既然写作有这么多的好处,为什么写作的人不多?</font></h1><p><font face="华文中宋" size="3">我觉得相当一部分的原因是因为,大多数人还没开始写作,就自己被自己吓死了.<br>怎么讲?你有没有这样的忧虑,当你想要开始写作的时候,突然有压力了,我如果写不好怎么办,我如果写的非常差劲怎么办,我还没搜集好相关素材…然后写作这件事就一直被放在了一边.<br>有这样的想法再正常不过,因为我刚开始在 CSDN 上写博客的时候也是这样,一想要在 CSDN 上写博客,心里就犯怵,我的天啊, CSDN 上牛人那么多,人家写的那么好,我再打磨打磨自己,我再深入学习学习,巴啦啦各种借口.后来就是破罐子破摔了,写的烂就写的烂了,先写出来再说吧.就这么逼着自己,先做起来.<br>结果呢,写出来之后发现,哎,这件事也没自己想象中那么难嘛~然后就这么一路写了下来.</font></p><p><font face="华文中宋" size="3">写作的人不多,我觉得可能还有一个原因就是,我写了但是没有人看,没有人跟我互动,让我突然没有了坚持下去的动力.<br>对于这一点,我只想说「将欲取之,必先予之」.<br>你想让别人来看你的博客,想让别人评论你的博客,给你动力或者提意见,让你写的更好,凭什么?<br>有一段时间我就挺鸡贼的,就是跑到各个博主下面去评论博客,因为别人评论我博客的时候,我会顺手点到对方博客里面去,看一眼别人写的内容,感兴趣的话,我就评论一下.这种心态,我觉得每个人可能都有,所以呢,我就跑到各个博主下面去评论人家的博客,有的博主就礼尚往来一下,也评论一下我的博客.<br>然后我一看,哇塞,有人评论我的博客了,不行我得再给对方评论回去.就这么一来二去,博客评论竟然也不少了,还连带着骗了很多粉丝,然后给我的动力就更大了,这样就形成了一个正反馈的闭环,直到现在写作对我来说成为了习惯.<br>所以呢,遇到问题,先从自身想想,别人凭什么要给你评论博客,这样问题就比较好解决了.</font></p><h1 id="「写作」和「笔记」的区别"><a href="#「写作」和「笔记」的区别" class="headerlink" title="「写作」和「笔记」的区别"></a><font face="华文中宋" size="3">「写作」和「笔记」的区别</font></h1><p><font face="华文中宋" size="3">我是一直建议身边的朋友写作的,但是几乎每次建议的时候,他们都会说,我有写啊,你看我都有记笔记.<br>所以这里说一下,「写作」和「笔记」的区别.<br>写作就是你需要发表出来,让别人看.如果写的太差劲了,你肯定不好意思发表出来,对吧?所以为了写一篇文章,你可能要花上两三个小时去写,我现在写一篇文章,都是先写一点儿东西,然后放在一边,过几天再回来看,再进行修改,然后再放在一边,过几天再来看,然后再修改.就这么一来一回,一篇文章从开始写,到它发表出来,至少有 5 天的时间.我写年终总结的时候,都是花费一周两周甚至是一个月的时间去写的,因为怕自己没写好,就把自己好不容易建立起来的信任给弄没了.<br>但是笔记呢,就是自己看,不需要发表出来,也不用担心写的好不好,遣词造句这些都不需要考虑,所以就写的比较随意,一个笔记,可能一分钟两分钟就完事了.结果呢?<br>我自己记的笔记,有时候过一段时间再回来看,我这儿写的啥,这上下文啥意思,一脸懵逼.嗯,就是随意到这种程度.<br>所以「写作」和「笔记」不一样,受众不一样,花费的时间不一样,质量也就不一样,而且留给自己的印象也不一样.<br>如果可以,还是尽可能的「写作」吧.</font></p><h1 id="什么人最适合写作"><a href="#什么人最适合写作" class="headerlink" title="什么人最适合写作"></a><font face="华文中宋" size="3">什么人最适合写作</font></h1><p><font face="华文中宋" size="3">请注意一下,我这里说的是「最适合」,并不是说不是这类型的人就不适合写作,而且这是我个人的观点,你可以不赞同.<br>我觉得大学生最适合写作.之所以这样认为,是有以下几点:</font></p><p><font face="华文中宋" size="3">1 ,有时间.<br>在大学里面的自由时间真的是太多了.一天除了上课之外,其余的时间都是自己的,最爽的是还有周六日.<br>工作之后就不一样了,首先工作之后,每天的 8 个小时是肯定要给公司的,等到公司这边忙完了,下班了,上司叫你去一个饭局;男/女朋友想让你陪她溜达溜达…你发现了嘛,等你工作之后,你的时间就已经不是你的时间了.<br>好,就算下班之后,你什么事情都没有,工作了一天,觉得很累吧?自制力差点儿的,想放松放松,刷刷抖音吧?所以就算下班之后,什么事情都没有,还能有人逼着自己去学习,去思考,去写作,不能说没有,但是很少.<br>对了,上面的情况,还没算加班.这样一对比,就能发现在大学,能够利用的时间,真的是太多太多了.</font></p><p><font face="华文中宋" size="3">2 ,没有压力.<br>大学生有什么压力呢?不用买房;不需要考虑父母年纪大的问题;还没成家,不需要考虑孩子的问题,不需要考虑婆媳关系.没钱了,给父母打个电话,上一秒还穷的不行,下一秒就富得流油.<br>所以写作这件事,对于大学生来说,是一件毫无压力的事情.我今天有灵感,就多写点儿,明天心情不开心,就不写了.也不用刻意的去追求,这篇文章要达到多少多少的阅读量,随心而动,率性而为.<br>但是工作了的人,你跟他说,好好写作吧,写作给你带来了很多很多的好处,他们都听不进去的.<br>也可能听得进去,也可能想要去做,但是一篇文章需要耗费好几个小时,还需要写很长时间才能有效果,他们就熬不下去了.</font></p><p><font face="华文中宋" size="3">3 ,写作这件事情,肯定是越早开始越好.<br>什么?你还想问问我为什么这件事越早开始越好?建议你再翻到上面,看看写作给你带来了什么好处.<br>系统性的思考,这种能力,越早锻炼自己,在以后越能少走弯路.通过写作,让自己的思考慢慢变的严谨,想法慢慢变得成熟,知识慢慢变得系统.<br>这种能力,动动小脑就应该知道,越早培养越好,对吧!</font></p><p><font face="华文中宋" size="3">所以写作这件事,对大学生来说,真的是再适合不过了.(不要脸的说一句,我就是活生生的一个例子)</font></p><h1 id="最后说几句"><a href="#最后说几句" class="headerlink" title="最后说几句"></a><font face="华文中宋" size="3">最后说几句</font></h1><p><font face="华文中宋" size="3">写作这件事情,如果认认真真去做,坚持下来,直到成为习惯,真的可以给你带来很多东西,但是这些东西都是无形的,就像前面说到的,系统性的思考,影响力,这些都没办法去量化.<br>但是如果因为看不到写作的意义,就不去写作,我觉得是一件非常可惜的事情.<br>生活中很多事情,其实我们都看不到它的意义,但是正因为这样,生活才充满了无限可能和乐趣,对不对?</font></p><p><font face="华文中宋" size="3">以上.<br>非常感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java]说说 JDBC ,再聊聊 ODBC</title>
      <link href="/posts/7f1c23b6.html"/>
      <url>/posts/7f1c23b6.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果要了解 J2EE 的知识,就不可避免的接触到 13 种规范.作为规范之一的 JDBC 吸引起了我的注意,因为我比较了解 ODBC .<br>所以这篇文章,就先说说 JDBC ,然后咱们再聊聊 ODBC ,最后再对比说一下,这样印象更深刻一些.<br><a id="more"></a></font></p><h1 id="JDBC"><a href="#JDBC" class="headerlink" title=" JDBC"></a><font face="华文中宋" size="3"> JDBC</font></h1><p><font face="华文中宋" size="3">JDBC ( Java DataBase Connectivity , Java 数据库连接)是一种用于执行 SQL 语句的 Java API ,可以为多种关系数据库提供统一访问,由一组用 Java 语言编写的类和接口组成.<br>使用 JDBC 的步骤:加载 JDBC 驱动程序 –&gt;建立数据库连接 Connection –&gt;创建执行 SQL 的语句 Statement –&gt;处理执行结果 ResultSet –&gt;释放资源<br>既然是和数据库相关,就不可避免谈谈 JDBC 常用接口:</font></p><ul><li><font face="华文中宋" size="3">1 , Driver 接口<br><font face="华文中宋" size="3">Driver 接口由数据库厂家提供,作为java开发人员,只需要使用 Driver 接口就可以了.在编程中要连接数据库,必须先装载特定厂商的数据库驱动程序,不同的数据库有不同的装载方法.</font></font></li><li><p><font face="华文中宋" size="3">2 , Connection 接口<br><font face="华文中宋" size="3">connection 与特定数据库的连接,在连接上下文中执行 sql 语句并返回结果. DriverManager.getConnection(url, user, password) 方法建立在 JDBC URL 中定义的数据库 Connection 连接上.<br>常用方法:</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createStatement() :创建向数据库发送 sql 的 statement 对象</span><br><span class="line">prepareStatement(sql) :创建向数据库发送预编译 sql 的 PrepareSatement 对象</span><br><span class="line">prepareCall(sql) :创建执行存储过程的 callableStatement 对象</span><br><span class="line">setAutoCommit(boolean autoCommit) :设置事务是否自动提交</span><br><span class="line">commit() :在链接上提交事务</span><br><span class="line">rollback() :在此链接上回滚事务</span><br></pre></td></tr></table></figure></li><li><p><font face="华文中宋" size="3">3 , Statement 接口<br><font face="华文中宋" size="3">用于执行静态 SQL 语句并返回它所生成结果的对象<br>常用的 Statement 方法：</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execute(String sql) :运行语句,返回是否有结果集</span><br><span class="line">executeQuery(String sql) :运行 select 语句,返回 ResultSet 结果集</span><br><span class="line">executeUpdate(String sql) :运行 insert/update/delete 操作,返回更新的行数</span><br><span class="line">addBatch(String sql) :把多条 sql 语句放到一个批处理中</span><br><span class="line">executeBatch() :向数据库发送一批 sql 语句执行</span><br></pre></td></tr></table></figure></li><li><p><font face="华文中宋" size="3">4 , ResultSet 接口<br><font face="华文中宋" size="3">ResultSet 提供检索不同类型字段的方法,常用的有:</font></font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getString(int index),getString(String columnName) :获得在数据库里是 varchar,char 等类型的数据对象</span><br><span class="line">getFloat(int index),getFloat(String columnName) :获得在数据库里是 Float 类型的数据对象</span><br><span class="line">getDate(int index),getDate(String columnName) :获得在数据库里是 Date 类型的数据</span><br><span class="line">getBoolean(int index),getBoolean(String columnName) :获得在数据库里是 Boolean 类型的数据</span><br><span class="line">getObject(int index),getObject(String columnName) :获取在数据库里任意类型的数据</span><br></pre></td></tr></table></figure></li></ul><p><font face="华文中宋" size="3">使用之后,依次关闭的对象及连接为: ResultSet –&gt; Statement –&gt; Connection</font></p><h1 id="ODBC"><a href="#ODBC" class="headerlink" title=" ODBC"></a><font face="华文中宋" size="3"> ODBC</font></h1><p><font face="华文中宋" size="3">在上面说了 JDBC ,我觉得看到 JDBC ,应该能够想到 ODBC ,所以接下来咱们聊聊 ODBC .<br>ODBC ( Open Database Connectivity )开放数据库连接,是为了解决异构数据库间的数据共享而产生的,用于对数据库的访问.<br>ODBC 实际上是一个数据库访问函数库,这样可以使得程序可以直接操纵数据库中的数据. ODBC 是基于 SQL 语言的,是一种在 SQL 和应用界面之间的标准接口,这样就免除了应用软件随着数据库的改变而进行改变的麻烦.<br>所以 ODBC 的一个显著优点就是:它生成的程序与数据库或数据库引擎是无关的,这样就为数据库用户和开发人员屏蔽了异构环境的复杂性,提供了数据库访问的一个统一接口,也就使得应用程序实现与平台的无关性和可移植性成为了可能.</font></p><li> <font face="华文中宋" size="3">ODBC 主要由四部分构成:应用程序,驱动程序管理器,驱动程序,数据源.<br><ul><br>     <li><font face="华文中宋" size="3">应用程序( Application ),主要任务有:连接数据库,提交 SQL 语句给数据库,检索结果并处理错误,提交或者回滚 SQL 语句的事务,与数据库断开连接<br>     <li><font face="华文中宋" size="3">驱动程序管理器 ( Driver Manager ):每种数据库引擎都需要向 ODBC 驱动程序管理器注册自己的 ODBC 驱动程序,这种驱动程序对于不同的数据库引擎是不同的. ODBC 驱动程序管理器能将与 ODBC 兼容的 SQL 请求从应用程序传给驱动程序,随后由驱动程序把对数据库的操作翻译成相应数据库引擎所提供的固有调用,对数据库实现访问操作.<br>     <li><font face="华文中宋" size="3">驱动程序:驱动程序是一个用于支持 ODBC 函数调用的模块,应用程序调用驱动程序所支持的函数来操纵数据库.若想使应用程序操作不同类型的数据库,就要动态连接到不同的驱动程序上. ODBC 驱动程序处理 ODBC 函数调用,将应用程序的 SQL 请求提交给指定的数据源,接受由数据源返回的结果,传回给应用程序.<br>     <li><font face="华文中宋" size="3">数据源:是用户,应用程序要访问的数据文件或数据库,以及访问他们需要的有关信息.它定义了数据库服务器的名称,登录名和密码等选项<br></font></li></font></li></font></li></font></li></ul></font></li> <h1 id="JDBC-与-ODBC"><a href="#JDBC-与-ODBC" class="headerlink" title=" JDBC 与 ODBC"></a><font face="华文中宋" size="3"> JDBC 与 ODBC</font></h1><p><font face="华文中宋" size="3">先说说 JDBC 和 ODBC 的联系.<br>JDBC 和 ODBC 都是用来连接数据库的启动程序, JDBC 和 ODBC 由于具有数据库独立性甚至平台无关性,因而对 Internet 上异构数据库的访问提供了很好的支持.</font></p><p><font face="华文中宋" size="3">接下来,说说 JDBC 与 ODBC 的区别(参考自:<a href="https://www.geeksforgeeks.org/difference-odbc-jdbc/" target="_blank" rel="noopener">Difference between ODBC and JDBC</a>):</font></p><table><thead><tr><th style="text-align:center">ODBC</th><th style="text-align:center">JDBC</th></tr></thead><tbody><tr><td style="text-align:center">ODBC Stands for Open Database Connectivity.</td><td style="text-align:center">JDBC Stands for java database connectivity.</td></tr><tr><td style="text-align:center">Introduced by Microsoft in 1992.</td><td style="text-align:center">Introduced by SUN Micro Systems in 1997.</td></tr><tr><td style="text-align:center">We can use ODBC for any language like C,C++,Java etc.</td><td style="text-align:center">We can use JDBC only for Java languages.</td></tr><tr><td style="text-align:center">We can choose ODBC only windows platform.</td><td style="text-align:center">We can Use JDBC in any platform.</td></tr><tr><td style="text-align:center">Mostly ODBC Driver developed in native languages like C,C++.</td><td style="text-align:center">JDBC Stands for java database connectivity.</td></tr><tr><td style="text-align:center">For Java applications it is not recommended to use ODBC because performance will be down due to internal conversion and applications will become platform Dependent.</td><td style="text-align:center">For Java application it is highly recommended to use JDBC because there we no performance &amp; platform dependent problem.</td></tr><tr><td style="text-align:center">ODBC is procedural.</td><td style="text-align:center">JDBC is object oriented.</td></tr></tbody></table><p><font face="华文中宋" size="3">你如果跟我说,看不明白,那就踏实学英语去吧!<br>以上,感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[mysql]修改 mysql 数据库端口</title>
      <link href="/posts/ade78a36.html"/>
      <url>/posts/ade78a36.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">背景:在一台 Linux 服务器上,安装了两个 mysql ,那么为了我能够同时连接到 mysql ,就需要对另外一个 mysql 修改连接端口.<br><a id="more"></a><br>修改 mysql 数据库之前,查看一下当前使用端口,命令(需要进入到 mysql 中进行操作),命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &apos;port&apos;;</span><br></pre></td></tr></table></figure></font></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3235nfvcaj30be036glo.jpg"></p><p><font face="华文中宋" size="3">可以看到,当前使用端口为 3306<br>接下来进入到 /etc 找到 my.cnf 文件,修改内容如下:<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g32369loe4j30di044q37.jpg"></font></p><p><font face="华文中宋" size="3">修改完成之后,重新启动 mysql 数据库,命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure></font></p><p><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3236vi7l6j30bl0403ym.jpg"></p><p><font face="华文中宋" size="3">此时,我们看到,已经修改成功.<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g323aigqywj30bg035t8t.jpg"></font></p><p><font face="华文中宋" size="3">端口已经修改成功了,如果 Navicat 连接不上 mysql 的话,就需要看看防火墙有没有打开相应的端口.想要打开特定端口,查看这篇文章吧,实在是懒得写了:<a href="https://blog.csdn.net/zll_0405/article/details/81208606" target="_blank" rel="noopener">CentOS7 开启防火墙及特定端口</a></font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[运维] proxmox ve 与 vSphere 对比</title>
      <link href="/posts/f77b1752.html"/>
      <url>/posts/f77b1752.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">一直关注我的博友,应该知道我曾经捣鼓过 vSphere 相关的内容,写过一个专栏: <a href="https://blog.csdn.net/zll_0405/column/info/21107" target="_blank" rel="noopener">VMware vSphere</a> ,起码有些许的成绩了,支撑起了公司大大小小的项目,虽然出过问题,但最后都有惊无险的熬了过来.<br><a id="more"></a><br>也算是基于兴趣,对这方面一直都有关注.前几天,贺信找到我,说发现了一个可以尝试的系统软件: proxmox ve (为了方便,下面我就写 proxmox 系统了).<br>在了解它之后,发现这个系统软件还真的不错,后期看看能不能推进一下这个方案,争取把这个方案落地.</font></p><p><font face="华文中宋" size="3">为什么想要推进这个方案,让它落地呢.我主要有以下几点考虑:<br>1 , proxmox ve 是开源的,而 vSphere 是收费的.<br>开源和收费,我觉得都没多大关系,只要符合自己公司当前发展的需求,我觉得付费也是 OK 的.但是开源的在于,它的氛围很不错,而且我看了一下,遇到的问题都有人写出过解决方案,这一点我是很看好的.(不过大部分解决方案都是英文,说明了英语的重要性)<br>vSphere 产品遇到问题的时候,一般查找不到相关解决资料,都是自己各种尝试,不知道哪儿懵对了,机器就好了,排查问题的时候,真的是靠个人经验.这一点,从我博客里面就能看出来,访问量最多的就是写 vSphere 的那几篇文章.说明在这方面沉淀的人少,所以搜索引擎把我的文章推出来.<br>而 proxmox ve 是开源的,这样就比较能够放心让别人大胆尝试,不至于遇到问题的时候,总是那几个人上,每个人都有锻炼的机会.<br>当然了,如果你真的比较土豪,购买 proxmox ve 系统也是 OK 的.</font></p><p><font face="华文中宋" size="3">2 , proxmox 虚拟机使用的是 kvm ,容器则使用的是 LXC( Linux Container ),也就是说,容器这方面相当于原生的,对于各类常见的应用软件容器,就不用再单独创建 Linux 虚拟机,可以直接在虚拟机上安装相关容器即可.<br>但是 proxmox 对物理服务器的限制是设定在 32 台物理主机,所以如果物理主机比较多的话,而且还需要统一集中在一个集群管理,它可能就不是最好的解决方案了.<br>但是就目前公司的需求来说,我觉得使用 proxmox 还是能够满足需求的.</font></p><p><font face="华文中宋" size="3">3 ,proxmox 支持市面上几乎所有的主流存储协议,特别是对 ceph 分布式存储的支持.这意味着,通过 ceph 可以实现虚拟机的 HA 功能,虚拟机动态迁移等高级特性,而且我觉得在以后,大数据是一个趋势,所以能够支持分布式存储的话,这一个优点无疑是比较吸引人的.</font></p><p><font face="华文中宋" size="3">4 , vSphere 出于商业收费和 license 的考虑,将很多功能进行了拆分,安装完 ESXi 之后,只能使用基本功能,如果想要使用高级功能,必须安装 vcenter 来进行相关操作才可以.<br>相比较之下, proxmox 就友好很多,安装完成之后,所有集群的物理节点都是平等的,通过每个物理节点都可以管理整个集群.<br>如果只是从稳定性来看的话, proxmox ve 和 vSphere 可以说是旗鼓相当,但是硬件兼容性则没有 proxmox 好,而且在 proxmox 中没有主次节点之分,所以它能够最大化的提高硬件的使用效率.</font></p><p><font face="华文中宋" size="3">5 ,这是最重要的一个原因: proxmox 相对于 vSphere 来说,它少了一层.<br>vSphere 的架构是:在服务器上安装 ESXi 系统,然后通过 vcenter 去管理,通过 vcenter 来创建虚拟机,管理集群等.<br>而 proxmox 架构是:在服务器上安装 proxmox 系统之后,就可以在上面创建虚拟机,随便访问一台物理节点,都可以来管理整个集群.<br>发现不同了嘛?好吧,我觉得你可能没发现.<br>proxmox 不需要经过 vcenter 这一层的管理,也就是少了一层通信.这一层通信少了之后,就可能将整个集群的读取速度,反应速度提升一个层次.<br>如果非要举个例子来说明的话(这个例子可能不太恰当,但是想不起来合适的了),就相当于你的笔记本从原来用机械硬盘,到后来改用固态,那种速度之间的差别,你可以想想.</font></p><p><font face="华文中宋" size="3">基于以上吧,我个人是觉得这个方案可以尝试去做.<br>后期看时间和精力,看看能不能弄起来.</font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> proxmox ve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[java]说说 JRE , JDK , JVM 三者之间的区别与联系</title>
      <link href="/posts/dfd14d26.html"/>
      <url>/posts/dfd14d26.html</url>
      
        <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在写了很多代码之后,如果问 jre 和 jdk 之间有什么关系, jvm 又是什么,估计有相当一部分人不知道在说什么.所以这篇文章,就尝试解释一下这三者之间的区别和联系.<br><a id="more"></a></font></p><table><tr><td bgcolor="#1E90FF"><font face="楷体" color="white" size="5">基本概念</font></td></tr></table><p><font face="华文中宋" size="3">咱们先来说说, jvm , jre , jdk 都是什么.</font></p><p><font face="华文中宋" size="5">JVM ( Java Virtual Machine ):</font></p><p><font face="华文中宋" size="3">就是常说的 java 虚拟机,顾名思义,它就是一个虚拟出来的计算机,通过在实际的计算机上模拟各种计算机功能来实现.<br>JVM 是 java 实现跨平台最核心的部分,所有的 java 程序,首先会被编译成 .class 的类文件, JVM 的主要工作是解释自己的指令集(即字节码)并映射到本地的 CPU 的指令集或 OS 的系统调用. java 面对不同操作系统使用不同的虚拟机,这样实现了跨平台.<br>因为 JVM 对上层的 java 源文件怎样是不关心的,它关心的是由源文件生成的类文件.</font></p><p><font face="华文中宋" size="5">JRE ( Java Runtime Environment ):</font></p><p><font face="华文中宋" size="3">java 运行时环境.<br>它主要包括两部分: jvm 的标准实现和 java 的一些基本类库还有一些模块等.<br>在 java 平台下,所有的 java 程序都需要在 JRE 下才能运行,这是因为在解释 class 时, JVM 需要调用解释所需要的类库 lib .<br>可以看看自己下载的 jre ,里面有 bin 和 lib , 在这里可以认为 bin 就是 JVM , lib 就是 JVM 所需要的类库. JVM 和 lib 合起来就称为 JRE .</font></p><p><font face="华文中宋" size="5">JDK (Java Development Kit ):</font></p><p><font face="华文中宋" size="3"> java 开发工具包.<br>jdk 是整个 java 开发的核心,包括了 java 的运行环境,一堆 java 工具和 java 基础的类库.你可以将 JDK 看成是 JRE 的一个超集.<br>由上,我们能够看出来,这三者之间的关系是层层嵌套的:<strong> JDK 包含 JRE , 而 JRE 包含 JVM .</strong></font></p><table><tr><td bgcolor="#1E90FF"><font face="楷体" color="white" size="5">Q &amp; A</font></td></tr></table><p><font face="华文中宋" size="3">在以上基础上,面试的时候,就有的问了.<br>比如:<br>Q : java 为什么能够跨平台,实现” write once , run anywhere “<br>A : java 能够跨平台运行的核心在于 jvm ,所以并不是 java 能够跨平台,而是它的 jvm 可以做到跨平台.<br>java 引入了字节码的概念, jvm 只认识字节码,并将它们解释到系统的 API 调用.不同的系统有不同的 jvm 实现,有 Linux 版本的 jvm 实现,也有 Windows 版本的 jvm 实现,但是同一段代码在编译后的字节码是一样的.<br>也就是说,我想要实现的功能,因为编译生成的字节码是唯一的,所以和系统无关,因为在不同的 jvm 实现上会映射到不同系统的 API 调用,从而实现了代码不做任何修改,就可以跨平台运行.</font></p><p><font face="华文中宋" size="3">Q : jdk 和 jre 有什么区别<br>A : 把&lt;基本概念&gt;里面的内容说说,然后再说一下在实际中:如果只是想跑 java 程序,只安装 jre 就可以了,如果想要写 java 程序并且运行,就需要 jdk .</font></p><p><font face="华文中宋" size="3">如果能够玩转 jre  , jdk , jvm ,你就可以骄傲的说,你有扎实的 java 基础了.<br>在这里推荐两篇博客,好好阅读,会有很多收获.<br><a href="http://www.cnblogs.com/zuoxiaolong/p/life51.html" target="_blank" rel="noopener">回答阿里社招面试如何准备，顺便谈谈对于Java程序猿学习当中各个阶段的建议</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/life53.html" target="_blank" rel="noopener">万能的林萧说：一篇文章教会你，如何做到招聘要求中的“要有扎实的Java基础”。</a></font></p><p><font face="华文中宋" size="3">感谢您的阅读~</font></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Linux]时间同步设置 + 防火墙设置 + SELinux 设置</title>
      <link href="/posts/d1d9f7bd.html"/>
      <url>/posts/d1d9f7bd.html</url>
      
        <content type="html"><![CDATA[<table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> 时间同步设置</font></td></tr></table><p><font face="华文中宋" size="3">在大数据集群环境中，要求每台集群的时间必须是同步的，这样我们就会要求每台集群的时间必须和一台服务的时间是同步的。接下来介绍一下步骤：<br><a id="more"></a><br>1，设置ntp客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum -y install ntp 安装ntp时间同步软件</span><br><span class="line">systemctl enable ntpd 使软件可用</span><br><span class="line">systemctl start ntpd 启动ntp软件</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2，编辑/etc/ntp.conf文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ntp.conf</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">重点修改以下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Use public servers from the pool.ntp.org project.</span><br><span class="line"># Please consider joining the pool (http://www.pool.ntp.org/join.html).</span><br><span class="line">#server 0.centos.pool.ntp.org iburst</span><br><span class="line"> </span><br><span class="line">server 192.168.243.133   -------&gt;（此处需要修改，以哪台为准就写那台的IP）</span><br><span class="line"> </span><br><span class="line">restrict 192.168.243.133 nomodify notrap noquery-------&gt;（此处需要修改，以哪台为准就写那台的IP）</span><br><span class="line"> </span><br><span class="line">server 192.168.243.***     -------&gt;（本机IP是多少就写多少）</span><br><span class="line">fudge 192.168.243.*** -------&gt;（本机IP是多少就写多少） stratum 10</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">3，重启ntpd服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart ntpd</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">4，启动后，查看同步情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ntpq -p</span><br><span class="line">ntpstat</span><br></pre></td></tr></table></figure></font></p><table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> 防火墙设置</font></td></tr></table><p><font face="华文中宋" size="3">关闭firewall：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">临时关闭防火墙: systemctl stop firewalld </span><br><span class="line">永久关闭防火墙： systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">关闭iptables：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭命令： service iptables stop </span><br><span class="line">永久关闭防火墙：chkconfig iptables off </span><br><span class="line">检查防火墙状态：service iptables status</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">查看防火墙状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">检查firewall的状态：systemctl status firewalld.service</span><br><span class="line">检查iptables状态：service iptables status</span><br></pre></td></tr></table></figure></font></p><table><tr><td bgcolor="navy" blue><font face="楷体" color="white" size="5"> SELinux设置</font></td></tr></table><p><font face="华文中宋" size="3">1，临时关闭SELinux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">2，永久关闭SELinux：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/selinux/config</span><br><span class="line">将配置文件中SELINUX=enforcing改为SELINUX=disabled</span><br><span class="line">注：修改配置文件需要重启机器，但我们已临时关闭SELinux，等下次机器重启后，配置文件自动生效</span><br></pre></td></tr></table></figure></font></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
