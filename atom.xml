<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑璐璐|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dynamic-zheng.com/"/>
  <updated>2020-07-26T09:41:34.252Z</updated>
  <id>https://www.dynamic-zheng.com/</id>
  
  <author>
    <name>郑璐璐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[碎碎念]我最近在做的事情</title>
    <link href="https://www.dynamic-zheng.com/posts/6240cbda.html"/>
    <id>https://www.dynamic-zheng.com/posts/6240cbda.html</id>
    <published>2020-07-26T09:40:28.000Z</published>
    <updated>2020-07-26T09:41:34.252Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周的时候,就已经预告了,这周文章也是水文一篇,因为我说最近比较忙嘛<br>那今天就来交代下,最近在忙什么<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">自考<br>八月初有考试,自学考试.(是的,你没看错,就是下周<br>我知道要早点儿开始学,但是一直到七月初我才开始看书,七月二十号的样子,才把课本第一遍看完,这个时候还没看课后题,也没有刷题<br>没办法,都是以前欠下的债<br>为了抓紧一切时间学习,大早上六点就起床,自己都被自己感动哭了</font></p><p><font face="华文中宋" size="3">写作训练营<br>我感觉自己最近写作遇到了瓶颈,我不知道该怎么去写一篇文章,写完之后阅读量也不怎么样,也不知道该写什么<br>这个时候就需要一位老师来帮助我了.正好一直信任的明白老师开了一个写作训练营,果断花了 1K+ 报名,说实话,因为训练营还有筛选机制,我还真的挺怕把我筛掉…不过蛮幸运的,没有被筛选掉<br>所以这几天的精力,除了工作,就是自考,要么是写作训练营</font></p><p><font face="华文中宋" size="3">三件事,就足够把我的时间和精力占满,每天都掏空了自己<br>总得想办法逃出自己的舒适区不是~<br>等我忙完了考试 &amp; 参加完训练营,我再认认真真写文章</font></p><p><font face="华文中宋" size="3">目前的话,我的脑袋里面已经有了一篇文章的大纲了,预计完整写出来的话,字数大概在 3000+<br>但是因为我下周有考试嘛,所以怎么也要等我考试完了,写完发出来的话,估计就是周日晚上了<br>就这样~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;上周的时候,就已经预告了,这周文章也是水文一篇,因为我说最近比较忙嘛&lt;br&gt;那今天就来交代下,最近在忙什么&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]坦白了,这是我最喜欢的一部动漫</title>
    <link href="https://www.dynamic-zheng.com/posts/18ababf6.html"/>
    <id>https://www.dynamic-zheng.com/posts/18ababf6.html</id>
    <published>2020-07-19T13:05:50.000Z</published>
    <updated>2020-07-19T13:10:45.870Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">坦白点儿,最近没有沉迷于学习,下班了就赖在床上刷动漫,真香!<br>虽然考试在即,可我还是想去刷我的动漫(废材就是我了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我还记得小时候看这部动漫,下课了就跑回家就是为了看这部动漫,如果停电了,都能被气的半死…(那个时候孩子还小;<br>这部动漫就是:犬夜叉<br>我自己都不知道这是刷的第几次了,自己压力大的时候,睡不着的时候,就会刷一遍,然后再刷一遍</font></p><p><img src="/images/2020/犬夜叉.jpg"></p><p><font face="华文中宋" size="3">小时候最喜欢的几部动漫:犬夜叉,名侦探柯南,网球王子,黑子的篮球,东京食尸鬼…这么一数好像喜欢的不少<br>之所以喜欢追动漫,是因为它真的给了我很多力量,特别适合在自己压力大的时候,去看看,然后我就动力满满,跟打了鸡血一样</font></p><p><font face="华文中宋" size="3">犬夜叉这部是我最喜欢的一部动漫,既然是水文一篇,那我就随便说说咯</font></p><p><font face="华文中宋" size="3">犬夜叉<br>刚开始的他,总是想获得更强大的力量,想要成为真正的妖怪<br>但是遇到桔梗之后,懂得了守护,开始想要陪伴一个人,但是因为命运,唉~<br>后来遇到了戈薇,七宝,弥勒,珊瑚,在和他们一起奋斗的日子里,开始慢慢变得信任别人,自己恢复为人的日子是不能让别人知道的,因为在这天会失去妖力,如果让别人知道,自己可能就会失去性命,到最后,越来越多的人知道朔日之夜,在变成人类的那个夜晚,他也越来越坦然<br>应该是真正接受了自己的身份吧</font></p><p><font face="华文中宋" size="3">戈薇<br>不得不说高桥留老师的心思细腻,戈薇只是一个女孩,她喜欢犬夜叉,当她看到犬夜叉放不下桔梗的时候,自己也会悲伤,也会嫉妒<br>桔梗被奈落的瘴气所伤,能净化的只有戈薇,戈薇但凡是有一点不想救桔梗的心,就会失败<br>最后成功救到了桔梗,因为她的心是善良的<br>她会大大方方的承认自己喜欢犬夜叉,也大大方方的承认自己嫉妒桔梗,这份坦诚,真的让人很感动</font></p><p><font face="华文中宋" size="3">弥勒 &amp; 珊瑚<br>这两个人,背负的东西都太多了<br>一个是不知道自己什么时候会死,一个是亲眼目睹了自己的家人被弟弟亲手杀害<br>但他们在旅行的途中,彼此治愈着 &amp; 温暖着<br>特别是完结篇,弥勒为了能够更好的保护珊瑚,喝下了可以抑制痛苦的药;在最后珊瑚说想陪他,最后还是不忍心</font></p><p><font face="华文中宋" size="3">杀生丸<br>这个人物简直不要太帅~<br>我还记得小时候看的,觉得杀生丸特别讨厌犬夜叉,因为犬夜叉是半妖,杀生丸是从内心鄙视犬夜叉的<br>相比于犬夜叉因为半妖的身份受尽欺负,杀生丸简直是含着金钥匙出生的,一出生就拥有很强大的力量,直接就是别人的顶点,但也是这一点,让他不知道什么是害怕,什么是恐惧,别人执着的东西,他是不屑的,就像四魂之玉一样,别的妖怪费尽心思想要,他却一看都不看<br>一直执着于获得铁碎牙的他,却一直被铁碎牙的结界给拒绝,后来在玲的陪伴下,慢慢了解到什么是恐惧,在完结篇中,玲因为在冥界承受不住阴气失去呼吸,天生牙也没办法拯救她时,杀生丸慌了,整个表情痛苦不已<br>啊啊啊,整部动漫就这里让杀生丸痛苦了,可以想象他的改变有多大~<br>知道害怕和恐惧之后,不再执着于获得铁碎牙的力量,反而因此获得了自己的力量—爆碎牙</font></p><p><font face="华文中宋" size="3">奈落<br>每次看到他,都想不行,我一定要继续快点儿看,这样才能看到他死去<br>奈落为了获得四魂之玉伤害了很多人,利用了很多人,践踏别人的感情<br>但是他又是可怜的,他所做的一切,也不过是为了得到桔梗的心<br>但是啊,爱情这种事情,怎么可能是你想得到就可以得到的呢<br>爱而不得的奈落,杀死了桔梗,玩弄别人的感情在股掌之中,可是想想,如果不曾体会过感情的话,又怎么可能玩弄别人的感情呢<br>奈落是爱桔梗的,但是他的爱,等不来她</font></p><p><font face="华文中宋" size="3">桔梗<br>这个人物是我最不想写的,太悲情了<br>身为一个巫女,她的一生都是活在战斗中的,后来复活的她,也是为了消除四魂之玉奋斗着,独自一人奋斗着,想想就觉得好孤独啊<br>印象特别深刻的是一个场景:在一个夜晚,犬夜叉和戈薇起来看星星,戈薇身上披着的是犬夜叉的火鼠裘,靠在犬夜叉的肩上,而与此同时,桔梗孤独一人只有死魂虫陪着她,在月色下她在想:犬夜叉,你现在在做什么呢<br>太让人心疼了~<br>明明她也只是一个平凡的女子啊,明明她也只是想过平凡的日子呀</font></p><p><font face="华文中宋" size="3">这篇文章就是这样啦~其实其他人物也很饱满 &amp; 鲜活,如果有想写的,等我再刷一遍,哈哈哈<br>对了,预告下,估计下周的文章我也要水一篇了<br>emmm ,最近有点儿忙<br>就酱~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;坦白点儿,最近没有沉迷于学习,下班了就赖在床上刷动漫,真香!&lt;br&gt;虽然考试在即,可我还是想去刷我的动漫(废材就是我了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]CopyOnWrite 了解吗?</title>
    <link href="https://www.dynamic-zheng.com/posts/9af0bfae.html"/>
    <id>https://www.dynamic-zheng.com/posts/9af0bfae.html</id>
    <published>2020-07-11T11:22:27.000Z</published>
    <updated>2020-07-11T11:26:01.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font face="华文中宋" size="3">概念</font></h1><p><font face="华文中宋" size="3">CopyOnWrite 只是看字面意思就能看出来,就是在写入时复制<br>说得轻巧,写入时复制,具体是怎么实现的呢?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">先来说说思想,具体怎么实现等下分析<br>CopyOnWrite 的思想就是:当向一个容器中添加元素的时候,不是直接在当前这个容器里面添加的,而是复制出来一个新的容器,在新的容器里面添加元素,添加完毕之后再将原容器的引用指向新的容器,这样就实现了写入时复制<br>你还记得在提到数据库的时候,我们经常说主从复制,读写分离吗? CopyOnWrite 的设计思想是不是和经常说的主从复制,读写分离如出一撤?</font></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><font face="华文中宋" size="3">优缺点</font></h1><p><font face="华文中宋" size="3">了解概念之后,对它的优缺点应该就比较好理解了<br>优点就是,读和写可以并行执行,因为读的是原来的容器,写的是新的容器,它们之间互不影响,所以读和写是可以并行执行的,在某些高并发场景下,可以提高程序的响应时间</font></p><p><font face="华文中宋" size="3">但是呢,你也看到了, CopyOnWrite 是在写入的时候,复制了一个新的容器出来,所以要考虑它的内存开销问题,又回到了在学算法时一直强调的一个思想:拿空间换时间<br>还有一点就是,它只保证数据的最终一致性.因为在读的时候,读取的内容是原容器里面的内容,新添加的内容是读取不到的</font></p><p><font face="华文中宋" size="3">基于它的优缺点应该就可以得出一个结论: CopyOnWrite 适用于写操作非常少的场景,而且还能够容忍读写的暂时不一致<br>如果你的应用场景不适合,那还是考虑使用别的方法来实现吧</font></p><p><font face="华文中宋" size="3">还有一点需要注意的是:在写入时,它会复制一个新的容器,所以如果有写入需求的话,最好可以批量写入,因为每次写入的时候,容器都会进行复制,如果能够减少写入的次数,就可以减少容器的复制次数</font></p><p><font face="华文中宋" size="3">在 JUC 包下,实现 CopyOnWrite 思想的就是 CopyOnWriteArrayList &amp; CopyOnWriteArraySet 这两个方法,本篇文章侧重于讲清楚 CopyOnWriteArrayList</font></p><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><font face="华文中宋" size="3">CopyOnWriteArrayList</font></h1><p><font face="华文中宋" size="3">在 CopyOnWriteArrayList 中,需要注意的是 add 方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 在写入的时候,需要加锁,如果不加锁的话,在多线程场景下可能会被 copy 出 n 个副本出来</span></span><br><span class="line">    <span class="comment">// 加锁之后,就能保证在进行写时,只有一个线程在操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制原来的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将要添加的元素添加到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将对原数组的引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在写的时候需要加锁,但是在读取的时候不需要添加<br>因为读取的是原数组的元素,对新数组没有什么影响,加了锁反而会增加性能开销</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子:"></a><font face="华文中宋" size="3">举个例子:</font></h1><p><font face="华文中宋" size="3">CopyOnWrite 在 JUC 包下,那么它就保证了线程安全<br>咱们来做个小 demo 验证一下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面是客户端请求 5000 次,有 200 个线程在同时请求,我使用的是 ArrayList 实现,咱们看下打印结果:</font></p><p><img src="/images/2020/ArrayListDemo.jpg"></p><p><font face="华文中宋" size="3">如果是线程安全的话,那么最后的结果应该是 5000 才对,多运行几次你会发现,每次程序的执行结果都是不一样的<br>如果是 CopyOnWriteArrayList 呢?</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"excepiton"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">多运行几次,结果都是一样的:</font></p><p><img src="/images/2020/CopyOnWriteArrayListDemo.jpg"></p><p><font face="华文中宋" size="3">CopyOnWriteArrayList 是线程安全的</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读~</font></p><hr><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;概念&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;CopyOnWrite 只是看字面意思就能看出来,就是在写入时复制&lt;br&gt;说得轻巧,写入时复制,具体是怎么实现的呢?&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[年中总结]若能控制住粗鄙的狂喜</title>
    <link href="https://www.dynamic-zheng.com/posts/2d11cb2d.html"/>
    <id>https://www.dynamic-zheng.com/posts/2d11cb2d.html</id>
    <published>2020-07-04T12:49:10.000Z</published>
    <updated>2020-07-04T12:50:17.752Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">每次都是感叹,时间怎么就过的这么快呢~<br>七月份了,说明啥?说明就这么一眨眼的时间,半年就过去了(要不我不眨眼了行不,时间就别过这么快了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">还记得以前自己的总结都能写出好长一篇出来,这次真的是有点儿惆怅了,不知道该写点儿啥</font></p><p><font face="华文中宋" size="3">要说起来的话,这半年就做了两件事:好好工作,好好精进自己<br>好好工作没啥说的,精进自己主要是从 技术 &amp; 眼界 两方面来提高自己</font></p><p><font face="华文中宋" size="3">今年情况也都知道,寒冬嘛,更应该做的就是提高自己<br>技术方面看我以前写的博客就能够看出来最近都干了啥<br>眼界这方面,第一就是自己不断地去学习吧(大年三十那天我还在读书 &amp; 写作,你敢信?<br>第二就是看自己身边优秀的朋友们都在做什么.我是觉得他们都那么厉害,那我跟着他们的脚步去走,最后应该也不会很差</font></p><p><font face="华文中宋" size="3">过去的一年,受明白老师影响蛮大的<br>看到他也会偷懒,看到他也会嫉妒,看到他也会焦虑,看到他也会纠结,让我觉得我不是一个人<br>我是那种,如果今天一天我是睡过去了,或者是玩过去了,没有看一会儿书,没有输出一点儿内容,就会无限制的责怪自己:你怎么能这样呢,时间这么宝贵,你怎么就这么浪费了呢<br>近距离观察明白老师之后,让我知道了再厉害的人也都有自己的情绪,所以现在我也在慢慢的去接受自己,或好或坏都在努力接受着<br>但是有时候如果一天什么都没做,就又会自觉不自觉的去责怪自己,比以前做的好的一点是:发现自己有这方面的倾向之后,觉察到自己的情绪之后,赶快去做调整<br>明白老师,乔老师还有 Ju 老师会在我不知所措的时候给我建议 &amp; 鼓励,能够得到他们的指点和教导,真的是一件值得感恩的事情<br>不知不觉认识他们都一年了,感觉就像是老友一般</font></p><p><font face="华文中宋" size="3">如果真要说起来的话,过去的半年,甚至是过去的很多年里,我一直都被身边的朋友们善待着 &amp; 治愈着<br>感恩,感谢遇到的所有~</font></p><p><font face="华文中宋" size="3">我知道,到了人生这一个时刻,其实都是要靠自己的,对那句话: <code>一个人的对手只有一个,那就是自己</code> 理解的也更加深刻<br>因为在这漫长的岁月中,你要不断的和自己的情绪,懒惰和意志去做斗争,而且你会发现,在绝大多数情况下,只能缴械投降,你还会发现,这事儿吧,就得你自己去做,你的朋友帮不了你,你的家人也帮不了你,只有你,只有你自己去面对这一切,是好的还是坏的,都是自己的,要自己接纳自己,要自己去努力 &amp; 奋斗<br>众生皆苦,只可自渡</font></p><p><font face="华文中宋" size="3">其实也正是因为能够深刻理解一个人才是常态,所以更加觉得成年人之间的温暖,是及其珍贵的<br>帮助过我的,一直惦记着我的,总是鼓励着我的,我都有记在心里,没啥说的,拿行动说话<br>如果你有幸感受到成年人之间的温暖,好好珍惜<br>如果还没有遇到,别太担心,照顾好自己</font></p><p><font face="华文中宋" size="3">人生最重要的不是快乐,而是平和<br>所以,如果能够控制住粗鄙的狂喜,就不会有深入骨髓的悲伤<br>人生路还长,不要着急,要慢慢来</font></p><p><font face="华文中宋" size="3">我又成功的水了一篇文章,又成功的骗你看到这里<br>哈哈哈,谢谢你,耐心看这篇文章到这里,看我的各种碎碎念</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;每次都是感叹,时间怎么就过的这么快呢~&lt;br&gt;七月份了,说明啥?说明就这么一眨眼的时间,半年就过去了(要不我不眨眼了行不,时间就别过这么快了&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="https://www.dynamic-zheng.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年中总结" scheme="https://www.dynamic-zheng.com/tags/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]你知道不知道 Fork/Join ?</title>
    <link href="https://www.dynamic-zheng.com/posts/a16e4d0e.html"/>
    <id>https://www.dynamic-zheng.com/posts/a16e4d0e.html</id>
    <published>2020-06-27T00:38:37.000Z</published>
    <updated>2020-06-27T00:40:36.251Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果要说 Fork/Join 的话,就得来说说分治.<br><a id="more"></a><br>分治分治,就是分而治之嘛,具体一点儿就是把一个复杂的问题分解成多个相似的子问题,然后呢,再把子问题分解成更小的子问题,直到子问题简单到可以直接求解才算结束<br>这种思想,是不是让你想起了归并排序/快速排序/二分查找?没错,这些算法的实现也是借助了分治的思想</font></p><p><font face="华文中宋" size="3">分治分治,估计可以猜出来吧,最重要的就是两点:一个是分,一个是治<br>分什么呢?就是把一个复杂的问题分解成子问题,直到子问题可以直接求解结束<br>治什么呢?刚刚把分解的子问题求解出来了对吧?那是不是要汇总一下,最后求出总问题的解?<br>千言万语不如一张图,那就来张图:</font></p><p><img src="/images/2020/fork&join.jpg"></p><p><font face="华文中宋" size="3">看完有没有觉得,哦,原来这就是 fork/join 的赶脚?<br>如果有的话,那我这张图就没白画,头发没白掉~</font></p><h1 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a><font face="华文中宋" size="3">ForkJoinTask</font></h1><p><font face="华文中宋" size="3">Fork/Join 是一个并行计算的框架,主要就是用来支持分治任务模型的<br>Fork/Join 计算框架主要包含两部分,一部分是<strong>分治任务的线程池 ForkJoinPool </strong> ,另一部分是<strong>分治任务 ForkJoinTask </strong> ,先来看 ForkJoinTask<br>因为如果你想要 join 的话,是不是要先有 fork ?而 fork 方法在 ForkJoinTask 里面,所以咱们先来看看它</font></p><p><font face="华文中宋" size="3">在源码中,能够看到 fork 方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// ForkJoinWorkerThread 是执行 ForkJoinTask 的专有线程</span></span><br><span class="line">    <span class="comment">// 判断当前线程是否是 ForkJoin 专有线程,如果是则将任务 push 到当前线程所负责的队列里面去</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 如果不是 ForkJoin 专有线程,就将任务提交到默认的 common 线程池中</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">仔细看的话, fork() 就做了一件事,就是把<strong>任务放到当前工作线程的工作队列中</strong><br>咱们继续往下看, fork() 结束,是怎么做的 join()</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">// 调用 dojoin 方法来获取当前任务的执行状态</span></span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">    <span class="comment">// 任务异常,抛出异常</span></span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="comment">// 任务完成,返回结果</span></span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够看到, join() 方法就是等待处理任务的线程结束,然后拿到返回值<br>在 join 方法中调用了 doJoin 方法,咱们来瞅瞅它具体是个啥</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="comment">// 首先判断任务是否执行完毕,如果执行完毕,直接返回结果就可以了</span></span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    <span class="comment">// 如果没有执行完毕,接下来要判断是不是 ForkJoinWorkerThread 线程</span></span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        <span class="comment">// 如果是,判断这个任务是不是在工作队列最前边(也就是下一个执行的就是它)</span></span><br><span class="line">        <span class="comment">// tryUnpush() 方法判断任务是不是在工作队列最前边,是的话就返回 true</span></span><br><span class="line">        <span class="comment">// doExec() 方法执行任务</span></span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        <span class="comment">// 如果是在工作队列最前边,并且任务执行完毕,直接返回结果即可</span></span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        <span class="comment">// 如果不是工作队列最前边或者任务没有执行完毕,调用 awaitJoin() 来执行任务</span></span><br><span class="line">        <span class="comment">// awaitJoin(): 使用自旋使得任务执行完成,返回结果</span></span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        <span class="comment">// 如果不是 ForkJoinWorkThread 线程,执行 externalAwaitDone() 返回任务结果</span></span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">我知道,你看完上面的分析之后,就懵逼了<br>因为我当时分析这块还理解了好久<br>那如果来张图呢?</font></p><p><img src="/images/2020/join流程图.png"></p><p><font face="华文中宋" size="3">ForkJoinTask 有两个子类 –&gt; RecursiveAction &amp; RecursiveTask ,它们都是通过递归的方式来处理分治任务的,这两个子类都定义了抽象方法 compute() ,不过区别就是 RecursiveAction 定义的 compute() 没有返回值,而 RecursiveTask 定义的 compute() 方法是有返回值的</font></p><h1 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><font face="华文中宋" size="3">ForkJoinPool</font></h1><p><font face="华文中宋" size="3">ForkJoinPool 是用来执行 ForkJoinTask 任务的线程池,它负责管理线程池中的线程和任务队列,还有就是线程池是否还接受任务,显示线程的运行状态也是在这里处理<br>ForkJoinPool 本质上是一个 生产者-消费者 的实现,但是它更加的只能,因为它可以窃取别的任务,也就是说,如果一个工作线程空闲了,那么它可以”窃取”其他工作队列中的任务来做<br>接下来咱们瞅瞅 ForkJoinPool 的源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> ForkJoinPool&#125; with the given parameters, without</span></span><br><span class="line"><span class="comment"> * any security checks or parameter validation.  Invoked directly by</span></span><br><span class="line"><span class="comment"> * makeCommonPool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 私有构造方法,没有任何的安全检查和参数校验,由 makeCommonPool 直接调用</span></span><br><span class="line"> <span class="comment">// parallelism 并行度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">ForkJoinPool 由 makeCommonPool 直接调用,来瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns the common pool, respecting user settings</span></span><br><span class="line"><span class="comment"> * specified via system properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通过系统指定相关参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing properties</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>);</span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.threadFactory"</span>);</span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.exceptionHandler"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 factory 为空</span></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 getSecurityManager 返回 null ,说明系统还没有为当前应用程序建立安全管理器</span></span><br><span class="line">    <span class="comment">// 使用 defaultForkJoinWorkerThreadFactory 来进行创建</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">        <span class="comment">// 如果 getSecurityManager 返回不是 null ,说明系统为当前应用程序建立好了安全管理器</span></span><br><span class="line">        <span class="comment">// 使用 InnocuousForkJoinWorkerThreadFactory 来进行创建</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                            <span class="string">"ForkJoinPool.commonPool-worker-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这篇文章到这里,我就要划一个句号了<br>摸着良心说,这篇文章内容,相对来说不是很多,因为很多源码都还没分析到,比如使用的 <code>workQueues</code> 队列,比如如何实现的任务窃取,都还没说到,等我回头再写一篇文章出来<br>主要是分析源码,太费脑细胞 &amp; 头发了 ٩(º﹃º٩)<br>再加上最近有点儿放飞自我,沉迷于动漫中,等我刷完了动漫我再把细节补充上来</font></p><p><font face="华文中宋" size="3">就酱~<br>感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;如果要说 Fork/Join 的话,就得来说说分治.&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发] ThreadPoolExecutor 是如何做到线程复用的</title>
    <link href="https://www.dynamic-zheng.com/posts/9595861d.html"/>
    <id>https://www.dynamic-zheng.com/posts/9595861d.html</id>
    <published>2020-06-21T06:02:30.000Z</published>
    <updated>2020-06-21T06:04:37.447Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在上篇文章 <a href="https://www.dynamic-zheng.com/posts/d3e00aa7.html#more">[Java 并发]详解 ThreadPoolExecutor</a>  中说过了,创建线程池的好处之一就是它可以做到线程复用<br>那么,它是如何做到线程复用的呢?<br>这事儿,还得从源码说起<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">先解决一个基础问题:啥是线程复用?<br>如果是一个线程的话,那么在它创建的时候,我们会给它指定一个线程任务对不对?那如果执行完任务之后,这个线程是不是就会自动销毁?<br>但是在线程池中可不是呦~线程池中的线程,在执行完任务之后不会销毁,会继续执行另外的任务<br>这就是我们说的,线程复用</font></p><p><font face="华文中宋" size="3">OK ,线程复用明白了,新的问题就来了:在 ThreadPoolExecutor 中,它是如何做到线程复用的呢?<br>这就得去看源码是怎么写的了</font></p><h1 id="execute"><a href="#execute" class="headerlink" title=" execute"></a><font face="华文中宋" size="3"> execute</font></h1><p><font face="华文中宋" size="3">做到线程复用,肯定要先 execute 起来吧(这块在刚开始的文章中已经有过解释了,就直接放源码了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于 corePoolSize 时,调用 addWorker 创建核心线程来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程数不小于 corePoolSize ,就将任务添加到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="comment">// 获取到当前线程的状态,赋值给 recheck ,是为了重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果 isRunning 返回 false ,那就 remove 掉这个任务,然后执行拒绝策略,也就是回滚重新排队</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 线程池处于 running 状态,但是没有线程,那就创建线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入 workQueue 失败,尝试通过创建非核心线程来执行任务</span></span><br><span class="line">    <span class="comment">// 如果还是失败,说明线程池已经关闭或者已经饱和,会拒绝执行该任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a><font face="华文中宋" size="3">addWorker</font></h1><p><font face="华文中宋" size="3">从上面能够看出来,主要是 addWorker 方法<br>addWorker 主要是用来创建核心线程的,它主要的实现逻辑是:</font></p><ul><li><font face="华文中宋" size="3">判断线程数量有没有超过规定的数量,如果超过了就返回 false</font></li><li><font face="华文中宋" size="3">如果没有超过,就会创建 worker 对象,并初始化一个 Thread 对象,然后启动这个线程对象</font></li></ul><p><font face="华文中宋" size="3">接下来瞅瞅源码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line"><span class="comment">// 线程池状态 &gt;= SHUTDOWN 时,不再接受新的任务,直接返回 false</span></span><br><span class="line"><span class="comment">// 如果 rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty() 同样不接受新的任务,返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"><span class="comment">// wc &gt;= CAPACITY 说明线程数不够,所以就返回 false</span></span><br><span class="line"><span class="comment">// wc &gt;= (core ? corePoolSize : maximumPoolSize) 是在做判断</span></span><br><span class="line"><span class="comment">// 如果 core 为 true ,说明要创建的线程是核心线程,接下来判断 wc 是否大于 核心线程数 ,如果大于返回 false</span></span><br><span class="line"><span class="comment">// 如果 core 为 false ,说明要创建的线程是非核心线程,接下来判断 wc 是否大于 最大线程数 ,如果大于返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// CAS 操作增加 workerCount 的值,如果成功跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"><span class="comment">// 判断线程池状态有没有变化,如果有变化,则重试</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// workerCount 增加成功之后开始走下面的代码</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 worker 对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"><span class="comment">// 实例化一个 Thread 对象</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 接下来的操作需要加锁进行</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"><span class="comment">// 将任务线程添加到线程池中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line"><span class="comment">// 启动任务线程,开始执行任务</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line"><span class="comment">// 如果任务线程启动失败调用 addWorkerFailed </span></span><br><span class="line"><span class="comment">// addWorkerFailed 方法里面主要做了两件事:将该线程从线程池中移除;将 workerCount 的值减 1</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Worker-类"><a href="#Worker-类" class="headerlink" title="Worker 类"></a><font face="华文中宋" size="3">Worker 类</font></h1><p><font face="华文中宋" size="3">在 addWorker 中,主要是由 Worker 类去做一些相应处理, worker 继承 AQS ,实现 Runnable 接口<br>线程池维护的是 <code>HashSet&lt;Worker&gt;</code> ,一个由 <code>worker</code> 对象组成的 <code>HashSet</code></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">worker 继承 AQS 主要是利用 AQS 独占锁机制,来标识线程是否空闲;另外, worker 还实现了 Runnable 接口,所以它本身就是一个线程任务,在构造方法中创建了一个线程,线程的任务就是自己 <code>this.thread = getThreadFactory().newThread(this);</code><br>咱们瞅瞅里面的源码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">        * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 处理任务的线程</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">// worker 传入的任务</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Worker(Runnable firstTask) &#123;</span><br><span class="line">       <span class="comment">// 将 state 设为 -1 ,避免 worker 在执行前被中断</span></span><br><span class="line">           setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">           <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line"><span class="comment">// 创建一个线程,来执行任务</span></span><br><span class="line">           <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           runWorker(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Lock methods</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">       <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           setState(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Thread t;</span><br><span class="line">           <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   t.interrupt();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a><font face="华文中宋" size="3">runWorker</font></h1><p><font face="华文中宋" size="3">worker 类在执行 run 方法时,实际上调用的是 runWorker 方法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">       Thread wt = Thread.currentThread();</span><br><span class="line">       Runnable task = w.firstTask;</span><br><span class="line">       w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 允许中断</span></span><br><span class="line">       w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">       <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 判断 task 是否为空,如果不为空直接执行</span></span><br><span class="line">       <span class="comment">// 如果 task 为空,调用 getTask() 方法,从 workQueue 中取出新的 task 执行</span></span><br><span class="line">           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 加锁,防止被其他线程中断</span></span><br><span class="line">               w.lock();</span><br><span class="line">               <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">               <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">               <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">               <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">               <span class="comment">// 检查线程池的状态,如果线程池处于 stop 状态,则需要中断当前线程</span></span><br><span class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                   !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 执行 beforeExecute </span></span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行任务</span></span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行 afterExecute 方法</span></span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 将 task 设置为 null ,循环操作</span></span><br><span class="line">                   task = <span class="keyword">null</span>;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   <span class="comment">// 释放锁</span></span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 runWorker 方法中,首先会去执行创建这个 worker 时就有的任务,当执行完这个任务之后, worker 并不会被销毁,而是在 while 循环中, worker 会不断的调用 getTask 方法从阻塞队列中获取任务然后调用 <code>task.run()</code> 来执行任务,这样就达到了<strong>复用线程</strong>的目的.通过循环条件 <code>while (task != null || (task = getTask()) != null)</code> 可以看出,只要 getTask 方法返回值不为 null ,就会一直循环下去,这个线程也就会一直在执行,从而达到了线程复用的目的</font></p><h1 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a><font face="华文中宋" size="3">getTask</font></h1><p><font face="华文中宋" size="3">咱们来看看 getTask 方法的实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">           <span class="comment">// allowCoreThreadTimeOut 变量默认为 false ,也就是核心线程就算是空闲也不会被销毁</span></span><br><span class="line">           <span class="comment">// 如果为 true ,核心线程在 keepAliveTime 内是空闲的,就会被销毁</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果运行线程数大于最大线程数,但是缓存队列已经空了,此时递减 worker 数量</span></span><br><span class="line">           <span class="comment">// 如果有设置允许线程超时或者线程数量超过了核心线程数量,并且线程在规定时间内没有 poll 到任务并且队列为空,此时也递减 worker 数量</span></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果 timed 为 true ,会调用 workQueue 的 poll 方法</span></span><br><span class="line">               <span class="comment">// 超时时间为 keepAliveTime ,如果超过 keepAliveTime 时长的话, poll 就会返回 null </span></span><br><span class="line">               <span class="comment">// 如果返回为 null ,在 runWorker 中 </span></span><br><span class="line">               <span class="comment">// while (task != null || (task = getTask()) != null) 循环条件被打破,从而跳出循环,此时线程执行完毕</span></span><br><span class="line">               <span class="comment">// 如果 timed 为 false ( allowCoreThreadTimeOut 为 false ,并且 wc &gt; corePoolSize 为 false )</span></span><br><span class="line">               <span class="comment">// 会调用 workQueue 的 take 方法阻塞到当前</span></span><br><span class="line">               <span class="comment">// 当队列中有任务加入时,线程被唤醒, take 方法返回任务,开始执行</span></span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> r;</span><br><span class="line">               timedOut = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">源码分析到这里就差不多清楚了<br>线程复用主要体现在 runWorker 方法中的 while 循环中,在 while 循环里面, worker 会不断的调用 getTask 方法,而在 getTask 方法里,如果任务队列中没有了任务,此时如果线程是核心线程则会一直卡在 workQueue.take 方法,这个时候会被阻塞并挂起,不会占用 CPU 资源,直到拿到任务然后返回 true , 此时 runWorker 中得到这个任务来继续执行任务,从而实现了线程复用</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在上篇文章 &lt;a href=&quot;https://www.dynamic-zheng.com/posts/d3e00aa7.html#more&quot;&gt;[Java 并发]详解 ThreadPoolExecutor&lt;/a&gt;  中说过了,创建线程池的好处之一就是它可以做到线程复用&lt;br&gt;那么,它是如何做到线程复用的呢?&lt;br&gt;这事儿,还得从源码说起&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]详解 ThreadPoolExecutor</title>
    <link href="https://www.dynamic-zheng.com/posts/d3e00aa7.html"/>
    <id>https://www.dynamic-zheng.com/posts/d3e00aa7.html</id>
    <published>2020-06-14T02:29:12.000Z</published>
    <updated>2020-06-14T02:32:38.687Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">ThreadPoolExecutor 可能在别的地方已经看过好多了,那我就尽量讲点儿不一样的知识出来<br><a id="more"></a></font></p><h1 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a><font face="华文中宋" size="3">为什么要用线程池</font></h1><p><font face="华文中宋" size="3">你有没有这样的疑惑,为什么要用线程池呢?可能你会说,我可以复用已经创建的线程呀;线程是个重量级对象,为了避免频繁创建和销毁,使用线程池来管理最好了<br>没毛病,各位都很懂哈~<br>不过使用线程池还有一个重要的点:可以控制并发的数量.如果并发数量太多了,导致消耗的资源增多,直接把服务器给搞趴下了,肯定也是不行的</font></p><p><font face="华文中宋" size="3">咱们再看看 ThreadPoolExecutor ,把这三个单词分开看, <code>Thread 线程</code>, <code>Pool 池</code>, <code>Executor</code> 执行者.如果连起来的话,是线程池执行者<br>所以呢, ThreadPoolExecutor 它强调的是 <code>Executor</code> ,而不是一般意义上的池化资源</font></p><h1 id="绕不过去的几个参数"><a href="#绕不过去的几个参数" class="headerlink" title="绕不过去的几个参数"></a><font face="华文中宋" size="3">绕不过去的几个参数</font></h1><p><font face="华文中宋" size="3">提到 ThreadPoolExecutor 那么你的小脑袋肯定会想到那么几个参数,咱们来瞅瞅源码(我就直接放有 7 个参数的那个方法了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">咱们分别来看:</font></p><ul><li><font face="华文中宋" size="3">corePoolSize :<br><font face="华文中宋" size="3">核心线程数,在线程池中有两种线程,核心线程和非核心线程.在线程池中的核心线程,就算是它什么都不做,也会一直在线程池中,除非设置了  <code>allowCoreThreadTimeOut</code> 参数</font></font></li><li><font face="华文中宋" size="3">maximumPoolSize:<br><font face="华文中宋" size="3">线程池能够创建的最大线程数.这个值 = 核心线程数 + 非核心线程数</font></font></li><li><font face="华文中宋" size="3">keepAliveTime &amp; unit :<br><font face="华文中宋" size="3">线程池是可以撤销线程的,那么什么时候撤销呢?一个线程如果在一段时间内,都没有执行任务,那说明这个线程很闲啊,那是不是就可以把它撤销掉了?<br>所以呢,如果一个线程不是核心线程,而且在 keepAliveTime &amp; unit 这段时间内,还没有干活,那么很抱歉,只能请你走人了<br>核心线程就算是很闲,也不会将它从线程池中清除,没办法谁让它是 <code>core</code> 线程呢~</font></font></li><li><font face="华文中宋" size="3">workQueue :<br><font face="华文中宋" size="3">工作队列,这个队列维护的是等待执行的 Runnable 任务对象<br>常用的几个队列: LinkedBlockingQueue , ArrayBlockingQueue , SynchronousQueue , DelayQueue<br>大厂的编码规范,相信各位都知道,并不建议使用 Executors ,最重要的一个原因就是: Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue ,在高负载情况下,无界队列很容易就导致 OOM ,而 OOM 会让所有请求都无法处理,所以在使用时,<strong>强烈建议使用有界队列</strong>,因为如果你使用的是有界队列的话,当线程数量太多时,它会走拒绝策略</font></font></li><li><font face="华文中宋" size="3">threadFactory :<br><font face="华文中宋" size="3">创建线程的工厂,用来批量创建线程的.如果不指定的话,就会创建一个默认的线程工厂</font></font></li><li><font face="华文中宋" size="3">handler :<br><font face="华文中宋" size="3">拒绝处理策略.在 workQueue 那里说了,如果使用的是有界队列,那么当线程数量大于最大线程数的时候,拒绝处理策略就起到作用了<br>常用的有四种处理策略:<ul><li><font face="华文中宋" size="3">AbortPolicy :默认的拒绝策略,会丢弃任务并抛出 RejectedExecutionException 异常</font></li><li><font face="华文中宋" size="3">CallerRunsPolicy :提交任务的线程,自己去执行这个任务</font></li><li><font face="华文中宋" size="3">DiscardOldestPolicy :直接丢弃新来的任务,也没有任何异常抛出</font></li><li><font face="华文中宋" size="3">DiscardOldestPolicy :丢弃最老的任务,然后将新任务加入到工作队列中</font></li></ul></font></font></li></ul><p><font face="华文中宋" size="3">默认拒绝策略是 AbortPolicy ,会  throw RejectedExecutionException 异常,但是这是一个运行时异常,对于运行时异常编译器不会强制 catch 它,所以就会比较容易忽略掉错误.<br>所以,如果线程池处理的任务非常重要,<strong>尽量自定义自己的拒绝策略</strong></font></p><h1 id="线程池的几个状态"><a href="#线程池的几个状态" class="headerlink" title="线程池的几个状态"></a><font face="华文中宋" size="3">线程池的几个状态</font></h1><p><font face="华文中宋" size="3">这篇文章开始我就说了,希望能写出一点儿不一样的东西,那咱们就从源码撸一撸<br>撸啥呢,源码那么多,总不能毫无目的的撸吧?<br>咱们来吧线程池的 5 种状态来撸一撸<br>在源码中,我们能够很明显看到定义的 5 种状态:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>同时,使用 AtomicInteger 类型的变量 ctl 来控制线程池的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li><font face="华文中宋" size="3">线程池创建之后就处于 RUNNING 状态</font></li><li><font face="华文中宋" size="3">调用 shutdown() 方法之后处于 SHUTDOWN 状态,此时线程池不再接受新的任务,清除一些空闲 worker ,等待阻塞队列的任务完成</font></li><li><font face="华文中宋" size="3">调用 shutdownNow() 方法后处于 STOP 状态,此时线程池不再接受新的任务,中断所有的线程,阻塞队列中没有被执行的任务也会被全部丢弃</font></li><li><font face="华文中宋" size="3">当线程池中执行的任务为空时,也就是此时 ctl 的值为 0 时,线程池会变为 TIDYING 状态,接下来会执行 terminated() 方法</font></li><li><font face="华文中宋" size="3">执行完 terminated() 方法之后,线程池的状态就由 TIDYING 转到 TERMINATED 状态</font></li></ul><p><font face="华文中宋" size="3">最后上张图总结一下:</font></p><p><img src="/images/2020/线程池状态转换.jpg"></p><h2 id="线程池是如何处理任务的"><a href="#线程池是如何处理任务的" class="headerlink" title="线程池是如何处理任务的"></a><font face="华文中宋" size="3">线程池是如何处理任务的</font></h2><p><font face="华文中宋" size="3">线程池处理任务的核心方法是 execute ,大概思路就是:</font></p><ul><li><font face="华文中宋" size="3">如果 command 为 null ,没啥说的,直接抛出异常就完事儿了</font></li><li><font face="华文中宋" size="3">如果当前线程数小于 corePoolSize ,会新建一个核心线程执行任务</font></li><li><font face="华文中宋" size="3">如果当前线程数不小于 corePoolSize ,就会将任务放到队列中等待,如果任务排队成功,仍然需要检查是否应该添加线程,所以需要重新检查状态,并且在必要时回滚排队;如果线程池处于 running 状态,但是此时没有线程,就会创建线程</font></li><li><font face="华文中宋" size="3">如果没有办法给任务排队,说明这个时候,缓存队列满了,而且线程数达到了 maximumPoolSize 或者是线程池关闭了,系统没办法再响应新的请求,此时会执行拒绝策略</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于 corePoolSize 时,调用 addWorker 创建核心线程来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程数不小于 corePoolSize ,就将任务添加到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="comment">// 获取到当前线程的状态,赋值给 recheck ,是为了重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果 isRunning 返回 false ,那就 remove 掉这个任务,然后执行拒绝策略,也就是回滚重新排队</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 线程池处于 running 状态,但是没有线程,那就创建线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入 workQueue 失败,尝试通过创建非核心线程来执行任务</span></span><br><span class="line">    <span class="comment">// 如果还是失败,说明线程池已经关闭或者已经饱和,会拒绝执行该任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在上面源码中,判断了两次线程池的状态,为什么要这么做呢?<br>这是因为在多线程环境下,线程池的状态是时刻发生变化的,可能刚获取线程池状态之后,这个状态就立刻发生了改变.如果没有二次检查的话,线程池处于非 RUNNING 状态时, command 就永远不会执行<br>来张图,总结一下上面说的:</font></p><p><img src="/images/2020/线程执行任务过程.jpg"></p><p><font face="华文中宋" size="3">这篇文章写到这里就没有啦~<br>希望你能从中得到一些收获<br>感谢你的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;ThreadPoolExecutor 可能在别的地方已经看过好多了,那我就尽量讲点儿不一样的知识出来&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]跳出来,看全貌</title>
    <link href="https://www.dynamic-zheng.com/posts/ccdbd4d7.html"/>
    <id>https://www.dynamic-zheng.com/posts/ccdbd4d7.html</id>
    <published>2020-06-06T10:56:26.000Z</published>
    <updated>2020-06-06T11:01:15.559Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">Java 并发这块,比较难,为啥呢,因为这一个知识点,那一个知识点的,特别碎<br>所以这个时候最重要的就是要对 Java 并发这块的知识有一个全貌<br><a id="more"></a><br>我先上一张图,下面的内容主要就是围绕这张图来说:</font></p><p><img src="/images/2020/concurrent-programming.png"></p><h1 id="主要矛盾"><a href="#主要矛盾" class="headerlink" title="主要矛盾"></a><font face="华文中宋" size="3">主要矛盾</font></h1><p><font face="华文中宋" size="3">凡事都有它的发展规律, Java 并发也是如此,不可能说突然这个事物就出来了<br>那为什么会有并发编程呢?这就要说一说 CPU/内存/磁盘 它们之间的速度差异了<br>应该都知道 CPU 的速度非常快,比内存的速度还要快,如果拿”天上一天,地上一年”来比喻 CPU 和内存之间的差异我觉得也是很合适的.内存的速度又要比磁盘的速度要快,快的量级是十倍都不止,那么可想而知, CPU 的一天,对于磁盘来说可能就是十年了.</font></p><p><font face="华文中宋" size="3">怎么办呢?既然 CPU 这么快,那就用一用 CPU 缓存嘛,我先把一些数据放在 CPU 缓存中,这样是不是读取的速度就快一些;在操作系统层面,增加进程/线程,这样如果这个线程不用 CPU 了,赶紧换另外一个线程使用;编译程序在进行编译的时候,可以将指令进行一下优化<br>这样看起来是不错,但是它们分别带来了不同的问题.比如 CPU 缓存这一块,缓存最大的问题是什么?是数据不一致问题,源数据都已经做了更新,但是在 CPU 缓存中没有去做这个更新,此时别的程序来读,就很容易导致可见性问题;操作系统增加了进程/线程,那么线程之间的切换就没有办法导致原子性问题,比如经典的 i++ ;编译器不是会对指令进行优化吗,那就没办法保证优化之后的结果还是原来的执行顺序,这就导致了有序性问题</font></p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a><font face="华文中宋" size="3">JMM</font></h1><p><font face="华文中宋" size="3">有问题就要有解决方案嘛, JMM 的存在就解决了可见性和有序性的问题,怎么解决的呢?<br>这就要说, Happens-Before 规则, volatile , synchronized , final 这些内容了.<br>以前写过一些这部分的内容,就直接放链接了: </font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/e3a1cde0.html">[Java 并发]为什么会有重排序?和 happens-before 有啥关系</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/6bdf9b1b.html">[Java 并发]你确定你了解 volatile ?</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/c8ca8c17.html">[Java 并发]深入浅出 synchronized 与锁</a></font></p><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a><font face="华文中宋" size="3">核心</font></h1><p><font face="华文中宋" size="3">并发编程的核心主要有 3 点:</font></p><ul><li><font face="华文中宋" size="3">分工<br><font face="华文中宋" size="3">因为是多线程嘛,那就肯定要分工好咯,就像一个团队,这个功能你来开发,那个功能他来开发,如果两个人开发同样一个任务,那不就有点儿浪费资源了嘛<br>在并发编程这块,分工就是由 Executor/线程池/Fork/Join 来实现的</font></font></li><li><font face="华文中宋" size="3">协作<br>分工好了,接下来就是怎么互相协作一起做好,协作的核心技术是管程,其实分工里面就有协作的解决方案,比如 Fork/Join 它就有定义分工完了怎么再协作,所以导图就没有列出,主要说了 CountDownLantch/CyclicBarrier/Monitor ,因为接下来我想针对这几个方面去写几篇文章(不偷懒的话;</font></li><li><font face="华文中宋" size="3">互斥<br>分工/同步主要说的是性能,但是在并发程序里面还要求正确,也就是”线程安全”,解决这个问题的核心就是互斥.<br>解决互斥的方案就是锁嘛.所以就有无锁和互斥锁两种方案.具体可以见思维导图</font></li></ul><p><font face="华文中宋" size="3">思维导图里面涉及到的内容,接下来我会慢慢都写出来(就是不确定什么时候写完<br>有时候我觉得自己扎到细节里面去之后,就不知道在做什么了,需要再看看全貌,也就是这张导图<br>也算是对自己接下来要写的内容的一个总结吧</font></p><p><font face="华文中宋" size="3">最后推荐几篇文章,相信你看完再看这个导图会有不小的收获</font></p><p><font face="华文中宋" size="3">文章推荐:</font></p><ul><li><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a></font></li><li><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/23fd3456.html">[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</a></font></li></ul><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;Java 并发这块,比较难,为啥呢,因为这一个知识点,那一个知识点的,特别碎&lt;br&gt;所以这个时候最重要的就是要对 Java 并发这块的知识有一个全貌&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]听说,你对 Java 线程的生命周期了如指掌</title>
    <link href="https://www.dynamic-zheng.com/posts/90b87b3d.html"/>
    <id>https://www.dynamic-zheng.com/posts/90b87b3d.html</id>
    <published>2020-05-30T10:56:39.000Z</published>
    <updated>2020-05-30T11:00:23.110Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">有点儿尴尬,前几篇文章吭哧吭哧写完发现,把最基础的给忘了,这篇文章来补一补,关于 Java 线程的生命周期,可以说是基础而又必须掌握的内容了<br>话不多说,咱们直接开聊<br><a id="more"></a></font></p><h1 id="通用的线程生命周期"><a href="#通用的线程生命周期" class="headerlink" title="通用的线程生命周期"></a><font face="华文中宋" size="3">通用的线程生命周期</font></h1><p><font face="华文中宋" size="3">如果要说 Java 线程的生命周期的话,就绕不过去操作系统的线程生命周期<br>毕竟 JVM 是跑在操作系统上面的嘛,绕不过去的,而且可以说, Java 语言中的线程本质上就是操作系统的线程<br>聪明的你肯定也发现了,不管是操作系统,还是 Java 或者 C# 都有线程的概念.在它们之间,关于线程的生命周期这一部分,肯定是有相同之处的,否则的话,操作系统自己一套生命周期流程, Java 又有自己的一套, C# 又有自己的一套,而且相互之间还要能够互相配合,这种成本想想就大的不行对吧</font></p><p><font face="华文中宋" size="3">所以咱们就来看看,通用的线程生命周期都有啥<br>先直接上张图(这次的图,我画的还可以吧):</font></p><p><img src="/images/2020/system-thread-state.jpg"></p><p><font face="华文中宋" size="3">可以看到,主要有 new , ready , running , waiting , terminated 5 种状态<br>其中:</font></p><ul><li><font face="华文中宋" size="3">new 只是说,这个线程被创建了,但是还不允许分配 CPU 执行.因为这个状态只是说明你在编程语言层面被创建了,操作系统层面还没有被创建,肯定就谈不上分配 CPU 执行了</font></li><li><font face="华文中宋" size="3">ready 这个状态是说,在操作系统层面已经成功创建了,所以接下来就是等待分配 CPU 执行了.还记得那句经典的嘛? ready ? go !</font></li><li><font face="华文中宋" size="3">running 的状态,相信你就知道了,我都已经 ready 了,此时如果再给我分配一下 CPU 我是不是就可以 go 了?那不就是 running 状态了嘛</font></li><li><font face="华文中宋" size="3">waiting 状态,就是线程在 running 状态的时候,突然发现,哎,我需要进行一下 I/O 操作,或者需要等待某个事件发生(比如说需要某个条件变量),这个时候是不是就不能再继续 happy 的 running 了.那咋办, waiting 一下呗<ul><li><font face="华文中宋" size="3">那你都 waiting 了,占用的 CPU 资源是不是应该释放掉?所以说, waiting 状态的线程是永远没有机会获得 CPU 使用权的.</font></li><li><font face="华文中宋" size="3">你是不是一听「永远没有机会」这几个字就给吓坏了,我该不会永远没有机会执行了吧.放心吧,你不是在 waiting 嘛,等你 wait 的事件发生了,就可以继续到 running 状态</font></li></ul></font></li><li><font face="华文中宋" size="3">当整个线程执行完毕,或者出现异常的时候,就进入了 terminated 状态,也就是线程的使命就完成啦,处于 terminated 状态的线程不会再切换到其他状态了</font></li></ul><p><font face="华文中宋" size="3">通用的线程生命周期以及它们之间是如何切换的,到这里,应该就比较清楚了<br>接下来咱们看看 Java 线程的生命周期,在这个基础上是怎么做的优化,有什么区别</font></p><h1 id="Java-线程的生命周期"><a href="#Java-线程的生命周期" class="headerlink" title="Java 线程的生命周期"></a><font face="华文中宋" size="3">Java 线程的生命周期</font></h1><p><font face="华文中宋" size="3">咱们先来瞅瞅源码定义的状态(为了突出重点,我把注释都去掉了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">NEW,</span><br><span class="line">RUNNABLE,</span><br><span class="line">BLOCKED,</span><br><span class="line">WAITING,</span><br><span class="line">TIMED_WAITING,</span><br><span class="line">TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够清楚的看到,在源码中定义了 6 种线程状态<br>刚才的通用状态有几种来着? 5 种对吧,现在是 6 种.<br>哪 6 种呢?刚才的 5 种状态以及它们之间的切换我搞清楚了,这 6 种状态它们之间又是怎么切换的呢?<br>别急,这么贴心的我,肯定也是画好了一张图的:</font></p><p><img src="/images/2020/Thread-state.png"></p><p><font face="华文中宋" size="3">这 6 个状态咱们也是分别来看:</font></p><ul><li><font face="华文中宋" size="3">NEW 到 RUNNABLE ,应该是挺容易理解的,就是 thread 调用了 start 方法<ul><li><font face="华文中宋" size="3">Java 刚创建出来的 Thread 对象就是 NEW 状态,创建 Thread 对象主要有两种方法,一种是继承 Thread 对象,重写 run() 方法,一种是实现 Runnable 接口,重写 run() 方法,并将该实现类作为创建 Thread 对象的参数,相信各位比我还要懂哈~</font></li><li><font face="华文中宋" size="3">但是还记得嘛, NEW 只是说,这个线程在编程语言层面创建了,在操作系统层面还没有创建,那当然就不会被操作系统调度了对不对,就更谈不上执行了</font></li><li><font face="华文中宋" size="3">所以 Java 线程如果想要执行的话,就必须转换到 RUNNABLE 状态,也就是 thread 调用 start 方法</font></li></ul></font></li><li><font face="华文中宋" size="3"> RUNNABLE 与 BLOCKED ,如果线程等待 synchronized 的隐式锁时,就会从 RUNNABLE 状态转到 BLOCKED 状态.因为 synchronized 修饰的方法/代码块同一时刻只允许一个线程执行,所以其他线程就只能等待了呗,当等待的线程获得 synchronized 隐式锁时,就会从 BLOCKED 状态转到 RUNNABLE 状态<ul><li><font face="华文中宋" size="3">在这里有没有个疑问?就是线程在 wait 一个条件发生时,在操作系统层面线程会转到 waiting 状态,那么在 JVM 层面呢?在 JVM 层面, Java 线程状态是不会发生变化的.也就是此时 Java 线程的状态依然是 RUNNABLE 状态</font></li></ul></font></li><li><font face="华文中宋" size="3"> RUNNABLE 与 WAITING 状态转换,我感觉图已经说得很好了,在这里不再赘述</font></li><li><font face="华文中宋" size="3"> RUNNABLE 与 TIMED_WAITING 状态转换,我感觉图已经说得很好了,在这里也不再赘述,仔细观察下会发现, TIMED_WAITING 与 WAITING 相比,就是多了超时参数,毕竟 TIMED_WAITING 是有时限等待嘛</font></li><li><font face="华文中宋" size="3"> RUNNABLE 到 TERMINATED ,这个过程比较好理解,线程执行完 run() 方法之后,就自动到 TERMINATED 状态了,当然了如果在执行 run() 方法过程中有异常抛出,也会导致线程终止<ul><li><font face="华文中宋" size="3">有时候我们可能需要强制中断 run() 方法的执行,怎么办呢?是使用 stop() 方法还是 interrupt() 方法呢?正确的姿势是调用 interrupt() 方法</font></li><li><font face="华文中宋" size="3">stop() 方法会真的杀死线程,不给线程一点儿喘息的机会,如果被杀死的线程持有 synchronized 隐式锁,那就再也不会释放掉这个锁了,接下来的线程也就没办法获得 synchronized 隐式锁,是不是特别危险?同样 suspend() 和 resume() 这两个方法也是不建议使用</font></li><li><font face="华文中宋" size="3">interrupt() 方法相比于 stop() 方法就温柔很多,它只是通知线程后续的操作可以不用去执行了,线程可以选择执行现在就不执行,当然也可以选择再执行一段时间后再停止,或者我就不听你的,非要执行完,都没关系, interrupt() 只是通知一下你而已.就比如你要做火车去一个地方,突然通知你这个火车晚点了,你可以选择无视这个通知继续等待,或者选择另外一趟高铁,但是不管你做什么,和火车站都没啥关系,它通知的责任尽到了</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">看到这里应该就比较清楚了吧<br>在 Java 线程生命周期中, RUNNABLE 状态是将 ready 和 running 两种状态合并在了一起,而 BLOCKED , WAITING , TIMED_WAITING 这三种状态其实就是 waiting 状态,也就是线程要等待某些事件发生,才能继续向下执行下去<br>关于 Java 线程的生命周期,到这里就说完啦</font></p><p><font face="华文中宋" size="3">在文章刚开始就说了, Java 线程的生命周期,可以说是基础而又必须掌握的内容,因为只有理解了 Java 线程的生命周期以及各种状态之间的转换,在诊断多线程 Bug 的时候,才能够在最短的时间内定位到问题<br>看到这里的你,如果有所收获,我会非常开心的</font></p><p><font face="华文中宋" size="3">参考:<br>极客时间—&lt; Java 并发编程实战&gt;</font></p><p><font face="华文中宋" size="3">以上<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;有点儿尴尬,前几篇文章吭哧吭哧写完发现,把最基础的给忘了,这篇文章来补一补,关于 Java 线程的生命周期,可以说是基础而又必须掌握的内容了&lt;br&gt;话不多说,咱们直接开聊&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]进来唠唠嗑</title>
    <link href="https://www.dynamic-zheng.com/posts/9adc1e81.html"/>
    <id>https://www.dynamic-zheng.com/posts/9adc1e81.html</id>
    <published>2020-05-24T09:46:19.000Z</published>
    <updated>2020-05-24T09:48:03.850Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">向各位读者大大们道个歉,最近比较忙,有好多事情都想要去做,所以这周可以说没啥输入,没有好的输入,那就很难有高质量的输出嘛,所以这篇文章咱们就来唠唠嗑.要是您不想看,就不要点进来了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">时间真的是太快了,一天天的,一眨眼,这都是 5 月底了,下个月就是 6 月,说明什么?这一年就过去了一半,再瞅瞅年初给自己定的目标,就问你慌不慌?<br>说实话,我是挺慌的~</font></p><p><font face="华文中宋" size="3">再慌也得一个一个脚印的踏踏实实去走不是~<br>特别是今年情况大家也都知道,身体是非常重要的,如果身体不太好,干啥啥没劲<br>所以自从天气暖和之后,恢复了以前的生物钟,早上 6 点起床溜达锻炼去(当然也有偷懒的时候,记得有次休息太累了,直接睡到了上午十点多)<br>然后每天都能走够 1 万步,谁说的 1 万步能够有效缓解亚健康状态来着,也不知道准不准,先自己每天做到了再说~</font></p><p><font face="华文中宋" size="3">最近是在精进并发多线程这块,不过这周是偷懒了,休息时间全都被我拿来刷动漫了,要不然我就不会厚着脸皮来写这篇碎碎念了~<br>其他不知道各位读者大大们想看啥,留个言?也算是给我点儿灵感</font></p><p><font face="华文中宋" size="3">以前的碎碎念,都是被我写 7,8 百字,我看了一下这篇碎碎念, 400 多字,所以知道我这周看动漫看的有多厉害了吧(逃;</font></p><p><font face="华文中宋" size="3">以上,就是这样啦~<br>你有想看的内容,记得留个言哇<br>感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;向各位读者大大们道个歉,最近比较忙,有好多事情都想要去做,所以这周可以说没啥输入,没有好的输入,那就很难有高质量的输出嘛,所以这篇文章咱们就来唠唠嗑.要是您不想看,就不要点进来了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[MySQL]来讲讲一条查询语句的具体过程</title>
    <link href="https://www.dynamic-zheng.com/posts/4e657641.html"/>
    <id>https://www.dynamic-zheng.com/posts/4e657641.html</id>
    <published>2020-05-17T13:01:34.000Z</published>
    <updated>2020-05-17T13:05:15.598Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">前几篇文章是关于 Java 并发,说实话比较费力气,因为一个知识点讲清楚,常常会牵扯出另外一个知识点,然后为了保证写的尽量是对的,还要去翻源码求证,所以你看到的一篇文章,我可能是一周的时间就出去了<br>这周的文章咱们来看个相对来说轻松的点儿的:一条查询语句在 MySQL 中是如何查询的(并发那块,等我回来有时间和精力了,我再慢慢补回来,肯定不会就到此为止的,啊,对了还有算法,有种欠了好多债的赶脚<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">一条看似非常简单的查询语句:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T where id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">然后 MySQL 就返回给了你结果,但是里面具体是如何执行的呢?<br>先上一张图:<br><img src="/images/2020/search.jpg"></font></p><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a><font face="华文中宋" size="3">连接器</font></h1><p><font face="华文中宋" size="3">当客户端连接 MySQL 时,会发出连接请求到连接器,连接器此时就会去验证这个连接的账号密码</font></p><ul><li><font face="华文中宋" size="3">如果账号或者密码不正确,客户端就会收到一个” Access denied for user”的错误,之后此次连接结束</font></li><li><font face="华文中宋" size="3">账号密码正确,连接器会到权限表里面查询出该账号所拥有的权限,之后这个连接里面的权限判断,都是以此时读到的权限为根据</font></li></ul><p><font face="华文中宋" size="3">所以你知道为什么更改了一个账号的权限之后,一定要断开再重连才有效吧~</font></p><p><font face="华文中宋" size="3">在实际中肯定有这样的情况,就是一个连接建立之后,但是我没有执行什么操作,那么就可以说这个连接处于空闲状态( sleep )<br>如果长时间都没有什么操作的话,连接器就会选择把它断开,这个时间是由 wait_timeout 来控制的,默认值是 8 小时<br>连接都被断开了,如果此时客户端再次发送请求想要进行一些操作的话,那就需要重新建立连接才能往下走</font></p><p><font face="华文中宋" size="3">在数据库中有两种连接:</font></p><ul><li><font face="华文中宋" size="3">短连接:每次执行完很少的几次查询就断开连接,下次想查询时,就要重新建立一个</font></li><li><font face="华文中宋" size="3">长连接:如果客户端持续有请求,那就一直使用同一个连接</font></li></ul><p><font face="华文中宋" size="3">建立连接是比较麻烦的,首先要发送请求吧,发送了请求要去验证账号密码吧,验证完了要去看你所拥有的权限吧,所以在使用过程中,尽量使用长连接<br>但是使用长连接又有新的问题:有时候,你会发现 MySQL 占用内存,因为是长连接嘛,所以它会在断开的时候才将资源释放掉.<br>可以考虑下面两种方案:</font></p><ul><li><font face="华文中宋" size="3">定期断开长连接</font></li><li><font face="华文中宋" size="3">如果使用的是 MySQL 5.7 或者更高版本,可以在每次执行一个比较大的操作之后,通过执行 mysql_reset_connection 来重新初始化连接资源,这个过程不需要重新连接和权限验证</font></li></ul><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a><font face="华文中宋" size="3">分析器</font></h1><p><font face="华文中宋" size="3">连接器这一关是过来了,接下来就是去查询缓存.<br>首先看缓存里面有没有,如果有呢,那就没有必要向下走,直接返回给客户端结果就可以了.<br>如果缓存中没有的话,那就去分析器.</font></p><p><font face="华文中宋" size="3">但是聪明的你肯定发现了,我的小标题并不是缓存,而是分析器,为啥呢?<br>因为查询缓存的失效非常频繁,只要有对一个表的更新,那在这个表上的所有查询缓存都会被清空.所以就会出现, MySQL 费劲吧啦的把缓存给建立起来了,结果呢还没怎么用,一个更新操作,给弄没了<br>所以 MySQL 8.0 版本直接将查询缓存的整块功能都给删掉了,那么在这里也不细说,免得奇怪的知识增加</font></p><p><font face="华文中宋" size="3">分析器首先会进行”词法分析”,词法分析就是 <code>select * from T where id=1;</code> ,它会将 <code>select</code> 识别出来,哦,这是一个查询语句,接下来会将 <code>T</code> 也识别出来,哦,你是想要在这个表中做查询,然后将 <code>where</code> 后面的条件也识别出来,原来我需要去查找这些内容<br>OK ,”词法分析”之后,接下来是”语法分析”,语法分析主要就是分析输入的 SQL 语句合不合法.<br>就比如英语里面的语法” 我用 is , 你用 are “这种,如果不对肯定是不可以的,语法分析之后发现你的 SQL 语句不符合规则,就会收到 <code>You hava an error in your SQL syntax</code> 的错误提示</font></p><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a><font face="华文中宋" size="3">优化器</font></h1><p><font face="华文中宋" size="3">经过分析器分析之后, MySQL就知道你要的是什么了.<br>但是就像条条大路通罗马一样,看似是一条简单的 SQL 查询语句,有可能有好多条执行路径可以走,比如说要查询的表里面有多个索引,我使用哪儿个索引效率会比较高呀;多表联查的时候,我先关联哪儿个表效率会比较高呀<br>像这种就是优化器需要做的事情</font></p><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a><font face="华文中宋" size="3">执行器</font></h1><p><font face="华文中宋" size="3">优化器做完优化之后,就到了执行器<br>执行器就是要去执行语句了嘛,那我肯定要看看对于要查询的表 <code>T</code> 有没有查询权限,如果没有直接就拒绝,这没啥说的<br>如果有的话,那就会这样(在这里以 InnoDB 为例):</font></p><ul><li><font face="华文中宋" size="3">调用 InnoDB 引擎接口取这个表的第一行,判断 <code>ID</code> 的值是不是 10 ,如果不是就跳过,如果是那就放在结果集中;</font></li><li><font face="华文中宋" size="3">调用引擎接口取”下一行”,重复相同的判断逻辑,直到这个表的最后一行</font></li><li><font face="华文中宋" size="3">执行器将上述遍历过程中所有满足条件的行,组成记录集返回给客户端</font></li></ul><p><font face="华文中宋" size="3">至此,语句执行结束.</font></p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><font face="华文中宋" size="3">存储引擎</font></h1><p><font face="华文中宋" size="3">存储引擎,一听名字大概就能知道,它负责的是对数据的存储和提取.<br>关于存储引擎这块,最熟悉的应该就是 InnoDB 了,毕竟从 MySQL 5.5.5 版本开始它就成为了默认得存储引擎</font></p><p><font face="华文中宋" size="3">参考:<br>极客时间- MySQL 实战 45 讲</font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容了,是不是还好理解那么一点儿?<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;前几篇文章是关于 Java 并发,说实话比较费力气,因为一个知识点讲清楚,常常会牵扯出另外一个知识点,然后为了保证写的尽量是对的,还要去翻源码求证,所以你看到的一篇文章,我可能是一周的时间就出去了&lt;br&gt;这周的文章咱们来看个相对来说轻松的点儿的:一条查询语句在 MySQL 中是如何查询的(并发那块,等我回来有时间和精力了,我再慢慢补回来,肯定不会就到此为止的,啊,对了还有算法,有种欠了好多债的赶脚&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</title>
    <link href="https://www.dynamic-zheng.com/posts/23fd3456.html"/>
    <id>https://www.dynamic-zheng.com/posts/23fd3456.html</id>
    <published>2020-05-09T23:40:42.000Z</published>
    <updated>2020-05-09T23:44:13.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReentrantLock-是可重入锁"><a href="#ReentrantLock-是可重入锁" class="headerlink" title="ReentrantLock 是可重入锁"></a><font face="华文中宋" size="3">ReentrantLock 是可重入锁</font></h1><a id="more"></a><p><font face="华文中宋" size="3">啥是可重入锁呢?比如:线程 1 通过调用 lock() 方法获取锁之后,再调用 lock 时,就不会再进行阻塞获取锁,而是直接增加重试次数.<br>在 <a href="https://www.dynamic-zheng.com/posts/c8ca8c17.html">[Java 并发]深入浅出 synchronized 与锁</a> 文章中,说过 synchronized 中有 monitorenter 和 monitorexit 两种指令来保证锁,而它们的作用可以理解为每个锁对象拥有一个锁计数器,也就是如果再次调用 lock() 方法,计数器会进行加 1 操作<br>所以, synchronized 和 ReentrantLock 都是可重入锁</font></p><h1 id="ReentrantLock-与-synchronized-区别"><a href="#ReentrantLock-与-synchronized-区别" class="headerlink" title="ReentrantLock 与 synchronized 区别"></a><font face="华文中宋" size="3">ReentrantLock 与 synchronized 区别</font></h1><p><font face="华文中宋" size="3">既然 synchronized 和 ReentrantLock 都是可重入锁,那 ReentrantLock 与 synchronized 有什么区别呢?</font></p><ul><li><font face="华文中宋" size="3">synchronized 是 Java 语言层面提供的语法,所以不需要考虑异常; ReentrantLock 是 Java 代码实现的锁,所以必须先要获取锁,然后再正确释放锁</font></li><li><font face="华文中宋" size="3">synchronized 在获取锁时必须一直等待没有额外的尝试机制; ReentrantLock 可以尝试获取锁(这一点等下分析源码时会看到)</font></li><li><font face="华文中宋" size="3">ReentrantLock 支持获取锁时的公平和非公平选择</font></li></ul><p><font face="华文中宋" size="3">在接下来之前,如果你对 AQS 不太熟悉,建议先花时间看看这篇博客: <a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a><br>不废话了,就直接上源码</font></p><h1 id="lock-amp-NonfairSync-amp-FairSync-详解"><a href="#lock-amp-NonfairSync-amp-FairSync-详解" class="headerlink" title="lock &amp; NonfairSync &amp; FairSync 详解"></a><font face="华文中宋" size="3">lock &amp; NonfairSync &amp; FairSync 详解</font></h1><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a><font face="华文中宋" size="3">lock</font></h2><p><font face="华文中宋" size="3">锁的入口是 lock() 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">其中, sync 是 ReentrantLock 的静态内部类,它继承 AQS 来实现重入锁的逻辑, Sync 有两个具体实现类: <code>NonfairSync</code> 和 <code>FairSync</code> </font></p><h2 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a><font face="华文中宋" size="3">NonfairSync</font></h2><p><font face="华文中宋" size="3">先来看一下 <code>NonfairSync</code> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">    * acquire on failure.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 重写 Sync 的 lock 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先不管其他,上来就先 CAS 操作,尝试抢占一下锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 如果抢占成功,就获得了锁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 没有抢占成功,调用 acquire() 方法,走里面的逻辑</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 重写了 AQS 的 tryAcquire 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a><font face="华文中宋" size="3">FairSync</font></h2><p><font face="华文中宋" size="3">接下来看一下 <code>FairSync</code> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 Sync 的 lock 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">    * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 重写了 Sync 的 tryAcquire 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前执行的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取 state 的值</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 在无锁状态下</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有前驱节点且替换 state 的值成功时</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                <span class="comment">// 保存当前获得锁的线程,下次再来时,就不需要尝试竞争锁,直接重入即可</span></span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 如果是同一个线程来获得锁,直接增加重入次数即可</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="comment">// nextc 小于 0 ,抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="comment">// 获取锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取锁失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="总结-NonfairSync-与-FairSync"><a href="#总结-NonfairSync-与-FairSync" class="headerlink" title="总结 NonfairSync 与 FairSync"></a><font face="华文中宋" size="3">总结 NonfairSync 与 FairSync</font></h2><p><font face="华文中宋" size="3">到这里,应该就比较清楚了,  Sync 有两个具体的实现类,分别是:</font></p><ul><li><font face="华文中宋" size="3">NonfairSync :可以抢占锁,调用 NonfairSync 时,不管当前队列上有没有其他线程在等待,上来我就先 CAS 操作一番,成功了就获得了锁,没有成功就走 acquire 的逻辑;在释放锁资源时,走的是 Sync.nonfairTryAcquire 方法</font></li><li><font face="华文中宋" size="3">FairSync :所有线程按照 FIFO 来获取锁,在 lock 方法中,没有 CAS 尝试,直接就是 acquire 的逻辑;在释放资源时,走的是自己的 tryAcquire 逻辑</font></li></ul><p><font face="华文中宋" size="3">接下来咱们看看 NonfairSync 和 FairSync 是如何获取锁的</font></p><h1 id="ReentrantLock-获取锁"><a href="#ReentrantLock-获取锁" class="headerlink" title="ReentrantLock 获取锁"></a><font face="华文中宋" size="3">ReentrantLock 获取锁</font></h1><h2 id="NonfairSync-lock"><a href="#NonfairSync-lock" class="headerlink" title="NonfairSync.lock()"></a><font face="华文中宋" size="3">NonfairSync.lock()</font></h2><p><font face="华文中宋" size="3">在 NonfairSync 中,获取锁的方法是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 不管别的,上来就先 CAS 操作,尝试抢占一下锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 如果抢占成功,就获得了锁</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 没有抢占成功,调用 acquire() 方法,走里面的逻辑</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">if 里面没啥说的,咱们来看看 acquire() 方法</font></p><h3 id="AQS-acquire"><a href="#AQS-acquire" class="headerlink" title="AQS.acquire()"></a><font face="华文中宋" size="3">AQS.acquire()</font></h3><p><font face="华文中宋" size="3">acquire 是 AQS 的核心方法(如果你看了我这篇博客:  <a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a>   会觉得很熟悉,所以刚开始就让你看了,别偷懒,看到这里如果觉得不好理解,回过去看):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在这里,会先 tryAcquire 去尝试获取锁,如果获取成功,那就返回 true ,如果失败就通过 addWaiter 方法,将当前线程封装成 Node 插入到等待队列中<br>先来看 tryAcquire 方法:</font></p><h3 id="NonfairSync-tryAcquire-arg"><a href="#NonfairSync-tryAcquire-arg" class="headerlink" title="NonfairSync.tryAcquire(arg)"></a><font face="华文中宋" size="3">NonfairSync.tryAcquire(arg)</font></h3><p><font face="华文中宋" size="3">在 AQS 中 tryAcquire 方法没有具体实现,只是抛出了异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">NonfairSync 中的 tryAcquire() 方法,才是我们想要看的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取 state 的值</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 当 state 为 0 是,说明此时为无锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// CAS 替换 state 的值,如果 CAS 成功,则获取锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">        <span class="comment">// 保存当前获得锁的线程,当该线程再次获得锁时,直接重入即可</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否是同一个线程来竞争锁</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="comment">// 如果是,直接增加重入次数</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">// 获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">有没有一种似曾相识的赶脚?在 FairSync 那里,分析过 90% 的代码(好像说分析过 99% 的代码也不过分),只是 FairSync 多了一个判断就是,是否有前驱节点<br>tryAcquire 分析完毕了,接下来看 addWaiter 方法(虽然在这篇文章中:  <a href="https://www.dynamic-zheng.com/posts/c1cacb19.html">[Java 并发] AQS 是个啥?</a>   分析过,但是在这里我还想再分析一遍,这样才是一个整体~原谅我这个人有点儿强迫症;</font></p><h3 id="AQS-addWaiter"><a href="#AQS-addWaiter" class="headerlink" title="AQS.addWaiter"></a><font face="华文中宋" size="3">AQS.addWaiter</font></h3><p><font face="华文中宋" size="3">如果 tryAcquire() 方法获取锁成功,那就直接执行线程的任务就可以了,执行完毕释放锁<br>如果获取锁失败,就会调用 addWaiter 方法,将当前线程插入到等待队列中,插入的逻辑大概是这样的:</font></p><ul><li><font face="华文中宋" size="3">将当前线程封装成 Node 节点</font></li><li><font face="华文中宋" size="3">当前链表中 tail 节点(也就是下面的 pred )是否为空,如果不为空,则 CAS 操作将当前线程的 node 添加到 AQS 队列</font></li><li><font face="华文中宋" size="3">如果为空,或者 CAS 操作失败,则调用 enq 方法,再次自旋插入</font></li></ul><p><font face="华文中宋" size="3">咱们看具体的代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 生成该线程所对应的 Node 节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将 Node 插入队列中</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果 pred 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 CAS 操作,如果成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 pred == null 或者 CAS 操作失败,则调用 enq 方法再次自旋插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋 CAS 插入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">        <span class="comment">// 必须初始化,使用 CAS 操作进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            <span class="comment">// 初始化状态时,头尾节点指向同一节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 如果刚开始就是初始化好的,直接 CAS 操作,将 Node 插入到队尾即可</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h3 id="AQS-acquireQueued"><a href="#AQS-acquireQueued" class="headerlink" title="AQS.acquireQueued"></a><font face="华文中宋" size="3">AQS.acquireQueued</font></h3><p><font face="华文中宋" size="3">通过 addWaiter 将当前线程加入到队列中之后,会走 <code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code> 方法<br>acquireQueued 方法实现的主要逻辑是:</font></p><ul><li><font face="华文中宋" size="3">获取当前节点的前驱节点 p</font></li><li><font face="华文中宋" size="3">如果节点 p 为 head 节点,说明当前节点为第二个节点,那么它就可以尝试获取锁,调用 tryAcquire 方法尝试进行获取</font></li><li><font face="华文中宋" size="3">调用 tryAcquire 方法获取锁成功之后,就将 head 指向自己,原来的节点 p 就需要从队列中删除</font></li><li><font face="华文中宋" size="3">如果获取锁失败,则调用 shouldParkAfterFailedAcquire 或者 parkAndCheckInterrupt 方法来决定后面操作</font></li><li><font face="华文中宋" size="3">最后,通过 cancelAcquire 方法取消获得锁</font></li></ul><p><font face="华文中宋" size="3">看具体的代码实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果 Node 的前驱节点 p 是 head,说明 Node 是第二个节点,那么它就可以尝试获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果锁获取成功,则将 head 指向自己</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 锁获取成功之后,将 next 指向 null ,即将节点 p 从队列中移除</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点进入等待队列后,调用 shouldParkAfterFailedAcquire 或者 parkAndCheckInterrupt 方法</span></span><br><span class="line">            <span class="comment">// 进入阻塞状态,即只有头结点的线程处于活跃状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h3 id="shouldParkAfterFailedAcquire"><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a><font face="华文中宋" size="3">shouldParkAfterFailedAcquire</font></h3><p><font face="华文中宋" size="3">线程获取锁失败之后,会通过调用 shouldParkAfterFailedAcquire 方法,来决定这个线程要不要挂起<br>shouldParkAfterFailedAcquire 方法实现的主要逻辑:</font></p><ul><li><font face="华文中宋" size="3">首先判断 pred 的状态是否为 SIGNAL ,如果是,则直接挂起即可</font></li><li><font face="华文中宋" size="3">如果 pred 的状态大于 0 ,说明该节点被取消了,那么直接从队列中移除即可</font></li><li><font face="华文中宋" size="3">如果 pred 的状态不是 SIGNAL 也不大于 0 ,进行 CAS 操作修改节点状态为 SIGNAL ,返回 false ,也就是不需要挂起</font></li></ul><p><font face="华文中宋" size="3">看一下代码是如何实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取 pred 的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果状态为 SIGNAL ,那么直接返回 true ,挂起线程即可</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果状态大于 0 ,说明线程被取消</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 从链表中移除被 cancel 的线程,使用循环来保证移除成功</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// CAS 操作修改 pred 节点状态为 SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不需要挂起线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">到这里,关于 NonfairSync 的获取锁就结束了<br>接下来咱们看看 FairSync 的获取锁和它有什么不同</font></p><h2 id="FairSync-lock"><a href="#FairSync-lock" class="headerlink" title="FairSync.lock()"></a><font face="华文中宋" size="3">FairSync.lock()</font></h2><p><font face="华文中宋" size="3">在 FairSync.lock() 方法中是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">因为 FairSync 是公平锁,所以不存在 CAS 操作去竞争,直接就是调用 acquire 方法<br>接下来的逻辑就和上面一样了,这里我就不重复了<br>咱们瞅瞅 ReentrantLock 是怎么释放锁的</font></p><h1 id="ReentrantLock-释放锁"><a href="#ReentrantLock-释放锁" class="headerlink" title="ReentrantLock 释放锁"></a><font face="华文中宋" size="3">ReentrantLock 释放锁</font></h1><p><font face="华文中宋" size="3">在 ReentrantLock 释放锁时,调用的是 sync.release() 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">点进去发现调用的是 AQS 的 release 方法</font></p><h2 id="AQS-release"><a href="#AQS-release" class="headerlink" title="AQS.release()"></a><font face="华文中宋" size="3">AQS.release()</font></h2><p><font face="华文中宋" size="3">AQS 的 release 方法比较好理解,就直接看源码了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 获取 AQS 队列的头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果头结点不为空,且状态 != 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 unparkSuccessor 方法唤醒后续节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="ReentrantLock-tryRelease"><a href="#ReentrantLock-tryRelease" class="headerlink" title="ReentrantLock.tryRelease()"></a><font face="华文中宋" size="3">ReentrantLock.tryRelease()</font></h2><p><font face="华文中宋" size="3">在 AQS 中的 tryRelease 方法,只是抛出了异常而已,说明具体实现是由子类 ReentrantLock 来实现的<br>就直接看 ReentrantLock 中的 tryRelease 方法了<br>在 ReentrantLock 中实现 tryRelease 方法主要逻辑是:</font></p><ul><li><font face="华文中宋" size="3">首先,如果是同一个线程获取的同一个锁,那么它有可能被重入多次,所以需要获取到要释放线程的重入次数即 getState()</font></li><li><font face="华文中宋" size="3">然后判断,该线程是否为获取到锁的线程,只有获取到锁的线程,才有释放锁一说</font></li><li><font face="华文中宋" size="3">进行 unlock 释放锁,即:将 state 的值减到 0 ,才算是释放掉了锁,此时才能将 owner 置为 null 同时返回 true</font></li></ul><p><font face="华文中宋" size="3">看一下具体实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为获取到锁的线程,如果不是则抛出异常</span></span><br><span class="line">    <span class="comment">// 只有获取到锁的线程才释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 次数为 0 ,说释放锁完毕</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 释放之后,当前线程置为 null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新重入次数</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h2 id="AQS-unparkSuccessor"><a href="#AQS-unparkSuccessor" class="headerlink" title="AQS.unparkSuccessor"></a><font face="华文中宋" size="3">AQS.unparkSuccessor</font></h2><p><font face="华文中宋" size="3">释放锁成功之后,接下来要做的就是唤醒后面的进程,这个方法是在 AQS 中实现的<br>主要逻辑是:</font></p><ul><li><font face="华文中宋" size="3">获取当前节点状态,如果小于 0 ,则置为 0</font></li><li><font face="华文中宋" size="3">获取当前节点的下一个节点,如果不为空,直接唤醒</font></li><li><font face="华文中宋" size="3">如果为空,或者节点状态大于 0 ,则寻找下一个状态小于 0 的节点</font></li></ul><p><font face="华文中宋" size="3">代码的具体实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取当前节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果节点状态小于 0 ,则进行 CAS 操作设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 获取当前节点的下一个节点 s</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果 s 为空,则从尾部节点开始,或者s.waitStatus 大于 0 ,说明节点被取消</span></span><br><span class="line">    <span class="comment">// 从尾节点开始,寻找到距离 head 节点最近的一个 waitStatus &lt;= 0 的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// next 节点不为空,直接唤醒即可</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在 <a href>[Java 并发] AQS 是个啥?</a> 这篇文章中,留下过悬念,就是为什么要从尾节点开始寻找距离 head  节点最近的一个 waitStatus &lt;= 0 的节点<br>这是因为在 enq() 构建节点的方法中,最后是 <code>t.next = node</code> (忘了就再往上翻翻看),设置原来的 tail 的 next 节点指向新的节点<br>如果在 CAS 操作之后, <code>t.next = node</code> 操作之前,有其他线程调用 unlock 方法从 head 开始向后遍历,因为此时 <code>t.next = node</code> 还没有执行结束,意味着链表的关系还没有建立好,这样就会导致遍历的时候到 t 节点这里发生中断,因为此时 tail 还没有指向新的尾节点<br>所以如果从后向前遍历的话,就不会存在这样的问题</font></p><p><font face="华文中宋" size="3">接下来下一个线程就被唤醒了,然后程序会把它当成新的节点开始执行<br>而原来执行结束的线程,则会将它从队列中移除,然后开始循环循环</font></p><p><font face="华文中宋" size="3">到这里,这篇文章终于可以告一个段落了,有没有松一口气?反正我是松了一口<br>这篇文章,被我断断续续写了有一周的时间,我的拖延症哇<br>如果能够给你带来一些帮助,甚感高兴</font></p><ul><li><font face="华文中宋" size="3">参考<br>JDK 源码( 1.8 )<br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580960149538" target="_blank" rel="noopener">廖雪峰的官方网站</a></font></li></ul><p><font face="华文中宋" size="3">以上<br>非常感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ReentrantLock-是可重入锁&quot;&gt;&lt;a href=&quot;#ReentrantLock-是可重入锁&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock 是可重入锁&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;ReentrantLock 是可重入锁&lt;/font&gt;&lt;/h1&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发] AQS 是个啥?</title>
    <link href="https://www.dynamic-zheng.com/posts/c1cacb19.html"/>
    <id>https://www.dynamic-zheng.com/posts/c1cacb19.html</id>
    <published>2020-05-03T07:50:36.000Z</published>
    <updated>2020-05-05T00:45:43.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><font face="华文中宋" size="3">基本概念</font></h1><p><font face="华文中宋" size="3">AQS 是 <code>AbstractQueuedSynchronizer</code> 的简称,翻译成中文就是 <code>抽象队列同步器</code> ,这三个单词分开来看:<br><a id="more"></a></font></p><ul><li><font face="华文中宋" size="3">Abstract (抽象):也就是说, AQS 是一个抽象类,只实现一些主要的逻辑,有些方法推迟到子类实现</font></li><li><font face="华文中宋" size="3">Queued (队列):队列有啥特征呢?先进先出( FIFO )对吧?也就是说, AQS 是用先进先出队列来存储数据的</font></li><li><font face="华文中宋" size="3">Synchronizer (同步):即 AQS 实现同步功能</font></li></ul><p><font face="华文中宋" size="3">以上概括一下, AQS 是一个用来构建锁和同步器的框架,使用 AQS 能简单而又高效地构造出同步器.</font></p><h1 id="AQS-内部实现"><a href="#AQS-内部实现" class="headerlink" title="AQS 内部实现"></a><font face="华文中宋" size="3">AQS 内部实现</font></h1><p><font face="华文中宋" size="3">AQS 队列在内部维护了一个 FIFO 的双向链表,如果对数据结构比较熟的话,应该很容易就能想到,在双向链表中,每个节点都有两个指针,分别指向直接前驱节点和直接后继节点.使用双向链表的优点之一,就是从任意一个节点开始都很容易访问它的前驱节点和后继节点.<br>在 AQS 中,每个 Node 其实就是一个线程封装,当线程在竞争锁失败之后,会封装成 Node 加入到 AQS 队列中;获取锁的线程释放锁之后,会从队列中唤醒一个阻塞的 Node (也就是线程)<br>AQS 使用 volatile 的变量 state 来作为资源的标识:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">关于 state 状态的读取与修改,子类可以通过覆盖 <code>getState()</code> 和 <code>setState()</code> 方法来实现自己的逻辑,其中比较重要的是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入期望值 expect ,想要修改的值 update ,然后通过 Unsafe 的 compareAndSwapInt() 即 CAS 操作来实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">下面是 AQS 中两个重要的成员变量:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;   <span class="comment">// 头结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;   <span class="comment">// 尾节点</span></span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">关于 AQS 维护的双向链表,在源码中是这样解释的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The wait queue is a variant of a <span class="string">"CLH"</span> (Craig, Landin, and Hagersten) lock queue. </span><br><span class="line">CLH locks are normally used <span class="keyword">for</span> spinlocks.  We instead use them <span class="keyword">for</span> blocking synchronizers, </span><br><span class="line">but use the same basic tactic of holding some of the control information </span><br><span class="line">about a thread in the predecessor of its node.</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">也就是 AQS 的等待队列是 “CLH” 锁定队列的变体<br>直接来一张图会更形象一些(每次画图头发都会掉不少,所以原来我这种不会配色的人,逃;):<br><img src="https://img-blog.csdnimg.cn/20200503111204645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">Node 节点维护的是线程,控制线程的一些操作,具体来看看是 Node 是怎么做的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">    <span class="comment">// 标记一个节点,在 共享模式 下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">    <span class="comment">// 标记一个节点,在 独占模式 下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示该节点从队列中取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示后继节点在等待唤醒</span></span><br><span class="line">    <span class="comment">// 只有处于 signal 状态的节点,才能被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示该节点在等待一些条件</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// waitStatus 的值,表示有资源可以使用,新 head 节点需要唤醒后继节点</span></span><br><span class="line">    <span class="comment">// 如果是在共享模式下,同步状态应该无条件传播下去</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点状态,取值为 -3,-2,-1,0,1</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点所对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// condition 队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否是共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回前驱节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将线程构造成一个 Node 节点,然后添加到 condition 队列中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 等待队列用到的方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h1 id="AQS-如何获取资源"><a href="#AQS-如何获取资源" class="headerlink" title="AQS 如何获取资源"></a><font face="华文中宋" size="3">AQS 如何获取资源</font></h1><p><font face="华文中宋" size="3">在 AQS 中,获取资源的入口是 <code>acquire(int arg)</code> 方法,其中 arg 是获取资源的个数,来看下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在获取资源时,会首先调用 <code>tryAcquire</code> 方法,这个方法是在子类中具体实现的<br>如果通过 <code>tryAcquire</code> 获取资源失败,接下来会通过 <code>addWaiter(Node.EXCLUSIVE)</code> 方法,将这个线程插入到等待队列中,具体代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 生成该线程所对应的 Node 节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 将 Node 插入到队列中</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 使用 CAS 操作,如果成功就返回</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 pred == null 或者 CAS 操作失败,则调用 enq 方法再次自旋插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自旋 CAS 插入等待队列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在上面能够看到使用的是 CAS 自旋插入,这是因为在 AQS 中会存在多个线程同时竞争资源的情况,进而一定会出现多个线程同时插入节点的操作,这里使用 CAS 自旋插入是为了保证操作的线程安全性<br>现在呢,申请 <code>acquire(int arg)</code> 方法,然后通过调用 <code>addWaiter</code> 方法,将一个 Node 插入到了队列尾部.处于等待队列节点是从头结点开始一个一个的去获取资源,获取资源方式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果 Node 的前驱节点 p 是 head,说明 Node 是第二个节点,那么它就可以尝试获取资源</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 如果资源获取成功,则将 head 指向自己</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 节点进入等待队列后,调用 shouldParkAfterFailedAcquire 或者 parkAndCheckInterrupt 方法</span></span><br><span class="line">            <span class="comment">// 进入阻塞状态,即只有头结点的线程处于活跃状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在获取资源时,除了 <code>acquire</code> 之外,还有三个方法:</font></p><ul><li><font face="华文中宋" size="3">acquireInterruptibly :申请可中断的资源(独占模式)</font></li><li><font face="华文中宋" size="3">acquireShared :申请共享模式的资源</font></li><li><font face="华文中宋" size="3">acquireSharedInterruptibly :申请可中断的资源(共享模式)</font></li></ul><p><font face="华文中宋" size="3">到这里,关于 AQS 如何获取资源就说的差不多了,接下来看看 AQS 是如何释放资源的</font></p><h1 id="AQS-如何释放资源"><a href="#AQS-如何释放资源" class="headerlink" title="AQS 如何释放资源"></a><font face="华文中宋" size="3">AQS 如何释放资源</font></h1><p><font face="华文中宋" size="3">释放资源相对于获取资源来说,简单了很多.源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 获取 AQS 队列中的头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果头结点不为空,且状态 != 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 调用 unparkSuccessor(h) 方法,唤醒后续节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果状态是负数,尝试将它改为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 得到头结点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果 waitStatus 大于 0 ,说明这个节点被取消</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 那就从尾节点开始,找到距离 head 最近的一个 waitStatus&lt;=0 的节点进行唤醒</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果后继节点不为空,则将其从阻塞状态变为非阻塞状态</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在上面你肯定会有疑问,为什么要从尾节点开始,找距离 head 最近的一个节点,我直接从前向后不可以嘛?<br>这里就先留个悬念,等我再写篇文章来解答</font></p><h1 id="AQS-两种资源共享模式"><a href="#AQS-两种资源共享模式" class="headerlink" title="AQS 两种资源共享模式"></a><font face="华文中宋" size="3">AQS 两种资源共享模式</font></h1><p><font face="华文中宋" size="3">资源有两种共享模式:</font></p><ul><li><font face="华文中宋" size="3">独占模式( Exclusive ):资源是独占的,也就是一次只能被一个线程占有,比如 ReentrantLock</font></li><li><font face="华文中宋" size="3">共享模式( Share ):同时可以被多个线程获取,具体的资源个数可以通过参数来确定,比如 Semaphore/CountDownLatch </font></li></ul><p><font face="华文中宋" size="3">这一点,在刚开始介绍的 Node 节点源码那部分应该就能看到了.之所以把这部分内容写在后面,是想回头写几篇文章去分析一下 ReentrantLock/Semaphore/CountDownLatch (如果我有时间 + 不偷懒的话</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;基本概念&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;AQS 是 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt; 的简称,翻译成中文就是 &lt;code&gt;抽象队列同步器&lt;/code&gt; ,这三个单词分开来看:&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]深入浅出 synchronized 与锁</title>
    <link href="https://www.dynamic-zheng.com/posts/c8ca8c17.html"/>
    <id>https://www.dynamic-zheng.com/posts/c8ca8c17.html</id>
    <published>2020-05-02T09:21:29.000Z</published>
    <updated>2020-05-02T09:34:14.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><font face="华文中宋" size="3">synchronized 关键字</font></h1><p><font face="华文中宋" size="3">说到锁,都会提 synchronized .这个英文单词儿啥意思呢?翻译成中文就是「同步」的意思<br>一般都是使用 synchronized 这个关键字来给一段代码或者一个方法上锁,使得这段代码或者方法,在同一个时刻只能有一个线程来执行它.<br><a id="more"></a><br>synchronized 相比于 volatile 来说,用的比较灵活,你可以在方法上使用,可以在静态方法上使用,也可以在代码块上使用.<br>关于 synchronized 这一块大概就说到这里,我想着重来说一下, synchronized 底层是怎么实现的</font></p><h2 id="JVM-是如何实现-synchronized-的"><a href="#JVM-是如何实现-synchronized-的" class="headerlink" title="JVM 是如何实现 synchronized 的?"></a><font face="华文中宋" size="3">JVM 是如何实现 synchronized 的?</font></h2><p><font face="华文中宋" size="3">我知道可以利用 synchronized 关键字来给程序进行加锁,但是它具体怎么实现的我不清楚呀,别急,咱们先来看个 demo :</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedDemo</span><span class="params">(Object lock)</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">lock.hashCode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面是我写的一个 demo ,然后进入到 class 文件所在的目录下,使用 <code>javap -v demo.class</code> 来看一下编译的字节码(在这里我截取了一部分):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synchronizedDemo</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">  descriptor: (Ljava/lang/Object;)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">2</span></span><br><span class="line">       <span class="number">0</span>: aload_1</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_2</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       <span class="number">4</span>: aload_1</span><br><span class="line">       5: invokevirtual #2                  // Method java/lang/Object.hashCode:()I</span><br><span class="line">       <span class="number">8</span>: pop</span><br><span class="line">       <span class="number">9</span>: aload_2</span><br><span class="line">      <span class="number">10</span>: monitorexit</span><br><span class="line">      <span class="number">11</span>: goto          <span class="number">19</span></span><br><span class="line">      <span class="number">14</span>: astore_3</span><br><span class="line">      <span class="number">15</span>: aload_2</span><br><span class="line">      <span class="number">16</span>: monitorexit</span><br><span class="line">      <span class="number">17</span>: aload_3</span><br><span class="line">      <span class="number">18</span>: athrow</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">11</span>    <span class="number">14</span>   any</span><br><span class="line">          <span class="number">14</span>    <span class="number">17</span>    <span class="number">14</span>   any</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">应该能够看到当程序声明 synchronized 代码块时,编译成的字节码会包含 monitorenter 和 monitorexit 指令,这两种指令会消耗操作数栈上的一个引用类型的元素(也就是 synchronized 关键字括号里面的引用),作为所要加锁解锁的锁对象.如果看的比较仔细的话,上面有一个 monitorenter 指令和两个 monitorexit 指令,这是 Java 虚拟机为了确保获得的锁不管是在正常执行路径,还是在异常执行路径上都能够解锁.</font></p><p><font face="华文中宋" size="3">关于 monitorenter 和 monitorexit ,可以理解为每个锁对象拥有一个锁计数器和一个指向持有该锁的线程指针:</font></p><ul><li><font face="华文中宋" size="3">当程序执行 monitorenter 时,如果目标锁对象的计数器为 0 ,说明这个时候它没有被其他线程所占有,此时如果有线程来请求使用, Java 虚拟机就会分配给该线程,并且把计数器的值加 1<ul><li><font face="华文中宋" size="3">目标锁对象计数器不为 0 时,如果锁对象持有的线程是当前线程, Java 虚拟机可以将其计数器加 1 ,如果不是呢?那很抱歉,就只能等待,等待持有线程释放掉</font></li></ul></font></li><li><font face="华文中宋" size="3">当执行 monitorexit 时, Java 虚拟机就将锁对象的计数器减 1 ,当计数器减到 0 时,说明这个锁就被释放掉了,此时如果有其他线程来请求,就可以请求成功</font></li></ul><p><font face="华文中宋" size="3">为什么采用这种方式呢?是为了允许同一个线程重复获取同一把锁.<br>比如,一个 Java 类中拥有好多个 synchronized 方法,那这些方法之间的相互调用,不管是直接的还是间接的,都会涉及到对同一把锁的重复加锁操作.这样去设计的话,就可以避免这种情况.</font></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a><font face="华文中宋" size="3">锁</font></h1><p><font face="华文中宋" size="3">在 Java 多线程中,所有的锁都是基于对象的.也就是说, Java 中的每一个对象都可以作为一个锁.你可能会有疑惑,不对呀,不是还有类锁嘛.但是 class 对象也是特殊的 Java 对象,所以呢,在 Java 中所有的锁都是基于对象的<br>在 Java6 之前,所有的锁都是”重量级”锁,重量级锁会带来一个问题,就是如果程序频繁获得锁释放锁,就会导致性能的极大消耗.为了优化这个问题,引入了”偏向锁”和”轻量级锁”的概念.所以在 Java6 及其以后的版本,一个对象有 4 种锁状态:无锁状态,偏向锁状态,轻量级锁状态,重量级锁状态.</font></p><p><font face="华文中宋" size="3">在 4 种锁状态中,无锁状态应该比较好理解,无锁就是没有锁,任何线程都可以尝试修改,所以这里就一笔带过了.</font></p><p><font face="华文中宋" size="3">随着竞争情况的出现,锁的升级非常容易发生,但是如果想要让锁降级,条件非常苛刻,有种你想来可以,但是想走不行的赶脚.</font></p><blockquote><p><font face="华文中宋" size="3">在这里啰嗦一句:很多文章说,锁如果升级之后是不能降级的,其实在 HotSpot JVM 中,是支持锁降级的</font></p><p><font face="华文中宋" size="3">锁降级发生在 Stop The World 期间,当 JVM 进入安全点的时候,会检查有没有闲置的锁,如果有就进行降级</font></p><p><font face="华文中宋" size="3">看到 Stop The World 和 安全点 可能有人比较懵,我这里简单说一下,具体还需要读者自己去探索一番.(因为这是 JVM 的内容,这篇文章的重点不是 JVM )</font></p><p><font face="华文中宋" size="3">在 Java 虚拟机里面,传统的垃圾回收算法采用的是一种简单粗暴的方式,就是 Stop-the-world ,而这个 Stop-the-world 就是通过安全点( safepoint )机制来实现的,安全点是什么意思呢?就是 Java 程序在执行本地代码时,如果这段代码不访问 Java 对象/调用 Java 方法/返回到原来的 Java 方法,那 Java 虚拟机的堆栈就不会发生改变,这就代表执行的这段本地代码可以作为一个安全点.当 Java 虚拟机收到 Stop-the-world 请求时,它会等所有的线程都到达安全点之后,才允许请求 Stop-the-world 的线程进行独占工作</font></p></blockquote><p><font face="华文中宋" size="3">接下来就介绍一下几种锁和锁升级</font></p><h2 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a><font face="华文中宋" size="3">Java 对象头</font></h2><p><font face="华文中宋" size="3">在刚开始就说了, Java 的锁都是基于对象的,那是怎么告诉程序我是个锁呢?就不得不来说, Java 对象头<br>每个 Java 对象都有对象头,如果是非数组类型,就用 2 个字宽来存储对象头,如果是数组,就用 3 个字宽来存储对象头.在 32 位处理器中,一个字宽是 32 位;在 64 位处理器中,字宽就是 64 位咯~对象头的内容就是下面这样:</font></p><table><thead><tr><th style="text-align:center">长度</th><th style="text-align:center">内容</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">32/64 bit</td><td style="text-align:center">Mark Word</td><td style="text-align:center">存储对象的 hashCode 或锁信息等</td></tr><tr><td style="text-align:center">32/64 bit</td><td style="text-align:center">Class Metadata Address</td><td style="text-align:center">存储到对象类型数据的指针</td></tr><tr><td style="text-align:center">32/64 bit</td><td style="text-align:center">Array length</td><td style="text-align:center">数组的长度(如果是数组)</td></tr></tbody></table><p><font face="华文中宋" size="3">咱们主要来看 Mark Word 的内容:</font></p><table><thead><tr><th style="text-align:center">锁状态</th><th style="text-align:center">29 bit/61 bit</th><th style="text-align:center">1 bit 是否是偏向锁</th><th style="text-align:center">2 bit 锁标志位</th></tr></thead><tbody><tr><td style="text-align:center">无锁</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">01</td></tr><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">线程 ID</td><td style="text-align:center">1</td><td style="text-align:center">01</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">指向栈中锁记录的指针</td><td style="text-align:center">此时这一位不用于标识偏向锁</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">指向互斥量(重量级锁)的指针</td><td style="text-align:center">此时这一位不用于标识偏向锁</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">GC 标记</td><td style="text-align:center"></td><td style="text-align:center">此时这一位不用于标识偏向锁</td><td style="text-align:center">11</td></tr></tbody></table><p><font face="华文中宋" size="3">从上面表格中,应该能够看到,是偏向锁时, <code>Mark Word</code> 存储的是偏向锁的线程 ID ;是轻量级锁时, <code>Mark Word</code> 存储的是指向线程栈中 <code>Lock Record</code> 的指针;是重量级锁时, <code>Mark Word</code> 存储的是指向堆中的 <code>monitor</code> 对象的指针</font></p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><font face="华文中宋" size="3">偏向锁</font></h2><p><font face="华文中宋" size="3">HotSpot 的作者经过大量的研究发现,在大多数情况下,<strong>锁不仅不存在多线程竞争,而且总是由同一线程多次获得</strong><br>基于此,就引入了偏向锁的概念</font></p><p><font face="华文中宋" size="3">所以啥是偏向锁呢?用大白话说就是,我现在给锁设置一个变量,当一个线程请求的时候,发现这个锁是 <code>true</code> ,也就是说这个时候没有所谓的资源竞争,那也不用走什么加锁/解锁的流程了,直接拿来用就行.但是如果这个锁是 <code>false</code> 的话,说明存在其他线程竞争资源,那咱们再走正规的流程</font></p><h3 id="看一下具体的实现原理"><a href="#看一下具体的实现原理" class="headerlink" title="看一下具体的实现原理:"></a><font face="华文中宋" size="3">看一下具体的实现原理:</font></h3><p><font face="华文中宋" size="3">当一个线程第一次进入同步块时,会在对象头和栈帧中的锁记录中存储锁偏向的线程 ID .当下次该线程进入这个同步块时,会检查锁的 Mark Word 里面存放的是不是自己的线程 ID.如果是,说明线程已经获得了锁,那么这个线程在进入和退出同步块时,都不需要花费 CAS 操作来加锁和解锁;如果不是,说明有另外一个线程来竞争这个偏向锁,这时就会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID .此时会有两种情况:</font></p><ul><li><font face="华文中宋" size="3">替换成功,说明之前的线程不存在了,那么 Mark Word 里面的线程 ID 为新线程的 ID ,锁不会升级,此时仍然为偏向锁</font></li><li><font face="华文中宋" size="3">替换失败,说明之前的线程仍然存在,那就暂停之前的线程,设置偏向锁标识为 0 ,并设置锁标志位为 00 ,升级为轻量级锁,按照轻量级锁的方式进行竞争锁</font></li></ul><h3 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a><font face="华文中宋" size="3">撤销偏向锁</font></h3><p><font face="华文中宋" size="3">偏向锁使用了一种等到竞争出现时才释放锁的机制.也就说,如果没有人来和我竞争锁的时候,那么这个锁就是我独有的,当其他线程尝试和我竞争偏向锁时,我会释放这个锁<br>在偏向锁向轻量级锁升级时,首先会暂停拥有偏向锁的线程,重置偏向锁标识,看起来这个过程挺简单的,但是开销是很大的,因为:</font></p><ul><li><font face="华文中宋" size="3">首先需要在一个安全点停止拥有锁的线程</font></li><li><font face="华文中宋" size="3">然后遍历线程栈,如果存在锁记录的话,就需要修复锁记录和 Mark Word ,变成无锁状态</font></li><li><font face="华文中宋" size="3">最后唤醒被停止的线程,把偏向锁升级成轻量级锁</font></li></ul><p><font face="华文中宋" size="3">你以为就是升级一个轻量级锁?  too young too simple<br>偏向锁向轻量级锁升级的过程中,是非常耗费资源的,如果应用程序中所有的锁通常都处于竞争状态,偏向锁此时就是一个累赘,此时就可以通过 JVM 参数关闭偏向锁: <code>-XX:-UseBiasedLocking=false</code> ,那么程序默认会进入轻量级锁状态<br>最后,来张图吧~</font></p><p><img src="/images/2020/偏向锁.jpg"></p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><font face="华文中宋" size="3">轻量级锁</font></h2><p><font face="华文中宋" size="3">如果多个线程在不同时段获取同一把锁,也就是不存在锁竞争的情况,那么 JVM 就会使用轻量级锁来避免线程的阻塞与唤醒</font></p><h3 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a><font face="华文中宋" size="3">轻量级锁加锁</font></h3><p><font face="华文中宋" size="3">JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间,称之为 Displaced Mark Word .如果一个线程获得锁的时候发现是轻量级锁,就会将锁的 Mark Word 复制到自己的 Displaced Mark Word 中.之后线程会尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针.<br>如果替换成功,当前线程获得锁,那么整个状态还是 <code>轻量级锁</code> 状态<br>如果替换失败了呢?说明 Mark Word 被替换成了其他线程的锁记录,那就尝试使用自旋来获取锁.(自旋是说,线程不断地去尝试获取锁,一般都是用循环来实现的)</font></p><p><font face="华文中宋" size="3">自旋是耗费 CPU 的,如果一直获取不到锁,线程就会一直自旋, CPU 那么宝贵的资源就这么被白白浪费了<br>解决这个问题最简单的办法就是指定自旋的次数,比如如果没有替换成功,那就循环 10 次,还没有获取到,那就进入阻塞状态<br>但是 JDK 采用了一个更加巧妙的方法—适应性自旋.就是说,如果这次线程自旋成功了,那我下次自旋次数更多一些,因为我这次自旋成功,说明我成功的概率还是挺大的,下次自旋次数就更多一些,那么如果自旋失败了,下次我自旋次数就减少一些,就比如,已经看到了失败的前兆,那我就先溜,而不是非要”不撞南墙不回头”</font></p><p><font face="华文中宋" size="3">自旋失败之后,线程就会阻塞,同时锁会升级成<strong>重量级锁</strong></font></p><h3 id="轻量级锁释放"><a href="#轻量级锁释放" class="headerlink" title="轻量级锁释放:"></a><font face="华文中宋" size="3">轻量级锁释放:</font></h3><p><font face="华文中宋" size="3">在释放锁时,当前线程会使用 CAS 操作将 Displaced Mark Word 中的内容复制到锁的 Mark Word 里面.如果没有发生竞争,这个复制的操作就会成功;如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁, CAS 操作就会失败,此时会释放锁同时唤醒被阻塞的过程</font></p><p><font face="华文中宋" size="3">同样,来一张图吧:</font></p><p><img src="/images/2020/轻量级锁及其膨胀.jpg"></p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><font face="华文中宋" size="3">重量级锁</font></h2><p><font face="华文中宋" size="3">重量级锁依赖于操作系统的互斥量( mutex )来实现.但是操作系统中线程间状态的转换需要相对比较长的时间(因为操作系统需要从用户态切换到内核态,这个切换成本很高),所以重量级锁效率很低,但是有一点就是,被阻塞的线程是不会消耗 CPU 的<br>每一个对象都可以当做一个锁,那么当多个线程同时请求某个对象锁时,它会怎么处理呢?<br>对象锁会设置集中状态来区分请求的线程:</font></p><blockquote><p><font face="华文中宋" size="3">Contention List:所有请求锁的线程将被首先放置到该竞争队列</font></p><p><font face="华文中宋" size="3">Entry List: Contention List 中那些有资格成为候选人的线程被移到 Entry List 中</font></p><p><font face="华文中宋" size="3">Wait Set:调用 wait 方法被阻塞的线程会被放置到 Wait Set 中</font></p><p><font face="华文中宋" size="3">OnDeck:任何时刻最多只能有一个线程正在竞争锁,该线程称为 OnDeck</font></p><p><font face="华文中宋" size="3">Owner:获得锁的线程称为 Owner</font></p><p><font face="华文中宋" size="3">!Owner:释放锁的线程</font></p></blockquote><p><font face="华文中宋" size="3">当一个线程尝试获得锁时,如果这个锁被占用,就会把该线程封装成一个 <code>ObjectWaiter</code> 对象插入到 Contention List 队列的队首,然后调用 <code>park</code> 函数挂起当前线程<br>当线程释放锁时,会从 Contention List 或者 Entry List 中挑选一个线程进行唤醒<br>如果线程在获得锁之后,调用了 <code>Object.wait</code> 方法,就会将该线程放入到 WaitSet 中,当被 <code>Object.notify</code> 唤醒后,会将线程从 WaitSet 移动到 Contention List 或者 Entry List 中.<br>但是,当调用一个锁对象的 <code>wait</code> 或 <code>notify</code> 方法时,<strong>如果当前锁的状态是偏向锁或轻量级锁,则会先膨胀成重量级锁</strong></font></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><font face="华文中宋" size="3">总结:</font></h2><p><font face="华文中宋" size="3">synchronized 关键字是通过 monitorenter 和 monitorexit 两种指令来保证锁的<br>当一个线程准备获取共享资源时:</font></p><ul><li><font face="华文中宋" size="3">首先检查 MarkWord 里面放的是不是自己的 ThreadID ,如果是,说明当前线程处于 “偏向锁”</font></li><li><font face="华文中宋" size="3">如果不是,锁升级,这时使用 CAS 操作来执行切换,新的线程根据 MarkWord 里面现有的 ThreadID 来通知之前的线程暂停,将 MarkWord 的内容置为空<br>然后,两个线程都将锁对象 HashCode 复制到自己新建的用于存储锁的记录空间中,接着开始通过 CAS 操作,把锁对象的 MarkWord 的内容修改为自己新建的记录空间地址,以这种方式竞争 MarkWord ,成功执行 CAS 的线程获得资源,失败的则进入自旋<ul><li><font face="华文中宋" size="3">自旋的线程在自旋过程中,如果成功获得资源(也就是之前获得资源的线程执行完毕,释放了共享资源),那么整个状态依然是 <code>轻量级锁</code> 的状态</font></li><li><font face="华文中宋" size="3">如果没有获得资源,就进入  <code>重量级锁</code> 的状态,此时,自旋的线程进行阻塞,等待之前线程执行完成并且唤醒自己</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">参考:</font></p><ul><li><font face="华文中宋" size="3">Java 并发编程的技术</font></li><li><font face="华文中宋" size="3">极客时间—深入拆解 Java 虚拟机</font></li></ul><p><font face="华文中宋" size="3">到这里,整篇文章的内容就算是结束了.<br>没想到这篇文章竟然被我写了有 5000 多字(我已经有些虚脱了<br>能够阅读到这里的各位,希望能够给你带来一些帮助<br>以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;synchronized-关键字&quot;&gt;&lt;a href=&quot;#synchronized-关键字&quot; class=&quot;headerlink&quot; title=&quot;synchronized 关键字&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;synchronized 关键字&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;说到锁,都会提 synchronized .这个英文单词儿啥意思呢?翻译成中文就是「同步」的意思&lt;br&gt;一般都是使用 synchronized 这个关键字来给一段代码或者一个方法上锁,使得这段代码或者方法,在同一个时刻只能有一个线程来执行它.&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]你确定你了解 volatile ?</title>
    <link href="https://www.dynamic-zheng.com/posts/6bdf9b1b.html"/>
    <id>https://www.dynamic-zheng.com/posts/6bdf9b1b.html</id>
    <published>2020-05-01T10:10:33.000Z</published>
    <updated>2020-05-01T10:13:46.986Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">学 Java 并发,过不去 volatile 和 synchronized ,既然过不去,那就不过了,踏踏实实把它搞懂,踩在脚下.<br><a id="more"></a><br>这篇文章先搞定 volatile ,后面我再写另外一篇文章关于 synchronized 和锁的.<br>以下,正文开始:</font></p><p><font face="华文中宋" size="3">在 Java 中, volatile 主要有两个功能:</font></p><ul><li><font face="华文中宋" size="3">保证变量的内存可见性</font></li><li><font face="华文中宋" size="3">禁止 volatile 变量与普通变量重排序</font></li></ul><p><font face="华文中宋" size="3">接下来一一来看这两个功能,以及是怎么实现的</font></p><h1 id="什么是内存可见性"><a href="#什么是内存可见性" class="headerlink" title="什么是内存可见性"></a><font face="华文中宋" size="3">什么是内存可见性</font></h1><p><font face="华文中宋" size="3">如果要谈 volatile 保证了变量的内存可见性,那就需要了解什么是内存可见性</font></p><blockquote><p><font face="华文中宋" size="3">所谓内存可见性是说,当一个线程对 <code>volatile</code> 修饰的变量进行<strong>写操作</strong>时, JMM 会立即将该线程对应的本地内存中的共享变量的值刷新到主内存中;当一个线程对 <code>volatile</code> 修饰的变量进行<strong>读操作</strong>时, JMM 会立即将该线程对应的本地内存设置为无效,然后从主内存中读取共享变量的值</font></p></blockquote><p><font face="华文中宋" size="3">在 JSR-133 之前的旧的 Java 内存模型中,是允许 volatile 变量与普通变量重排序的.<br>也就是说,虽然 volatile 变量能够保证内存可见性,但是可能程序执行的结果依旧不是你想要的.<br>如果直接使用锁的话,又会让整个程序变得比较重量级,基于以上考虑, JSR-133 专家组决定增强 volatile 的内存语义:<strong>严格限制编译器和处理器对 volatile 变量与普通变量的排序</strong></font></p><h1 id="如何禁止-volatile-变量与普通变量重排序"><a href="#如何禁止-volatile-变量与普通变量重排序" class="headerlink" title="如何禁止 volatile 变量与普通变量重排序"></a><font face="华文中宋" size="3">如何禁止 volatile 变量与普通变量重排序</font></h1><p><font face="华文中宋" size="3">俗话说,说得容易,做起来就比较难.定义了严格限制 volatile 变量与普通变量的排序,那是拿什么来做保证的呢? JVM 在处理器层面是通过<strong>内存屏障</strong>来实现的.</font></p><ul><li><font face="华文中宋" size="3">什么是内存屏障呢?从硬件层面来说,内存屏障分为两种:读屏障( Load Barrier )和写屏障( Store Barrier ).内存屏障有两个作用:<ul><li><font face="华文中宋" size="3">阻止屏障两侧的指令重排序</font></li><li><font face="华文中宋" size="3">强制把写缓冲区/高速缓存中的脏数据等写回主内存,或者让缓存中相应的数据失效.<br>这里的缓存主要是指: CPU 缓存,如 L1 , L2 等</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序.<br>在这里编译器选择了一个比较保守的 JMM 内存屏障插入策略,保守的好处就是,可以保证在任何处理器平台,任何程序中都能得到正确的 volatile 内存语义.这个保守策略就是( Load 代表读操作, Store 代表写操作):</font></p><ul><li><font face="华文中宋" size="3">在每个 volatile 写操作前,插入一个 StoreStore 屏障;<ul><li><font face="华文中宋" size="3">比如: <code>Store1 ; StoreStore ; Store2</code> 语句,在 Store2 及后续写入操作执行前,要保证 Store1 的写入操作对其他处理器可见</font></li></ul></font></li><li><font face="华文中宋" size="3">在每个 volatile 写操作后,插入一个 StoreLoad 屏障;<ul><li><font face="华文中宋" size="3">比如: <code>Store1 ; StoreLoad ; Load2</code> 语句,在 Load2 及后续所有读取操作之前,要保证 Store1 的写入对所有处理器可见</font></li></ul></font></li><li><font face="华文中宋" size="3">在每个 volatile 读操作后,插入一个 LoadLoad 屏障;<ul><li><font face="华文中宋" size="3">比如: <code>Load1 ; LoadLoad ; Load2</code> ,在 Load2 及后续读取操作要读取的数据被访问前,要保证 Load1 要读取的数据读取完毕</font></li></ul></font></li><li><font face="华文中宋" size="3">在每个 volatile 读操作后,再插入一个 LoadStore 屏障<ul><li><font face="华文中宋" size="3">比如: <code>Load1 ; LoadStore ; Store2</code> 在 Store2 及后续写入操作被刷出前,要保证 Load1 读取的数据读取完毕</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">是不是有点儿懵?别急,我这里画了两张图,可以看着理解一下</font></p><p><img src="/images/2020/volatile写.jpg"><br><img src="/images/2020/volatile读.jpg"></p><p><font face="华文中宋" size="3">写到这里了,就顺便介绍一下 volatile 和普通变量的重排序规则:</font></p><ul><li><font face="华文中宋" size="3">如果第一个操作是 volatile 读,那么不管第二个操作是什么,都不能重排序;</font></li><li><font face="华文中宋" size="3">如果第二个操作是 volatile 写,那么不管第一个操作是什么,都不能重排序;</font></li><li><font face="华文中宋" size="3">如果第一个操作是 volatile 写,第二个操作是 volatile 读,也不能重排序;</font></li></ul><p><font face="华文中宋" size="3">可以发现,针对 volatile 写操作来说,是比较严格的,但是如果第一个是普通变量的读,第二个是 volatile 的读,我可不可以重排序呢?可以</font></p><h1 id="volatile-怎么用"><a href="#volatile-怎么用" class="headerlink" title="volatile 怎么用"></a><font face="华文中宋" size="3">volatile 怎么用</font></h1><p><font face="华文中宋" size="3">看到这里,应该就能知道, volatile 保证了内存可见性以及禁止重排序.<br>在保证内存可见性这一点上,可以说 volatile 和锁有着相同的意义,所以 volatile 可以作为一个”轻量级”锁来使用.<br>volatile 的本质其实就是告诉 JVM ,我修饰的这个变量在寄存器中的值是不确定的,如果需要的话,不能直接从本地内存中读取,需要从主存中去拿,所以 volatile 它改变的只是变量的可见性,但是不保证原子性.<br>基于此,就需要搞清楚,在什么情况下使用 volatile 比较好.</font></p><p><font face="华文中宋" size="3">对于 volatile 关键字来说,当且仅当满足以下所有条件时,才可以使用:</font></p><ul><li><font face="华文中宋" size="3">对变量的写操作不依赖变量的当前值,或者确保只有单个线程更新变量的值</font></li><li><font face="华文中宋" size="3">变量没有包含在具有其他变量的不变式中</font></li></ul><p><font face="华文中宋" size="3">我觉得上面的条件,就是为了保证操作是原子性操作,因为 volatile 不保证原子性,那为了安全,就要保证你本身的操作就是原子性操作,相当于直接从源头上就把不是原子性操作给排除掉.<br>这样的话,就比较容易搞清楚 volatile 这个变量使用在什么场景下了:</font></p><ul><li><font face="华文中宋" size="3">用来标识状态,比如 <code>boolean flag</code> 这种</font></li><li><font face="华文中宋" size="3">一次性安全发布( one-time safe publication ):实现安全发布对象的一种技术就是将对象引用定义为 volatile 类型</font></li><li><font face="华文中宋" size="3">独立观察( independent observation):安全使用 volatile 的另一种简单模式是:定期”发布” 观察结果供程序内部使用.例如,假设有一种环境传感器能够感觉环境温度,一个后台线程可能会每隔几秒读取一次该传感器,并更新包含当前文档的 volatile 变量.然后,其他线程可以读取这个变量,从而随时能够看到最新的温度值</font></li></ul><p><font face="华文中宋" size="3">参考:<br>深入理解 JVM<br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">Java 理论与实践:正确使用 Volatile 变量</a><br><a href="https://www.jianshu.com/p/ef8de88b1343" target="_blank" rel="noopener">并发关键字 volatile（重排序和内存屏障）</a><br><a href="https://blog.csdn.net/hqq2023623/article/details/51013468" target="_blank" rel="noopener">JMM——volatile与内存屏障</a></font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;学 Java 并发,过不去 volatile 和 synchronized ,既然过不去,那就不过了,踏踏实实把它搞懂,踩在脚下.&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]为什么会有重排序?和 happens-before 有啥关系</title>
    <link href="https://www.dynamic-zheng.com/posts/e3a1cde0.html"/>
    <id>https://www.dynamic-zheng.com/posts/e3a1cde0.html</id>
    <published>2020-05-01T00:50:20.000Z</published>
    <updated>2020-05-01T00:53:47.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a><font face="华文中宋" size="3">举个例子</font></h1><a id="more"></a><p><font face="华文中宋" size="3">在讲重排序之前,先来看一个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> one = a;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> two = b;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">应该不难看出,在上面的例子中,我定义了两个共享变量 a 和 b ,以及两个方法.其中第一个方法是将局部变量 one 赋值为 a ,然后将 b 的值置为 1 .第二个方法则是将局部变量 two 赋值为 b ,然后将 a 的值置为 2 .<br>那么我在这里有个问题,  <code>( one , two )</code> 的值会是什么?</font></p><p><font face="华文中宋" size="3">你可能会不假思索的告诉我,不是 <code>( 0 , 1 )</code> 就是 <code>( 2 , 0 )</code> ,这需要看我的 main 方法先执行哪个 method 方法.<br>不错,如果这个程序跑在了单线程上面,这样回答一点儿毛病都没有.<br>但是,如果是在多线程环境下呢?</font></p><p><font face="华文中宋" size="3">假设,现在 <code>methodOne</code> 和 <code>methodTwo</code> 分别在两个不同的线程上执行,此时 Java 虚拟机在执行了任意一个方法的第一条赋值语句之后就切换线程,这个时候的 <code>( one , two )</code> 的值可能是 <code>( 0 , 0 )</code><br>看到这儿,有没有疑惑?为啥呢,怎么我写的程序好好的,到 Java 虚拟机这里了,它就变了呢?<br>就是因为在执行的过程中,发生了重排序.它可能是即时编译器的重排序,可能是处理器的乱序执行,或者是内存系统的重排序.<br>总之,在程序执行过程中,发生了重排序,然后得到的结果可能是 <code>( 0 , 0 )</code> 这种情况.</font></p><h1 id="为什么会重排序"><a href="#为什么会重排序" class="headerlink" title="为什么会重排序"></a><font face="华文中宋" size="3">为什么会重排序</font></h1><p><font face="华文中宋" size="3">看完上面,你可能会有疑问,为什么会有重排序呢?<br>我的程序按照我自己的逻辑写下来好好的没啥问题, Java 虚拟机为什么动我的程序逻辑?<br>你想想, CPU ,内存这些都是非常宝贵的资源, Java 虚拟机如果在重排序之后没啥效果,肯定也不会做这种费力不讨好的事情.<br>那么,重排序带来了什么好处呢?</font></p><h2 id="重排序使得程序的性能得以提高"><a href="#重排序使得程序的性能得以提高" class="headerlink" title="重排序使得程序的性能得以提高"></a><font face="华文中宋" size="3">重排序使得程序的性能得以提高</font></h2><p><font face="华文中宋" size="3">为了方便理解,我拿生活中的场景来举例子.<br>大早上起来,你会穿衣服,洗漱,做饭,吃饭对吧.那么在你起床之后,你是怎么做的呢?你是不是会在洗漱的时候,先把饭做上(比如让蒸蛋机帮你蒸个鸡蛋),然后呢等你洗漱完毕之后,就可以直接吃早饭了.<br>你为什么要这样做呢?还不是为了省时间,可以多睡那么一分钟,对不对.</font></p><p><font face="华文中宋" size="3">同样的道理, Java 虚拟机之所以要进行重排序就是为了提高程序的性能.你写的程序,简简单单一行代码,到底层可能需要使用不同的硬件,比如一个指令需要同时使用 CPU 和打印机设备,但是此时 CPU 的任务完成了,打印机的任务还没完成,这个时候怎么办呢?不让 CPU 执行接下来的指令吗? CPU 的时间那么宝贵,你不让它工作,确定不是在浪费它的生命?<br>所以为了提高利用率以及程序的性能, Java 虚拟机会在你这个指令还没完全执行完毕的时候,就去执行另外一个指令.这就是流水线技术<br>流水线最怕的是啥?是我执行着命令,执行着命令,突然中断了,恢复中断的成本是很大的,所以就要想尽办法,绞尽脑汁不要让中断的情况发生.</font></p><p><font face="华文中宋" size="3">即时编译器的重排序,处理器的乱序执行,以及内存系统的重排序的存在,都是为了减少中断.<br>到这里,你是不是对于 Java 虚拟机进行重排序这一点有了了解?</font></p><h1 id="重排序带来的问题"><a href="#重排序带来的问题" class="headerlink" title="重排序带来的问题"></a><font face="华文中宋" size="3">重排序带来的问题</font></h1><p><font face="华文中宋" size="3">回到文章刚开始举的那个例子,重排序提高了 CPU 的利用率没错,提高了程序性能没错,但是我的程序得到的结果可能是错误的啊,这是不是就有点儿得不偿失了?<br>因为<strong>重排序可以保证串行语义一致,但是没有义务保证多线程间的语义也一致</strong></font></p><p><font face="华文中宋" size="3">凡是问题,都有办法解决,要是没有,那就再想想.<br>它是怎么解决的呢?这就需要来说说,顺序一致性内存模型和 JMM ( Java Memory Model , Java 内存模型)</font></p><h1 id="顺序一致性内存模型与-JMM"><a href="#顺序一致性内存模型与-JMM" class="headerlink" title="顺序一致性内存模型与 JMM"></a><font face="华文中宋" size="3">顺序一致性内存模型与 JMM</font></h1><p><font face="华文中宋" size="3">要说数据一致性的话,就要说一说,数据竞争.<br>啥是数据竞争呢?在 Java 内存模型规范中给出了定义:</font></p><ul><li><font face="华文中宋" size="3">在一个线程中写一个变量</font></li><li><font face="华文中宋" size="3">在另外一个线程中读同一个变量</font></li><li><font face="华文中宋" size="3">写和读没有通过同步来排序</font></li></ul><p><font face="华文中宋" size="3">当代码中包含数据竞争时,程序的执行结果往往会超出你的想象,比如咱们刚开始说的那个例子,得到的结果可能是 <code>( 0 , 0 )</code> .但是如果一个多线程程序能够正确同步的话,那上面的结果就不会出现了.<br>Java 内存模型对于正确同步多线程程序的内存一致性做了下面的保证:</font></p><blockquote><p><font face="华文中宋" size="3"><strong>如果程序是正确同步的,程序的执行也会具有顺序一致性</strong>即,程序的执行结果与该程序在顺序一致性模型中执行的结果相同</font></p></blockquote><p><font face="华文中宋" size="3">这里面的同步包括了使用 <code>volatile</code> , <code>final</code> , <code>synchronized</code> 等关键字来实现多线程下的同步.那也就是说,如果没有正确使用这些同步, JMM 就不会有内存可见性的保证,这就会导致写的程序出错.</font></p><p><font face="华文中宋" size="3">顺序一致性内存模型是一个<strong>理想状态下的理论参考模型</strong>,它为程序员提供了特别强的内存可见性保证,顺序一致性模型有两大特性:</font></p><ul><li><font face="华文中宋" size="3">一个线程中的所有操作必须按照程序的顺序来执行(也就是按照写的代码的顺序来执行)</font></li><li><font face="华文中宋" size="3">不管程序是否同步,所有线程都只能看到一个单一的操作执行顺序.也就是说,在顺序一致性模型中,每个操作必须是原子性的,而且立刻对所有线程都是可见的.</font></li></ul><p><font face="华文中宋" size="3">上面说了,顺序一致性内存模型是一个理想状态下的理论参考模型,因为顺序一致性内存模型要求操作对所有线程都是可见,只是这一点就会让 Java 虚拟机的性能降低. JMM 就是在顺序一致性内存模型的基础上,做了一些优化:</font></p><ul><li><font face="华文中宋" size="3">针对同步的多线程程序来说,也就是临界区内的代码, JMM 允许发生重排序(但是不允许临界区内的代码”逃逸”到临界区之外,因为如果允许的话,就会破坏锁的内存语义)</font></li><li><font face="华文中宋" size="3">针对未同步的多线程程序来说, JMM 只提供最小安全性:线程读取到的值,要么是之前某个线程写入的值,要么是默认值,不会无中生有.</font></li></ul><p><font face="华文中宋" size="3">应该能够感觉到,相比于顺序一致性内存模型来说, JMM 给了编译器和处理器一些空间,允许它们发生重排序.<br>这时候就有冲突点了:程序员这边需要 JMM 提供一个强的内存模型来编写代码,也就是我代码写的顺序是什么样,那程序执行的时候就要是什么样;但是编译器和处理器则需要 JMM 对它们的约束越少越好,这样它们就可以尽可能多的去做优化,来提高性能<br>作为 JMM 这个中介者来说,既要满足程序员的需求,又要满足编译器和处理器的需求,那就需要在这两者之间找一个平衡点,让程序员写的代码能够产生他期望的结果,同时呢,也让编译器和处理器能够做一些优化<br>JMM 提出的解决方案就是:对于程序员,提供 happens-before 规则,这样就满足了程序员的需求 —&gt; 简单易懂,而且提供了足够强的内存可见性保证;对于编译器和处理器来说,只要不改变程序的执行结果(前提是正确同步了多线程程序),想怎么优化就怎么优化.</font></p><h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a><font face="华文中宋" size="3">happens-before</font></h1><p><font face="华文中宋" size="3">终于讲到了 happens-before .<br>先来看 happens-before 关系的定义:</font></p><ul><li><font face="华文中宋" size="3">如果一个操作 happens-before 另一个操作,那么第一个操作的执行结果就会对第二个操作可见</font></li><li><font face="华文中宋" size="3">两个操作之间如果存在 happens-before 关系,并不意味着 Java 平台的具体实现就必须按照 happens-before 关系指定的顺序来执行.如果重排序之后的执行结果,与按照 happens-before 关系来执行的结果一直,那么 JMM 也允许这样的重排序</font></li></ul><p><font face="华文中宋" size="3">看到这儿,你是不是觉得,这个怎么和 as-if-serial 语义一样呢.没错, happens-before 关系本质上和 as-if-serial 语义是一回事.<br>as-if-serial 语义保证的是单线程内重排序之后的执行结果和程序代码本身应该出现的结果是一致的, happens-before 关系保证的是正确同步的多线程程序的执行结果不会被重排序改变.<br>一句话来总结就是:如果操作 A happens-before 操作 B ,那么操作 A 在内存上所做的操作对操作 B 都是可见的,不管它们在不在一个线程.</font></p><p><font face="华文中宋" size="3">在 Java 中,对于 happens-before 关系,有以下规定:</font></p><ul><li><font face="华文中宋" size="3">程序顺序规则:一个线程中的每一个操作, happens-before 于该线程中的任意后续操作</font></li><li><font face="华文中宋" size="3">监视器锁规则:对一个锁的解锁, happens-before 于随后对这个锁的加锁</font></li><li><font face="华文中宋" size="3">volatile 变量规则:对一个 volatile 域的写, happens-before 与任意后续对这个 volatile 域的读</font></li><li><font face="华文中宋" size="3">传递性:如果 A happens-before B , 且 B happens-before C ,那么 A happens-before C</font></li><li><font face="华文中宋" size="3">start 规则:如果线程 A 执行操作 ThreadB.start() 启动线程 B ,那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作</font></li><li><font face="华文中宋" size="3">join 规则:如果线程 A 执行操作 ThreadB.join() 并成功返回,那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回.</font></li></ul><p><font face="华文中宋" size="3">写到这里,我感觉终于是写完这篇文章了,从为什么要重排序讲到 happens-before .</font></p><ul><li><font face="华文中宋" size="3">参考:<br>Java 并发编程的艺术</font></li></ul><p><font face="华文中宋" size="3">最后,真是太感谢您的阅读了哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;举个例子&quot;&gt;&lt;a href=&quot;#举个例子&quot; class=&quot;headerlink&quot; title=&quot;举个例子&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;举个例子&lt;/font&gt;&lt;/h1&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]带你从源码解读线程组( ThreadGroup )好不好</title>
    <link href="https://www.dynamic-zheng.com/posts/63ed9e38.html"/>
    <id>https://www.dynamic-zheng.com/posts/63ed9e38.html</id>
    <published>2020-04-25T05:45:04.000Z</published>
    <updated>2020-05-01T00:47:57.462Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadGroup-概念"><a href="#ThreadGroup-概念" class="headerlink" title="ThreadGroup 概念"></a><font face="华文中宋" size="3">ThreadGroup 概念</font></h1><a id="more"></a><p><font face="华文中宋" size="3">只是从英文名字上,也能看到这个概念的简单粗暴, ThreadGroup 就是线程组.<br>也就是说,每个 Thread 都能在一个 ThreadGroup 中找到.那么你可能会问了,我不存在于一个 ThreadGroup 不行?自己在程序里面一个人潇洒走天下,岂不是超级爽?<br>抱歉,此路不通.为啥呢?咱们来看源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">               what to do. */</span></span><br><span class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = security.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">               use the parent thread group. */</span></span><br><span class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">                g = parent.getThreadGroup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">我们能够看到,如果 g 为空,会做这样的处理</font></p><ul><li><font face="华文中宋" size="3">首先看 security 是否为空,如果不为空,直接使用 security 的线程组</font></li><li><font face="华文中宋" size="3">如果 security 是空的话,那么这个线程就获取当前线程所属的线程组<br>所以你想脱离组织自己玩?这种事情想都不要想.<br>操作系统怎么可能允许有逃离自己掌控之外的存在呢!</font></li></ul><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a><font face="华文中宋" size="3">优先级</font></h1><p><font face="华文中宋" size="3">OK ,咱们接下来谈另外一个问题.<br>一个 Thread 必然存在于一个 ThreadGroup , Thread 有自己的优先级, ThreadGroup 也有优先级,如果 Thread 的优先级大于 ThreadGroup 的优先级了,这个时候咋整呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="comment">// 如果设置的 priority 大于系统设置的最大值,或者小于系统设置的最小值</span></span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置线程的优先级大于线程组的优先级,则重置线程的优先级为线程组的优先级</span></span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">所以啊,优先级冲突了,两位也别吵吵, Thread 踏踏实实跟着 ThreadGroup 走才有肉吃不是~</font></p><h1 id="ThreadGroup-还可以做"><a href="#ThreadGroup-还可以做" class="headerlink" title="ThreadGroup 还可以做"></a><font face="华文中宋" size="3">ThreadGroup 还可以做</font></h1><p><font face="华文中宋" size="3">看完上面,你可能觉得,哦,原来线程组就是管线程的啊<br>你如果真的这么认为的话,我赶紧写写接下来的内容,把你的思绪拉一拉<br>线程组管理的可不单单是线程.<br>咱们看看源码里面,线程组的成员变量都有啥:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroup</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup parent;  <span class="comment">// 父 ThreadGroup</span></span><br><span class="line">    String name;  <span class="comment">// ThreadGroup 名称</span></span><br><span class="line">    <span class="keyword">int</span> maxPriority;  <span class="comment">// 线程最大优先级</span></span><br><span class="line">    <span class="keyword">boolean</span> destroyed;  <span class="comment">// 是否被销毁</span></span><br><span class="line">    <span class="keyword">boolean</span> daemon;  <span class="comment">// 是否守护线程</span></span><br><span class="line">    <span class="keyword">boolean</span> vmAllowSuspension;  <span class="comment">// 是否可以中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nUnstartedThreads = <span class="number">0</span>;  <span class="comment">// 还未启动的线程</span></span><br><span class="line">    <span class="keyword">int</span> nthreads;  <span class="comment">// ThreadGroup 中线程数目</span></span><br><span class="line">    Thread threads[];  <span class="comment">// ThreadGroup 中的线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ngroups;  <span class="comment">// 线程组数目</span></span><br><span class="line">    ThreadGroup groups[];  <span class="comment">// 线程组数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">吼,原来线程组里面还可以有线程组,不单单是有线程,原来还可以控制线程优先级,还可以决定是否销毁线程或者守护线程,或者中断线程.</font></p><p><font face="华文中宋" size="3">到这里,咱们来总结一下:</font></p><ul><li><font face="华文中宋" size="3">线程组是一个父子结构,一个线程组可以属于其他线程组,也可以拥有自己的子线程组,如果你一直向上追溯的话,会发现所有的线程组都在一个根线程组里面— System 线程组</font></li><li><font face="华文中宋" size="3">线程组的出现可不是为耍酷用的,它是为了更方便的管理线程而存在的.比如设置线程最大优先级,销毁线程等等</font></li></ul><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ThreadGroup-概念&quot;&gt;&lt;a href=&quot;#ThreadGroup-概念&quot; class=&quot;headerlink&quot; title=&quot;ThreadGroup 概念&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;ThreadGroup 概念&lt;/font&gt;&lt;/h1&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]16 你是不是和我一样,不知道图这种数据结构怎么用?</title>
    <link href="https://www.dynamic-zheng.com/posts/1eb1a8ac.html"/>
    <id>https://www.dynamic-zheng.com/posts/1eb1a8ac.html</id>
    <published>2020-04-18T01:05:35.000Z</published>
    <updated>2020-04-18T01:32:25.910Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">你是不是和我一样,在学习数据结构与算法时,了解了一下图这种数据结构之后,根本不知道它的用武之地在哪里?<br>在我查了资料之后,现在我可以跟你讲讲,图可以这么用!<br><a id="more"></a></font></p><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a><font face="华文中宋" size="3">概念介绍</font></h1><p><font face="华文中宋" size="3">先来了解一下什么是图.<br>图,是一种非线性表数据结构.<br>那么你可能会问了,什么是线性表结构哇,我怎么区别一种数据结构是线性的,还是非线性的呢.<br>哈哈,还好我机智,在这篇文章之前就写了一篇文章来介绍,如果还有疑问,楼上雅座请: <a href="https://www.dynamic-zheng.com/posts/d42777bf.html">[数据结构与算法]14 搞不懂线性结构,非线性结构?</a></font></p><p><font face="华文中宋" size="3">在图中元素叫做顶点( vertex ),图中的一个顶点可以和其他任意顶点建立连接关系,这种建立的关系叫做边( edge )</font></p><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a><font face="华文中宋" size="3">无向图</font></h1><p><img src="/images/2020/undirected-graph.jpg"></p><p><font face="华文中宋" size="3">上面给出的是无向图.看到这里你可能就觉得比较疑惑,这个无向图看起来没啥呀,怎么会有这种数据结构呢?<br>不知道你是怎么想的,我刚开始学的时候就有这种疑问,这是什么神仙数据结构哇,还会有应用场景?<br><img src="/images/2020/真香警告.jpg"></font></p><p><font face="华文中宋" size="3">既然有疑惑,那就给个应用场景:<br>假设,现在你和我是微信好友,那是不是应该你的好友列表里面有我,我的好友里面有你,这样咱们才是好友对不对~<br>那在数据库中如何表示呢?吼~这个时候无向图就登场了<br>你和我是微信好友,那就在咱俩之间来条线,表示咱俩之间有关系,一条线就解决了问题,真是完美至极啊<br>假设,(怎么又是假设,哈哈哈)上图中表示的就是 A,B,C,D,E,F 之间的关系,那你可能就发现问题了,有的顶点线比较多,比如 D 有四条线,有的就相对少一些,比如 B 有两条线.这些线就表示顶点的度( degree ).这个概念有啥用?<br>能一眼看出来谁的好友多!那这个功能有啥用?(好吧,这个功能好像是有点儿鸡肋,不过也算是一个应用场景</font></p><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a><font face="华文中宋" size="3">有向图</font></h1><p><font face="华文中宋" size="3">看到上面的无向图,基础不错的小伙伴肯定会说了,我还知道有向图呢!<br>呦呵,不错,有向图就是下面这个样子:<br><img src="/images/2020/directed-graph.jpg"></font></p><p><font face="华文中宋" size="3">在无向图中,咱们知道一个顶点有多少条边,就说它的度为多少.<br>在有向图中呢,有指向顶点的,也有从顶点指出去的,基于无向图的概念,咱们把从这个顶点指出去的边称为出度,指向该顶点的边称为入度.<br>那么有向图会应用在哪些场景呢?微信好友这个场景是不太可以了<br>那么微博呢?<br>微博和微信有什么不一样呢?微信是你和我是好友,那么咱们的好友列表里一定是要有彼此的,拉黑或者删除彼此了,那就不能互相发送消息了.<br>但是微博呢?你关注了我,并不代表我就要关注你对吧?看到这里有没有一种豁然开朗的感觉~<br>那么我关注了多少人就是出度,多少人关注了我就是入度.<br>这样带入理解是不是会比较好一点儿?(我可真是个天才,哈哈哈</font></p><h1 id="带权图"><a href="#带权图" class="headerlink" title="带权图"></a><font face="华文中宋" size="3">带权图</font></h1><p><font face="华文中宋" size="3">看完了无向图,有向图,相信就有人说,我还见过带权图!(陈独秀给我坐下!<br>带权图长啥样呢?就下面这个样子:<br><img src="/images/2020/weighted-graph.jpg"></font></p><p><font face="华文中宋" size="3">懵逼了,这每条边上的数字是个什么鬼呦<br>别急,咱们来个场景:大家都玩 QQ 嘛?(别跟我说不玩,配合一下嘛…<br>玩 QQ 的话,一定知道有 QQ 空间,然后空间里面有个「谁在意我」「我在意谁」的功能,就是下图:<br><img src="/images/2020/QQ.jpg"></font></p><p><font face="华文中宋" size="3">那么有没有好奇过呢? QQ 怎么知道我在意谁,谁在意我呢?<br>就是通过带权图哇<br>你访问了一个人的空间,这条边的权重就增加一点儿;别人访问了你的空间,那这条边的权重就增加一点儿;这段时间你们两个人聊天聊得比较频繁,来个小火花,顺便在你们两者之间的边权重增加一点儿.然后根据这些边的权重从大到小排序就得出了「谁在意我」「我在意谁」</font></p><p><font face="华文中宋" size="3">到这里,上面的一切理解都还 OK ?<br>那咱们继续.图是怎么表示的呢?<br>图这种数据结构,再怎么画顶点,画边,到最后在物理结构上是怎么存储的呢?<br>别急,你所疑惑的,我都帮你想到了</font></p><h1 id="图的存储方法"><a href="#图的存储方法" class="headerlink" title="图的存储方法"></a><font face="华文中宋" size="3">图的存储方法</font></h1><p><font face="华文中宋" size="3">图的存储方法主要有以下两种:</font></p><ul><li><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a><font face="华文中宋" size="3">邻接矩阵</font></h2><font face="华文中宋" size="3">邻接矩阵的底层依赖一个二维数组.对于无向图来说,如果 i 与 j 之间有边,那就将 A[i][j] 和 A[j][i] 标记为 1 ;对于无向图来说,如果 i 指向 j ,那么 A[i][j] 值为 1 ,如果 j 指向 i ,那么 A[j][i] 值为 1 ;对于带权图来说, A[i][j] 存储的值就不是 1 了,而是对应的权重值.所以这是图最直观的一种存储方法.<br>啥,你跟我说这还不直观?该不会是没有看下图吧:<br><img src="/images/2020/adjacency-matrix.jpg"><br><font face="华文中宋" size="3">但是你发现问题了嘛,这样看起来确实是直观了很多,但是很浪费空间有没有!比如无向图,如果 A[i][j] 为 1 ,那么 A[j][i] 肯定也是 1 ,多存储 A[j][i] 根本没啥必要.就像买东西,明明一块钱能买到的东西,为啥非要花两块钱?<br>所以如果使用邻接矩阵来表示的话,一定要清楚它的缺点.</font></font></li></ul><p><font face="华文中宋" size="3">但这并不是说,使用邻接矩阵来存储就没啥优点.这天底下哪儿有那么绝对的事情呢.<br>首先,邻接矩阵的存储方式简单,直接,所以当我们需要获取两个顶点之间的关系时,相信我没有比这种存储结构更高效的了.<br>还有就是使用邻接矩阵存储图的另外一个优点就是方便计算,因为可以将很多图的运算转换成矩阵之间的运算.</font></p><ul><li><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a><font face="华文中宋" size="3">邻接表</font></h2><font face="华文中宋" size="3">先来看图:<br><img src="/images/2020/adjacency-list.jpg"><br><font face="华文中宋" size="3">乍一看,这不是散列表嘛!每个顶点对应一条链表,链表中存储的是与这个顶点相连接的其他顶点.<br>嘿嘿,直觉超棒!</font></font></li></ul><p><font face="华文中宋" size="3">如果你对散列表熟悉的话,应该知道,在散列表中,如果链太长了,会导致冲突概率增大,复杂度也蹭的一下升高.而且吧,链表的存储方式你也知道,不是连续的,所以相对于数组来说, CPU 读取就会慢一些,相对于邻接矩阵的存储方式,在邻接表中查询两个顶点之间的关系就没那么高效了.<br>所以在实际开发中要注意遇到这种情况该如何处理,或者在刚开始的时候就直接设计好实现方式.比如可以将邻接表中的链表改为平衡二叉树,或者红黑树.</font></p><p><font face="华文中宋" size="3">我觉得对于数据结构来说,没有最好的,只有最合适的~</font></p><p><font face="华文中宋" size="3">参考</font></p><ul><li><font face="华文中宋" size="3">极客时间—&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;你是不是和我一样,在学习数据结构与算法时,了解了一下图这种数据结构之后,根本不知道它的用武之地在哪里?&lt;br&gt;在我查了资料之后,现在我可以跟你讲讲,图可以这么用!&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]15 两行代码就可以搞定求众数,但还有更巧的</title>
    <link href="https://www.dynamic-zheng.com/posts/de95c539.html"/>
    <id>https://www.dynamic-zheng.com/posts/de95c539.html</id>
    <published>2020-04-11T23:38:17.000Z</published>
    <updated>2020-04-11T23:40:40.369Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">这个周末刷了几道算法题,把其中一个比较不错的分享给你~<br><a id="more"></a></font></p><blockquote><p> 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br> 示例 1:<br> 输入: [3,2,3]<br> 输出: 3<br> 示例 2:<br> 输入: [2,2,1,1,1,2,2]<br> 输出: 2</p></blockquote><p><font face="华文中宋" size="3">哦,原来是求众数,注意一下哈,这里的众数是指”在数组中出现次数大于 ⌊ n/2 ⌋ 的元素”,不要问我为什么要你们注意一下这个条件,因为我钻牛角尖了!</font></p><p><font face="华文中宋" size="3">拿到这个题目,我的第一反应就是,那我给这个数组排个序然后取中间的值不就得了?<br>所以代码就只有两行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line">return nums[nums.length &gt;&gt; 1];</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">写完程序运行,一点儿毛病都没有,简简单单两行代码就搞定,那一刻我觉得我就是个天才!<br>后来梦醒了,冷静分析了一下,我去这样的代码简单是简单,但是时间复杂度是 O(nlogn) ,空间复杂度是 O(logn)<br>所以有没有更好的解决方案呢?能让它的时间复杂度和空间复杂度都降下来<br>必须得有哇!要不然我写这篇文章是为了啥<br>这种比较好的解决方案就是摩尔投票法</font></p><p><font face="华文中宋" size="3">这个方法理解起来有点儿绕,我先来讲讲,这一块儿看懂了,咱们再往下走<br>先回到现实生活中,投票的时候咱们是怎么投的呢?大家每个人都选一个人,然后开始拆开纸团瞅瞅选的是谁,刚开始默认大家都是 0 票,然后纸条上投的是谁,这个人就多一票,最后看谁的票数比较多.<br>回到咱们这个题目,既然是众数,而且出现的次数大于 ⌊ n/2 ⌋ ,那我们可以假设一个数就是要求的众数,同时设置这个数字出现的次数为 0 ,然后和接下来的数字进行比较,如果一样呢,咱们把这个数字出现的次数加上 1 ,如果不一样,就让次数减 1 ,当这个值减到 0 时,说明刚开始假设的数字不是众数,那就换当前的这个数字,继续循环<br>这样最后这个数字出现的次数一定是大于等于 0 的,要不然就不符合 <code>出现的次数大于 ⌊ n/2 ⌋</code> 这个题意了<br>最后,将真正的众数返回即可<br>具体代码可见下面:</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int count = 0 ;</span><br><span class="line">Integer candidate = null;</span><br><span class="line"></span><br><span class="line">    for(int num : nums)&#123;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">        &#125;</span><br><span class="line">        count += ( num == candidate ) ? 1 : -1 ;</span><br><span class="line">    &#125;</span><br><span class="line">return candidate;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">分析一下,这样实现的时间复杂度是 O(n) ,空间复杂度是 O(1)<br>和刚开始使用的方法相比,好了许多</font></p><p><font face="华文中宋" size="3">你有没有更巧妙的方法实现,欢迎评论区和我交流哇<br>最后,感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;这个周末刷了几道算法题,把其中一个比较不错的分享给你~&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]14 搞不懂线性结构,非线性结构?</title>
    <link href="https://www.dynamic-zheng.com/posts/d42777bf.html"/>
    <id>https://www.dynamic-zheng.com/posts/d42777bf.html</id>
    <published>2020-04-05T02:46:43.000Z</published>
    <updated>2020-04-05T02:47:47.371Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在前面文章中介绍的数组,栈,队列这种都是线性结构,在接下来的文章中,会介绍图,这是一种非线性结构.<br>朋友,你是不是一脸问号?啥是线性结构,什么又是非线性结构呢?我怎么区别这两者呢.<br>别慌,一点点来看.<br><a id="more"></a></font></p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a><font face="华文中宋" size="3">线性结构</font></h1><p><font face="华文中宋" size="3">我在学习知识的时候,喜欢和以前的知识联系起来.<br>线性结构,我就想到了在学数学的时候,常说的线性相关,或者说这两个变量之间呈线性关系.<br>那么,在数学的定义上,什么是线性关系呢?<br>我就直接把维基百科的定义搬过来了,链接在这儿: <a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E9%97%9C%E4%BF%82" target="_blank" rel="noopener">线性关系</a></font></p><blockquote><p><font face="华文中宋" size="3"> 在现代学术界中，线性关系一词存在 2 种不同的含义。其一，若某数学函数或数量关系的函数图形呈现为一条直线或线段，那么这种关系就是一种线性的关系。其二，在代数学和数学分析学中，如果一种运算同时满足特定的“加性”和“齐性”，则称这种运算是线性的。</font></p></blockquote><p><font face="华文中宋" size="3">咱们着重看第一个含义,和数学上面的定义差不多,大概意思就是 y 和 x 的关系在图中表示为一条直线或线段,比如 y=x ,那么这种关系我们就可以称之为是线性关系.<br>OK ,那 y=x 有什么特殊之处呢?是不是每一个 x 的取值,都唯一对应一个 y 值?<br>Nice !能够想到这一点,就触及到了线性结构的本质,即:数据元素之间存在着”一对一”的线性关系的数据结构就称为 线性结构.</font></p><p><font face="华文中宋" size="3">了解本质之后,咱们应该就很好理解了,像: 线性表,栈,队列,双队列 这种都是线性结构.</font></p><h1 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a><font face="华文中宋" size="3">非线性结构</font></h1><p><font face="华文中宋" size="3">在了解线性结构之后,再来理解非线性结构就好说了.<br>既然线性结构是一对一的关系,那么非线性结构就存在不是一对一的关系了呗,比如一对多?<br>恭喜你,答对了!<br>那么我们常见的: 二维数组,多维数组,树,图 就都是非线性结构了.</font></p><p><font face="华文中宋" size="3">以上就是想要分享的内容了<br>最近感觉自己写文章遇到了瓶颈一般,总是觉得没有写出自己想要的效果<br>关于我的文章,欢迎各位留言和我交流哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在前面文章中介绍的数组,栈,队列这种都是线性结构,在接下来的文章中,会介绍图,这是一种非线性结构.&lt;br&gt;朋友,你是不是一脸问号?啥是线性结构,什么又是非线性结构呢?我怎么区别这两者呢.&lt;br&gt;别慌,一点点来看.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
