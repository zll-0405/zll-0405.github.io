<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑璐璐|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dynamic-zheng.com/"/>
  <updated>2020-04-18T01:32:25.910Z</updated>
  <id>https://www.dynamic-zheng.com/</id>
  
  <author>
    <name>郑璐璐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[数据结构与算法]16 你是不是和我一样,不知道图这种数据结构怎么用?</title>
    <link href="https://www.dynamic-zheng.com/posts/1eb1a8ac.html"/>
    <id>https://www.dynamic-zheng.com/posts/1eb1a8ac.html</id>
    <published>2020-04-18T01:05:35.000Z</published>
    <updated>2020-04-18T01:32:25.910Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">你是不是和我一样,在学习数据结构与算法时,了解了一下图这种数据结构之后,根本不知道它的用武之地在哪里?<br>在我查了资料之后,现在我可以跟你讲讲,图可以这么用!<br><a id="more"></a></font></p><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a><font face="华文中宋" size="3">概念介绍</font></h1><p><font face="华文中宋" size="3">先来了解一下什么是图.<br>图,是一种非线性表数据结构.<br>那么你可能会问了,什么是线性表结构哇,我怎么区别一种数据结构是线性的,还是非线性的呢.<br>哈哈,还好我机智,在这篇文章之前就写了一篇文章来介绍,如果还有疑问,楼上雅座请: <a href="https://www.dynamic-zheng.com/posts/d42777bf.html">[数据结构与算法]14 搞不懂线性结构,非线性结构?</a></font></p><p><font face="华文中宋" size="3">在图中元素叫做顶点( vertex ),图中的一个顶点可以和其他任意顶点建立连接关系,这种建立的关系叫做边( edge )</font></p><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a><font face="华文中宋" size="3">无向图</font></h1><p><img src="/images/2020/undirected-graph.jpg"></p><p><font face="华文中宋" size="3">上面给出的是无向图.看到这里你可能就觉得比较疑惑,这个无向图看起来没啥呀,怎么会有这种数据结构呢?<br>不知道你是怎么想的,我刚开始学的时候就有这种疑问,这是什么神仙数据结构哇,还会有应用场景?<br><img src="/images/2020/真香警告.jpg"></font></p><p><font face="华文中宋" size="3">既然有疑惑,那就给个应用场景:<br>假设,现在你和我是微信好友,那是不是应该你的好友列表里面有我,我的好友里面有你,这样咱们才是好友对不对~<br>那在数据库中如何表示呢?吼~这个时候无向图就登场了<br>你和我是微信好友,那就在咱俩之间来条线,表示咱俩之间有关系,一条线就解决了问题,真是完美至极啊<br>假设,(怎么又是假设,哈哈哈)上图中表示的就是 A,B,C,D,E,F 之间的关系,那你可能就发现问题了,有的顶点线比较多,比如 D 有四条线,有的就相对少一些,比如 B 有两条线.这些线就表示顶点的度( degree ).这个概念有啥用?<br>能一眼看出来谁的好友多!那这个功能有啥用?(好吧,这个功能好像是有点儿鸡肋,不过也算是一个应用场景</font></p><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a><font face="华文中宋" size="3">有向图</font></h1><p><font face="华文中宋" size="3">看到上面的无向图,基础不错的小伙伴肯定会说了,我还知道有向图呢!<br>呦呵,不错,有向图就是下面这个样子:<br><img src="/images/2020/directed-graph.jpg"></font></p><p><font face="华文中宋" size="3">在无向图中,咱们知道一个顶点有多少条边,就说它的度为多少.<br>在有向图中呢,有指向顶点的,也有从顶点指出去的,基于无向图的概念,咱们把从这个顶点指出去的边称为出度,指向该顶点的边称为入度.<br>那么有向图会应用在哪些场景呢?微信好友这个场景是不太可以了<br>那么微博呢?<br>微博和微信有什么不一样呢?微信是你和我是好友,那么咱们的好友列表里一定是要有彼此的,拉黑或者删除彼此了,那就不能互相发送消息了.<br>但是微博呢?你关注了我,并不代表我就要关注你对吧?看到这里有没有一种豁然开朗的感觉~<br>那么我关注了多少人就是出度,多少人关注了我就是入度.<br>这样带入理解是不是会比较好一点儿?(我可真是个天才,哈哈哈</font></p><h1 id="带权图"><a href="#带权图" class="headerlink" title="带权图"></a><font face="华文中宋" size="3">带权图</font></h1><p><font face="华文中宋" size="3">看完了无向图,有向图,相信就有人说,我还见过带权图!(陈独秀给我坐下!<br>带权图长啥样呢?就下面这个样子:<br><img src="/images/2020/weighted-graph.jpg"></font></p><p><font face="华文中宋" size="3">懵逼了,这每条边上的数字是个什么鬼呦<br>别急,咱们来个场景:大家都玩 QQ 嘛?(别跟我说不玩,配合一下嘛…<br>玩 QQ 的话,一定知道有 QQ 空间,然后空间里面有个「谁在意我」「我在意谁」的功能,就是下图:<br><img src="/images/2020/QQ.jpg"></font></p><p><font face="华文中宋" size="3">那么有没有好奇过呢? QQ 怎么知道我在意谁,谁在意我呢?<br>就是通过带权图哇<br>你访问了一个人的空间,这条边的权重就增加一点儿;别人访问了你的空间,那这条边的权重就增加一点儿;这段时间你们两个人聊天聊得比较频繁,来个小火花,顺便在你们两者之间的边权重增加一点儿.然后根据这些边的权重从大到小排序就得出了「谁在意我」「我在意谁」</font></p><p><font face="华文中宋" size="3">到这里,上面的一切理解都还 OK ?<br>那咱们继续.图是怎么表示的呢?<br>图这种数据结构,再怎么画顶点,画边,到最后在物理结构上是怎么存储的呢?<br>别急,你所疑惑的,我都帮你想到了</font></p><h1 id="图的存储方法"><a href="#图的存储方法" class="headerlink" title="图的存储方法"></a><font face="华文中宋" size="3">图的存储方法</font></h1><p><font face="华文中宋" size="3">图的存储方法主要有以下两种:</font></p><ul><li><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a><font face="华文中宋" size="3">邻接矩阵</font></h2><font face="华文中宋" size="3">邻接矩阵的底层依赖一个二维数组.对于无向图来说,如果 i 与 j 之间有边,那就将 A[i][j] 和 A[j][i] 标记为 1 ;对于无向图来说,如果 i 指向 j ,那么 A[i][j] 值为 1 ,如果 j 指向 i ,那么 A[j][i] 值为 1 ;对于带权图来说, A[i][j] 存储的值就不是 1 了,而是对应的权重值.所以这是图最直观的一种存储方法.<br>啥,你跟我说这还不直观?该不会是没有看下图吧:<br><img src="/images/2020/adjacency-matrix.jpg"><br><font face="华文中宋" size="3">但是你发现问题了嘛,这样看起来确实是直观了很多,但是很浪费空间有没有!比如无向图,如果 A[i][j] 为 1 ,那么 A[j][i] 肯定也是 1 ,多存储 A[j][i] 根本没啥必要.就像买东西,明明一块钱能买到的东西,为啥非要花两块钱?<br>所以如果使用邻接矩阵来表示的话,一定要清楚它的缺点.</font></font></li></ul><p><font face="华文中宋" size="3">但这并不是说,使用邻接矩阵来存储就没啥优点.这天底下哪儿有那么绝对的事情呢.<br>首先,邻接矩阵的存储方式简单,直接,所以当我们需要获取两个顶点之间的关系时,相信我没有比这种存储结构更高效的了.<br>还有就是使用邻接矩阵存储图的另外一个优点就是方便计算,因为可以将很多图的运算转换成矩阵之间的运算.</font></p><ul><li><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a><font face="华文中宋" size="3">邻接表</font></h2><font face="华文中宋" size="3">先来看图:<br><img src="/images/2020/adjacency-list.jpg"><br><font face="华文中宋" size="3">乍一看,这不是散列表嘛!每个顶点对应一条链表,链表中存储的是与这个顶点相连接的其他顶点.<br>嘿嘿,直觉超棒!</font></font></li></ul><p><font face="华文中宋" size="3">如果你对散列表熟悉的话,应该知道,在散列表中,如果链太长了,会导致冲突概率增大,复杂度也蹭的一下升高.而且吧,链表的存储方式你也知道,不是连续的,所以相对于数组来说, CPU 读取就会慢一些,相对于邻接矩阵的存储方式,在邻接表中查询两个顶点之间的关系就没那么高效了.<br>所以在实际开发中要注意遇到这种情况该如何处理,或者在刚开始的时候就直接设计好实现方式.比如可以将邻接表中的链表改为平衡二叉树,或者红黑树.</font></p><p><font face="华文中宋" size="3">我觉得对于数据结构来说,没有最好的,只有最合适的~</font></p><p><font face="华文中宋" size="3">参考</font></p><ul><li><font face="华文中宋" size="3">极客时间—&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;你是不是和我一样,在学习数据结构与算法时,了解了一下图这种数据结构之后,根本不知道它的用武之地在哪里?&lt;br&gt;在我查了资料之后,现在我可以跟你讲讲,图可以这么用!&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]15 两行代码就可以搞定求众数,但还有更巧的</title>
    <link href="https://www.dynamic-zheng.com/posts/de95c539.html"/>
    <id>https://www.dynamic-zheng.com/posts/de95c539.html</id>
    <published>2020-04-11T23:38:17.000Z</published>
    <updated>2020-04-11T23:40:40.369Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">这个周末刷了几道算法题,把其中一个比较不错的分享给你~<br><a id="more"></a></font></p><blockquote><p> 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br> 示例 1:<br> 输入: [3,2,3]<br> 输出: 3<br> 示例 2:<br> 输入: [2,2,1,1,1,2,2]<br> 输出: 2</p></blockquote><p><font face="华文中宋" size="3">哦,原来是求众数,注意一下哈,这里的众数是指”在数组中出现次数大于 ⌊ n/2 ⌋ 的元素”,不要问我为什么要你们注意一下这个条件,因为我钻牛角尖了!</font></p><p><font face="华文中宋" size="3">拿到这个题目,我的第一反应就是,那我给这个数组排个序然后取中间的值不就得了?<br>所以代码就只有两行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line">return nums[nums.length &gt;&gt; 1];</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">写完程序运行,一点儿毛病都没有,简简单单两行代码就搞定,那一刻我觉得我就是个天才!<br>后来梦醒了,冷静分析了一下,我去这样的代码简单是简单,但是时间复杂度是 O(nlogn) ,空间复杂度是 O(logn)<br>所以有没有更好的解决方案呢?能让它的时间复杂度和空间复杂度都降下来<br>必须得有哇!要不然我写这篇文章是为了啥<br>这种比较好的解决方案就是摩尔投票法</font></p><p><font face="华文中宋" size="3">这个方法理解起来有点儿绕,我先来讲讲,这一块儿看懂了,咱们再往下走<br>先回到现实生活中,投票的时候咱们是怎么投的呢?大家每个人都选一个人,然后开始拆开纸团瞅瞅选的是谁,刚开始默认大家都是 0 票,然后纸条上投的是谁,这个人就多一票,最后看谁的票数比较多.<br>回到咱们这个题目,既然是众数,而且出现的次数大于 ⌊ n/2 ⌋ ,那我们可以假设一个数就是要求的众数,同时设置这个数字出现的次数为 0 ,然后和接下来的数字进行比较,如果一样呢,咱们把这个数字出现的次数加上 1 ,如果不一样,就让次数减 1 ,当这个值减到 0 时,说明刚开始假设的数字不是众数,那就换当前的这个数字,继续循环<br>这样最后这个数字出现的次数一定是大于等于 0 的,要不然就不符合 <code>出现的次数大于 ⌊ n/2 ⌋</code> 这个题意了<br>最后,将真正的众数返回即可<br>具体代码可见下面:</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int count = 0 ;</span><br><span class="line">Integer candidate = null;</span><br><span class="line"></span><br><span class="line">    for(int num : nums)&#123;</span><br><span class="line">        if (count == 0)&#123;</span><br><span class="line">            candidate = num;</span><br><span class="line">        &#125;</span><br><span class="line">        count += ( num == candidate ) ? 1 : -1 ;</span><br><span class="line">    &#125;</span><br><span class="line">return candidate;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">分析一下,这样实现的时间复杂度是 O(n) ,空间复杂度是 O(1)<br>和刚开始使用的方法相比,好了许多</font></p><p><font face="华文中宋" size="3">你有没有更巧妙的方法实现,欢迎评论区和我交流哇<br>最后,感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;这个周末刷了几道算法题,把其中一个比较不错的分享给你~&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]14 搞不懂线性结构,非线性结构?</title>
    <link href="https://www.dynamic-zheng.com/posts/d42777bf.html"/>
    <id>https://www.dynamic-zheng.com/posts/d42777bf.html</id>
    <published>2020-04-05T02:46:43.000Z</published>
    <updated>2020-04-05T02:47:47.371Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在前面文章中介绍的数组,栈,队列这种都是线性结构,在接下来的文章中,会介绍图,这是一种非线性结构.<br>朋友,你是不是一脸问号?啥是线性结构,什么又是非线性结构呢?我怎么区别这两者呢.<br>别慌,一点点来看.<br><a id="more"></a></font></p><h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a><font face="华文中宋" size="3">线性结构</font></h1><p><font face="华文中宋" size="3">我在学习知识的时候,喜欢和以前的知识联系起来.<br>线性结构,我就想到了在学数学的时候,常说的线性相关,或者说这两个变量之间呈线性关系.<br>那么,在数学的定义上,什么是线性关系呢?<br>我就直接把维基百科的定义搬过来了,链接在这儿: <a href="https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E9%97%9C%E4%BF%82" target="_blank" rel="noopener">线性关系</a></font></p><blockquote><p><font face="华文中宋" size="3"> 在现代学术界中，线性关系一词存在 2 种不同的含义。其一，若某数学函数或数量关系的函数图形呈现为一条直线或线段，那么这种关系就是一种线性的关系。其二，在代数学和数学分析学中，如果一种运算同时满足特定的“加性”和“齐性”，则称这种运算是线性的。</font></p></blockquote><p><font face="华文中宋" size="3">咱们着重看第一个含义,和数学上面的定义差不多,大概意思就是 y 和 x 的关系在图中表示为一条直线或线段,比如 y=x ,那么这种关系我们就可以称之为是线性关系.<br>OK ,那 y=x 有什么特殊之处呢?是不是每一个 x 的取值,都唯一对应一个 y 值?<br>Nice !能够想到这一点,就触及到了线性结构的本质,即:数据元素之间存在着”一对一”的线性关系的数据结构就称为 线性结构.</font></p><p><font face="华文中宋" size="3">了解本质之后,咱们应该就很好理解了,像: 线性表,栈,队列,双队列 这种都是线性结构.</font></p><h1 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a><font face="华文中宋" size="3">非线性结构</font></h1><p><font face="华文中宋" size="3">在了解线性结构之后,再来理解非线性结构就好说了.<br>既然线性结构是一对一的关系,那么非线性结构就存在不是一对一的关系了呗,比如一对多?<br>恭喜你,答对了!<br>那么我们常见的: 二维数组,多维数组,树,图 就都是非线性结构了.</font></p><p><font face="华文中宋" size="3">以上就是想要分享的内容了<br>最近感觉自己写文章遇到了瓶颈一般,总是觉得没有写出自己想要的效果<br>关于我的文章,欢迎各位留言和我交流哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在前面文章中介绍的数组,栈,队列这种都是线性结构,在接下来的文章中,会介绍图,这是一种非线性结构.&lt;br&gt;朋友,你是不是一脸问号?啥是线性结构,什么又是非线性结构呢?我怎么区别这两者呢.&lt;br&gt;别慌,一点点来看.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]13 再来谈散列表</title>
    <link href="https://www.dynamic-zheng.com/posts/45c48476.html"/>
    <id>https://www.dynamic-zheng.com/posts/45c48476.html</id>
    <published>2020-03-28T10:53:19.000Z</published>
    <updated>2020-03-28T10:55:00.692Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">关于散列表入门级的知识,在这篇文章里面写过一些: <a href="https://blog.csdn.net/zll_0405/article/details/102208638" target="_blank" rel="noopener">[算法]散列表( Hash Table)</a><br>咱们今天再来详细讲一讲散列表.<br><a id="more"></a></font></p><h1 id="散列表与数组"><a href="#散列表与数组" class="headerlink" title="散列表与数组"></a><font face="华文中宋" size="3">散列表与数组</font></h1><p><font face="华文中宋" size="3">散列表最重要的就是,给我一个 key 值,我就能知道对应的 value 值.<br>在基础的数据结构里面,哪儿种数据结构能做到这样?<br>是不是数组?只要你给我一个数组的下标,我就能知道这个下标对应的值.<br>所以,散列表用的是数组支持按照下标随机访问数据的特性,散列表就是数组的一种扩展.<br>可以说,如果没有数组的话,就没有散列表.</font></p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a><font face="华文中宋" size="3">散列函数</font></h1><p><font face="华文中宋" size="3">OK ,在了解散列表与数组关系之后,咱们来说说散列函数.<br>在上面我们已经知道,散列表和数组的关系,也就是散列表利用了数组访问数据时间复杂度为 O( 1 ) 的特性,但是 value 值,是如何生成 key 值的呢?<br>利用的就是散列函数.<br>在构造散列函数时,有三点基本要求:</font></p><ul><li><font face="华文中宋" size="3">散列函数计算得到的散列值是一个非负整数;</font></li><li><font face="华文中宋" size="3">如果 key1 = key2 ,则经过散列函数散列之后得到的值也应该相等</font></li><li><font face="华文中宋" size="3"> 如果 key1 ≠ key2 ,那么经过散列函数散列之后得到的值也不应该相等</font></li></ul><p><font face="华文中宋" size="3">这三点要求应该挺容易理解的.首先数组下标是从 0 开始的,所以散列函数计算得到的散列值不能是一个非负整数;其次, key 值相等的,那么经过散列函数散列之后得到的 value 值也应该是一样的;当然,如果 key 值不相等,那么经过散列函数散列之后得到的 value 值也应该不一样.<br>这三点要求看起来挺少的,满足一下应该不过分吧?<br>不,太过分了!</font></p><p><font face="华文中宋" size="3">你想想呀, key 值不相等,就要有一个不同的 value 值,比如 “散列表” 这可以是一个 key 值吧?那 “散,列,表” 是不是另外一个 key 值?那 “散列,表” 是不是另外一个 key 值.<br>发现问题了嘛?也就是 key 只要稍微不一样,哪怕是多了一个符号,或者一个字母,就是不一样的 key 值,每一个 key 都要对应一个不同的 value 值,如果要满足这个要求,需要耗费很大的空间时间成本.<br>所以,目前为止,还没有一个完美的散列函数,使得散列之后的 value 值不重复.<br>这就引出了,散列冲突.</font></p><h1 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a><font face="华文中宋" size="3">散列冲突</font></h1><p><font face="华文中宋" size="3">既然到目前为止,还没有一个完美的散列函数,无法避免散列冲突,那咱们就曲线救国一下,遇到散列冲突了,该如何解决呢?<br>常用的散列冲突解决方法有两类:</font></p><ul><li><font face="华文中宋" size="3">开放寻址法<br><font face="华文中宋" size="3">开放寻址法的核心思想就是,如果出现了散列冲突,那就重新探测一个空闲位置,插入进来.<br>比如很经典的线性探测法:出现了散列冲突?行嘞,那咱们就从当前位置开始,再往下瞅瞅哪儿个位置是空的呗,有空的就插进去<br>比如很经典的二次探测法:出现了散列冲突?好呀,这次探测的下标序列是 +0 ,接下来看看 +1² 的位置有没有空闲,还是没有?那就 +2² 继续下去,直到找到空闲位置为止.</font></font></li><li><font face="华文中宋" size="3">链表法<br><font face="华文中宋" size="3">散列函数散列之后,存放值不再是一个空闲位置,而是一个链表.<br>一个空闲位置只能存放一个值,咱们不用了,改成一个链表,如果有两个值,很简单,这个链表的 next 指针指向要插入的值就好了.</font></font></li></ul><h1 id="散列冲突解决办法适合哪些应用场景"><a href="#散列冲突解决办法适合哪些应用场景" class="headerlink" title="散列冲突解决办法适合哪些应用场景?"></a><font face="华文中宋" size="3">散列冲突解决办法适合哪些应用场景?</font></h1><p><font face="华文中宋" size="3">散列冲突的两种主要解决办法是:开放寻址法 + 链表法.<br>那为什么在 Java 中 LinkedHashMap 就采用链表法来解决冲突,而 ThreadLocalMap 则是通过线性探测法来解决冲突呢?<br>换句话说,在什么场景下使用开放寻址法比较好,在什么场景下使用链表法比较好?这两者之间又有什么优劣呢?</font></p><ul><li><font face="华文中宋" size="3">开放寻址法<br><font face="华文中宋" size="3">咱们先来看开放寻址法:在开放寻址法中,散列表中的数据都存储在数组中,这样就可以有效利用 CPU 缓存来加快查询速度.此外使用这种方法实现的散列表,序列化起来就比较简单.但是链表法中包含指针,序列化起来就没有那么容易.<br>那么,开放寻址法有什么不足呢?我觉得最重要的一点就是,冲突的代价比较高.当出现冲突时,它不像链表那样,直接修改 next 指针就可以了,而是在空闲的位置中寻找,这样就会导致最后找不到空闲位置.<br>所以,如果我们的数据量比较小,填入表中的元素较少时,使用开放寻址法比较合适.这也是为什么 Java 中 ThreadLocalMap 使用开放寻址法解决散列冲突的原因.</font></font></li><li><font face="华文中宋" size="3">链表法<br><font face="华文中宋" size="3">链表法优点在于对内存的利用率比较高.因为链表节点可以在需要的时候创建,而不是在一开始就申请好.<br>其次,在开放寻址法中,如果有大量的散列冲突,就会导致大量的探测再散列,这样会使得性能下降,但是对于链表法来说,不会出现上述情况,只是会使链表长度变长.但即便如此,查找起来也还是快于开放寻址法的.<br>但是链表法因为要存放指针,所以是很消耗内存的.<br>基于以上,如果数据量较大,那么链表指针的内存消耗在很大数据量面前就可以忽略掉.</font></font></li></ul><p><font face="华文中宋" size="3">以上,就是想要分享的内容了,感谢您的阅读哇~</font></p><ul><li><font face="华文中宋" size="3">参考: 极客时间 — &lt;数据结构与算法之美&gt;</font></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;关于散列表入门级的知识,在这篇文章里面写过一些: &lt;a href=&quot;https://blog.csdn.net/zll_0405/article/details/102208638&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[算法]散列表( Hash Table)&lt;/a&gt;&lt;br&gt;咱们今天再来详细讲一讲散列表.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]12 你可能知道二分查找,但你肯定不知道还有这样的二分查找!</title>
    <link href="https://www.dynamic-zheng.com/posts/d4eedbd.html"/>
    <id>https://www.dynamic-zheng.com/posts/d4eedbd.html</id>
    <published>2020-03-20T23:53:53.000Z</published>
    <updated>2020-03-20T23:54:51.504Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">对于二分查找,应该不是很陌生.<br>比如,我写了一个数字 23 ,让你在 0-99 里面猜,猜大了或者猜小了我会告诉你,直到猜对为止.<br>为了尽快猜对,你是不是会这样猜?<br><a id="more"></a></font></p><table><thead><tr><th style="text-align:center">次数</th><th style="text-align:center">猜测范围</th><th style="text-align:center">中间数</th><th style="text-align:center">对比大小</th></tr></thead><tbody><tr><td style="text-align:center">第 1 次</td><td style="text-align:center">0 - 99</td><td style="text-align:center">49</td><td style="text-align:center">49 &gt; 23</td></tr><tr><td style="text-align:center">第 2 次</td><td style="text-align:center">0 - 48</td><td style="text-align:center">24</td><td style="text-align:center">24 &gt; 23</td></tr><tr><td style="text-align:center">第 3 次</td><td style="text-align:center">0 - 23</td><td style="text-align:center">11</td><td style="text-align:center">11 &lt; 23</td></tr><tr><td style="text-align:center">第 4 次</td><td style="text-align:center">12 - 23</td><td style="text-align:center">17</td><td style="text-align:center">17 &lt; 23</td></tr><tr><td style="text-align:center">第 5 次</td><td style="text-align:center">18 - 23</td><td style="text-align:center">20</td><td style="text-align:center">20 &lt; 23</td></tr><tr><td style="text-align:center">第 6 次</td><td style="text-align:center">21 - 23</td><td style="text-align:center">22</td><td style="text-align:center">22 &lt; 23</td></tr><tr><td style="text-align:center">第 7 次</td><td style="text-align:center">23</td><td style="text-align:center"></td><td style="text-align:center">√</td></tr></tbody></table><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><font face="华文中宋" size="3">代码实现</font></h1><p><font face="华文中宋" size="3">看起来这个过程蛮简单的,代码实现也挺简单的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:01:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Binary</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020-3-20 20:03:56</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (( high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ( arr[mid] == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( arr[mid] &lt; value)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">13</span>,<span class="number">25</span>,<span class="number">27</span>,<span class="number">30</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">66</span>,<span class="number">95</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BinarySearch </span></span><br><span class="line">        <span class="keyword">int</span> binarySearch = binarySearch(arr,arr.length,<span class="number">95</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(binarySearch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在写二分查找时,注意三点写出的代码就差不了多少:</font></p><ul><li><font face="华文中宋" size="3">循环退出条件<br>注意是 low &lt;= high ; 而不是 low &lt; high .</font></li><li><font face="华文中宋" size="3"> mid 的取值<br>这里 mid = low + (( high - low)&gt;&gt;1) 这种方式是将除以 2 的操作转化成了位运算,这样对于计算机来说处理速度会更快一些</font></li><li><font face="华文中宋" size="3"> low 和 high 的更新<br>low = mid + 1;  high = mid - 1; 不要写成 low = mid 或者 high = mid ,因为假设 high = 5 , low = 5 时, arr[5] 可能不等于 value ,这样就会导致程序陷入死循环.</font></li></ul><h1 id="二分查找适用场景"><a href="#二分查找适用场景" class="headerlink" title="二分查找适用场景"></a><font face="华文中宋" size="3">二分查找适用场景</font></h1><p><font face="华文中宋" size="3">二分查找的时间复杂度是 O(log n),查找数据的效率很高,但是不是什么情况下都可以使用二分查找.<br>首先,二分查找依赖的是顺序表结构,也就是数组.<br>它可以依赖其他数据结构嘛?比如链表?答案是不能,因为二分查找算法需要按照下标随机访问元素,而链表不能做到.</font></p><p><font face="华文中宋" size="3">其次,二分查找针对的是已经排好序的数据.<br>如果想要使用二分查找,那么数据必须是有序的.<br>数据无序怎么办?那就先排好序咯~<br>否则的话,有可能导致查找不到你想要的数据(不信可以试试,事实会告诉你真相的~<br>那么,既然要求数据有序,所以如果应用场景是频繁对数据进行插入,删除的话,想都不用想,不适合使用二分查找</font></p><p><font face="华文中宋" size="3">最后,数据量如果太小的话,不适合二分查找.<br>如果要处理的数据量非常小,直接顺序遍历就可以了,完全没有必要使用二分查找.<br>什么都会有个度,所以数据量如果太大的话,也不适合二分查找.</font></p><h1 id="二分查找的一些变形"><a href="#二分查找的一些变形" class="headerlink" title="二分查找的一些变形"></a><font face="华文中宋" size="3">二分查找的一些变形</font></h1><p><font face="华文中宋" size="3"> OK ,在掌握基础的二分查找之后,咱们来对它进行一下变形<br>因为比较简单而且容易理解,我就直接上代码了~</font></p><h2 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a><font face="华文中宋" size="3">查找第一个值等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:32:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchEqualFirst</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid]&gt;value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果 mid 等于 0 ,说明这个元素是数组的第一个元素</span></span><br><span class="line">            <span class="comment">// 或者 arr[mid-1] 不等于要查找的值,说明此时查找到的元素即为第一个找到等于给定值的元素</span></span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>)|| (arr[mid - <span class="number">1</span>] != value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a><font face="华文中宋" size="3">查找最后一个值等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:39:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchEqualFinal</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n-<span class="number">1</span>) || (arr[mid+<span class="number">1</span>] != value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a><font face="华文中宋" size="3">查找第一个大于等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:47:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (arr[mid - <span class="number">1</span>] &lt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a><font face="华文中宋" size="3">查找最后一个小于等于给定值的元素</font></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找---查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数组的长度</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-20 20:54:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchFinal</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; value)&#123;</span><br><span class="line">            high = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n-<span class="number">1</span>) || (arr[mid + <span class="number">1</span>] &gt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font face="华文中宋" size="3">参考<br>极客时间&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;对于二分查找,应该不是很陌生.&lt;br&gt;比如,我写了一个数字 23 ,让你在 0-99 里面猜,猜大了或者猜小了我会告诉你,直到猜对为止.&lt;br&gt;为了尽快猜对,你是不是会这样猜?&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]11 单链表反转进阶之递归操作( Java 版)</title>
    <link href="https://www.dynamic-zheng.com/posts/9cc5c0a0.html"/>
    <id>https://www.dynamic-zheng.com/posts/9cc5c0a0.html</id>
    <published>2020-03-14T09:21:03.000Z</published>
    <updated>2020-03-19T06:23:13.771Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在这一篇文章中,关于单链表反转,在 <a href="https://www.dynamic-zheng.com/posts/745fa732.html">[数据结构与算法]04 Link List (链表)及单链表反转实现</a> 中已经写过了,不是使用递归方法来实现的.因为递归不太容易讲清楚.<br><a id="more"></a><br>但是不能因为害怕讲不清楚就不写了,对不对.<br>所以这篇文章来使用递归来实现一下,并且尝试将里面的细节一一剖出来,不废话.</font></p><p><font face="华文中宋" size="3">首先,咱们要先明确,什么是递归.递归就是自己调用自己对吧.比如:有一个函数为 <code>f(n) = f(n-1) * n</code> ,(注意,我这里是举例子,这个函数没有给出递归的结束条件)给 n 赋值为 5 , 则:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--&gt; f(<span class="number">5</span>)</span><br><span class="line">--&gt; <span class="number">5</span> * f(<span class="number">4</span>)</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * f(<span class="number">3</span>))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * (<span class="number">3</span> * f(<span class="number">2</span>)))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * ( <span class="number">3</span> * ( <span class="number">2</span> * f (<span class="number">1</span>))))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * ( <span class="number">3</span> * ( <span class="number">2</span> * <span class="number">1</span>)))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * ( <span class="number">3</span> * <span class="number">2</span>))</span><br><span class="line">--&gt; <span class="number">5</span> * ( <span class="number">4</span> * <span class="number">6</span> )</span><br><span class="line">--&gt; <span class="number">5</span> * <span class="number">24</span></span><br><span class="line">--&gt; <span class="number">120</span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在看完例子之后,咱们接下来不 BB ,直接 show code:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单链表反转---递归实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-14 08:47:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseSingleList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">( <span class="keyword">int</span> data , Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;<span class="keyword">return</span>  data;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化单链表</span></span><br><span class="line">        Node node5 = <span class="keyword">new</span> Node(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node node4 = <span class="keyword">new</span> Node(<span class="number">4</span>,node5);</span><br><span class="line">        Node node3 = <span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">        Node node2 = <span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">        Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用反转方法</span></span><br><span class="line">        Node recursiveList = recursiveList(node1);</span><br><span class="line">        System.out.println(recursiveList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *递归实现单链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 为传入的单链表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020-3-14 08:55:45</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">recursiveList</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果链表为空 或者 链表中只有一个节点,直接返回</span></span><br><span class="line">        <span class="comment">// 也是递归结束的条件</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span> || list.next == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        Node recursive = recursiveList(list.next);</span><br><span class="line">        <span class="comment">// 将 list.next.next 指针指向当前链表 list</span></span><br><span class="line">        list.next.next = list ;</span><br><span class="line">        <span class="comment">// 将 list.next 指针指向 null</span></span><br><span class="line">        list.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 返回反转之后的链表 recursive</span></span><br><span class="line">        <span class="keyword">return</span> recursive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">经过上面的代码,应该能够看到核心代码就是,递归实现单链表反转部分的那 5 行代码,别小看了这 5 行代码,想要真正弄清楚还真的挺不容易的.<br>我把这 5 行代码贴在这里,咱们一行行分析,争取看完这篇博客就能懂~(注释我就去掉了,咱们专心看这几行核心代码)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (list == <span class="keyword">null</span> || list.next == <span class="keyword">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">Node recursive = recursiveList(list.next);</span><br><span class="line">list.next.next = list ;</span><br><span class="line">list.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> recursive;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">第一行就是一个判断,条件不满足,那就往下走,第二行是自己调用自己,程序又回到第一行,不满足条件程序向下执行,自己调用自己<br>就这样循环到符合条件为止,那么什么时候符合条件呢?也就是 <code>list == null</code> 或者 <code>list.next == null</code> 时,看一下自己定义的链表是 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,所以符合条件时,此时的链表为 <code>5-&gt;null</code> ,符合条件之后,程序继续向下执行,在执行完 <code>Node recursive = recursiveList(list.next);</code> 这行代码之后,咱们来看一下此时的程序执行结果:<br><img src="/images/2020/oneRecursive.jpg"></font></p><p><font face="华文中宋" size="3">我把上面这个给画出来(画工不好,不要在乎它的美丑~)<br><img src="/images/2020/one.jpg"></font></p><p><font face="华文中宋" size="3">接下来程序该执行 <code>list.next.next = list</code> 执行结束之后,链表大概就是这个样子:<br><img src="/images/2020/two.jpg"></font></p><p><font face="华文中宋" size="3">那是图,下面是程序断点调试程序的结果,发现和上面的图是一样的:<br><img src="/images/2020/twoRecursive.jpg"></font></p><p><font face="华文中宋" size="3">程序继续向下走 <code>list.next = null</code> ,也就是说,将 list 的 next 指针指向 null :<br><img src="/images/2020/three.jpg"></font></p><p><font face="华文中宋" size="3">从图中看到, list 为 <code>4-&gt;null</code> , recursive 为 <code>5-&gt;4-&gt;null</code> ,咱们来看看程序的结果,是不是和图相符:<br><img src="/images/2020/threeRecursive.jpg"></font></p><p><font face="华文中宋" size="3">完全一样有没有!<br>OK ,还记得咱们刚开始的递归函数例子嘛?现在执行完毕,开始执行下一次,咱们继续来看,此时的链表是这个样子的:<br><img src="/images/2020/four.jpg"></font></p><p><font face="华文中宋" size="3">接下来程序执行的代码就是四行了:</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node recursive = recursiveList(list.next);</span><br><span class="line">list.next.next = list ;</span><br><span class="line">list.next = null;</span><br><span class="line">return recursive;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">继续执行程序,咱们来看结果,将 <code>list.next.next = list</code> 运行结束时,此时链表为:<br><img src="/images/2020/five.jpg"></font></p><p><font face="华文中宋" size="3">从图中能够看到,链表 list 为 <code>3-&gt;4-&gt;3-&gt;4</code> 循环中, recursive 为 <code>5-&gt;4-&gt;3-&gt;4-&gt;3</code> 循环,咱们看一下程序是不是也是如此(在这里我截了两个循环作为示例):<br><img src="/images/2020/fiveRecursive.jpg"></font></p><p><font face="华文中宋" size="3">接下来程序执行 <code>list.next = null</code> ,执行完毕之后,就是将 list 的 next 指针指向 null :<br><img src="/images/2020/six.jpg"></font></p><p><font face="华文中宋" size="3">从图中能够看出来, list 为 <code>3-&gt;null</code> , recursive 为 <code>5-&gt;4-&gt;3-&gt;null</code> ,上图看看实际结果和分析的是否一致:<br><img src="/images/2020/sixRecursive.jpg"></font></p><p><font face="华文中宋" size="3">说明什么?!<br>说明咱们上面的分析是正确的~<br>接下来的程序分析,读者就自行研究吧`<br>相信接下来的分析就难不倒你了~</font></p><h1 id="反转单链表的前-N-个节点"><a href="#反转单链表的前-N-个节点" class="headerlink" title="反转单链表的前 N 个节点"></a><font face="华文中宋" size="3">反转单链表的前 N 个节点</font></h1><p><font face="华文中宋" size="3">OK ,咱们趁热打铁一下,刚刚是通过递归实现了整个单链表反转,那如果我只是想反转前 N 个节点呢?<br>比如单链表为 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,现在我只想反转前三个节点,变为 <code>3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;null</code><br>有没有想法?<br>咱们进行整个单链表反转时,可以理解为传递了一个参数 n ,这个 n 就是单链表的长度,然后递归程序不断调用自己,然后实现了整个单链表反转.<br>那么,如果我想要反转前 N 个节点,是不是传递一个参数 n 来解决就好了?<br>咱们就直接上代码了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *反转单链表前 n 个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 为传入的单链表 , n 为要反转的前 n 个节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-14 09:13:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseListN</span><span class="params">(Node list,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 要进行反转链表时,先将 list 后的节点数据保存到 next 中</span></span><br><span class="line">        next = list.next;</span><br><span class="line">        <span class="keyword">return</span>  list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node reverse = reverseListN(list.next , n-<span class="number">1</span>);</span><br><span class="line">    list.next.next = list;</span><br><span class="line">    <span class="comment">// 将 list.next 的指针指向没有进行反转的链表</span></span><br><span class="line">    list.next = next ;</span><br><span class="line">    <span class="keyword">return</span> reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><h1 id="反转单链表的一部分"><a href="#反转单链表的一部分" class="headerlink" title="反转单链表的一部分"></a><font face="华文中宋" size="3">反转单链表的一部分</font></h1><p><font face="华文中宋" size="3">既然反转整个单链表实现了,反转前 N 个节点实现了,那么如果有个需求是反转其中的一部分数据呢?大概就是这样,原来的链表为 <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</code> ,反转其中的一部分,使反转后的链表为 <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;null</code><br>借用反转前 N 个节点的思路,是不是我传两个参数进来,一个是开始反转的节点,一个是结束反转的节点,然后递归操作就可以了?<br>瞅瞅代码是怎么写的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *反转部分单链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 为传入的单链表, m 为开始反转的节点, n 为结束的反转节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-3-14 09:32:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseBetween</span><span class="params">(Node list , <span class="keyword">int</span> m , <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseListN(list,n);</span><br><span class="line">    &#125;</span><br><span class="line">    list.next = reverseBetween(list.next,m-<span class="number">1</span>,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">大早上就开始写代码验证 + 写这篇文章,终于给弄清楚了<br>最后两个例子,读者们可以自行研究,我这里因为篇幅的问题就不进行解析了,如果第一个例子自己能够剖析清楚,下面两个也没啥大问题~</font></p><p><font face="华文中宋" size="3">以上,就是这篇文章想要分享的内容啦<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在这一篇文章中,关于单链表反转,在 &lt;a href=&quot;https://www.dynamic-zheng.com/posts/745fa732.html&quot;&gt;[数据结构与算法]04 Link List (链表)及单链表反转实现&lt;/a&gt; 中已经写过了,不是使用递归方法来实现的.因为递归不太容易讲清楚.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[工具集]介绍一波我常用的小工具</title>
    <link href="https://www.dynamic-zheng.com/posts/22ced40a.html"/>
    <id>https://www.dynamic-zheng.com/posts/22ced40a.html</id>
    <published>2020-03-06T13:07:57.000Z</published>
    <updated>2020-03-06T13:13:13.946Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">和很多人交流之后,我发现很多我以为大家都知道的小工具,到最后只是我以为.<br>既然这样,这篇文章就分享一波~<br><a id="more"></a><br>如果你那里也有好的小工具,欢迎评论区交流<br>毕竟,你有一个苹果,我有一个梨,咱俩一交流,就有了两种水果可以吃,哈哈哈</font></p><h1 id="技术"><a href="#技术" class="headerlink" title="技术."></a><font face="华文中宋" size="3">技术.</font></h1><p><font face="华文中宋" size="3">技术上,我喜欢有事没事逛逛 github ,这应该是程序员/程序媛们的标配吧?<br>上面开源的项目,很多质量都非常高,能够从里面学习到很多东西.给个传送门:  <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>还有个网站: <a href="https://stackoverflow.com" target="_blank" rel="noopener">stackoverflow</a></font></p><p><font face="华文中宋" size="3">站在巨人的肩膀上,能够走得更快.<br>在编程这个道路上,我特别佩服耗子叔,所以常常有事没事就刷他的网站.<br>每次觉得迷茫了,不知道要做什么了,就去刷一刷大佬的网站,然后收获就很多: <a href="https://coolshell.cn/" target="_blank" rel="noopener">酷 壳 – CoolShell</a></font></p><p><font face="华文中宋" size="3">在学习上,肯定也少不了理论的补充,我喜欢去极客时间: <a href="https://time.geekbang.org/" target="_blank" rel="noopener">极客时间</a></font></p><p><font face="华文中宋" size="3">在写博客的时候,很多情况下都需要画图,而且是很好看的那种,这个时候推荐 ProcessOn : <a href="https://www.processon.com/;jsessionid=198BBBBCD99C1191E9265342EA9F1D95.jvm1" target="_blank" rel="noopener">ProcessOn</a> ,支持将文件导出,也是很方便</font></p><h1 id="提升认知"><a href="#提升认知" class="headerlink" title="提升认知"></a><font face="华文中宋" size="3">提升认知</font></h1><p><font face="华文中宋" size="3">想要提升认知,读书是必不可少的,给一份书单: <a href="https://www.douban.com/note/686630327/" target="_blank" rel="noopener">北京地铁书单：理想的地铁是图书馆的模样（396种+持续更新）</a><br>现在微信读书上面的书籍是挺多的了,特别是出了网页版,很方便,抱个电脑,一天的阅读就都有了: <a href="https://weread.qq.com/" target="_blank" rel="noopener">微信读书</a><br>如果微信读书上没有,也可以来这里搜书看看有没有: <a href="https://obook.cc/" target="_blank" rel="noopener">偶书</a><br>可以这么说,微信读书 + NeatReader 覆盖了我 90% 的阅读需求. NeatReader 是一个 epub 阅读器,花钱买个终身会员,在任何平台都可以看自己存储的书籍,爽的一批,你可以尝试一下</font></p><p><font face="华文中宋" size="3">读完书之后,不能只是读完书对吧?最好还能写写读后感,我比较喜欢用 Notion 来做记录,但是 Notion 对新手很不友好,很多功能都需要你自己去尝试,而且吧,还需要 google 账号,如果你没有 google 账号的话,也不知道怎么注册,那我还是建议你忽略这个推荐好了,因为没有 google 账号也不知道怎么注册,我觉得大概率都是懒得摸索,那这个网站大概率你也不会怎么探索.<br>既然推荐了,还是给个传送门: <a href="https://www.notion.so/?r=a4ce1b04924f4686824c5492db62a3b2" target="_blank" rel="noopener">Notion</a><br>给大家看一下 Notion 界面,我喜欢黑色,酷酷的~<br><img src="/images/2020/notion.jpg"></font></p><p><font face="华文中宋" size="3">最后推荐一位跨境电商的大佬博客: <a href="http://www.guxiaobei.com/history-articles.html" target="_blank" rel="noopener">顾小北的 B2C 博客</a><br>看这个博客,能让你增长很多见识.真的,程序员/程序媛别限制自己.<br>至于这位大佬多厉害呢:大学毕业就已经挣够了百万,现在已经挣够 1 个亿了,重点是,他还年轻啊!!!羡慕的一批<br>所以没事多看看大佬的文章,多瞅瞅人家的思维模式,收获颇丰.</font></p><h1 id="chrome-常用插件"><a href="#chrome-常用插件" class="headerlink" title=" chrome 常用插件"></a><font face="华文中宋" size="3"> chrome 常用插件</font></h1><p><font face="华文中宋" size="3">chrome 插件有很多,但是我这里只推荐 6 个.<br><img src="/images/2020/chrome插件.jpg"></font></p><p><font face="华文中宋" size="3">第一个插件就不用多说了,安装上之后,界面清爽了很多.<br>第二个插件是清空访问网站记录的,我这个人有强迫症,每次浏览器关闭之前,都会将访问的历史记录清空一下,有了这个插件,一键搞定.<br>第三个插件是一个非常漂亮的标签页<br>第四个 + 第六个插件,是在 github 上用的.<br>第五个插件是为了保存网页,不知道你有没有这样一个痛点:我在手机上发现了一个好网站,也想在电脑上访问;同样我在电脑上发现了一个好的网站,也想在手机上访问,这个插件就可以完美解决以上困境.发现一个好的网站,直接鼠标右键将网站保存到这里,然后手机上也装上这个软件就可以在手机上也访问了.</font></p><h1 id="windows-系统下常用插件"><a href="#windows-系统下常用插件" class="headerlink" title="windows 系统下常用插件"></a><font face="华文中宋" size="3">windows 系统下常用插件</font></h1><p><font face="华文中宋" size="3">每次我的电脑重装系统之后,第一件事情就是把下面这 4 个软件装上,要不然会觉得不舒服.<br><img src="/images/2020/windows小工具.jpg"></font></p><p><font face="华文中宋" size="3">第一个软件是 WGestures ,这个软件是鼠标手势.复制粘贴你还在用 Ctrl + c/v 嘛? out 啦~用这个插件,只需要鼠标右键操作即可.<br>还有一点是我常用的:比如和别人聊天,突然发过来一个名字我不知道,想搜索怎么办?你是不是需要打开浏览器,然后输入关键字回车?使用这个软件的话,直接鼠标右键就可以搞定!<br>还有很多很强大的功能,在这里就不多做介绍了,读者可以自行尝试~<br>来个传送门: <a href="http://www.yingdev.com/projects/wgestures" target="_blank" rel="noopener">WGestures 全局鼠标手势</a></font></p><p><font face="华文中宋" size="3">第二个软件是 Listary .<br>这个软件以前写过一篇文章,我就不详细介绍了: <a href="https://blog.csdn.net/zll_0405/article/details/77815032" target="_blank" rel="noopener">Listary 的使用</a></font></p><p><font face="华文中宋" size="3">第三个软件是 Snipaste .这个是一个截图软件.<br>看到这里你可能会说,截图我用微信或者 QQ 截图就可以呀.但是这个截图软件有一个很特殊的功能: 贴图.<br>在码代码的时候,你有没有一种冲动,想把这几行代码固定在屏幕上不动,和正常的代码对比着看,瞅瞅到底哪里有错误.那么,这个软件可能是你需要的.<br>最重要的是,很方便,直接 F1 就将程序调用出来.<br>同样,来个传送门: <a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a></font></p><p><font face="华文中宋" size="3">第四个软件,你熟悉的话就知道怎么用,不熟悉的话,我也就不介绍了.</font></p><p><font face="华文中宋" size="3">以上,就是我比较常用的各种网站 + 软件 + 小工具,是我压箱底的分享了.<br>不知道你有没有想和我分享的?<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;和很多人交流之后,我发现很多我以为大家都知道的小工具,到最后只是我以为.&lt;br&gt;既然这样,这篇文章就分享一波~&lt;br&gt;
    
    </summary>
    
      <category term="工具集" scheme="https://www.dynamic-zheng.com/categories/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
      <category term="工具集" scheme="https://www.dynamic-zheng.com/tags/%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]10 直接插入排序( Java 版)</title>
    <link href="https://www.dynamic-zheng.com/posts/df2b73be.html"/>
    <id>https://www.dynamic-zheng.com/posts/df2b73be.html</id>
    <published>2020-02-29T08:12:08.000Z</published>
    <updated>2020-03-19T06:07:25.128Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">直接插入排序,当你看到这几个字的时候,首先第一想法是什么?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我第一想法是在我斗地主的时候,比如我的牌是 5,J,K 下一张牌是 8 ,那我就直接把它放在 5 和 J 之间,此时手里面的牌就是 5,8,J,K 再来一张牌是 4 ,那就放在最前面,此时是 4,5,8,J,K 又来一张牌是 10 ,那就直接把它放在 8 和 J 之间,就是 5,8,10,J,K .(原谅我有点儿强迫症,一定要把牌从大到小码好才觉得顺眼)<br>发现规律了嘛?在我手里面的牌是有序的,没有在我手里面的牌则是无序的,然后我一张一张的从无序的牌里面抽出来,然后和我手里面的牌进行比较,看看抽到的这张牌将它放在哪个位置比较好.<br>如果找到了合适的位置,就直接插入进去就可以了.<br>上面的这个过程,就是直接插入排序的体现.</font></p><p><font face="华文中宋" size="3">上面的描述比较口语化,咱们用术语来说一下原理(显得我比较有文化,哈哈哈):</font></p><ul><li><font face="华文中宋" size="3">将 n 个待排序的元素看成是一个有序表和无序表</font></li><li><font face="华文中宋" size="3">每次从无序表中取出第一个元素,把它插入到有序表的合适位置,使得有序表从整体来看依然有序.</font></li><li><font face="华文中宋" size="3">第一趟比较前两个数,然后把第二个数按照大小插入到有序表中;第二趟将第三个数据与前面两个数据进行比较,将第三个数据插入到有序表合适的位置中</font></li><li><font face="华文中宋" size="3">按照这样的步骤依次进行下去,进行了 n-1 趟扫描以后,就整个待排序列排好了.</font></li></ul><p><font face="华文中宋" size="3">从上面的步骤中,应该能够体会到,直接插入排序有两层嵌套循环.<br>第一层是外循环,标识待比较的数值,也就是从无序表中取出来的那个值.<br>第二层是内循环,是为了确定从无序表中取出的值的最终位置.<br>但是外循环是从第二个数开始比较的,因为直接插入排序是将待比较的数值与它的前一个数值进行比较,如果没有前一个数值,也就没有直接插入排序这一说.</font></p><p><font face="华文中宋" size="3">OK ,理论知识补充完毕了,咱们来看看代码上是如何实现的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接插入排序代码实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-25 11:39:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StraightInsert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">straightInsert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义变量</span></span><br><span class="line">        <span class="keyword">int</span> i , j , insertNote;</span><br><span class="line">        <span class="comment">// 从数组的第二个元素开始循环,将数组中的元素插入</span></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 第一次循环,假设第 2 个元素为要插入的元素</span></span><br><span class="line">            insertNote = arr[i];</span><br><span class="line">            j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; insertNote &lt; arr[j])&#123;</span><br><span class="line">                <span class="comment">// 如果要插入的元素小于第 j 个元素,就将第 j 个元素向后移动</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 要插入的元素大于第 j 个元素时,将要插入的数据插入到数组中</span></span><br><span class="line">            arr[j+<span class="number">1</span>] = insertNote;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">95</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">456</span>,<span class="number">741</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">        straightInsert(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容啦~<br>感谢您的阅读哇<br>有什么更好的实现方法更欢迎评论区交流~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;直接插入排序,当你看到这几个字的时候,首先第一想法是什么?&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]09 冒泡排序( Java 版)</title>
    <link href="https://www.dynamic-zheng.com/posts/9e1c66c3.html"/>
    <id>https://www.dynamic-zheng.com/posts/9e1c66c3.html</id>
    <published>2020-02-29T02:37:51.000Z</published>
    <updated>2020-03-19T06:07:52.218Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">当你想到冒泡的时候,第一反应是什么?<br>我这个人比较喜欢可口可乐,所以当看到冒泡,我的第一反应就是喝可乐的时候,有一个个的小泡泡冒出来,如果你仔细观察过的话,会看到这个小泡泡刚开始很小,但是等冒上来的时候,就比较大了.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">上面大概就是一个描述,咱们根据上面的描述,详细说说原理:</font></p><ul><li><font face="华文中宋" size="3">1 ,比较相邻的元素.如果第一个比第二个大,就交换他们两个</font></li><li><font face="华文中宋" size="3">2 ,对接下来的每一对相邻元素都做同样的比较,从开始第一对到结尾的最后一对.<br>还记得第 1 条嘛?如果第一个比第二个大,那么就交换他们两个,对不对?所以,这样一轮结束之后,最后一个值是这些数中最大的值.</font></li><li><font face="华文中宋" size="3">3 ,针对所有的元素重复 1,2 的步骤,除了最后一个元素.<br>因为最后一个元素咱们已经确定了是最大的了,所以接下来的排序就不再担心了.</font></li><li><font face="华文中宋" size="3">4 ,持续 1,2,3 直到所有排序完毕.</font></li></ul><p><font face="华文中宋" size="3">看完原理之后,我们就能知道,冒泡排序就是将大的元素向后调,比较发生在两个元素之间,交换也是发生在这两个元素之间,也就是说,假设第一个数小于第二个数,那么接下来第一个数总是在第二个数前面,相对位置总是不变的.<br>所以,我们说冒泡排序是一种稳定的算法.<br>当然了,冒泡排序也可以将小的元素向后调,这些都取决于你怎么制定规则,你最大,你说了算~</font></p><p><font face="华文中宋" size="3">上面介绍完毕了,咱们就直接上代码来看看.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-19 08:49:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">         <span class="comment">// 定义变量</span></span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;n-i;j++)&#123;</span><br><span class="line">                <span class="comment">// 如果前面的数字,大于后面的数字,则进行交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j-<span class="number">1</span>]&gt;arr[j])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp;</span><br><span class="line">                    temp = arr[j-<span class="number">1</span>];</span><br><span class="line">                    arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">95</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">456</span>,<span class="number">741</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr,arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">上面的就能实现冒泡排序,但是今天在写这篇博客,看书的时候,发现了一个很巧的方法,我也贴出来:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.anomalous.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-2-29 09:36:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 临时变量</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 标识变量,表示是否进行过交换</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果前面的数比后面的数大,则交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 改变标识变量为 true</span></span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在一趟排序中,一次交换都没有发生过</span></span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 重置 flag ,进行下次判断</span></span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr =&#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">95</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">56</span>,<span class="number">23</span>,<span class="number">456</span>,<span class="number">741</span>,<span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr,arr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">如果仔细看的话,你会发现引入了一个标识变量.<br>这个标识变量有什么作用呢?如果你感兴趣可以运行一下程序,观察一下比较次数,会发现第二种方法程序的运行次数是比第一次的运行次数少的.<br>为什么呢?你想想,其实最后一趟排序的时候,整体已经排好了,但是第一种方法会再次进行排序,第二种因为有标识变量的存在,如果一次交换都没有发生过,说明此时整个数组已经有序,所以不会再进行排序一次.<br>只是因为多了一个标识变量,就节省了时间,这种思路,很巧妙~</font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容了.<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;当你想到冒泡的时候,第一反应是什么?&lt;br&gt;我这个人比较喜欢可口可乐,所以当看到冒泡,我的第一反应就是喝可乐的时候,有一个个的小泡泡冒出来,如果你仔细观察过的话,会看到这个小泡泡刚开始很小,但是等冒上来的时候,就比较大了.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[操作系统]关于 Windows 文件访问方式,你可能真的不是很了解</title>
    <link href="https://www.dynamic-zheng.com/posts/34678e11.html"/>
    <id>https://www.dynamic-zheng.com/posts/34678e11.html</id>
    <published>2020-02-22T10:49:12.000Z</published>
    <updated>2020-02-22T10:51:40.748Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在 Windows 操作系统下,想要访问文件时,一般有以下三种方式:</font></p><ul><li><font face="华文中宋" size="3">不使用文件缓存</font></li><li><font face="华文中宋" size="3">使用文件缓存</font></li><li><font face="华文中宋" size="3">异步模式<a id="more"></a><font face="华文中宋" size="3">动动小脑就应该知道,最常用的是「使用文件缓存」这种方式(好吧,小脑是为了保证身体平衡,不是为了思考;<br>接下来就说说,在 Windows 操作系统下,当我们以「使用文件缓存」这种方式来访问文件时,操作系统所做的事情.</font></font></li></ul><p><font face="华文中宋" size="3">使用文件缓存访问:</font></p><ul><li><font face="华文中宋" size="3">由 Windows 的 Cache Manager 实现对缓存的控制,读取数据时,进行预取<ul><li><font face="华文中宋" size="3">如果 Cache 满了怎么办?<br><font face="华文中宋" size="3">Cache Manager 会根据 LRU ( Least Recently Used ,最近最少使用)原则,来清除一些缓存内容<br>同时还需要定期更新磁盘内容,让磁盘内容和 Cache 中保持一致(通常是 1 秒更新一次)</font></font></li></ul></font></li><li><font face="华文中宋" size="3">Write-back 机制:<ul><li><font face="华文中宋" size="3">在对文件进行访问时,会涉及到对文件的一些修改,这就涉及到了对磁盘写数据<br>此时,我们不直接对磁盘进行更改,而是只更改 Cache 中的内容,然后由 Cache Manager 决定什么时候将用户所做的更新反映到磁盘上<ul><li><font face="华文中宋" size="3">为什么不直接对磁盘进行更改?<br>对任何操作系统来说, I/O 的读写速度永远都是硬伤,如果频繁对磁盘进行 I/O 操作,会使得系统性能降低</font></li></ul></font></li></ul></font></li></ul><p><font face="华文中宋" size="3">画一个图,能够更直观的看到(请忽略我的画图水平):<br><img src="/images/2020/file.jpg"></font></p><p><font face="华文中宋" size="3">如上图,阴影部分表示需要访问的数据.<br>数据在磁盘,系统缓存和进程地址空间有 3 份拷贝,通常情况下用户对数据的修改并不直接反映到磁盘上,而是通过 write-back 机制定期更新到磁盘上.</font></p><p><font face="华文中宋" size="3">为了尽可能提高读取速度,我们应该将要存储的数据,尽量放在同一个柱面上.</font></p><p><font face="华文中宋" size="3">以上,就是想要分享的内容<br>感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在 Windows 操作系统下,想要访问文件时,一般有以下三种方式:&lt;/font&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;不使用文件缓存&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;使用文件缓存&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;异步模式
    
    </summary>
    
      <category term="操作系统" scheme="https://www.dynamic-zheng.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://www.dynamic-zheng.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>[操作系统]当双击某程序到它显示运行界面时,操作系统做了什么</title>
    <link href="https://www.dynamic-zheng.com/posts/e6161cda.html"/>
    <id>https://www.dynamic-zheng.com/posts/e6161cda.html</id>
    <published>2020-02-15T10:41:53.000Z</published>
    <updated>2020-02-15T10:43:44.245Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">继<a href="https://www.dynamic-zheng.com/posts/ebb383b9.html#more">[计算机网络]从页面输入网址,回车到显示内容,这中间到底经历了什么</a>这篇文章之后,我突然发现我对计算机网络的一些知识串了起来,它们对我来说不再是一个个的单独个体.<br>基于这个经验,我再来梳理一下当双击某程序到它显示运行界面时,操作系统做了什么,尝试将操作系统的一些东西,也串起来.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">假设:我们现在想要让操作系统运行「微信」,那么首先我们会怎么做?</font></p><ul><li><p><font face="华文中宋" size="3"> 1 ,双击微信图标.<br>但是打开一个程序的方式不止一种,不要限制了自己,比如也可以通过命令行键入命令的方式将它打开(不过一般不会这么做吧;<br>当我们双击了微信图标时,就告诉了操作系统,我希望你能帮我运行「微信」</font></p></li><li><p><font face="华文中宋" size="3"> 2 ,此时操作系统接收到请求之后,就去磁盘上找到「微信」程序的相关信息,检测它的类型是不是可执行文件,同时通过程序首部信息确定代码和数据在可执行文件中的位置并且计算出对应的磁盘块地址.</font></p><ul><li><font face="华文中宋" size="3">看完上面的解释,你有疑问嘛?操作系统怎么检测它是不是可执行文件呢?对于 Windows 系统来说,可执行文件是 <a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%A7%BB%E6%A4%8D%E5%8F%AF%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener">PE(Portable Executable)</a>,对于 Linux 系统来说,可执行文件是 <a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%9F%B7%E8%A1%8C%E8%88%87%E5%8F%AF%E9%8F%88%E6%8E%A5%E6%A0%BC%E5%BC%8F" target="_blank" rel="noopener">ELF(Executable and Linkable Format)</a>,对于 Mac 系统来说,可执行文件是<a href="https://zh.wikipedia.org/wiki/Mach-O" target="_blank" rel="noopener">Mach-O(Mach Object)</a></font></li></ul></li><li><p><font face="华文中宋" size="3"> 3 ,操作系统做完第 2 步之后,就会创建一个进程,并且将「微信」的可执行文件映射到该进程结构,意思就是,这个进程负责执行「微信」程序.</font></p></li><li><font face="华文中宋" size="3"> 4 ,接下来操作系统会为「微信」程序设置 CPU 上下文环境,此时我们假设这个调度程序选中了「微信」程序,那么操作系统就会跳到程序开始处</font></li><li><font face="华文中宋" size="3"> 5 ,接下来执行「微信」程序的第一条指令.<br>但是它会发生缺页异常.<ul><li><font face="华文中宋" size="3">为什么会发生缺页异常?<br>因为程序在执行时,要将代码和数据读入内存, CPU 才能执行,但此时因为内存中还没有相关数据,进而触发了硬件机制,捕获到缺页异常,将控制权交给操作系统</font></li></ul></font></li><li><font face="华文中宋" size="3"> 6 ,操作系统此时会分配一页物理内存,同时将代码从磁盘读入内存,然后继续执行「微信」程序.<br>如果程序很大,一页内存不够的话,会在执行过程中重复 5,6 步骤,直至将程序全部读入内存为止</font></li><li><font face="华文中宋" size="3"> 7 ,之后,「微信」程序执行相关函数(系统调用),在显示器上显示「微信」图标</font></li><li><font face="华文中宋" size="3"> 8 ,操作系统接收到这个请求,然后找到显示设备,通常显示设备是由一个进程控制的,所以操作系统将要显示的「微信」图标给该进程</font></li><li><font face="华文中宋" size="3"> 9 ,控制设备的进程告诉设备的窗口系统它要显示「微信」图标,窗口系统在确定这是一个合法的操作之后,会将「微信」图标转换成像素,将像素写入设备的存储映像区</font></li><li><font face="华文中宋" size="3"> 10 ,视频硬件将像素转换成显示器可以接收的一组控制数据信号</font></li><li><font face="华文中宋" size="3"> 11 ,显示器解释数据信号,激发液晶屏<br>此时,我们就能够在屏幕上看到「微信」的登录界面.</font></li></ul><p><font face="华文中宋" size="3">至此,当我们双击某个程序,到显示运行界面时,操作系统做的工作我们就比较清楚了.</font></p><p><font face="华文中宋" size="3">这篇文章的灵感来源于:</font></p><p><font face="华文中宋" size="3"><a href="https://www.bilibili.com/video/av9555596?t=4" target="_blank" rel="noopener">操作系统做了什么?</a></font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;继&lt;a href=&quot;https://www.dynamic-zheng.com/posts/ebb383b9.html#more&quot;&gt;[计算机网络]从页面输入网址,回车到显示内容,这中间到底经历了什么&lt;/a&gt;这篇文章之后,我突然发现我对计算机网络的一些知识串了起来,它们对我来说不再是一个个的单独个体.&lt;br&gt;基于这个经验,我再来梳理一下当双击某程序到它显示运行界面时,操作系统做了什么,尝试将操作系统的一些东西,也串起来.&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://www.dynamic-zheng.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://www.dynamic-zheng.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>[计算机网络]从页面输入网址,回车到显示内容,这中间到底经历了什么</title>
    <link href="https://www.dynamic-zheng.com/posts/ebb383b9.html"/>
    <id>https://www.dynamic-zheng.com/posts/ebb383b9.html</id>
    <published>2020-02-14T13:03:45.000Z</published>
    <updated>2020-02-14T13:10:52.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><font face="华文中宋" size="3">写在前面</font></h1><p><font face="华文中宋" size="3">在学习计算机网络的内容时,脑子里面突然冒出来一个问题:当我们在一个浏览器界面输入网址,回车到界面显示内容,这中间经历了什么?<br>先不要往下看,你能想到什么?<br>下面是我能想到的过程,有可能不是很准确,如有错误之处,还望指出.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">计算机网络大体上可以分为应用层,传输层,网络层,链路层和物理层.<br>当我们在页面输入网址,然后回车到显示内容时,我通过上面的层次依次来说.</font></p><h1 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a><font face="华文中宋" size="3">详细过程</font></h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a><font face="华文中宋" size="3">应用层</font></h2><p><font face="华文中宋" size="3">假设我们现在要访问 google 网站,那么第一步要做的就是打开浏览器,在地址栏中输入 google 的地址,当你点击回车时,浏览器知道你要访问 google 了,但是对于浏览器来说,这只是一个名字,但是具体在哪儿它是不知道的.比如,你知道某位明星的名字,但是他/她具体的地址在哪儿你不清楚,对吧?对于浏览器来说也是这样.<br>比较好的一点是,想要访问网站,不像你想见明星那么难.此时浏览器通过 DNS 找到你要访问的具体网站地址.<br>当然了,如果你想要更准确的找到地址,也可以通过 HTTPDNS 去查找.<br>通过 DNS 或者 HTTPDNS 现在浏览器拿到了具体的 IP 地址,随后它就开始打包你的请求.对于举的例子来说,你只是想要访问一下,一般使用 HTTP 协议就可以了;如果有些请求会涉及到你的账号密码,就会使用 HTTPS 协议来保证你的数据安全.</font></p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a><font face="华文中宋" size="3">传输层</font></h2><p><font face="华文中宋" size="3">到这里, DNS , HTTP , HTTPS 所在的层称之为应用层.<br>现在应用层的事情做完了,接下来应用层会将以上相关数据进行封装,经过 Socket 编程,将应用层的包发送给传输层.<br>如果这个包是使用 HTTP 或者 HTTPS 协议发送过来的,那传输层就会使用 TCP 协议来将数据进行封装;如果是使用 DNS 协议发送过来的,则会使用 UDP 协议来进行封装.<br>封装完毕之后,浏览器就会将包交给操作系统的网络层.</font></p><h2 id="网络层-链路层-物理层"><a href="#网络层-链路层-物理层" class="headerlink" title="网络层 + 链路层 + 物理层"></a><font face="华文中宋" size="3">网络层 + 链路层 + 物理层</font></h2><p><font face="华文中宋" size="3">这一部分会涉及到网络层 + 链路层 + 物理层,我就不分那么详细了~<br>网络层的协议是 IP 协议,在 IP 协议中会有源 IP 地址和目标 IP 地址.<br>源 IP 地址也就是浏览器所在机器的 IP 地址,说的再白点儿就是,假设你是使用电脑浏览器发出的访问请求,这个源 IP 地址就是你的电脑 IP 地址<br>目标 IP 地址就是你想要访问的网站地址.还记得嘛,在应用层,我们根据 DNS 或 HTTPDNS 已经获取到了想要访问网站的具体 IP 地址.<br>OK ,既然此时操作系统已经知道了目标 IP 地址,接下来它就会想我怎么根据这个目标 IP 地址找到这台机器呢.首先操作系统会看这个 IP 地址是不是在局域网内,如果是的话,从目标 IP 地址就能看出来.但是很明显,想要访问的 google 地址不在本地,在那触不到的远方.</font></p><p><font face="华文中宋" size="3">操作系统知道要访问的地址在远方,但是远方在哪儿它也不知道.所以它就将这个数据包发给网关( gateway ),但是它不知道网关是哪儿台机器,这可咋整.<br>没事儿,反正大家都在一个地方,吼一嗓子不就得了~所以操作系统就大吼了一声:咱们的网关是谁来着.网关就会回答它,我就是,我在这儿呢.<br>上面的那一声吼,就是 ARP 协议,通过 ARP 协议,就知道了网关的具体地址,也就是 MAC 地址.<br>接下来这个数据包就到了网关那里.网关一般就是路由器,到某个 IP 地址怎么走,在一个叫做「路由表」中维护着.<br>出网关就比较复杂了,这里就不详细说了,具体可以看这篇文章: <a href="https://www.dynamic-zheng.com/posts/ff423025.html">[计算机网络]想出网关?你需要懂得这些</a></font></p><p><font face="华文中宋" size="3">出了网关之后,就需要拿出源 IP 地址和目标 IP 地址.因为只要出了网关,那就是在外面肉搏,如果没有源 IP 地址和目标 IP 地址,就不知道这个请求是从哪儿发出的,要往哪儿去.<br>现在这个数据包经过了重重关卡,终于找到了目标 IP 地址所在的服务器.此时服务器会首先发送一个接收请求,然后再将数据包一层层解析,在 TCP 头中含有目标端口号,通过这个端口号,就能够找到哪儿个程序的进程正在监听这个端口号,进而我们就找到了我们想要访问的网页.</font></p><p><font face="华文中宋" size="3">但是我怎么知道从我这里发出的数据包有没有丢失呢?所以此时 TCP 层会隔一段时间发送一次,这并不是说,页面又发送了一次请求,只是 TCP 自己在闷头重试,直到收到了接收请求.</font></p><p><font face="华文中宋" size="3">在我们找到了想要访问的网页之后,接下来就会像来的时候,再原路返回去.</font></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后:"></a><font face="华文中宋" size="3">最后:</font></h1><p><font face="华文中宋" size="3">没想到吧~一个简单的打开界面,竟然涉及到了这么多的知识~<br>当然你会发现在你输入网址之后敲回车,页面几乎是立刻出来了,这就涉及到了缓存,再深入讲的话,这篇文章就很长了.</font></p><p><font face="华文中宋" size="3">这里推荐几篇文章,想深入理解的建议读一下:</font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/a43453ce.html">[计算机网络] DNS 协议</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/4e5d330.html">[计算机网络] HTTPDNS 协议</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/d26db2c7.html">[计算机网络]简单聊聊套接字 Socket</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/e579f21d.html">[计算机网络] IP 地址与 MAC 地址之间的关系</a></font></p><p><font face="华文中宋" size="3"><a href="https://www.dynamic-zheng.com/posts/ff423025.html">[计算机网络]想出网关?你需要懂得这些</a></font></p><ul><li><font face="华文中宋" size="3">参考:<br>极客时间-趣谈网络协议</font></li></ul><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;写在前面&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在学习计算机网络的内容时,脑子里面突然冒出来一个问题:当我们在一个浏览器界面输入网址,回车到界面显示内容,这中间经历了什么?&lt;br&gt;先不要往下看,你能想到什么?&lt;br&gt;下面是我能想到的过程,有可能不是很准确,如有错误之处,还望指出.&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.dynamic-zheng.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.dynamic-zheng.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]在嘛,吱一声.吱...</title>
    <link href="https://www.dynamic-zheng.com/posts/bded181d.html"/>
    <id>https://www.dynamic-zheng.com/posts/bded181d.html</id>
    <published>2020-02-07T06:16:37.000Z</published>
    <updated>2020-02-07T06:18:57.996Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">好吧,题目是来搞笑的<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">如果问我过去的一年,最大的收获是什么?仔细想了想,其中一件事应该是认识了明白老师.<br>去年下半年加入明白老师的星球之后,又得以加入他的社群,进而和他本人有了更近的交流,更重要的是,我能近距离观察他.<br>和这篇文章有什么关系?因为我看了他的这篇文章:<a href="https://mp.weixin.qq.com/s/7FkMPMO_yONc_neEUQROVw" target="_blank" rel="noopener">为什么日更比周更容易？收益更大？</a></font></p><p><font face="华文中宋" size="3">任何事情,最难的就是第一步.当你踏出了第一步,就会踏出第二步,进而第三步第四步.<br>看完明白老师的文章之后,让我很触动.<br>说实话,我的博客更新频率挺低的,一周一篇.而且很多时候,不是没有时间和精力去写,而是自己各种犯懒,不想去写.<br>看到明白老师的这篇文章之后,我突然也想将更新的频率提高一些试试,看看自己的感受如何,成长如何.<br>我应该是做不到日更的.毕竟一篇技术文章,从选材,实践到组织语言形成一篇文章,没有两三天的时间写不出来的.(起码对于我这个渣渣来说是这样;<br>日更做不到,周更的频率高一点儿,努努力还是可以做到的.(也或者,我写着写着,突然就日更了呢,哈哈哈;</font></p><p><font face="华文中宋" size="3">之所以下定要将周更的频率再提高一些,除了这篇受明白老师这篇文章启发之外,还因为早些时候一起做的事情.<br>大概是在去年 8 月份,明白老师在群里问,他想要坚持每天做 3 件事,有没有人和他一起.我自然报名,但是我不知道我每天应该做哪些事情.<br>3 件事,一天很容易做到,两天也很容易,但是做到每天,就很难.<br>既然报名了,牛逼吹出去了,硬着头皮也要做下去.<br>那个时候给自己定的 3 件事是:工作,读书,锻炼.<br>也正是每天的这 3 件事,让我工作的时候,认真对待工作;上下班的路上,好好锻炼身体;晚上到家之后,读读书.<br>让我享受到了,诗和远方.<br>更重要的是,在这个过程中,我获得的掌控感,让我变的更加自信.<br>是啊,我能够每天坚持 3 件重要的事情,还有什么是我不能做到的呢.</font></p><p><font face="华文中宋" size="3">每天 3 件事,不贪多不贪少,这样的习惯保持到现在,受益匪浅.<br>也是基于这样的获益,看到明白老师决定日更,并且阐述了为什么日更比周更更容易,收益更大,也让我决定,提高自己的周更频率.</font></p><p><font face="华文中宋" size="3">最近在准备自考,这次考试科目是计算机网络.还有一直在学数据结构和算法的一些东西,所以接下来的博客更新,应该是这两个大方面:计算机网络 + 数据结构和算法<br>可能中间还会夹杂我的碎碎念,就像这一篇.</font></p><p><font face="华文中宋" size="3">总之,今天受了不少的刺激,在接下来的日子里,要好好努力了.<br>各位,可以一起来监督我呀~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;好吧,题目是来搞笑的&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]08 队列( Queue )以及队列实现的三种方式( Java 版)</title>
    <link href="https://www.dynamic-zheng.com/posts/a433947a.html"/>
    <id>https://www.dynamic-zheng.com/posts/a433947a.html</id>
    <published>2020-02-01T08:36:30.000Z</published>
    <updated>2020-02-01T08:39:17.272Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">年初生了一场大病,博客搁了几周,惭愧.今天来一篇.<br><a id="more"></a></font></p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a><font face="华文中宋" size="3">队列</font></h1><p><font face="华文中宋" size="3">说队列的时候,常常会想到栈,因为栈是后进先出,而队列则是先进先出.<br>关于栈,前面已经写过了:<a href="https://www.dynamic-zheng.com/posts/3671c55b.html">[数据结构与算法]05 Stack 经典面试题之判断字符串是否合法( Java 版)</a><br>这篇文章的主要焦点就在队列上了.</font></p><p><font face="华文中宋" size="3">队列,你的第一反应是不是排队?不管是在食堂买饭,还是在银行办理业务,或者进高铁站的时候,都会排队.<br>排队有一个很明显的特点:早来的人,就会早点儿办完事情.<br>这就是队列:先进先出.</font></p><p><font face="华文中宋" size="3">队列可以用数组实现,叫做顺序队列.也可以用链表实现,叫做链式队列.<br>在这里,分别用数组和链表来实现一下.</font></p><h1 id="数组实现队列"><a href="#数组实现队列" class="headerlink" title="数组实现队列"></a><font face="华文中宋" size="3">数组实现队列</font></h1><p><font face="华文中宋" size="3">使用数组来实现队列,相对来说还是比较简单的,因为数组和队列一样都是线性表结构.<br>废话不多说,咱们直接看代码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用数组实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-29 15:51:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       数组：items，数组大小：n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       head表示队头下标，tail表示队尾下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       申请一个大小为capacity的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">        n = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果tail == n 表示队列已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果head == tail 表示队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; i++) &#123;</span><br><span class="line">            System.out.print(items[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayQueue queue=<span class="keyword">new</span> ArrayQueue(<span class="number">5</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"1"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"4"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"5"</span>);</span><br><span class="line">        queue.dequeue();</span><br><span class="line">        queue.enqueue(<span class="string">"6"</span>);</span><br><span class="line"></span><br><span class="line">        queue.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">使用数组实现队列有个问题,就是删除不是真的删除,只是在打印的时候将 i 的值指向了 head 而已,但是要删除的数据,仍然在数组中.</font></p><h1 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a><font face="华文中宋" size="3">链表实现队列</font></h1><p><font face="华文中宋" size="3">使用链表实现队列也较为简单:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用链表实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-30 09:20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkListQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        队列的队首和队尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Node tail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node newNode = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line">            head = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> Node(value, <span class="keyword">null</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String value = head.data;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(p.data + <span class="string">" "</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String data, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkListQueue queue=<span class="keyword">new</span> LinkListQueue();</span><br><span class="line">        queue.enqueue(<span class="string">"3"</span>);</span><br><span class="line">        queue.enqueue(<span class="string">"2"</span>);</span><br><span class="line">        queue.dequeue();</span><br><span class="line">        queue.printAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈实现队列"><a href="#栈实现队列" class="headerlink" title="栈实现队列"></a><font face="华文中宋" size="3">栈实现队列</font></h1><p><font face="华文中宋" size="3">除了使用数组和链表实现,还有一种方法就是使用栈来实现队列.<br>使用栈来实现队列,顾名思义就是只能使用栈的操作: pop , push , peek 等,其他操作不允许出现,否则就不是使用栈来实现队列了.<br>使用数组和链表来实现栈都较为简单,因为在读取数据时,只需要按照顺序读取即可.<br>但是对于栈来说,顺序读取行不通,为什么呢?假设我的队列数据为 1,2,3,4 依次存入栈中之后再读取的话,则是 4,3,2,1 因为栈是后进先出.<br>如果使用栈来实现队列的话,需要用到两个栈.一个栈的输出顺序就是 4,3,2,1 在读取之前,我们把读取出来的数据存入到另外一个栈中,然后从后面这个栈读取,那么输出顺序就是 1,2,3,4 和原来队列的数据一致.<br>在这里要注意一点:当后面的栈中有数据,前面的栈中也有数据时,要先将后面的栈中数据读取完毕,再将前面的数据放到后面的数据中.<br>接下来看下代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈实现队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-1-30 17:21:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Stack&lt;Integer&gt; stackTemp = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Stack&lt;Integer&gt; stackQueue = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">       入队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stackTemp.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        出队</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 整个队列不为空时</span></span><br><span class="line">        <span class="keyword">if</span> (empty()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果 stackQueue 为空时,则将 stackTemp 中的数据放入 stackQueue 中</span></span><br><span class="line">            <span class="comment">// 如果 stackQueue 不为空,直接输出即可</span></span><br><span class="line">            <span class="keyword">if</span> (stackQueue.isEmpty())&#123;</span><br><span class="line">                backFill();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackQueue.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 整个队列为空,则返回 -1 ,代表队列中没有值</span></span><br><span class="line">            System.out.println(<span class="string">"队列为空"</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 判断队列是否为空,如果返回值为 0 ,则代表队列为空</span></span><br><span class="line">        <span class="comment">// 注意,两个栈均为空时,队列才为空</span></span><br><span class="line">        <span class="keyword">return</span> stackQueue.size() + stackTemp.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        将 stackTemp 中的数据放入 stackQueue 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backFill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stackTemp.isEmpty())&#123;</span><br><span class="line">            stackQueue.push(stackTemp.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StackQueue stack = <span class="keyword">new</span> StackQueue();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">以上,就是想要分享的内容了<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;年初生了一场大病,博客搁了几周,惭愧.今天来一篇.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[年终总结]愿你在以后的黑暗时刻,都能想起我</title>
    <link href="https://www.dynamic-zheng.com/posts/99fcee38.html"/>
    <id>https://www.dynamic-zheng.com/posts/99fcee38.html</id>
    <published>2020-01-01T13:21:48.000Z</published>
    <updated>2020-01-01T13:25:27.234Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">今天是新的一年开始.<br>这次的总结,不想像以前那样细数过去的一年发生了什么,经历了什么,我就随便写了,写到哪儿算哪儿(说白了就是碎碎念<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">过去的一年,我一直都觉得自己像是开挂了一样.自从打破了自己的一个认知局限之后,认识到了很多厉害的人,在和这些人的交流中,也慢慢让我变得很自信.<br>因为我看到他们,之所以能够成功,是因为有耐心,相信自己,敢冒险.反观一下我自己,我身上也有这些,那我和他们的差距就在于时间,所以我相信就目前的状态一直下去,有一天我也会变得很厉害,只不过是时间早晚的问题.<br>这样对于很多事情就不纠结了,主要是纠结也没用,还不如拿这些时间读读书,跑跑步.</font></p><p><font face="华文中宋" size="3">我现在想想,都觉得以前的自己真的是太拼了.你能想象我在大年三十那天早上,还写了一篇博客嘛;你能想象我在休息日的时候,还坚持读书和写作嘛.在过去的时间里,我得到了很多,但是也忽略了很多.有很多朋友,本来可以玩的更好的,但是因为我一心扑在工作上,所以很多次的邀约都拒绝了,说真的,以前的我和母亲视频都觉得是在浪费时间.<br>可能是因为在我小的时候,经历了那种无力感,那种痛苦,我到现在想起来都会泪流满面.<br>我特别害怕再经历这种事情,所以我就想要抓住一切时间去努力,因为我想让我成功的速度快过亲人老去的速度.<br>过去的一年改变了我的一些想法.观念转变应该是 6 月份和一位朋友的关系出现危机.我挺在乎她的,对我来说,她对我的意义就和家人一样重要,所以当我们之间的距离越来越远的时候,我很害怕,但是却发现我越是想要靠近,我们之间反而越是疏离,以至于到最后我不知道我该怎么做.<br>那段时间,碰巧亲人去世,工作上需要带领项目上线,我的心态崩溃过很多次,我开始怀疑自己这样做的对不对,不知道我努力的意义是什么.如果是让家人过上更好的生活,那我这样对他们不闻不问,几乎没有陪伴,就是对他们好嘛.<br>从那段时间之后,开始寻找工作和生活的一个平衡点.现在我学会了在休息日跑到北京只是为了找一家咖啡厅坐坐放空自己;学会了花费一天的时间去陪伴重要的人,哪怕只是逛逛街吃吃饭,或者是看看电影;学会了一整天都赖在家里,亲手做饭,或者只是在有阳光的午后躺在沙发上;也或者花一天的时间压马路,各种放空心情.<br>我发现当我这样去做之后,失去的固然有,比如技术上的成长,相对来说慢了一些,但是我却得到了很多.<br>在我难过的时候,会有朋友陪在身边;在我怀疑自己的时候,会有人鼓励我说我很棒;当我一心只是想要飞的更高的时候,总有朋友一直叮嘱我去按摩,照顾好自己的身体.</font></p><p><font face="华文中宋" size="3">慢下来之后,我发现原来生活不光光是工作,努力也不是只有一种方式.<br>就像是开窍一般,对发生的所有事情都心怀感恩,感激当下发生的一切.关于这一点,在一篇文章中其实是说过的:<a href="https://www.dynamic-zheng.com/posts/a353dbe7.html">[碎碎念]不知道该起什么题目的一篇文章</a>.<br>接受自己的平凡,承认自己是一个平凡的人,是一件很难的事情.我庆幸,现在的我就做到了,虽然做的不是很好.</font></p><p><font face="华文中宋" size="3">博客印象中是有一两周的时间没有写,以后再也不能说自己坚持每周写一篇博客了,气哭…<br>但是我可以说,一直在坚持写博客呀,哈哈哈哈哈<br>因为博客,认识了一群优秀的人.<br>反正技术这条路,真的是需要活到老,学到老的.</font></p><p><font face="华文中宋" size="3">过去的一年,我只做好了 4 件事:工作,读书,写作,锻炼.<br>说到这里,我突然想起来,前一段时间有人来问我,说我没办法坚持读书,我没办法坚持写作,我没办法坚持锻炼,问我为什么能够坚持下来.其实秘诀只有一个:我有同伴在和我一起同行.<br>有同伴一起同行,真的是一件超级幸福的事情,特别是相处让你觉得很舒服那种.和晓鸿开始真正熟悉,是当时我们一起在外出差,两个女孩子之间互相照顾,慢慢开始了解对方.后来和晓鸿说,要不要一起学习,一起在技术上做深入研究,她说可以.<br>我觉得我和晓鸿是那种,制定了计划,就一定要完成的那种人.所以在 19 年 10 月份的时候,我才敢说在 19 年结束之前,把计算机网络过一遍.和晓鸿一起学习,我们在 12 月份中旬就结束了,用了将近两个月的时间.<br>我说我想去学算法,她二话没说就和我一起学;我说我想去练字,也是二话没说就一起去练了;有一次我想要学一个资料,挺贵的,问她要不要一起学,也是二话没说就入了.有这样一个朋友一起前行,不可能坚持不下去的.</font></p><p><font face="华文中宋" size="3">过去的一年,影响了一些人.<br>我看到因为我自己坚持写博客,导致身边的人也开始写博客的时候;我看到因为我坚持读书,导致身边的人也开始养成读书习惯的时候;我看到因为我为了吃的更加健康,而不怎么吃主食,导致身边的人也开始慢慢不吃主食的时候,那种成就感很大.<br>有一种,哦,原来我也能影响别人,原来我的做法也能帮助一部分人找到他们热爱的事情,这种感觉想想都满脸骄傲.(以后走路横着走,哈哈哈;</font></p><p><font face="华文中宋" size="3">对于接下来的一年,我还是只想做好 4 件事:工作,读书,写作,锻炼.<br>这 4 件事做好了,其他就是享受当下.这样想想,对于接下来的一年,充满的是憧憬和感恩.</font></p><p><font face="华文中宋" size="3">最后感谢,感谢这一路一直帮助我的人,对我来说,他们都是贵人.<br>我也不知道此时的我能给他们带来什么,把这份感激都放在心底,希望有一天,我能让他们拿我来吹牛逼.</font></p><p><font face="华文中宋" size="3">对于我的父母,我一直都很感激,很感谢他们对于我一直都是舍得的.<br>现在能做的就是没事多和他们视视频,聊聊天.每次和母亲视频的时候,都能感受到她是很开心的.</font></p><p><font face="华文中宋" size="3">愿你在以后的黑暗时刻,都能想起我.因为在你黑暗的时刻,你能够想起我说明我对你来说是重要的,我是被需要的,我觉得很荣幸,能够被你当成这样重要的存在.(好吧,我承认我有些标题党了,挺煽情的一个题目,被我写成了碎碎念,逃;<br>如果让您有所收获,倍感荣幸.<br>就是这样了!<br>还有,新年快乐~<br>感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;今天是新的一年开始.&lt;br&gt;这次的总结,不想像以前那样细数过去的一年发生了什么,经历了什么,我就随便写了,写到哪儿算哪儿(说白了就是碎碎念&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="https://www.dynamic-zheng.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年终总结" scheme="https://www.dynamic-zheng.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]07 关于单链表环的操作( Java 版)</title>
    <link href="https://www.dynamic-zheng.com/posts/9b14f6f8.html"/>
    <id>https://www.dynamic-zheng.com/posts/9b14f6f8.html</id>
    <published>2019-12-29T00:39:33.000Z</published>
    <updated>2019-12-29T00:54:24.258Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">单链表经典操作,第一个是单链表反转,在这篇文章中已经写过了:<a href="https://www.dynamic-zheng.com/posts/745fa732.html">[数据结构与算法]04 Link List (链表)及单链表反转实现</a>,第二个是判断链表中是否有环,也就是今天这篇文章想要说的.<br><a id="more"></a></font></p><h1 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a><font face="华文中宋" size="3">判断链表是否有环</font></h1><p><font face="华文中宋" size="3">如图,我们能够清楚看到,这个链表是有环的.<br><img src="/images/2019/有环链表.jpg"></font></p><p><font face="华文中宋" size="3">咱们一起来分析一下</font></p><blockquote><p><font face="华文中宋" size="3">判断链表中是否有环,可以从头结点开始,依次遍历单链表中的每一个节点.每遍历一个节点,就和前面的所有节点作比较,如果发现新节点和之前的某个节点相同,则说明此节点被遍历过两次,说明链表有环,反之就是没有.</font></p></blockquote><p><font face="华文中宋" size="3">但是仔细看一下这种方法,你会发现这种方法很耗时耗力,因为每遍历一个节点,都要把它和前面所有的节点都比较一遍.<br>还有一个很巧妙的方法,就是使用两个指针.</font></p><blockquote><p><font face="华文中宋" size="3">使用两个指针,一个快指针,一个慢指针.<br>快指针每次走 2 步,慢指针每次走 1 步.<br>如果链表中没有环,则快指针会先指向 null<br>如果链表中有环,则快慢指针一定会相遇</font></p></blockquote><p><font face="华文中宋" size="3">基于这个思路,可以使用代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断链表是否有环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-12-28 09:44:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsHasLoop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data,Node next)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data=data;</span><br><span class="line">            <span class="keyword">this</span>.next=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化单链表</span></span><br><span class="line">        Node node5=<span class="keyword">new</span> Node(<span class="number">5</span>,<span class="keyword">null</span>);</span><br><span class="line">        Node node4=<span class="keyword">new</span> Node(<span class="number">4</span>,node5);</span><br><span class="line">        Node node3=<span class="keyword">new</span> Node(<span class="number">3</span>,node4);</span><br><span class="line">        Node node2=<span class="keyword">new</span> Node(<span class="number">2</span>,node3);</span><br><span class="line">        Node node1=<span class="keyword">new</span> Node(<span class="number">1</span>,node2);</span><br><span class="line">        <span class="comment">// 让 node5 的指针指向 node1 形成一个环</span></span><br><span class="line">        node5.next=node1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag=isHasLoop(node1);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHasLoop</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="comment">// 如果快慢指针相遇,则说明链表中有环</span></span><br><span class="line">            <span class="keyword">if</span> (slow==fast)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 反之链表中没有环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求环长"><a href="#求环长" class="headerlink" title=" 求环长"></a><font face="华文中宋" size="3"> 求环长</font></h1><p><font face="华文中宋" size="3">现在已经将链表中是否有环判断出来了,接下来扩展一下,求环长.</font></p><p><font face="华文中宋" size="3">先理一下整体思路:<br>当快慢指针第一次相遇时,我们可以记录下此时的位置.<br>接下来让慢指针继续走,每次走 1 步,直到走到第一次相遇的地方,此时慢指针走过的长度即为环长<br>基于这样的思路,就可以将代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义环长初始值为 0</span></span><br><span class="line">        <span class="keyword">int</span> loopLength=<span class="number">0</span>;</span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次相遇时跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fast next 指针首先指向 null 指针,说明该链表没有环,则环长为 0</span></span><br><span class="line">        <span class="keyword">if</span>(fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有环,使用临时变量保存当前的链表</span></span><br><span class="line">        Node temp = slow;</span><br><span class="line">        <span class="comment">// 让慢指针一直走,直到走到原来位置</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            loopLength++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loopLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求入环点"><a href="#求入环点" class="headerlink" title="求入环点"></a><font face="华文中宋" size="3">求入环点</font></h1><p><font face="华文中宋" size="3">求入环点有点儿绕,咱们先来上一张图:<br><img src="/images/2019/入环点.jpg"><br> <font face="华文中宋" size="3">如上图,假设:<br>入环点距离头结点距离为 D<br> 入环点与首次相遇点较短的距离为 S1<br> 入环点与首次相遇点较长的距离为 S2</font></font></p><blockquote><p><font face="华文中宋" size="3"> 当两个指针首次相遇时,慢指针一次只走 1 步,则它所走的距离为: D+S1<br>快指针每次走 2 步,多走了 n(n&gt;=1) 圈,则它所走的距离为: D+S1+n(S1+S2)<br>快指针速度为慢指针的 2 倍,则: 2(D+S1)=D+S1+n(S1+S2)<br>上面等式,整理可得: D=(n-1)(S1+S2)+S2</font></p></blockquote><p><font face="华文中宋" size="3">如果让 (n-1)(S1+S2) 为 0 ,是不是 D 和 S2 就相等了?也就是说,当两个指针第一次相遇时,只要把其中一个指针放回到头结点位置,另外一个指针保持在首次相遇点,接下来两个指针每次都向前走 1 步,接下来这两个指针相遇说,就是要求的入环点.<br>有点儿像做数学题的感觉~<br>基于这样的思路,可以将代码实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">entryNodeOfLoop</span><span class="params">(Node list)</span></span>&#123;</span><br><span class="line">        Node slow=list;</span><br><span class="line">        Node fast=list;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 慢指针走一步,快指针走两步</span></span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一次相遇时跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 fast next 指针首先指向 null 指针,说明该链表没有环,则入环点为 null</span></span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一次相遇之后,让一个指针指向头结点,另外一个指针在相遇位置</span></span><br><span class="line">        <span class="comment">// 两个指针每次走 1 步,相遇为止,此时相遇节点即为入环点</span></span><br><span class="line">        Node head=list; <span class="comment">// 头结点</span></span><br><span class="line">        Node entryNode=slow;    <span class="comment">// 相遇节点</span></span><br><span class="line">        <span class="keyword">while</span> (entryNode != head)&#123;</span><br><span class="line">            entryNode=entryNode.next;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entryNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <font face="华文中宋" size="3">关于链表的一些操作差不多就是这些了.<br> 其实仔细观察能够看到,不管是求环长,还是找到入环点,最关键的是找到第一次相遇时所在的位置,基于这一点,接下来的问题就比较容易解决.</font></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考:"></a><font face="华文中宋" size="3">参考:</font></h1><p><font face="华文中宋" size="3"> &lt;漫画算法&gt;-程序员小灰<br> 以上,感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;单链表经典操作,第一个是单链表反转,在这篇文章中已经写过了:&lt;a href=&quot;https://www.dynamic-zheng.com/posts/745fa732.html&quot;&gt;[数据结构与算法]04 Link List (链表)及单链表反转实现&lt;/a&gt;,第二个是判断链表中是否有环,也就是今天这篇文章想要说的.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]06 数组( Array )</title>
    <link href="https://www.dynamic-zheng.com/posts/99ead990.html"/>
    <id>https://www.dynamic-zheng.com/posts/99ead990.html</id>
    <published>2019-12-22T12:59:48.000Z</published>
    <updated>2019-12-22T13:02:07.524Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">什么是数组呢?你的脑海中是不是第一反应是这样的:<br><a id="more"></a></font></p><blockquote><p><font face="华文中宋" size="3"> 数组 ( Array )是一种线性表数据结构,它用一组连续的内存空间,来存储一组具有相同类型的数据.</font></p></blockquote><p><font face="华文中宋" size="3">在定义上,咱们来死扣两个概念.</font></p><ul><li><font face="华文中宋" size="3">线性表.<br><font face="华文中宋" size="3">线性线性,就是数据排成像一条线一样的结构,每个线性表上的数据最多只有前和后两个方向.这样看定义的话,除了数组,链表,队列,栈也是线性表结构.</font></font></li><li><font face="华文中宋" size="3">是一组连续的内存空间,存储一组具有相同类型的数据.<br><font face="华文中宋" size="3">这句话能够看出来,对于数组有两个限制:第一空间必须是连续的,第二,数据需要是相同类型的.<br>也就是说,如果内存空间剩余 1MB 但是不是连续的,此时创建数组就会失败;如果数组内存储的不是相同类型的数据,就会报错</font></font></li></ul><h2 id="数组是如何实现”随机访问”的"><a href="#数组是如何实现”随机访问”的" class="headerlink" title="数组是如何实现”随机访问”的"></a><font face="华文中宋" size="3">数组是如何实现”随机访问”的</font></h2><p><font face="华文中宋" size="3">当我们申请创建一个数组时,比如此时我申请一个数组 <code>int[] a = new int[10]</code> ,计算机会给数组 <code>a[10]</code> 分配一块连续内存空间.<br>计算机会给每个内存单元分配一个地址,通过地址来访问内存中的数据.当计算机需要随机访问数组中的某个元素时,它会首先通过下面的寻址公式,来计算出想要访问元素的存储内存地址:</font></p><blockquote><p>a[i]_address = base_address + i * data_type_size</p></blockquote><p><font face="华文中宋" size="3">根据 CPU 的预读机制,存储的数组就有可能被 CPU 全部读入,在 CPU 中进行访问,那个速度你可以想象~</font></p><h2 id="警惕数组越界问题"><a href="#警惕数组越界问题" class="headerlink" title="警惕数组越界问题"></a><font face="华文中宋" size="3">警惕数组越界问题</font></h2><p><font face="华文中宋" size="3">咱们先来看一段 C 语言代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">arr[i]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">仔细看,发现问题了嘛?这段代码不会打印 3 行” hello world “,而是会无限打印” hello world “.<br>因为,数组大小为 3 , a[0] , a[1] , a[2] ,实例代码中因为书写错误,导致 for 循环的结束条件错写成了 <code>i&lt;=3</code> ,而不是 <code>i&lt;3</code> ,所以当 <code>i=3</code> 时,会导致数组 <code>a[3]</code> 访问越界.在 C 语言中,只要不是访问受限的内存,那么所有的内存空间都是可以自由访问的.如果 <code>a[3]=0</code> 恰好是 <code>i=0</code> ,循环就会又开始.<br>所以这段代码就陷入了死循环.</font></p><hr><p><font face="华文中宋" size="3">参考:</font></p><ul><li><font face="华文中宋" size="3"> 极客时间&lt;数据结构与算法之美&gt;</font></li></ul><p><font face="华文中宋" size="3">以上,感谢您的阅读(这篇文章确实写得有些仓促了,逃;<br>最后,祝您冬至快乐~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;什么是数组呢?你的脑海中是不是第一反应是这样的:&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]不知道该起什么题目的一篇文章</title>
    <link href="https://www.dynamic-zheng.com/posts/a353dbe7.html"/>
    <id>https://www.dynamic-zheng.com/posts/a353dbe7.html</id>
    <published>2019-12-14T13:15:29.000Z</published>
    <updated>2019-12-14T13:16:35.878Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">这篇文章我是真的不知道该起一个什么样的题目,因为想要说的东西有些杂.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">在我身边的人应该对我比较清楚,以前的我可以说是「拼命三郎」,就算是休息也能看到我继续在技术上做一些研究,甚至我有时候不想和我母上大人视频聊天,为什么?因为我觉得和她视频聊天的时间,我还不如用来学习呢.<br>所以最近下班回到家,就抱着手机看奇葩说的时候,身边的小伙伴都惊呆了,说我变了,说我以前不是这样的.<br>emmm ,我不知道该怎么去做回应.只是觉得人变了,是一件很正常的事情.组成人身体的每个细胞,每时每刻都在变化,忘记了在哪儿看到的一句话,人全身的细胞每 7 年会换一次,所以只是从生理上来说,人每时每刻都在变化.从思想上说,小时候的你和现在的你,想法应该也是不一样的.<br>不管是从生理上,还是思想上你都在变化,所以我变了,它本身就是一件很正常的事情.<br>我知道我的小伙伴接受不了的是,我以前是一个在技术上深究的人,最近怎么看起了奇葩说.说实话,我没觉得这两者对我来说有什么不一样.因为对我来说,不管是在技术上做一些研究,还是去看视频,都是学习.<br>我是认真的,我真的从看视频这件事情上学到了很多.</font></p><p><font face="华文中宋" size="3">我以前是一个很敏感的人,敏感到如果身边的人不开心,我会想,是不是我哪里做错了,是不是我说的哪句话不得体了,是不是我得罪人家了,所以人家才会不开心,才会给我摆脸色看.可是看到奇葩说之后,我才知道可能仅仅是对方刚好心情不好而已,和我没什么关系,所以现在如果我再陷入那种思维的话,我就会这样提醒自己,然后我发现,现在的我每天都超级开心,是发自内心的那种;<br>我小的时候看事情,就是非黑即白,甚至是现在,有时候对一些事情的看法也会比较偏执,最近看奇葩说,常常会让我惊叹,我去竟然还可以从这个角度去思考,我天竟然还能再提升一个层次,所以现在我意识到我的看法比较偏执的时候,我就会想是不是我的思考角度太单一了,有没有另外的角度去考虑,我能不能再提高一个层次去看这个问题;<br>这是这个节目带给我的一些思考.<br>所以,对我来说,这又何尝不是学习?</font></p><p><font face="华文中宋" size="3">我常常觉得,人生就像做技术一样.做技术的话,你会发现想要继续向上走,你就必须再回到计算机网络,数据结构和算法,计算机组成原理这种底层上面来;人生也是如此,如果想要继续向前走,就必须明白自己的性格是怎样的,如何和自己的情绪对话,弄清楚自己的欲望.<br>当你把自己的底层操作系统弄明白之后,你这个人会很厉害.因为很多人究其一生都不明白,当然这其中也包括我.</font></p><p><font face="华文中宋" size="3">最近在看佛学的一些东西,我觉得佛学真的是一件很神奇的事情,小的时候总觉得佛学挺苦的,一提到佛教我脑袋里面冒出的想法就是:不能吃肉,不能喝酒,要禁欲这种.<br>在明白老师和乔老师的影响下去看佛学,我有些明白,其实佛学想要教的不是禁欲,而是放下我执.<br>仔细想想,为什么我们会常常感到烦恼?因为我们总是觉得,我和别人不一样,我不是一般人,我怎么能被命运这样对待呢.但是想想为什么不应该呢.不要把自己看得太重,烦恼就会少很多.</font></p><p><font face="华文中宋" size="3">有我微信好友的人应该知道,我特别喜欢在朋友圈里面秀.我喜欢秀今天这个朋友约我出去玩,明天那个朋友要带我去哪儿哪儿玩,以至于有的人就以为我的生活每天都挺好的,不是今天计划去那儿,就是明天去那儿.<br>之所以这样以为,是因为你没看到我为了项目熬夜通宵的时候,你没看到我压力大到崩溃的时候,你没看到我痛苦迷茫的时候.<br>每个人都是不容易的,可是如果每天眼睛里面只有这些事情的时候,你的心情很难美丽.如何保持对生命的敬畏,如何保持对生命的好奇?我觉得最重要的一点就是:感恩.<br>当我明白这一点之后,我开始享受和母上大人的视频时间,我开始感恩身边的人对我的善意,现在哪怕一天我什么都不做,就在家赖着躺一天,我的内心第一反应不再是苛责自己怎么可以这样浪费时间,而是感恩给了自己一天的时间去放空自己.<br>当我每天都是这样的感恩心态的时候,我发现了更多生活中的美好,而这又让我特别感恩.<br>这个正循环让我在某种程度上放下了我执.<br>我能清楚感觉到,有时候我还是会控制不住自己的脾气,还是会把自己看得很重,但是那又怎样呢.<br>惯性这种事情,总得慢慢来不是.况且我还这么年轻,一点儿都不着急~</font></p><p><font face="华文中宋" size="3">写这篇文章,纯粹是因为最近一周技术上没什么输入,各种碎碎念.<br>如果对您有所启发,倍感荣幸.</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;这篇文章我是真的不知道该起一个什么样的题目,因为想要说的东西有些杂.&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[计算机网络]想出网关?你需要懂得这些</title>
    <link href="https://www.dynamic-zheng.com/posts/ff423025.html"/>
    <id>https://www.dynamic-zheng.com/posts/ff423025.html</id>
    <published>2019-12-05T12:43:51.000Z</published>
    <updated>2019-12-05T12:50:28.719Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在学算法之余,也在学习计算机网络方面的东西,就是极客时间上刘超老师的&lt;趣谈网络协议&gt;那门课程,其中有一篇讲得非常有意思,也有些难以理解,我以我的角度来谈谈.<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">想要跨网段访问的话,有一关是必须要过的:网关( Gateway )<br>配置好 IP 地址和网关之后,就能够自由访问上网了,想访问哪儿网站就访问哪儿个网站,各种浪.但是在进行跨网访问的时候,会牵扯到 MAC 地址和 IP 地址的变化,所以咱们先来知道一下 MAC 头和 IP 头的细节.</font></p><p><font face="华文中宋" size="3">MAC 头和 IP 头的细节(画的不是太好哈):<br><img src="/images/2019/mac-and-ip.jpg"></font></p><p><font face="华文中宋" size="3">简单来说一下内容:<br>目标 MAC 地址和源 MAC 地址应该不需要说明什么了,协议类型是为了说明里面是 IP 协议<br>版本( Version ):占 4 位,用来表明 IP 协议实现的版本号,目前来说主流还是 IPV4<br>服务类型 TOS ( Type of Service ):占 8 位,其中前 3 位比特为优先权字段,第 8 位保留未用,第 4 至 7 位分别代表延迟,吞吐量,可靠性和花费.<br>总长度:占 16 位,说明整个数据报的长度(以字节为单位),最大长度为 65535 字节<br>标识:占 16 位,用来唯一标识主机发送的每一份数据报,通常每发一份报文,它的值会加 1<br>标志:占 3 位,标志一份数据报是否要求分段<br>片偏移:占 13 位,如果一份数据报要求分段的话,该字段指明该段偏移距原始数据报开始的位置<br>生存期 TTL ( Time to Live ):占 8 位,用来设置数据报最多可以经过的路由器数,由发送数据的源主机设置,通常为 32,64,128 等.没经过一个路由器,它的值减 1,直到 0 时该数据报被丢弃.<br>协议:占 8 位,用来说明 IP 层所封装的上层协议类型,如 ICMP( 1 ), IGMP( 2 ), TCP( 6 ), UDP( 17 )等.<br>首部校验和:占 16 位,根据 IP 头部计算得到的校验和码.<br>源 IP 地址,目标 IP 地址:各占 32 位,用来标明发送 IP 数据报文的源主机地址和接收 IP 报文的目标主机地址.</font></p><p><font face="华文中宋" size="3">在任何一台机器上,如果想要访问另一个 IP 地址时,都会先判断,要访问的目标 IP 地址,与当前机器 IP 地址是否在同一个网段内.<br>如果是同一个网段,这就好说了,直接将源地址和目标地址放入到 IP 头中,然后通过 ARP 得到 MAC 地址,将源 MAC 和目标 MAC 放入 MAC 头中,发出去就 OK 了.<br>但是如果不是同一个网段呢,这就需要发往默认网关 Gateway 了.Gateway 的地址一定是和源 IP 地址是同一个网段的,如果不是第一个,就是第二个.比如, 192.168.1.0/24 这个网段,Gateway 一般就是 192.168.1.1/24 或者 192.168.1.2/24.因为网关和源 IP 地址在同一个网段内,所以发给 Gateway 的过程和上面同一个网段的过程是一样的.网关接收到之后,接下来怎么处理就是它自己的事情了.<br>做了上面那么多的铺垫,终于来到了今天想要说的主要内容:网关是怎么将数据跨网段发送出去的.因为在这里面涉及到了 IP 地址和 MAC 地址的变化.</font></p><p><font face="华文中宋" size="3">MAC 地址是在一个局域网内才有效的地址,所以 MAC 地址只要经过网关,就一定会改变,因为经过网关就意味着换了局域网.主要在于 IP 地址是否改变.如果 IP 地址不改变,那我们就将网关称为转发网关;如果 IP 地址改变,则将网关称为 NAT 网关.<br>先来说一下转发网关:<br><img src="/images/2019/transfor.jpg"></font></p><p><font face="华文中宋" size="3">如图,我们能够看到,服务器 A 的 IP 地址为 192.168.1.101/24 ,服务器 B 的 IP 地址为 192.168.4.101/24 ,现在服务器 A 想要访问服务器 B,不在同一个网段内,怎么办呢?肯定要经过网关的,对吧(因为 IP 头和 MAC 头里面的内容太多了,在这里主要写出 MAC 和 IP 内容)<br>此时,服务器 A 会给路由器 A 发送这样的内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :服务器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 A 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 A 接收到内容之后,发现是想访问 192.168.4.0/24 的,根据配置的路由规则,将要发送的内容通过 192.168.2.1 这个口发送出去,发送给路由器 B 的内容是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 B 接收到了来自路由器 A 的内容,它发现是想访问 192.168.4.0 这个地址,根据配置的路由规则,需要从 192.168.4.1 这个口出去,这样就能发给服务器 B,此时路由器 B 发送的包是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 B 的 MAC</span><br><span class="line">目标 MAC : 服务器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.4.101 (即服务器 B 的 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">至此,服务器 A 发送的内容就到达了服务器 B .<br>咱们来总结一下以上内容:在转发网关下,我不 care 其他的,我只知道我要发给哪儿个 IP ,所以在整个过程中,源 IP 和目标 IP 都没有发生改变.</font></p><p><font face="华文中宋" size="3">接下来咱们来说说 NAT 网关.照例,上个图:<br><img src="/images/2019/NAT.jpg"></font></p><p><font face="华文中宋" size="3">有没有发现一个问题,服务器 A 的 IP 地址是 192.168.1.101 ,要访问的服务器 B 的地址也是 192.168.1.101 ,如果只是看 IP 地址的话,是不是饶了一圈发现,这不就是自己访问自己嘛?惊不惊喜.<br>但是实际上服务器 A 在北京,服务器 B 在上海,两个地方有一个相同的 IP 地址罢了.问题就来了,服务器 A 怎么就可以访问到服务器 B 了呢?<br>就像上海人说上海话,北京人说北京话,一个区域内大家都听得懂,但是如果北京人跑到上海去,想要交流怎么办呢?说普通话呗,对不对.在网络中也可以这样做.既然这两个局域网之间没有商量过,各自使用各自的,内部使用的话这都没事儿,但是如果想要在外面也走的开,就需要制定规则.也就是说,路由器 A 和 B 在外网上需要有一个大家都公认的身份.<br>在图中我们能够看到路由器 A 在公网上的身份是 192.168.2.1/24 ,路由器 B 在公网上的身份是 192.168.2.2/24 .有了公认的身份之后,来看看接下来发送的内容:<br>服务器 A 发送给路由器 A 的内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :服务器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 A 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.1.101 (即服务器 A 的 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.2.2 (即路由器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">路由器 A 接收到内容之后,根据配置的路由规则,通过 192.168.2.1/24 发送给路由器 B ,此时发送的内容为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 A 的 MAC</span><br><span class="line">目标 MAC : 路由器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.2.1 (即路由器 A 的公网 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.2.2 (即路由器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">内容到达路由器 B 之后,根据它的配置规则,发现是想要发送给服务器 B 的,此时:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源 MAC :路由器 B 的 MAC</span><br><span class="line">目标 MAC : 服务器 B 的 MAC</span><br><span class="line">源 IP : <span class="number">192.168</span>.2.1 (即路由器 A 的公网 IP )</span><br><span class="line">目标 IP : <span class="number">192.168</span>.1.101 (即服务器 B 的公网 IP )</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">至此,服务器 A 发送的内容就到达了服务器 B .<br>咱们来总结一下以上内容:在 NAT 网关下, MAC 地址和 IP 地址都是会改变的. MAC 地址还好理解一些,要发送给谁,那么目标 MAC 地址就是要发送的机器 MAC 地址即可.但是 IP 地址如果是跨网段访问,则都需要通过公网 IP 来进行才可以.</font></p><p><font face="华文中宋" size="3">以上就是想要分享的内容,如果有错误之处,还希望指出哇~<br>感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在学算法之余,也在学习计算机网络方面的东西,就是极客时间上刘超老师的&amp;lt;趣谈网络协议&amp;gt;那门课程,其中有一篇讲得非常有意思,也有些难以理解,我以我的角度来谈谈.&lt;br&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://www.dynamic-zheng.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://www.dynamic-zheng.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[数据结构与算法]05 Stack 经典面试题之判断字符串是否合法( Java 版)</title>
    <link href="https://www.dynamic-zheng.com/posts/3671c55b.html"/>
    <id>https://www.dynamic-zheng.com/posts/3671c55b.html</id>
    <published>2019-11-26T11:56:55.000Z</published>
    <updated>2019-11-30T03:11:28.315Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">Stack (栈): 后进先出( Last In First Out ),也就是说后面进来的,会先出去.<br><a id="more"></a><br>说到这个场景,我就会想起烙饼这件事.每次母上大人烙饼的时候,先烙好的饼会放在最下面,后面烙好的饼会放在上面,还在烙饼的时候,我就想吃所以被我吃到的就是最上面的饼.<br>感觉这个过程是不是和栈这种数据结构很像~</font></p><p><font face="华文中宋" size="3">对于 Stack 来说,经典的面试题莫过于,判断字符串是否合法了.<br>判断字符串是否合法是这样的:有一个字符串,它只包含大中小括号,那么符号 ([)] 这样是不合法的,合法的应该是这样: ([]) ,同样 ([]){ 这样的符号也是不合法的<br>基于以上的共识,咱们先考虑使用数组的方式,来分析一下.</font></p><p><font face="华文中宋" size="3">1.  定义一个初始值,如果刚开始输入的就是 ( 或者 { 或者 [ ,那么我们不能立刻判断到它就是不合法的,因为它需要等待匹配,如果到最后还是没有匹配上,那就是不合法的;如果刚开始输入的是 ) 或者 } 或者 ] ,我们立刻就能知道这是不合法的.</font></p><p><font face="华文中宋" size="3">2.  如果此时输入了 ( 和 [ ,初始值应该 ++ ,接下来输入的是右边的符号的话应该是 ] 而不是 ) ,此时需要进行判断第三个输入的字符是否匹配第二个,只有第二个也匹配之后才需要进行匹配第一个字符.</font></p><p><font face="华文中宋" size="3">3.  如果匹配成功,则初始值应该 - - ,所有字符串匹配完毕之后,需要看初始值是否为最初赋予的值,如果是则说明所有符号都是合法的,否则说明还有符号没有匹配上,则不合法<br>经过这样的分析之后,写代码应该就比较好写了,比如我们可以这样实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否合法</span></span><br><span class="line"><span class="comment"> *      比如: "([)]" 不合法, "[()]" 合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-11-24 20:05:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsValidString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义字符串的内容</span></span><br><span class="line">        String symbol=<span class="string">"([])&#123;"</span>;</span><br><span class="line">        <span class="comment">// 调用判断方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result=isValid(symbol);</span><br><span class="line">        System.out.print(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 用来接收传入的值</span></span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="comment">// 定义一个数组,用来存放传入的字符串,长度为传入的字符串的值</span></span><br><span class="line">        <span class="keyword">char</span>[] stack = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="comment">// 定义 stackEnd 为 -1 是为了让第一个元素能够进入数组,即 stackEnd++ 值为 0</span></span><br><span class="line">        <span class="keyword">int</span> stackEnd=-<span class="number">1</span>,length=s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果刚开始是左括号,左中括号等符号,则不能直接判断为该符号不合法,而是放入数组,等待匹配</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i]==<span class="string">'('</span> || arr[i]==<span class="string">'['</span> || arr[i]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                stackEnd++;</span><br><span class="line">                stack[stackEnd]=arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果刚开始就是右括号,右中括号等符号,则不合法,直接返回 false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((arr[i]==<span class="string">']'</span> || arr[i]==<span class="string">')'</span> || arr[i]==<span class="string">'&#125;'</span>) &amp;&amp; stackEnd==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 分情况来进行匹配</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i]==<span class="string">')'</span> &amp;&amp; stack[stackEnd]==<span class="string">'('</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">']'</span> &amp;&amp; stack[stackEnd]==<span class="string">'['</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">'&#125;'</span> &amp;&amp; stack[stackEnd]==<span class="string">'&#123;'</span>)&#123;</span><br><span class="line">                    stackEnd--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 如果都匹配不到,说明该符号不合法,则直接返回 false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stackEnd!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果最后结果不等于 -1 ,说明 stackEnd 中还有符号没有被匹配到,则也是不合法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">可以明显看到,使用数组的话,会有很多 if , else , else if ,仿佛闻到了坏代码的味道.<br>如果使用栈来实现呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断字符串是否合法</span></span><br><span class="line"><span class="comment"> *      比如: "([)]" 不合法, "[()]" 合法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑璐璐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@datetime</span> 2019-11-24 20:05:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsValidString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义字符串的内容</span></span><br><span class="line">        String symbol=<span class="string">"([])&#123;"</span>;</span><br><span class="line">        <span class="comment">// 调用判断方法</span></span><br><span class="line">        <span class="keyword">boolean</span> result=isValid(symbol);</span><br><span class="line">        System.out.print(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个空栈</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 定义 map ,用来存放匹配的符号</span></span><br><span class="line">        Map&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr=s.toCharArray();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 如果 map 中不包含进入的符号,说明是左边的符号,直接入栈即可</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(arr[i]))&#123;</span><br><span class="line">                stack.push(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果进入的符号和栈顶的元素不匹配,则说明符号不合法</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(arr[i])!=stack.pop())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断栈是否为空,如果为空,说明所有符号都已匹配完毕,全都合法</span></span><br><span class="line">        <span class="comment">// 如果栈不为空,说明还有符号没有匹配到,则不合法</span></span><br><span class="line">        <span class="keyword">if</span> (stack.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">嗯,看起来简洁了不少.<br>欢迎评论区交流,感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;Stack (栈): 后进先出( Last In First Out ),也就是说后面进来的,会先出去.&lt;br&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://www.dynamic-zheng.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
