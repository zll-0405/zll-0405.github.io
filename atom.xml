<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑璐璐|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dynamic-zheng.com/"/>
  <updated>2020-12-12T12:02:50.483Z</updated>
  <id>https://www.dynamic-zheng.com/</id>
  
  <author>
    <name>郑璐璐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java 并发]为什么启动线程时使用 start 而不是 run ?</title>
    <link href="https://www.dynamic-zheng.com/posts/335e06cd.html"/>
    <id>https://www.dynamic-zheng.com/posts/335e06cd.html</id>
    <published>2020-12-12T12:00:32.000Z</published>
    <updated>2020-12-12T12:02:50.483Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在多线程中,如果想让一个线程启动,你使用的方法一定是 <code>thread.start()</code> 方法,而不是 <code>thread.run()</code> 方法(啥,你用的不是 <code>thread.start()</code> 方法?你的打开方式不对哦,下次不要这样了~<br><a id="more"></a><br>有没有疑惑,为什么每次我们都习惯调用 <code>start()</code> 方法,为什么不直接调用 <code>run()</code> 方法来启动线程呢?<br>而且如果去看源码的话,你会发现,在 <code>thread.start()</code> 方法中,其实最后还是调用了 <code>thread.run()</code> 方法来执行</font></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Causes <span class="keyword">this</span> thread to begin execution; the Java Virtual Machine</span><br><span class="line"> calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面的注释翻译一下:当线程开始执行时, JVM 会调用此线程的 run 方法<br>也就是说,线程的 run 方法是由 JVM 直接调用的,在 Java 中如果我们想要直接调用 run 方法也是可以的,因为在 Java 中 run 方法是 public 的</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">那既然 start 方法最后调用的也是 run 方法,再加上 run 方法本身支持直接调用,那为啥我们平时写的程序都是调用 start 方法,而不是 run 方法呢<br>那是因为,如果直接调用 run 方法,就不是多线程了<br>为了方便解释,咱们看个小 demo :</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread runThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"Run begin another , 当前线程 : %s.%n"</span> ,Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        runThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接调用 run 方法 -- 演示使用,实际中不要这么做!</span></span><br><span class="line">        runThread.run();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Run begin , 当前线程 : %s.%n"</span> ,Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面的程序运行结果如下:<br><img src="/images/2020/thread-run.jpg"></font></p><p><font face="华文中宋" size="3">你会发现, <code>runThread</code> 的 <code>run</code> 方法被执行了两次<br>一次是 run 方法运行在自己的线程中,从 <code>Run begin another , 当前线程 : Thread-0</code> 可以看到,这个线程是运行在 <code>Thread-0</code> 中<br>另外一次是因为我们的程序代码直接调用了 run 方法,此时的线程运行在 main 线程中,从 <code>Run begin another , 当前线程 : main</code> 可以看出来<br>也就是说,如果我们直接调用 run 方法的话,线程并不是运行在自己的线程中,而是运行在了当前线程中</font></p><p><font face="华文中宋" size="3">我们为什么要创建多线程?不就是希望多个线程并行执行,比如现在我是线程 A ,此时又起了一个线程,那么我希望这个线程是和线程 A 一起运行的,如果直接调用了 run 方法的话,就运行在线程 A 里面来了<br>并没有达到创建多线程的目标,这怎么行呢,对不对<br>所以在启动线程时,都是使用 start 方法,而不是 run 方法</font></p><p><font face="华文中宋" size="3">这一点,其实在源码中也有说明:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the Java Virtual Machine calls the run method of <span class="keyword">this</span> thread.</span><br><span class="line">The result is that two threads are running concurrently: </span><br><span class="line"><span class="function">the current <span class="title">thread</span> <span class="params">(which returns from the call to the start method)</span> </span></span><br><span class="line"><span class="function">and the other <span class="title">thread</span> <span class="params">(which executes its run method)</span>.</span></span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在 JVM 调用线程的 run 方法之后,结果就是两个线程同时运行:</font></p><ul><li><font face="华文中宋" size="3">当前线程(从调用返回到 start 方法)</font></li><li><font face="华文中宋" size="3"> 另一个线程(执行 run 方法)</font></li></ul><p><font face="华文中宋" size="3">以上,感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在多线程中,如果想让一个线程启动,你使用的方法一定是 &lt;code&gt;thread.start()&lt;/code&gt; 方法,而不是 &lt;code&gt;thread.run()&lt;/code&gt; 方法(啥,你用的不是 &lt;code&gt;thread.start()&lt;/code&gt; 方法?你的打开方式不对哦,下次不要这样了~&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]这周没有输入的我</title>
    <link href="https://www.dynamic-zheng.com/posts/76fe9e7d.html"/>
    <id>https://www.dynamic-zheng.com/posts/76fe9e7d.html</id>
    <published>2020-12-06T13:01:20.000Z</published>
    <updated>2020-12-06T13:02:24.082Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">一篇没有营养的文章<br>这不是今年的最后一个月了嘛,所以我最近的精力就在年终总结上了,写了几个版本都不满意,还在重新推翻重新写<br>然后,最后的这一个月,除了工作时间,其他时间几乎都约出去了,想着在 2021 年之前尽可能多见一些自己在乎的人吧,如果再不见的话,再见面就是 2021 年了,仪式感还是要有的</font></p><p><font face="华文中宋" size="3">这几天简单的复盘了一下去年的目标,除了一个目标没有实现之外,其他的目标都实现了,整体来说,对自己的表现还算满意吧,其实有些地方还是可以做的更好的,那就是明年要改进的地方了<br>今天和几个朋友去吃好吃的去了,吃了一肚子肉回来的我,现在满脑子大搞就是想要睡觉了~</font></p><p><font face="华文中宋" size="3">这周文章就是这样,没啥营养<br>依旧感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;一篇没有营养的文章&lt;br&gt;这不是今年的最后一个月了嘛,所以我最近的精力就在年终总结上了,写了几个版本都不满意,还在重新推翻重新写&lt;br&gt;然后,最后的这一个月,除了工作时间,其他时间几乎都约出去了,想着在 2021 年之前
      
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[Java]面试官你能不能别问我 HashMap 了?</title>
    <link href="https://www.dynamic-zheng.com/posts/7163f33e.html"/>
    <id>https://www.dynamic-zheng.com/posts/7163f33e.html</id>
    <published>2020-11-29T11:54:58.000Z</published>
    <updated>2020-12-05T13:19:41.821Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果你是个 Java 程序员,那一定对 HashMap 不陌生,巧的是只要你去面试,大概率都会被问到 HashMap 的相关内容<br>基于此,就总结一篇,争取不让面试官问倒~<br><a id="more"></a></font></p><h1 id="HashMap-的底层数据结构"><a href="#HashMap-的底层数据结构" class="headerlink" title="HashMap 的底层数据结构"></a><font face="华文中宋" size="3">HashMap 的底层数据结构</font></h1><p><font face="华文中宋" size="3">先来聊聊 HashMap 的底层数据结构<br>HashMap 的底层数据结构, 1.7 版本和 1.8 版本是有些不同的,但大体上都是 数组 + 链表 的形式来实现的<br>1.7 版本是这个样子:<br><img src="https://img-blog.csdnimg.cn/2020112912213098.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">1.8 版本是这样:<br><img src="https://img-blog.csdnimg.cn/2020112912221571.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">很明显就能看出来, 1.8 版本怎么多了一个树?还是红黑的?<br>这就要来分析 1.7 版本 HashMap 的实现有什么不足了.<br>1.7 版本主要就是 数组 + 链表,那么如果有一个 hash 值总是会发生碰撞,那么由此对应的链表结构也会越来越长,这个时候如果再想要进行查询操作,就会非常耗时,所以该如何优化这一点就是 1.8 版本想要实现的<br>1.8 版本采用了 数组 + 链表 + 红黑树 的方式去实现,当链表的长度大于 8 时,就会将链表转为红黑树.</font></p><p><font face="华文中宋" size="3">这个时候问题就来了,为什么会将链表转红黑树的值设定为 8 ?<br>这个问题我们或许可以从源码中窥探一二:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution </span><br><span class="line">with a parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing threshold of <span class="number">0.75</span>, although </span><br><span class="line">with a large variance because of resizing granularity. Ignoring variance, the expected </span><br><span class="line"><span class="function">occurrences of list size k <span class="title">are</span> <span class="params">(exp(<span class="number">-0.5</span>)</span> * <span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span> / <span class="title">factorial</span><span class="params">(k)</span>). </span></span><br><span class="line"><span class="function">The first values are:</span></span><br><span class="line"><span class="function">      0:    0.60653066</span></span><br><span class="line"><span class="function">      1:    0.30326533</span></span><br><span class="line"><span class="function">      2:    0.07581633</span></span><br><span class="line"><span class="function">      3:    0.01263606</span></span><br><span class="line"><span class="function">      4:    0.00157952</span></span><br><span class="line"><span class="function">      5:    0.00015795</span></span><br><span class="line"><span class="function">      6:    0.00001316</span></span><br><span class="line"><span class="function">      7:    0.00000094</span></span><br><span class="line"><span class="function">      8:    0.00000006</span></span><br><span class="line"><span class="function">      more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">为什么将链表转为红黑树,而不是平衡二叉树( AVL 树)呢?</font></p><ul><li><font face="华文中宋" size="3">因为 AVL 树比红黑树保持着更加严格的平衡, AVL 树中从根到最深叶的路径最多为 <code>1.44lg(n + 2)</code> ,红黑树中则最多为 <code>2lg( n + 1)</code> ,所以 AVL 树查找效果会比较快,如果是查找密集型任务使用 AVL 树比较好,相反插入密集型任务,使用红黑树效果就比较 nice</font></li><li><font face="华文中宋" size="3">AVL 树在每个节点上都会存储平衡因子</font></li><li><font face="华文中宋" size="3">AVL 树的旋转比红黑树的旋转更加难以平衡和调试,如果两个都给 O(lgn) 查找, AVL 树可能需要 O(log n) 旋转,而红黑树最多需要两次旋转使其达到平衡</font></li></ul><h1 id="HashMap-为什么是线程不安全的"><a href="#HashMap-为什么是线程不安全的" class="headerlink" title="HashMap 为什么是线程不安全的?"></a><font face="华文中宋" size="3">HashMap 为什么是线程不安全的?</font></h1><p><font face="华文中宋" size="3">HashMap 的线程不安全主要体现在两个方面: 扩容时导致的死循环 &amp; 数据覆盖<br>扩容时导致的死循环,这个问题只会在 1.7 版本及以前出现,因为在 1.7 版本及以前,扩容时的实现,采用的是头插法,这样就会导致循环链表的问题<br>什么时候会触发扩容呢?如果存储的数据,大于 当前的 <code>HashMap 长度( Capacity ) * 负载因子( LoadFactor )</code> 时,就会发生扩容.比如当前容量是 16 , <code>16 * 0.75 = 12</code> ,当存储第 13 个元素时,经过判断发现需要进行扩容,那么这个时候 HashMap 就会先进行扩容的操作<br>扩容也不是简简单单的将原来的容量扩大就完事儿了,扩容时,首先创建一个新的 Entry 空数组,长度是原数组的 2 倍,扩容完毕之后还会再进行 ReHash ,也就是将原 Entry 数组里面的数据,重新 hash 到新数组里面去<br>假设现在有一个 Entry 数组,大小是 2 ,那么当我们插入第 2 个元素时,大于 <code>2 * 0.75</code> 那么此时就会发生扩容,具体如下图:<br><img src="https://img-blog.csdnimg.cn/20201129192459721.jpg#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">扩容完毕之后,因为采用的是头插法,所以后面的元素会放在头部位置,那么就可能会这样:<br><img src="https://img-blog.csdnimg.cn/20201129193144151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">刚开始记录的是 <code>A.next = B</code> ,经过扩容之后是 <code>B.next = A</code> ,那么最后可能就是这样了:<br><img src="https://img-blog.csdnimg.cn/20201129193349908.jpg#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">明显看到造成了死循环,比较好的是, 1.8 版本之后采用了尾插法,解决了这个问题<br>还有个问题, 1.8 版本是没有解决的,那就是数据覆盖问题<br>假设现在线程 A 和线程 B 同时进行 put 操作,特别巧的是这两条不同的数据 hash 值一样,并且这个位置数据为 null ,那么是不是应该让线程 A 和 B 都执行 put 操作.假设线程 A 在要进行插入数据时被挂起,然后线程 B 正常执行将数据插入了,然后线程 A 获得了 CPU 时间片,也开始进行数据插入操作,那么就将线程 B 的数据给覆盖掉了<br>因为 HashMap 对 put 操作没有进行加锁的操作,那么就不能保证下一个线程 get 到的值,就一定是没有被修改过的值,所以 HashMap 是不安全的</font></p><h1 id="那既然-HashMap-线程不安全-你给推荐一个安全的"><a href="#那既然-HashMap-线程不安全-你给推荐一个安全的" class="headerlink" title="那既然 HashMap 线程不安全,你给推荐一个安全的?"></a><font face="华文中宋" size="3">那既然 HashMap 线程不安全,你给推荐一个安全的?</font></h1><p><font face="华文中宋" size="3">如果推荐的话,那肯定推荐 ConcurrentHashMap ,说到 ConcurrentHashMap 也有一个比较有趣的事情,那就是 ConcurrentHashMap 的 1.7 版本和 1.8 版本实现也不是很一样<br>在 1.7 版本, ConcurrentHashMap 采用的是分段锁( ReentrantLock + Segment + HashEntry )实现,也就是将一个 HashMap 分成多个段,然后每一段都分配一把锁,这样去支持多线程环境下的访问.但是这样锁的粒度太大了,因为你锁的直接就是一段嘛<br>所以 1.8 版本又做了优化,使用 CAS + synchronized + Node + 红黑树 来实现,这样就将锁的粒度降低了,同时使用 synchronized 来加锁,相比于 ReentrantLock 来说,会节省比较多的内存空间</font></p><p><font face="华文中宋" size="3">HashMap 这块,其实还可以扩展,比如 HashMap 和 HashTable 的区别, ConcurrentHashMap 1.7 版本和 1.8 版本具体的实现,等等等等<br>但是这篇文章已经比较长了,就写到这里吧~<br>感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;如果你是个 Java 程序员,那一定对 HashMap 不陌生,巧的是只要你去面试,大概率都会被问到 HashMap 的相关内容&lt;br&gt;基于此,就总结一篇,争取不让面试官问倒~&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.dynamic-zheng.com/categories/java/"/>
    
    
      <category term="java" scheme="https://www.dynamic-zheng.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>[JVM]来说说垃圾回收怎么样~</title>
    <link href="https://www.dynamic-zheng.com/posts/a228901d.html"/>
    <id>https://www.dynamic-zheng.com/posts/a228901d.html</id>
    <published>2020-11-22T02:55:52.000Z</published>
    <updated>2020-11-22T02:57:22.955Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">JVM 的自动内存管理,让原本应该是开发人员去做的事情,变成了垃圾回收器来做的事情<br><a id="more"></a><br>既然是别人帮忙做的事情,那么可能就不是自己想要的,所以就需要我们了解一下垃圾回收相关的内容</font></p><h1 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a><font face="华文中宋" size="3">引用计数法与可达性分析</font></h1><p><font face="华文中宋" size="3">垃圾回收,垃圾回收,那就是有的内存分配给了一些对象,但是这些对象已经用完了,那么它所占用的内存也就应该该释放掉了,却还没有释放<br>那么,这里就有个问题:该如何确定一个对象用完了呢?<br>其中一种方法就是引用计数法</font></p><p><font face="华文中宋" size="3">引用计数法就是给每个对象添加一个引用计数器,来统计指向该对象的引用个数<br>比如:如果有一个引用,被赋值为某一个对象,那么这个对象的引用计数器就 +1 ,如果一个指向这个对象的引用,被赋值为了其他的值,那么这个对象的引用计数器就 -1 ,这样如果这个对象的引用计数器为 0 ,我们就可以认为这个对象已经使用完毕,它所占用的内存空间可以回收掉了<br>这种方案听上去无懈可击,但是有一个致命的漏洞,就是没办法处理循环引用的问题<br>比如说: A 和 B 互相引用,除此之外也没有其他的引用指向 A 或者 B ,在这种情况下,其实 A 和 B 所占用的内存就可以释放掉了,但是因为它们互相都有引用,所以此时的引用计数器并不为 0 ,在这种情况下,就不能对它们进行回收<br>现在只是两个对象,如果再来两个,再来两个,这样循环引用的对象多了之后,就会造成内存泄露</font></p><p><font face="华文中宋" size="3">基于引用计数法的弊端,当前 JVM 主流的垃圾回收器采取的是可达性分析算法<br>这个算法本质就是将一系列的 GC Roots 作为初始的存活对象合集( live set ),然后从这个合集出发,探索所有能够被该集合引用到的对象,并把这些对象加入到集合中来,这个过程就叫做标记( mark ),遍历到最后,没有被探索到的对象就是可以回收的对象<br>那么什么是 GC Roots 嘞?一般包括(但不限于)以下几种:</font></p><ul><li><font face="华文中宋" size="3">Java 方法栈桢中的局部变量</font></li><li><font face="华文中宋" size="3">已加载类的静态变量</font></li><li><font face="华文中宋" size="3">JNI handles</font></li><li><font face="华文中宋" size="3">已启动并且没有停止的 Java 线程</font></li></ul><p><font face="华文中宋" size="3">刚才说因为引用计数法存在循环引用的问题,所以目前主流垃圾回收器选用的都是可达性分析法,也就是说,它解决了循环引用问题,其实这一点也比较好理解,虽然 A 和 B 相互引用,但是这个时候从 GC Roots 开始出发,是没有办法到达 A 和 B 的,那么就不会把它们放到存活对象合集之中,自然也就会被回收掉<br>但是在实际中还是会有问题的,比如:在多线程环境下,就会有其他线程更新已经访问过的对象中的引用,但是是多线程并行的嘛,这个时候可达性分析法已经把这个引用设置成了 null ,或者这个对象还在使用,但可达性分析法把它标记为了没有被访问过的对象,被回收掉了,这种情况可能直接导致 JVM 崩溃掉</font></p><h1 id="Stop-the-world-amp-safepoint"><a href="#Stop-the-world-amp-safepoint" class="headerlink" title="Stop-the-world &amp; safepoint"></a><font face="华文中宋" size="3">Stop-the-world &amp; safepoint</font></h1><p><font face="华文中宋" size="3">既然可达性分析法也有自己的一些缺陷,总得有解决方案吧?比较暴力的一种方法就是 Stop-the-world ,估计听名字也能知道,就是让全世界都停下来,也就是说,在进行垃圾回收的时候,其他所有非垃圾回收线程的工作都需要停下来,先让垃圾回收器工作完毕再说.这就是所谓的暂停时间( GC pause )<br>Stop-the-world 是通过安全点( safepoint )机制来实现的.啥意思嘞?咱先想个场景,现在你敲代码敲的特别开心,又有思路,状态又好,美滋滋的正在工作,突然毫无缘由的就让你现在不准敲代码,你会不会不开心?好不容易思路来了对吧,就一点儿理由都不给的就让我停下,不合理吧?<br>同样的场景,一个线程现在跑的特别 happy ,而且再有一秒钟就完成了任务,这个时候 JVM 收到了 Stop-the-world 请求,二话不说就把所有的线程给停掉,不太好吧?那么这个时候安全点( safepoint )机制就登场了.有了安全点机制,当 JVM 收到 Stop-the-world 请求的时候,它就会等待所有的线程都达到安全点,才允许请求 Stop-the-world 的线程进行独占的工作<br>那么,什么时候是安全点呢?举个例子来说:当 Java 程序通过 JNI 执行本地代码时,如果这段代码不访问 Java 对象,不调用 Java 方法,不返回到原 Java 方法,那么 Java 虚拟机的堆栈就不会发生改变,那这段本地代码就可以作为一个安全点.只要不离开这个安全点, JVM 就可以在垃圾回收的同时,继续运行这段本地代码<br>因为本地代码需要通过 JNI 的 API 来完成上述三个操作,因此 JVM 只需要在 API 的入口处进行安全点检测( safepoint poll ),看看有没有其他线程请求停留在安全点这里,就可以在必要的时候挂起当前线程</font></p><h1 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a><font face="华文中宋" size="3">垃圾回收的三种方式</font></h1><p><font face="华文中宋" size="3">当标记好存活的对象之后,就可以进行垃圾回收了<br>主流的垃圾回收方式,可以分为三种:清除( sweep ),压缩( compact ),复制( copy ).</font></p><p><font face="华文中宋" size="3">清除,就是把死亡对象所占据的内存标记成空闲内存,并把它记录在一个空闲列表( free list )中,当需要新建对象的时候,就直接在空闲列表中寻找空闲内存,划分给新建的对象就完了<br>但是这里会产生一个问题,因为死亡的对象所占据的内存可能是随机的,回收完毕之后,内存就是碎片化的,如果此时有对象申请一块连续的内存空间,尽管碎片化的内存空间是够用的,也没办法进行分配</font></p><p><font face="华文中宋" size="3">压缩,就是把存活的对象聚集到内存区域的起始位置,这样就可以留下一段连续的内存空间.这样去做的话,可以解决内存碎片化的问题,代价就是压缩算法带来的性能开销</font></p><p><font face="华文中宋" size="3">复制,就是把内存区域分成两等分,分别用两个指针 from 和 to 来维护,并且只是用 from 指针指向的内存区域来分配内存.当进行垃圾回收时,就把存活的对象复制到 to 指针指向的内存区域中,并且交换 from 指针和 to 指针的内容.<br>复制这种方式也可以解决内存碎片化的问题,但是它的缺点也是比较明显的,因为把内存区域分成了两等分嘛,那利用率就比较低咯,最高也是 50% 了,不能再高了</font></p><h1 id="垃圾回收在-JVM-中的应用"><a href="#垃圾回收在-JVM-中的应用" class="headerlink" title="垃圾回收在 JVM 中的应用"></a><font face="华文中宋" size="3">垃圾回收在 JVM 中的应用</font></h1><p><font face="华文中宋" size="3">上面说的三种垃圾回收方式是理论上的,那么在 JVM 中是如何应用的呢?<br>这就先要来了解下 JVM 的堆划分<br>大概就是这样子:</font></p><p><img src="/images/2020/内存区域划分.jpg"></p><p><font face="华文中宋" size="3">JVM 将堆划分为新生代和老年代,在新生代中又划分为 Eden 区,还有两个大小相同的 Survivor 区<br>当程序调用 new 指令时,会在 Eden 区中划出一块作为存储对象的内存,但是因为堆空间是线程共享的,所以在这里面划分空间的话就需要同步,要不然出现了两个对象共用一段内存,那不就该打架了嘛<br>JVM 为了避免两个对象打架的事情发生,就让每个线程向 JVM 申请一段连续的内存,来作为线程私有的 TLAB ( Thread Local Allocation Buffer ,对应虚拟机参数 <code>-XX:+UseTLAB</code> ,默认开启的)<br>Eden 区一直进行分配,总有空间分配完毕的时候,该怎么办?此时 JVM 就会触发一次 Minor GC ,来收集新生代的垃圾,存活下来的对象就会被送到 Survivor 区<br>在图中可以看到, Survivor 区有两个,一个是 from ,一个是 to ,其中 to 指向的 Survivor 区是空的</font></p><p><font face="华文中宋" size="3">当发生 Minor GC 时, Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区,然后交换 from 和 to 指针,这样就保证了下一次 Minor GC 时, to 指向的 Survivor 区还是空的<br>同时 JVM 会记录 Survivor 区的对象一共被来回复制了几次,如果一个对象被复制的次数为 15 (对应虚拟机参数 <code>-XX:+MaxTenuringThreshold</code> ),这个对象就会被晋升( promote )到老年代</font></p><p><font face="华文中宋" size="3">那么在发生 Minor GC 时,采用哪种垃圾回收方式会比较好一些呢?采用复制方式,也就是 标记-复制 算法会好一些.为什么呢?因为在新生代中,大部分的 Java 对象只存活一小段时间,那么我们就可以采用耗时比较短的垃圾回收算法,让大部分的垃圾都能在新生代被回收掉.使用 标记-复制 算法的话,理想情况下就是 Eden 区中的对象基本都死亡了,那么需要复制的数据非常少,此时这种算法的优势就被极大的体现了出来</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p><p><font face="华文中宋" size="3">参考:<br>极客时间  – 深入拆解 Java 虚拟机</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;JVM 的自动内存管理,让原本应该是开发人员去做的事情,变成了垃圾回收器来做的事情&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[JVM] JVM 是如何加载 Java 类的?</title>
    <link href="https://www.dynamic-zheng.com/posts/743ef9a0.html"/>
    <id>https://www.dynamic-zheng.com/posts/743ef9a0.html</id>
    <published>2020-11-15T06:48:13.000Z</published>
    <updated>2020-11-22T03:03:41.247Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">看到这个题目的时候,你可能就会觉得,这不是挺简单的一个问题么<br><a id="more"></a><br>如何加载?不就是 加载,链接,初始化 这三步嘛,说白了不就是类加载过程么<br>那么,你知道这三步具体又做了什么嘛?这就是本篇文章想要写的</font></p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a><font face="华文中宋" size="3">加载</font></h1><p><font face="华文中宋" size="3">加载的过程,就是查找字节流,并根据查找到的字节流来创建类的一个过程<br>Java 语言的类型可以分成两大类:基本类型和引用类型.基本类型就是由 JVM 预先定义好的,所以也就没有查找字节流这一说了<br>对于引用类型来说的话,又可以细分为四种:类,接口,数组类和泛型参数.因为泛型参数在编译过程中会被擦除,所以在 JVM 中就只有前三种.而数组类又是由 JVM 直接生成的,所以查找字节流的话,就只有类和接口了.</font></p><p><font face="华文中宋" size="3">那么 JVM 是怎么查找字节流的呢?如果你对这块内容比较熟的话,应该就能想起来类加载器,它主要有四类: 启动类加载器,扩展类加载器,应用程序类加载器和用户自定义类加载器<br>这块又有个知识点就是双亲委派机制:大概就是如果一个类加载器收到了类加载的请求,首先不会自己去加载这个类,而是把这个请求委派给父类加载器去完成.通过双亲委派机制就能保证同样一个类只被加载一次<br>经过类加载器之后,这个类就算是加载进来了</font></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a><font face="华文中宋" size="3">链接</font></h1><p><font face="华文中宋" size="3">链接这块又分为三部分:验证,准备,解析</font></p><p><font face="华文中宋" size="3">验证阶段就是想要看看 class 文件的前 8 位是不是 java 标识符,想看看符不符合规范什么的</font></p><p><font face="华文中宋" size="3">准备阶段就是给静态字段分配内存.除了分配内存之外,部分 JVM 还会在此阶段构造其他跟类层次相关的数据结构,比如说用来实现虚方法的动态绑定的方法表<br>在 class 文件被加载到 JVM 之前,这个类没办法知道其他类和方法,字段所对应的具体地址,甚至都不知道自己的方法,字段的地址,所以如果需要引用这些成员时, Java 编译器就会生成一个符号引用,在运行阶段,这个符号引用一般都可以准确的定位到具体目标上</font></p><p><font face="华文中宋" size="3">解析阶段主要就是将符号引用解析成实际引用.如果符号引用指向一个未被加载的类,或者没有被加载类的字段或方法,此时解析阶段就会触发这个类的加载(但不一定会触发这个类的链接以及初始化)</font></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><font face="华文中宋" size="3">初始化</font></h1><p><font face="华文中宋" size="3">在 Java 代码中,如果想要初始化一个静态字段,可以在声明的时候直接赋值,也可以选择在静态代码块中对它赋值<br>如果直接赋值的静态字段被 final 修饰了,而且这个静态字段是基本类型或者字符串时,就会被 Java  编译器标记成常量值,初始化就直接被 JVM 完成了.除此之外的直接赋值操作,还有所有静态代码块中的代码,就会被 Java 编译器放到同一个方法中,并且把它命名为 <code>&lt;clinit&gt;</code><br>类加载的最后一步就是初始化,就是给标记为常量值的字段赋值,执行 <code>&lt;clinit&gt;</code> 方法的过程.这个时候 JVM 会通过加锁来确保类的 <code>&lt;clinit&gt;</code> 方法只被执行一次<br>至此, JVM 成功的加载了 Java 类</font></p><h1 id="类的初始化何时会被触发"><a href="#类的初始化何时会被触发" class="headerlink" title="类的初始化何时会被触发?"></a><font face="华文中宋" size="3">类的初始化何时会被触发?</font></h1><p><font face="华文中宋" size="3">那么,类的初始化什么时候会被触发呢?<br>JVM 规范列举了以下几种触发情况:<br>1 , 当虚拟机启动时,初始化用户指定的主类;<br>2 ,当遇到用以新建目标类实例的 new 指令时,初始化 new 指令的目标类;<br>3 ,当遇到调用静态方法的指令时,初始化该静态方法所在的类;<br>4 ,当遇到访问静态字段的指令时,初始化该静态字段所在的类;<br>5 ,子类的初始化会触发父类的初始化;<br>6 ,如果一个接口定义了 default 方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化;<br>7 ,使用反射 API 对某个类进行反射调用时,初始化这个类;<br>8 ,当初次调用 MethodHandle 实例时,初始化该 MethodHandle 指向的方法所在的类</font></p><h1 id="再谈-双亲委派机制"><a href="#再谈-双亲委派机制" class="headerlink" title="再谈 双亲委派机制"></a><font face="华文中宋" size="3">再谈 双亲委派机制</font></h1><p><font face="华文中宋" size="3">在上面类加载机制那块,提了一下双亲委派机制<br>我觉得之所以有这样的机制,就是为了避免资源的浪费.上面的双亲委派机制我们在现实中也可以找到例子,比如说:公司部门有位程序员 A 发现如果做一个数据系统的话,来把公司各部门的数据打通,这样就可以减少很多交流成本,那么他可能就会和老大去说,申请去做这个系统,如果老大发现这个完全可以写成公共系统啊,就会对 A 说,这个系统我来做就可以了(公共内容父类加载器进行加载),那如果老大发现不太适合做成公共系统,就会对 A 说,想做就去做吧(父类不进行加载时,子类才进行加载)巧的是,程序员 B 也发现了,他也去找老大说,这个时候老大会说什么呢?这个事情 A 去做了,就不用太担心了(同样一个类只加载一次)<br>那如果程序员 A 和 B 发现了之后没有和老大交流,都自己闷头去做了,这样的话,同样的系统做了两遍,还浪费了两个人的时间精力,由此造成的资源浪费太大了<br>我觉得双亲委派的机制类似于这样,因为这个机制的存在,让资源浪费的现象大大减少了</font></p><p><font face="华文中宋" size="3">但是 tomcat 打破了这种机制,这怎么说?<br>我们都知道 tomcat 是个 web 容器,那么它应该:</font></p><ul><li><font face="华文中宋" size="3">支持部署两个应用程序,不同的应用程序可能会依赖同一个第三方类库的不同版本,就比如两个应用程序,其中一个依赖的是一个类库的 v1.0 ,另外一个依赖的是同样一个类库的 v2.0 ,那么 tomcat 是不是应该允许这个类库的 1.0 和 2.0 版本都存在?</font></li><li><font face="华文中宋" size="3">部署在同一个 web 容器中相同的类库相同的版本是应该可以共享的.就比如,服务器上有 100 个应用程序,这些程序依赖的都是相同的类库,那 tomcat 总不能把这 100 份相同的类库都加载到虚拟机里面去吧,要是非要加载进去,那服务器不得分分钟炸了</font></li><li><font face="华文中宋" size="3">web 容器需要支持 jsp 文件的修改,也就是说,当程序运行之后,我对 jsp 文件进行了修改,那么 tomcat 是不是也应该支持?如果不支持的话,那我修改一次就不能用了,不合适吧?</font></li></ul><p><font face="华文中宋" size="3">基于上面三点,就能看到 tomcat 其实是打破了双亲委派机制的<br>比如第一个问题,第三方类库就是同样一个资源,在双亲委派机制中,同样一个资源是不应该加载两次的,但是在 tomcat 里面却被允许了;但是第二个问题好像又在说双亲委派的机制,正是因为双亲委派机制的存在,所以第二个问题就不是问题了嘛;第三个问题又打破了双亲委派机制,因为如果不打破的话,原来的 jsp 文件已经加载进来了,现在对它进行了修改,那么应该还会加载原来的 jsp 文件,这样的话修改岂不是无效了?<br>所以, tomcat 打破了双亲委派机制,但并不是完全打破</font></p><p><font face="华文中宋" size="3">至于 tomcat 打破双亲委派的机制,我还没搞懂,等我搞懂了再来写吧<br>或者你搞懂了嘛?给我讲讲~</font></p><p><font face="华文中宋" size="3">参考: 极客时间 – 深入拆解 Java 虚拟机</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;看到这个题目的时候,你可能就会觉得,这不是挺简单的一个问题么&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[MySQL]是不是 redo log 和 binlog 傻傻分不清楚?</title>
    <link href="https://www.dynamic-zheng.com/posts/42d9f222.html"/>
    <id>https://www.dynamic-zheng.com/posts/42d9f222.html</id>
    <published>2020-11-08T11:44:45.000Z</published>
    <updated>2020-11-08T11:53:25.331Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在 MySQL 中,特别是存储引擎使用的是 InnoDB 时,那肯定绕不过去两个概念: redo log (重做日志) 和 binlog (二进制日志)<br><a id="more"></a><br>简单点儿说: redo log 是 InnoDB 存储引擎层方面的日志,所以如果你使用的存储引擎不是 InnoDB 的话,那就根本谈不上 redo log<br>binlog 是 MySQL Server 层记录的日志,所以不管是用的什么存储引擎,只要是 MySQL 都是会有 binlog 的存在,在做 MySQL 主从复制的时候,利用的就是 binlog<br>那么,你有疑问嘛?为什么要有 redo log 和 binlog ,只用一个 log 不可以嘛?<br>咱们详细来看看它们都分别做了啥</font></p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a><font face="华文中宋" size="3">redo log</font></h1><p><font face="华文中宋" size="3">为什么要有 redo log ?<br>我们可以这样想,如果没有 redo log 的话, MySQL 是如何进行工作的<br>查询还好说,毕竟只是查询一下记录而已,并没有对数据进行更改<br>那如果是增加和更新操作呢?现在一条 update 语句过来,后面是不是一定会有限定条件,就比如现在要更新一条记录,把 A 的银行卡余额更新到 1k ,那这条语句是不是应该来个限定条件,类似 <code>where userName = &#39;A&#39;</code> ,也就是说,一般 update 操作都伴随着查询的操作,得先找到这个人,然后再进行更新操作对吧<br>如果数据量比较小还好,很快就能找到并且更新完毕<br>但是如果数据量比较大,里面有一亿条数据,怎么办?而且更新操作肯定是要写到磁盘上去的,那这中间的 IO 成本呢?如果我有好几十条 update 语句先后更新呢?这样想的话,你就能想到,就这些操作,成本就高的不行,那能不能降低一下这些成本呢?</font></p><p><font face="华文中宋" size="3">这就是 redo log 的作用<br>就是当有一条记录更新的时候, InnoDB 引擎就会先把记录写到 redo log 里面去,同时更新内存,这样就算是更新这条数据成功了<br>但是此时,它并没有更新到磁盘上去对吧?别担心, InnoDB 会在恰当的时候,把这条及记录更新到磁盘上去<br>这样的思想或者技术,有个专有名词: WAL 技术,也就是 WriteAheadLogging ,核心就是先写日志,再写磁盘</font></p><p><font face="华文中宋" size="3">同样,这里面有个问题<br>redo log 不能一直写吧?如果更新操作一直写入到 redo log 中的话,不限制大小的话,可能服务器上的存储空间都被 redo log 给占满了<br>所以 InnoDB 的 redo log 是固定大小的,比如我们配置了一组 4 个文件,每个文件大小是 1GB ,那么它的操作可能就会这样:</font></p><p><img src="/images/2020/mysql.jpg"></p><p><font face="华文中宋" size="3">能够看到,主要就是 write pos 和 checkpoint , write pos 比较好理解,它就是当前记录的位置,有需要记录的操作就从当前位置向后移,等把 ib_logfile_3 写完之后,就回到 ib_logfile_0 文件开头继续写<br>checkpoint 是当前要擦除的位置,就是 InnoDB 引擎不是会在恰当的时候,将这些操作进行持久化,更新到磁盘上去,那持久化之后的数据是不是就可以擦除了<br>write pos 和 checkpoint 之间的部分就是可以用来记录操作的部分,那么如果 write pos 和 checkpoint 相遇了怎么办?相遇了是不是说明这个时候分配的 redo log 大小用完了,那这时候就不能再进行更新操作了,必须停下来处理一下,将 checkpoint 往前推推才行</font></p><p><font face="华文中宋" size="3">就是因为有了 redo log ,所以 InnoDB 才可以保证即使数据库发生了异常重启,也没关系,之前提交的记录都还在,只需要根据 redo log 里面的记录进行相应恢复就可以了<br>所以如果你和 DBA 比较熟的话,可以问问,咱们的 MySQL 是不是可以恢复到半个月内任意一秒的状态,如果对方回答是,别怀疑,他真的不是在吹牛逼</font></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a><font face="华文中宋" size="3">binlog</font></h1><p><font face="华文中宋" size="3">binlog 是 MySQL Server 层的记录日志,这块举个例子来说吧</font></p><p><font face="华文中宋" size="3">在说之前,我们要明白 redo log 和 binlog 的区别:</font></p><ul><li><font face="华文中宋" size="3">redo log 是 InnoDB 引擎特有的, binlog 是 MySQL 的 Server 层实现的,所有的引擎都是可以的</font></li><li><font face="华文中宋" size="3">redo log 是物理日志,记录的是”在 XXX 页上做了 XXX 修改”; binlog 是逻辑日志,比如” 给 id = 2 这一行的 c 字段加 1”</font></li><li><font face="华文中宋" size="3">redo log 是有固定大小的,所以它的空间会用完,如果用完的话,一定要进行一些写入磁盘的操作才可以继续; binlog 是可以追加写入的,也就是 binlog 没有空间的概念,一直写就行了</font></li></ul><p><font face="华文中宋" size="3">理解了它们之间区别之后,我们拿一个更新操作来举例<br>我现在要给 <code>id = 2 这一行的 c 字段加 1</code> ,到 MySQL 层面,它是如何去做的呢?<br>首先,会先找到这条 <code>id = 2</code> 的数据,然后找到 c 字段进行加 1 操作,这个时候,引擎会将这行数据更新到内存中,同时把这个更新操作记录到 redo log 里面,这个时候 redo log 处于 prepare 状态,随后执行器生成这个操作的 binlog ,并且把 binlog 写入到磁盘完成之后,执行器调用引擎的提交事务接口,引擎把刚刚写入的 redo log 从 prepare 状态改成 commit 状态,这样更新操作才算完成</font></p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><font face="华文中宋" size="3">两阶段提交</font></h1><p><font face="华文中宋" size="3">在上面的描述中,你能发现 redo log 竟然是先 prepare 状态,等 binlog 写完之后,才是 commit 状态,这种方式就叫”两阶段提交”<br>为什么会有这种方式呢?<br>redo log 和 binlog 都可以用于表示事务的提交状态,而两阶段提交就是让这两个状态保持逻辑上的一致</font></p><p><font face="华文中宋" size="3">可以假设一下,如果不采用这种方式,而是就先写 redo log ,再写 binlog ,会怎样?<br>如果在写 binlog 时,发生了异常,更新操作已经到 redo log 中了,但是此时 binlog 并没有进行更新,是不是出现了数据不一致?<br>先写 binlog 再写 redo log 也是一样<br>所以,在写时,先让 redo log 处于 prepare 状态,等 binlog 写完之后,再让 redo log 处于 commit 状态,这样就保持了逻辑上的一致</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇~</font></p><p><font face="华文中宋" size="3">参考<br>极客时间 – MySQL 实战 45 讲</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在 MySQL 中,特别是存储引擎使用的是 InnoDB 时,那肯定绕不过去两个概念: redo log (重做日志) 和 binlog (二进制日志)&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[项目]在 swagger 界面实现 token 验证</title>
    <link href="https://www.dynamic-zheng.com/posts/e23cc848.html"/>
    <id>https://www.dynamic-zheng.com/posts/e23cc848.html</id>
    <published>2020-10-30T15:43:16.000Z</published>
    <updated>2020-10-30T15:46:13.094Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我先说下背景:我最近不是换了家公司工作,然后这家公司就是不管发什么请求都是需要带着 token 信息的,也就是说,比如现在我写好代码了,想要验证我写的代码对不对,咱们现在用的都是 springboot , springcloud 框架,写完了直接在 swagger 界面上进行调试就 OK 了,但是现在不管什么请求都要携带 token 信息,默认的 swagger 配置是没有的<br><a id="more"></a><br>我在上家公司的时候,当时的权限部门帮我们都做好了 token 验证,只要是能够进入到我们系统的用户,那就是有权限的,所以当时的项目直接在 swagger 界面上进行测试就 OK 了<br>我刚接手项目熟悉的时候,想要测试一下请求, swagger 上没办法添加 token 信息,所以我就得用 postman 去测</font></p><p><font face="华文中宋" size="3">对我来说是有点儿难受的,你想想,我以前就是写好了接口,启动项目,去 swagger 项目上一测试,没问题提交代码完事儿,有问题我就可以直接进行调试<br>现在使用 postman 测试没问题还好,有问题的话, token 不知道怎么添加进去,感觉就是明明可以直接使用 swagger 的,现在要再进行一个第三方 postman ,就感觉用的不是很顺手嘛</font></p><p><font face="华文中宋" size="3">所以我就想,能不能在 swagger 上直接就可以添加上 token 信息,这样的话,我就不需要再借助第三方工具 postman 了<br>一倒腾还真的让我给搞成功了</font></p><p><font face="华文中宋" size="3">swagger 整合细节我就不说了,这里主要就是 swagger 启动那里需要设置,具体代码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">controllerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加 head 参数配置 start</span></span><br><span class="line">    ParameterBuilder token = <span class="keyword">new</span> ParameterBuilder();</span><br><span class="line">    List&lt;Parameter&gt; pars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    token.name(<span class="string">"Authorization"</span>).description(<span class="string">"token 信息"</span>).modelRef(<span class="keyword">new</span> ModelRef(<span class="string">"String"</span>))</span><br><span class="line">            .parameterType(<span class="string">"header"</span>).required(<span class="keyword">false</span>).build();</span><br><span class="line">    pars.add(token.build());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .enable(enable)</span><br><span class="line">            .apiInfo(<span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                    .title(projectName + <span class="string">"接口文档"</span>)</span><br><span class="line">                    .description(projectDesc + <span class="string">""</span>)</span><br><span class="line">                    .license(<span class="string">"郑璐璐 csdn"</span>)</span><br><span class="line">                    .licenseUrl(<span class="string">"https://blog.csdn.net/zll_0405"</span>)</span><br><span class="line">                    .version(version)</span><br><span class="line">                    .build())</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(basePackage))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            <span class="comment">// 注意一下 globalOperationParameters 这行配置</span></span><br><span class="line">            .globalOperationParameters(pars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">OK ,添加好上面的代码之后,再启动就能在 swagger 界面上看到下面的改动了:</font></p><p><img src="/images/2020/token.png"></p><p><font face="华文中宋" size="3">在图中红框框的地方,输入 token 信息,然后执行一下,你就会发现,使用 swagger 我又可以了,哈哈哈</font></p><p><font face="华文中宋" size="3">注意:给出的代码只是一个小 demo ,具体信息请根据自己的项目信息去配置<br>以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;我先说下背景:我最近不是换了家公司工作,然后这家公司就是不管发什么请求都是需要带着 token 信息的,也就是说,比如现在我写好代码了,想要验证我写的代码对不对,咱们现在用的都是 springboot , springcloud 框架,写完了直接在 swagger 界面上进行调试就 OK 了,但是现在不管什么请求都要携带 token 信息,默认的 swagger 配置是没有的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[碎碎念]是的,我换了家公司工作</title>
    <link href="https://www.dynamic-zheng.com/posts/83a68896.html"/>
    <id>https://www.dynamic-zheng.com/posts/83a68896.html</id>
    <published>2020-10-25T05:59:50.000Z</published>
    <updated>2020-10-25T06:02:41.935Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近我在忙着换公司工作的事情,虽然平时也一直在学习 &amp; 输出,也一直在尽力把自己写的文章系统化,但是去面试还是要好好准备的,所以各位读者可能也感受到了,最近这两周的文章质量都不是很高,毕竟我的时间精力都在那里嘛<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">经过最近的面试之后,有些感受,在这里写写,如果对你能够有所帮助的话,那可真是太好了</font></p><p><font face="华文中宋" size="3">1 ,自己简历上的东西,既然写了熟悉或者精通,那就一定要能够达到那样的层次<br>面试官面试的时候,都是根据你的简历来问你的,所以一定要对自己的简历负责.如果写了精通,那就一定要有对应的深度<br>因为我上家公司是做在线教育方面的,我负责的主要业务就是学生考试,并发量什么的都是比较多的,那最好就是使用多线程去处理啦,所以我对多线程这块就很熟悉,如果面试的话,不问那就算了,只要一问这块就是我的亮点<br>那么你肯定就会问了,什么程度算是精通呢,什么算是熟练使用呢,什么算是熟悉呢<br>我觉得精通的话,那肯定是不管这方面问你什么问题都是问不倒的.比如你说你精通多线程这块内容是吧,那么多内容,别的咱先别问,就问个 synchronized 关键字,它的锁膨胀是怎样的呢,你是怎么判断当前是有锁状态,无锁状态的, synchronized 后来做了优化,具体优化是什么呢,提到 synchronized 的话,它和 ReentrantLock 有什么区别? ReentrantLock 又是基于 AQS 实现的,又能说出来多少.我觉得如果这些问题都没问住你的话,那么你说你精通,我是相信的.<br>熟练使用的话,就需要你达到出现了问题知道怎么解决,比如你说你熟练使用 mysql , OK ,那现在有个 sql 语句执行特别慢,如果是你的话,你会怎么处理呢,其中的几个关键参数也是能够说出来的;你说你熟练使用 Linux 命令,那么我想要查看日志,想要查看特定进程,是不是都应该答上来<br>熟悉的话,我觉得就是一个你知道的层次,比如你说你熟悉 GC 算法,那 标记清除/标记复制/标记整理 优缺点,适用于新生代还是老年代就应该答出来<br>所以简历上如果写了精通,那就一定要有对应的深度;如果写了熟悉,那一些基本的知识应该能够答上来的</font></p><p><font face="华文中宋" size="3">2 ,如果面试官问了你不会的内容,那就坦白说自己不会<br>说来比较愧疚,虽然一直在用 ssm, springboot, springcloud 这些框架,但是 spring 源码我还没读过,一直都处在使用的层面<br>当时面试的时候,面试官就问我有没有阅读过 spring 的源码,我就很坦白的说,我没有阅读过,只是一直在用,面试官也就没有继续追问下去<br>如果我当时为了装逼说我阅读过源码的话,那估计被吊打的就是我了</font></p><p><font face="华文中宋" size="3">3 ,如果你面了几家公司,后续都没有了消息,别怀疑自己,只是职位不匹配而已<br>我当时在找工作的时候,恰好另外一位朋友也在找工作,所以我俩那时候交流就比较多嘛<br>然后他面了有十几家公司了,面到最后都没有了后话,那段时间他就一直问我,是不是自己不够好,是不是自己不够优秀.有一说一,我那位朋友技术上比我厉害是真的,所以我就安慰他,没事儿的,再面面,说不定下家公司就要你了呢<br>结果现在他手上有好几个 offer ,在愁去哪家公司比较好.<br>所以在面试的过程中,如果面了几家,几十家公司,还没收到一份 offer ,别怀疑自己,真的<br>这就像你去超市买东西一样,怎么那么多东西不拿,就拿快乐肥宅水呢,无他,只是匹配你的需求而已.那其他的就不好么?不是,只是目前还没有遇到买家而已<br>找工作也是这样,可能只是你的技术栈和对方不匹配,但总会有一家公司的技术栈和你是匹配的对吧,别灰心,继续努力就行</font></p><p><font face="华文中宋" size="3">4 ,面试过程中,不要怕,展示你自己就可以了<br>我记得我当时投简历的时候,想要换个领域去看看嘛,毕竟世界那么大<br>我就投了一家区块链公司,说真的,区块链公司和我目前接触的领域,差别太大了.我目前接触的领域,一天的数据量最多也就几百万数据,这还是最多的,但是我去面的那家区块链公司,数据量都已经达到了 T 级别<br>而且大家应该也都知道,很小的一个问题,当数据量非常大的时候,那么这个小问题可能就是一个大问题.比如现在要往数据库里面插入一条数据,插入之前先看看数据库中有没有,如果有的话,那就直接更新,如果没有再做插入<br>如果我来做的话,那就直接一个 if else 就完了,但是面试官说,如果直接 if else 的话,我现在的数据量就是几个 T ,只是判断数据库中有没有这条数据就可能要花费很多时间<br>就我上面的这个例子,大家也能看到,我接触的领域对于区块链领域来说,是非常不匹配的,当时面试的时候面试官也很坦率,就和我说他们想要的 java 不是我这样的,技术栈不匹配<br>我当时听了面试官这样说,就觉得都这样说了,可能就没有后续了,结果面试官说,但是在面试的整个过程中,我觉得你的性格,沟通能力都是蛮不错的,很适合和我们团队一起做事<br>所以嘞,面试过程中,别怕,哪怕去面试的领域不是自己擅长的领域,那也没啥怕的,会就说,不会就说不会,不懂就向面试官请教,说不定你身上的哪点特质就被面试官相中了呢~</font></p><p><font face="华文中宋" size="3">5,算法和数据结构是真的重要<br>实话实说,我的算法就不是很好,去面试的时候能够感觉到不管是大公司,还是小公司都是挺看重算法的,动不动就让你手写几个算法,真的就是标配了<br>所以面试的话,这块最好还是准备一下</font></p><p><font face="华文中宋" size="3">经过面试之后,发现了自己需要提高的地方还是蛮多的,接下来我就继续努力就完了</font></p><p><font face="华文中宋" size="3">感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;最近我在忙着换公司工作的事情,虽然平时也一直在学习 &amp;amp; 输出,也一直在尽力把自己写的文章系统化,但是去面试还是要好好准备的,所以各位读者可能也感受到了,最近这两周的文章质量都不是很高,毕竟我的时间精力都在那里嘛&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]爬上来说两句</title>
    <link href="https://www.dynamic-zheng.com/posts/78166b12.html"/>
    <id>https://www.dynamic-zheng.com/posts/78166b12.html</id>
    <published>2020-10-18T04:33:30.000Z</published>
    <updated>2020-10-18T04:35:37.284Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">先道个歉,因为上周博客我鸽了,另外我再摸着良心说,尴尬,我没良心<br>这周技术上没啥输入,也就没啥高质量的输出了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我最近在准备换家公司工作的事情,所以不管是时间上,还是精力上,都有些不够用,有时候真的恨不得把自己掰成好几个,一个在工作,一个在学习,一个在输出高质量文章,一个在准备面试,一个在面试,哈哈哈</font></p><p><font face="华文中宋" size="3">在交接工作的时候,我才发现原来在过去的时间里我成长了这么多<br>不管是开发,还是运维,还是管理,或是沟通,或是表达,都让我和几年前的自己全然不同<br>不过,能够有这样的我,中间付出了多少,怕是只有自己才知道吧<br>但是付出的东西我不想总是过多的去说,因为这都是我想要付出的,无怨无悔的那种,而且还是非常享受的那种,甘之如始</font></p><p><font face="华文中宋" size="3">我记得面试的时候,面试官问过我接下来的发展,这两天我也在问自己,未来到底是想要成为什么<br>我到现在都没有想清楚,我未来到底是想要成为什么,但是有一点是非常清楚的,就是我喜欢去钻技术,我想让自己的技术沉淀下来,我想通过业务去将我身上的技术价值发挥到最大,我喜欢看着自己写的代码通过网络给一些人带去了一些改变和方便<br>这是我目前享受,乐意去做的事情</font></p><p><font face="华文中宋" size="3">我觉得现在让我去计划五年之后的事情,太难了<br>就像五年前的我,没有想过我会走上编程的道路,成为一个程序媛一样,现在让我去想五年后的事情,我想象不出来<br>我能够想象出来的就是,五年之后的我,肯定比现在的自己,还要优秀.因为我在坚持每天进步一点点~</font></p><p><font face="华文中宋" size="3">就这样吧~主要是自己这周没啥输入,所以废话了好多文字<br>总是写这样的文章,我自己心里感觉也是挺过意不去的,因为我最近总是水文…</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;先道个歉,因为上周博客我鸽了,另外我再摸着良心说,尴尬,我没良心&lt;br&gt;这周技术上没啥输入,也就没啥高质量的输出了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[redis]关于 缓存穿透/缓存击穿/缓存雪崩 看这篇文章就够了</title>
    <link href="https://www.dynamic-zheng.com/posts/2d85a910.html"/>
    <id>https://www.dynamic-zheng.com/posts/2d85a910.html</id>
    <published>2020-10-04T09:41:52.000Z</published>
    <updated>2020-10-04T09:45:27.891Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">redis 在项目中用的话,主要就是用作缓存了<br>既然用作缓存,那就肯定会有 缓存穿透/缓存击穿/缓存雪崩 的问题<br>这篇文章就来说说,遇到这种情况时,该如何去处理<br><a id="more"></a></font></p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><font face="华文中宋" size="3">缓存穿透</font></h1><p><font face="华文中宋" size="3">首先咱们搞明白什么是缓存穿透?这三个词这么像,得把概念搞清楚不是<br>其实只是从字面意思上来看的话,大概也能知道一点儿,缓存穿透嘛,就是直接穿过了缓存,将请求打到了数据库上面去<br>一般情况下,去查询数据的话,缓存里面应该都是有的,但是防不住黑客呀,如果黑客请求查询的是数据库里面根本不存在的数据,数据库里面都没有的数据,缓存里面肯定也不会有了,对吧,那么此时请求就会打到咱们的数据库里面去,这就是<strong>缓存穿透</strong><br>你想啊,黑客想要攻击的话,怎么可能只请求一次呢,肯定是大量的请求过来,因为是拿数据库里面不存在的 id 来请求的,那么这些请求毫无疑问直接打到了数据库上面去,那咱们的数据库可能就会因为这些大量的请求直接宕掉</font></p><p><font face="华文中宋" size="3">如何解决呢?<br>咱们回到产生这个问题的场景中,为什么大量的请求会打到数据库上面来?因为缓存里面没有对应的 key 对吧,所以才会越过缓存直接到数据库<br>那么问题就好解决了嘛,缓存里面没有对应的 key ? OK,如果这个 key 数据库里面也没有,那我就在 redis 里面,存上这个 key ,值是 null ,这样如果有查询这个 key 的请求,我直接返回 null 就完事儿了,也就不用打到数据库上面去了<br>注意一下,要记得设置它的过期时间,一般三到五分钟就够了</font></p><p><font face="华文中宋" size="3">但是对方是个黑客呀,可能就用一个 key 去请求么?他可能会在短时间内用大量的 key 来发送请求,那如果一个 key 就在 redis 中存储一个 null 值的话,那么多 key 是不是就会存储那么多个 null 值嘞?<br>这样的话, redis 里面是不是都是值为 null 的了?<br>所以有没有更好的解决办法呢?<br>那必须得有!<br>布隆过滤器,你值得尝试</font></p><p><font face="华文中宋" size="3">什么是布隆过滤器呢?就是它能告诉你,某个值一定不存在或者可能存在( emmmm ,也不知道我有没有说清楚<br>所以可以将数据库的内容缓存一份到布隆过滤器,这样的话,当大量的请求过来的时候,<br> redis 里面没有,没关系,再去布隆过滤器过滤一下,这样请求不用打到数据库上面去,就能确定这个 key 数据库中有没有<br> 这样不就降低了数据库的压力么,可真是个天才~</font></p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><font face="华文中宋" size="3">缓存击穿</font></h1><p><font face="华文中宋" size="3">缓存击穿说的是,在高并发情况下,如果好多个请求都在查询一个 key ,好巧不巧的是,这个 key 因为某些原因失效了(比如设置的过期时间到了,缓存服务器宕机了),这样就会导致那么多的请求都直接打到数据库上面去了<br>那如果这些请求的数量足够大的话,可能直接把数据库就干掉了</font></p><p><font face="华文中宋" size="3">知道了造成结果的原因,那么寻找解决方案也就好办了<br>不是因为好多个请求打到了数据库嘛,但是它们请求的都只是一个 key ,所以这里可以使用排斥锁来实现,第一个请求达到请求 key 发现缓存里面没有,允许它去数据库查询,同时加锁,这样第二个请求,第三个请求…都会被锁阻塞到当前,不会再打到数据库,这样就减少了数据库的并发压力</font></p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><font face="华文中宋" size="3">缓存雪崩</font></h1><p><font face="华文中宋" size="3">缓存雪崩,雪崩雪崩嘛,就比较严重,击穿说的是一个 key 失效的情况,雪崩指的是大规模的缓存失效情况的发生,这是有可能发生的,比如说我的缓存服务器宕机了,那是不是直接就大规模的缓存失效了;或者说,我当时为了图省事,好多个 key 设置的过期时间都是一样的,然后刚好在缓存都失效的时候,好多请求不同的 key 过来了</font></p><p><font face="华文中宋" size="3">解决方案的话,其实就不适合使用加锁的方式去解决了,因为这是好多请求不同的 key ,它不是一个嘛<br>而且嘞,咱们是因为好多个 key 设置的过期时间都是一样的,所以解决方案就是,咱们不设置同样的时间让缓存失效了,咱们给一个随机时间,让缓存随机失效,这样的话,大规模的缓存失效情况就减少很多了<br>那还要一种情况呢,就是如果我的缓存服务器直接宕机了,这怎么办?也好弄,来个集群就解决了,这里只是一个解决方案,它的落地实现不是本文重点哈~</font></p><h1 id="再谈-布隆过滤器"><a href="#再谈-布隆过滤器" class="headerlink" title="再谈 布隆过滤器"></a><font face="华文中宋" size="3">再谈 布隆过滤器</font></h1><p><font face="华文中宋" size="3">OK ,你如果看到这里的话,其实这篇文章的内容就说完了<br>但是我感觉布隆过滤器那块,我没有说清楚,所以在这里拿出来详细说一说</font></p><p><font face="华文中宋" size="3">布隆过滤器是一种数据结构,它是一种概率型的数据结构,就是它能告诉你”某样东西一定不存在或者可能存在”<br>唉,你可能会说,这话刚刚不是说过了嘛,本来就挺拗口的,你咋还说<br>还不是因为这句话比较重要,我觉得把这句话理解透彻了,那么对布隆过滤器理解的应该也就到位了</font></p><p><font face="华文中宋" size="3">来,为了形象生动一些,咱们举个例子~<br>布隆过滤器是一个 bit 向量或者说 bit 数组,大概长这样:</font></p><p><img src="/images/2020/布隆过滤器-初始.jpg"></p><p><font face="华文中宋" size="3">现在,我们需要把 “AliPay” 这个字段给存储进去<br>大概的存储过程就是:将要映射的值,使用多个不同的哈希函数生成多个哈希值,然后每个生成的哈希值指向的 bit 置为 1<br>以给的为例,我们现在将 “AliPay” 这个值,通过三个不同的哈希函数进行映射,那么大概就是这样了:</font></p><p><img src="/images/2020/布隆过滤器-第一次映射.jpg"></p><p><font face="华文中宋" size="3">同样,现在我要存储另外一个值 “WechatPay” ,那么可能映射之后就是下面这样:</font></p><p><img src="/images/2020/布隆过滤器-第二次映射.jpg"></p><p><font face="华文中宋" size="3">细心的你可能就会发现, 4 号位置的值,刚开始不是给 “AliPay” 了么,后来 “WechatPay” 也在那里,这样的话,值不就给覆盖掉了嘛<br>嗯,没错,是给覆盖到了</font></p><p><font face="华文中宋" size="3">接下来,我们查询 “Ali” 那么查询之后,布隆过滤器可能会给你 “0,1,2” 的值, 结果呢 “2” 的位置是 0 ,说明没有任何值映射到这个位置上来,所以我们就可以判定数据库里面没有 “Ali” 这个值<br>那我查询 “AliPay” 的话,毫无疑问,肯定会返回给我 “1,4,6” ,那我们能说数据库里面一定有 “AliPay” 么?不能,因为 “1,4,6” 的值有可能被其他的值给映射了,所以我们只能说,数据库里可能存在 “AliPay”<br>这就是布隆过滤器说的”某个值一定不存在或者可能存在”<br>你理解了嘛?(不理解的话,我也就写到这儿了~</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;redis 在项目中用的话,主要就是用作缓存了&lt;br&gt;既然用作缓存,那就肯定会有 缓存穿透/缓存击穿/缓存雪崩 的问题&lt;br&gt;这篇文章就来说说,遇到这种情况时,该如何去处理&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="https://www.dynamic-zheng.com/categories/redis/"/>
    
    
      <category term="redis" scheme="https://www.dynamic-zheng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]面试官:三个线程顺序执行,你来说说有几种实现方式?</title>
    <link href="https://www.dynamic-zheng.com/posts/f0d1ecb0.html"/>
    <id>https://www.dynamic-zheng.com/posts/f0d1ecb0.html</id>
    <published>2020-09-25T13:44:49.000Z</published>
    <updated>2020-09-25T13:46:24.772Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">写在前面:<br>越是基础知识,越要系统<br><a id="more"></a><br>正文开始:</font></p><p><font face="华文中宋" size="3">先说下要求,就是三个线程,假设是线程 1,2,3, 现在的要求是:必须是线程 1 先执行,然后线程 2 再执行,最后是线程 3 执行<br>然后有几种实现方法呢?<br>其实它的本质就是实现,让线程 2,3  等待线程 1 执行完毕,所以重点就是有哪些方法可以让线程 2,3 等待</font></p><h1 id="join"><a href="#join" class="headerlink" title="join"></a><font face="华文中宋" size="3">join</font></h1><p><font face="华文中宋" size="3">第一反应应该就是使用 join 方法,因为 join 本来就是支持这种机制的<br>比如,我在线程 B 中调用了线程 A 的 join 方法,那么线程 B 就会等线程 A 执行结束之后再执行.<br>那么具体应该怎么使用嘞?<br>别慌嘛,我这里有例子,你瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(<span class="keyword">null</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t1));</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t2));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Thread beforeThread)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果有线程,就 join 进来,没有的话就直接输出</span></span><br><span class="line">            <span class="keyword">if</span> (beforeThread != <span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join();</span><br><span class="line">                    System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><font face="华文中宋" size="3">CountDownLatch</font></h1><p><font face="华文中宋" size="3">刚才说了,本质就是让线程 B,C 等待线程 A 执行完毕<br>那么信号量就是一个不错的选择<br>如果想要实现的话,那大概就是下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置线程 1 的信号量为 0</span></span><br><span class="line">        CountDownLatch cOne = <span class="keyword">new</span> CountDownLatch(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置线程 2 的信号量为 1</span></span><br><span class="line">        CountDownLatch cTwo = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置线程 3 的信号量为 1</span></span><br><span class="line">        CountDownLatch cThree = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 cOne 为 0 ,故 t1 可以直接执行</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cOne,cTwo));</span><br><span class="line">        <span class="comment">// 线程 t1 执行完毕之后,此时的 cTwo 为 0 , t2 开始执行</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cTwo,cThree));</span><br><span class="line">        <span class="comment">// 线程 t2 执行完毕,此时 cThree 为 0 , t3 开始执行</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cThree,cThree));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        CountDownLatch cOne;</span><br><span class="line">        CountDownLatch cTwo;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(CountDownLatch cOne, CountDownLatch cTwo)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.cOne = cOne;</span><br><span class="line">            <span class="keyword">this</span>.cTwo = cTwo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前一个线程信号量为 0 时,才执行</span></span><br><span class="line">                cOne.await();</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 后一个线程信号量减 1</span></span><br><span class="line">                cTwo.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用单个线程池"><a href="#使用单个线程池" class="headerlink" title="使用单个线程池"></a><font face="华文中宋" size="3">使用单个线程池</font></h1><p> <font face="华文中宋" size="3">之所以线程 1,2,3 的执行顺序无法保证,是因为在编译器可能会去做一些优化,导致没有办法按照顺序执行<br> 如果我们使用单个线程池去执行的话,那就没有这样的问题了<br> 具体实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopThree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run one"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run two"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run three"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 将线程依次加入到线程池中</span></span><br><span class="line">        executor.submit(t1);</span><br><span class="line">        executor.submit(t2);</span><br><span class="line">        executor.submit(t3);</span><br><span class="line">        <span class="comment">// 及时将线程池关闭</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><font face="华文中宋" size="3">CompletableFuture</font></h1><p><font face="华文中宋" size="3">如果使用 CompletableFuture 来实现的话,代码就非常简洁了</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopFour</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(()-&gt; t1.start())</span><br><span class="line">                .thenRun(()-&gt;t2.start())</span><br><span class="line">                .thenRun(()-&gt;t3.start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">你还有别的什么方法么?欢迎评论区和我交流~<br>以上,非常感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;写在前面:&lt;br&gt;越是基础知识,越要系统&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]面试官让我手写一个读写锁出来,我...</title>
    <link href="https://www.dynamic-zheng.com/posts/76a7b252.html"/>
    <id>https://www.dynamic-zheng.com/posts/76a7b252.html</id>
    <published>2020-09-18T14:35:25.000Z</published>
    <updated>2020-09-18T14:40:13.781Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">题目是个标题党,主要是想写一下 ReentrantReadWriteLock<br><a id="more"></a></font></p><h1 id="ReentrantReadWriteLock-与-ReentrantLock-区别"><a href="#ReentrantReadWriteLock-与-ReentrantLock-区别" class="headerlink" title="ReentrantReadWriteLock 与 ReentrantLock 区别?"></a><font face="华文中宋" size="3">ReentrantReadWriteLock 与 ReentrantLock 区别?</font></h1><p><font face="华文中宋" size="3">在这篇文章中:  <a href="https://blog.csdn.net/zll_0405/article/details/105927574" target="_blank" rel="noopener">[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</a>  对 ReentrantLock 已经做了非常详细的讲解了<br>那么,今天想要说的 ReentrantReadWriteLock 和 ReentrantLock 有什么区别呢?如果只是从名字上来说的话,就是多了一个 ReadWrite 嘛<br>如果对 ReentrantLock 比较熟的话,那么我问 ReentrantLock 是独占锁还是共享锁,你的第一反应就是: 独占锁</font></p><p><font face="华文中宋" size="3">ReentrantReadWriteLock 是在 ReentrantLock 的基础上做的优化,什么优化呢? ReentrantLock 就是不管操作是读操作还是写操作都会对资源进行加锁,但是你想想,如果好几个操作都只是读的话,并没有让数据的状态发生改变,这样的话是不是可以允许多个读操作同时运行?这样的话,相对来说是不是就提高了并发<br>很多事情都是说起来容易,具体是怎么实现的呢?<br>啥也不多说,咱们直接上源码好吧</font></p><p><font face="华文中宋" size="3">在使用 ReentrantReadWriteLock 时,一般都是调用 <code>writeLock</code> 和 <code>readLock</code> 两种方法,它在源码中定义如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">而 <code>writeLock</code> 和 <code>readLock</code> 是 <code>ReentrantReadWriteLock</code> 的两个内部类,其中这两种锁的实现如下(其中省略了一些代码):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享锁</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 共享锁</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 独占锁</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">从源码就能够看出,对于读锁 <code>readLock</code> 它使用的是共享锁,也就是多个线程读没问题<br>但是对于写锁 <code>writeLock</code> 它使用的是独占锁,就是当一个线程要进行写操作时,其他的线程都要停下来等待<br>简单点儿说就是:一个资源可以被多个读线程访问,或者被一个写线程访问,但是不能同时存在读线程和写线程,这也是读写锁的定义</font></p><h1 id="ReadLock-和-WriteLock-共享一个变量"><a href="#ReadLock-和-WriteLock-共享一个变量" class="headerlink" title="ReadLock 和 WriteLock 共享一个变量"></a><font face="华文中宋" size="3">ReadLock 和 WriteLock 共享一个变量</font></h1><p><font face="华文中宋" size="3">如果让你设计一个读写锁的话,会怎样设计?<br>我还真的认真想了想这个问题,如果让我设计的话,我应该会用两个变量去控制读和写,当线程获取到读锁时就对读变量进行 +1 操作,当获取到写锁时,就对写变量进行 +1 操作<br>但是通过看 ReentrantReadWriteLock 源码发现,它只是通过一个 state 来实现的<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">有两个关键方法 <code>sharedCount</code> 和 <code>exclusiveCount</code> ,乖,光是从名字意思来看应该也是可以猜出来的吧: <code>sharedCount</code> 就是共享锁的数量,而 <code>exclusiveCount</code> 则是独占锁的数量<br>通过看源码,能够看出来,对于 <code>sharedCount</code> 来说,它的计算方式就是无符号右移 16 位,空位都以 0 来补齐( <code>c &gt;&gt;&gt; SHARED_SHIFT;</code> )<br>对于 <code>exclusiveCount</code> 来说,它的计算方式就是将传进来的 c 和 <code>EXCLUSIVE_MASK</code> 做 “&amp;” 运算,那么 <code>EXCLUSIVE_MASK</code> 的值是什么呢?就是 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> ,如果对位运算比较熟的话,应该会很容易看出来 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> 的值就是 65535 ,化成二进制就是 16 个 1,传进来 c 的值,和 16 位全为 1 做 “&amp;” 运算的话,只有 <code>1 &amp; 1</code> 才为 1 ,也就是说,传进来的 c 值经过这样转换之后,还是原来的值</font></p><p> <font face="华文中宋" size="3">说到这里,可能有点儿懵了,没关系,咱们来个总结就好说了(为了好理解,我就用大白话说了,争取各位都能看懂<br> 对于 <code>sharedCount</code> 来说,只要传进来的值不大于 65535 ,那么经过计算之后,值都是 0<br> 对于 <code>exclusiveCount</code> 来说,传进来的值是多少,经过计算之后还是多少<br> 不管是 <code>sharedCount</code> 还是 <code>exclusiveCount</code> ,最大值都是 65535 ,因为是和 16 做位运算,其实这个数字也是相当够用了<br> 那么,看到这里,各位应该就比较了解了吧,对于 <code>ReadLock</code> 和 <code>WriteLock</code> 来说,在源码层次其实并不是用两个变量去做的,而是通过一个 state 来实现的,思路真的是非常的巧妙</font></p><p><font face="华文中宋" size="3">对于我上面说的,如果还是不清楚的话,可以自己写个 demo 去验证一下,很简单的,就比如下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shareCount = <span class="number">3000</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    System.out.println(<span class="string">"shareCount : "</span> + shareCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> exclusiveCount = <span class="number">1</span> &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"exclusiveCount : "</span> + exclusiveCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">等你运行完之后,你就发现,哇,怎么和我说的一样,哈哈哈哈<br>对于 <code>sharedCount</code> 来说,它是针对读锁的,所以不管多少进程进行读取资源,都没关系,所以它的值就是 0<br>对于 <code>exclusiveCount</code> 来说,它是针对写锁的,那么只要有一个进程在进行写入,其他线程都要停下来等待,所以它的值就是传进来的值<br>综上,使用一个状态的话,我们只需要去判断这个状态是否是 0 就可以了</font></p><h1 id="WriteLock-的具体实现"><a href="#WriteLock-的具体实现" class="headerlink" title="WriteLock 的具体实现"></a><font face="华文中宋" size="3">WriteLock 的具体实现</font></h1><p><font face="华文中宋" size="3">OK ,既然你都看到了这里,我就默认上面的内容你都理解了<br>WriteLock 说白了就是独占锁,所以在获取 WriteLock 时,不能只考虑是否有写锁在占用,还要考虑有没有读锁.接下来咱们就去探究一下, WriteLock 它具体是怎么实现的</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取到锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 获取写锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c != 0 说明有读锁/写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// w == 0 说明此时没有写锁,有读锁 或者 持有写锁的线程不是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果写锁数量超出了最大值,没啥说的,抛异常就完事儿了</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 当前线程持有写锁,为重入锁,直接 +acquires 即可</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS 操作,确保修改值成功</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">如果对 ReentrantLock 比较熟的话,你会发现,上面的代码大部分都是见过的<br>有一点区别就是调用了 <code>exclusiveCount</code> 方法,看当前是否有写锁存在,接下来通过 <code>c != 0 and w == 0</code> 判断了当前是否有读锁存在</font></p><h1 id="ReadLock-的具体实现"><a href="#ReadLock-的具体实现" class="headerlink" title="ReadLock 的具体实现"></a><font face="华文中宋" size="3">ReadLock 的具体实现</font></h1><p><font face="华文中宋" size="3">WriteLock 探究完了,接下来瞅瞅 ReadLock ,话不多说,直接上源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写锁不等于 0 时,看看当前写锁是否在尝试获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 读锁不需要阻塞,而且读锁需要小于最大读锁数量,同时 cas 操作进行加 1 操作</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 当前线程是第一个并且第一次获取读锁时</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程再次获取读锁,则直接进行 ++ 操作即可</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是第一个获取读锁的线程,就放入线程本地变量</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">看完有没有觉得和写锁那块挺像的,不同就在于因为是读锁嘛,所以只要没有写锁占用,而且读锁的数量没有超过最大的获取数量,就都可以获取读锁<br>在上面, <code>firstReader</code>  <code>firstReaderHoldCount</code>  <code>cachedHoldCounter</code> 都是为 <code>readHolds</code> 服务的,它是为了获取当前线程持有锁的数量,在 <code>ThreadLocal</code> 基础上添加了 Int 变量来统计,这样比较方便嘛<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程持有锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="comment">// 当前线程 ID</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回到题目-手写一个读写锁出来"><a href="#回到题目-手写一个读写锁出来" class="headerlink" title="回到题目,手写一个读写锁出来?"></a><font face="华文中宋" size="3">回到题目,手写一个读写锁出来?</font></h1><p><font face="华文中宋" size="3">接下来,再回到题目,如果面试官让手写一个读写锁出来,你会如何实现呢?<br>在读了源码之后,相信你心里应该有谱了<br>首先来个 state 变量,然后高 16 位设置为读锁数量,低 16 位设置为写锁数量低,然后在进行读锁时,先判断下是不是有写锁,如果没有,直接读取即可,如果有的话那就需要等待;在写锁想要拿到锁的时候,就要判断写锁和读锁是不是都存在了,如果存在那就等着,如果不存在才进行接下来的操作<br>在这里我给出一个简单版的实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个读写锁共享变量 state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 高 16 位为读锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getReadCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 低 16 位为写锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getWriteCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &amp; (( <span class="number">1</span> &lt;&lt; <span class="number">16</span> ) - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读锁时,先判断是否有写锁</span></span><br><span class="line">    <span class="comment">// 如果有写锁,就等待</span></span><br><span class="line">    <span class="comment">// 如果没有,进行加 1 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( getWriteCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"lockRead --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state = state + ( <span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放读锁数量减 1 ,通知其他线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unLockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = state - ( <span class="number">1</span> &lt;&lt; <span class="number">16</span> );</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取写锁时需要判断读锁和写锁是否都存在,有则等待,没有则将写锁数量加 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getReadCount() &gt; <span class="number">0</span> || getWriteCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"lockWrite --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放写锁数量减 1 ,通知所有等待线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWriters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state --;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">我自己测试了下,没啥大问题<br>但是如果细究的话,还是有问题的,就比如,如果现在我有好多个读锁,如果一直不释放的话,那么写锁是一直没办法获取到的,这样就造成了饥饿现象的产生嘛<br>解决的话也蛮好解决的,就是在上面添加一个记录写锁数量的变量,然后在读锁之前,去判断一下是否有线程要获取写锁,如果有的话,优先处理,没有的话再进行读锁操作<br>这块大家试试自己实现吧~我这里就不给具体实现了</font></p><p><font face="华文中宋" size="3">最后,我觉得一个专栏至少是要写 15 篇文章,才可以算得上专栏一说<br>Java 并发这个系列,带上这一篇,就已经写了 14 篇了,计划是再写一篇文章,然后 Java 并发这个系列就告一个段落,接下来 Java 并发系列的更新就随缘,看我兴趣了~<br>Java 并发结束之后,就想去写写 JVM/Dubbo/Zookeeper/Redis/RabbitMQ 等等的内容(总之是要写的内容还有好多</font></p><p><font face="华文中宋" size="3">保持饥饿,保持对技术的热情,就酱~<br>大晚上的更新一篇,感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;题目是个标题党,主要是想写一下 ReentrantReadWriteLock&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]最近有点儿飘</title>
    <link href="https://www.dynamic-zheng.com/posts/38d2bcc6.html"/>
    <id>https://www.dynamic-zheng.com/posts/38d2bcc6.html</id>
    <published>2020-09-13T11:01:59.000Z</published>
    <updated>2020-09-13T11:03:18.785Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周博客鸽了<br>因为最近有点儿飘<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">可能是前段时间逼自己太狠了,因为我在写博客之余,还和一群朋友们一起在做公众号,我负责的那一周文章几乎都是我自己硬怼出来的,再加上工作真的是把自己搞的有些累了<br>所以最近有点儿放松自己,下班之后没有看源码/技术书籍这种,是看了一本相对轻松愉快的书籍:  &lt;哑舍&gt;<br>这本书我在高中的时候就开始追了,但是没追完,毕竟当时学业比较繁重,后来上大学,工作了就忘了这回事儿,前几天在微信读书上看到这本书,顿时回忆袭来,所以下班之后就在看这本书了<br>这本书,是我看了这么久还不知道主角名字的一本书,但是它真的很好看,很适合我这种历史不好的人~</font></p><p><font face="华文中宋" size="3">昨天和朋友一起去爬了香山,爬完之后就觉得积累在自己心中的那些焦虑啊,迷茫啊,在这大自然面前都消失的无影无踪~<br>人生这么长,何必计较这一时的得与失,目前做的所有事情,都放在五年十年之后再看,就一定是另外一番景色,所以当下的得与失没必要看得那么重,继续踏踏实实的干就完事儿了<br>所以今天感觉自己以前的情绪,状态都回来了,明天我又是一个打不死的小强,哈哈哈哈<br>不过有一说一,爬完山的我,今天整个人都瘫了</font></p><p><font face="华文中宋" size="3">下周的博客应该会是一篇干货,写什么主题我还没有确定,不过写出来的话,应该不会让读文章的你失望的<br>就这样吧~<br>我再去看会儿书~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;上周博客鸽了&lt;br&gt;因为最近有点儿飘&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发] ThreadLocal 你怎么动不动就内存泄漏?</title>
    <link href="https://www.dynamic-zheng.com/posts/c4ae514c.html"/>
    <id>https://www.dynamic-zheng.com/posts/c4ae514c.html</id>
    <published>2020-08-29T08:42:12.000Z</published>
    <updated>2020-09-18T14:35:43.787Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果说 ThreadLocal 的话,那肯定就会涉及到内存泄漏<br>为啥嘞<br>因为 吧啦吧啦 ~<br><a id="more"></a></font></p><h1 id="ThreadLocal-解决了什么问题呢"><a href="#ThreadLocal-解决了什么问题呢" class="headerlink" title="ThreadLocal 解决了什么问题呢?"></a><font face="华文中宋" size="3">ThreadLocal 解决了什么问题呢?</font></h1><p><font face="华文中宋" size="3">它是为了解决<strong>对象不能被多线程共享访问的问题</strong>,通过 threadLocal.set() 方法将对象实例保存在每个线程自己所拥有的 threadLocalMap 中,这样的话每个线程都使用自己的对象实例,彼此不会影响从而达到了隔离的作用,这样就解决了对象在被共享访问时带来的线程安全问题<br>啥意思呢?打个比方,现在公司所有人都要填写一个表格,但是只有一支笔,这个时候就只能上个人用完了之后,下个人才可以使用,为了保证”笔”这个资源的可用性,只需要保证在接下来每个人的获取顺序就可以了,这就是 lock 的作用,当这支笔被别人用的时候,我就加 lock ,你来了那就进入队列排队等待获取资源(非公平方式那就另外说了),这支笔用完之后就释放 lock ,然后按照顺序给下个人使用<br>但是完全可以一个人一支笔对不对,这样的话,你填写你的表格,我填写我的表格,咱俩谁都不耽搁谁.这就是 ThreadLocal 在做的事情.因为每个 Thread 都有一个副本,就不存在资源竞争,所以也就不需要加锁,这不就是拿空间去换了时间嘛</font></p><p><font face="华文中宋" size="3">在开始之前,咱们先把 Thread, ThreadLocal, ThreadLocalMap 的关系捋一捋</font></p><p><img src="/images/2020/thread.jpg"></p><p><font face="华文中宋" size="3">可以看到,在 Thread 中持有一个 ThreadLocalMap , ThreadLocalMap 又是由 Entry 来组成的,在 Entry 里面有 ThreadLocal 和 value</font></p><h1 id="ThreadLocal-为啥动不动就内存泄漏呢"><a href="#ThreadLocal-为啥动不动就内存泄漏呢" class="headerlink" title="ThreadLocal 为啥动不动就内存泄漏呢?"></a><font face="华文中宋" size="3">ThreadLocal 为啥动不动就内存泄漏呢?</font></h1><p><font face="华文中宋" size="3">在这里先给个解释,后面咱们再详细分析:<br>首先是因为 ThreadLocal 是基于 ThreadLocalMap 实现的,其中 ThreadLocalMap 的 Entry 继承了 WeakReference ,而 Entry 对象中的 key 使用了 WeakReference 封装,也就是说, Entry 中的 key 是一个弱引用类型,对于弱引用来说,它只能存活到下次 GC 之前<br>如果此时一个线程调用了 ThreadLocalMap 的 set 设置变量,当前的 ThreadLocalMap 就会新增一条记录,但由于发生了一次垃圾回收,这样就会造成一个结果: key 值被回收掉了,但是 value 值还在内存中,而且如果线程一直存在的话,那么它的 value 值就会一直存在<br>这样被垃圾回收掉的 key 就会一直存在一条引用链: Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; Value :</font></p><p><img src="/images/2020/引用链.jpg"></p><p><font face="华文中宋" size="3">就是因为这条引用链的存在,就会导致如果 Thread 还在运行,那么 Entry 不会被回收,进而 value 也不会被回收掉,但是 Entry 里面的 key 值已经被回收掉了<br>这只是一个线程,如果再来一个线程,又来一个线程…多了之后就会造成内存泄漏</font></p><p><font face="华文中宋" size="3">知道是怎么造成内存泄漏之后,接下来要做的事情就好说了,不是因为 value 值没有被回收掉所以才会导致内存泄露的嘛<br>那使用完 key 值之后,将 value 值通过 remove 方法 remove 掉,这样的话内存中就不会有 value 值了,也就防止了内存泄漏嘛</font></p><h1 id="ThreadLocal-是基于-ThreadLocalMap-实现的"><a href="#ThreadLocal-是基于-ThreadLocalMap-实现的" class="headerlink" title="ThreadLocal 是基于 ThreadLocalMap 实现的?"></a><font face="华文中宋" size="3">ThreadLocal 是基于 ThreadLocalMap 实现的?</font></h1><p><font face="华文中宋" size="3">OK ,上面的内容讲完了,接下来一一来看<br>首先,你怎么知道 ThreadLocal 是基于 ThreadLocalMap 实现的呢?<br>从源码知道的~<br>在源码中能够看到下面这几行代码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">代码中说的很清楚了,在 ThreadLocal 内部维护着 ThreadLocalMap ,而它的 Entry 则继承自 WeakReference 的 ThreadLocal&lt;?&gt; ,其中 Entry 的 k 为 ThreadLocal , v 为 Object ,在调用 super(k) 时就将 ThreadLocal 实例包装成了一个 WeakReference</font></p><p><font face="华文中宋" size="3">强弱引用这块内容我就直接放一个表格吧:</font></p><table><thead><tr><th style="text-align:center">引用类型</th><th style="text-align:center">功能特点</th></tr></thead><tbody><tr><td style="text-align:center">强引用 ( Strong Reference )</td><td style="text-align:center">被强引用关联的对象永远不会被垃圾回收器回收掉</td></tr><tr><td style="text-align:center">软引用( Soft Reference )</td><td style="text-align:center">软引用关联的对象,只有当系统将要发生内存溢出时,才会去回收软引用引用的对象</td></tr><tr><td style="text-align:center">弱引用 ( Weak Reference )</td><td style="text-align:center">只被弱引用关联的对象,只要发生垃圾收集事件,就会被回收</td></tr><tr><td style="text-align:center">虚引用 ( Phantom Reference )</td><td style="text-align:center">被虚引用关联的对象的唯一作用是能在这个对象被回收器回收时收到一个系统通知</td></tr></tbody></table><p><font face="华文中宋" size="3">从表格中应该能够看出来,弱引用的对象只要发生垃圾收集事件,就会被回收<br>所以弱引用的存活时间也就是下次 GC 之前了<br>在这里我有个问题:为什么 ThreadLocal 采用弱引用,而不是强引用呢?<br>在 ThreadLocalMap 上面有些注释,我在这里摘录一部分,或许可以从中窥探一二:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To help deal with very large and <span class="keyword">long</span>-lived usages, the hash table entries use WeakReferences <span class="keyword">for</span> keys</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">翻译一下就是:(虽然我英语不是很好<br>为了解决非常大且长期使用的问题,哈希表使用了弱引用的 key<br>假设,假设, ThreadLocal 使用的是强引用,会怎样呢?<br>如果是强引用的话,在表格中也能够看出来,被强引用关联的对象,永远都不会被垃圾回收器回收掉<br>如果引用的 ThreadLocal 对象被回收了,但是 ThreadLocalMap 还持有对 ThreadLocal 的强引用,如果没有 remove 的话, 在 GC 时进行可达性分析, ThreadLocal 依然可达,这样就不会对 ThreadLocal 进行回收,但是我们期望的是引用的 ThreadLocal 对象被回收,这样不就达不到目的了嘛<br>使用弱引用的话,虽然会出现内存泄漏的问题,但是在 ThreadLocal 生命周期里面,都有对 key 值为 null 时进行回收的处理操作<br>所以,使用弱引用的话,可以在 ThreadLocal 生命周期中尽可能保证不出现内存泄漏的问题</font></p><p><font face="华文中宋" size="3">啥?在 ThreadLcoal 生命周期里面,都有对 key 值为 null 时进行回收的处理操作?<br>有证据么?<br>我这篇文章都这么写了,要是没有敢拿出来说么(毕竟我是个负责任的博主不是;<br>在源码中, get 方法, set 方法中都有相应的处理,咱们瞅瞅具体是怎么做的(先来看 set 方法)</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         <span class="comment">// 如果 e 不为空,说明 hash 冲突,需要向后查找</span></span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 从这里可以看出, ThreadLocalMap 采用的是开放地址法解决的 hash 冲突</span></span><br><span class="line">         <span class="comment">// 是最经典的 线性探测法 --&gt; 我觉得之所以选择这种方法解决冲突时因为数据量不大</span></span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要查找的 ThreadLocal 对象找到了,直接设置需要设置的值,然后 return</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 k 为 null ,说明有 value 没有及时回收,此时通过 replaceStaleEntry 进行处理</span></span><br><span class="line">        <span class="comment">// replaceStaleEntry 具体内容等下分析</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 tab[i] == null ,则直接创建新的 entry 即可</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 在创建之后调用 cleanSomeSlots 方法检查是否有 value 值没有及时回收</span></span><br><span class="line">    <span class="comment">// 如果 sz &gt;= threshold ,则需要扩容,重新 hash 即, rehash();</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">通过源码可以看到,在 set 方法中,主要是通过 <code>replaceStaleEntry</code> 方法和 <code>cleanSomeSlots</code> 方法去做的检测和处理<br>那咱从源码看看 <code>replaceStaleEntry</code> 它干了啥</font></p><h1 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a><font face="华文中宋" size="3">replaceStaleEntry</font></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前 staleSlot 位置开始向前遍历</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 当 e.get() == null 时, slotToExpunge 记录下此时的 i 值</span></span><br><span class="line">            <span class="comment">// 即 slotToExpunge 记录的是 staleSlot 左手边第一个空的 Entry</span></span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来从当前 staleSlot 位置向后遍历</span></span><br><span class="line">    <span class="comment">// 这两个遍历是为了清理在左边遇到的第一个空的 entry 到右边的第一个空的 entry 之间所有过期的对象</span></span><br><span class="line">    <span class="comment">// 但是如果在向后遍历过程中,找到了需要设置值的 key ,就开始清理,不会再继续向下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 k == key 说明在插入之前就已经有相同的 key 值存在,所以需要替换旧的值</span></span><br><span class="line">        <span class="comment">// 同时和前面过期的对象进行交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 slotToExpunge == staleSlot 说明向前遍历时没有找到过期的</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 进行清理过期数据</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在向后遍历时,没有找到 value 被回收的 Entry 对象</span></span><br><span class="line">        <span class="comment">// 且刚开始 staleSlot 的 key 为空,那么它本身就是需要设置 value 的 Entry 对象</span></span><br><span class="line">        <span class="comment">// 此时不涉及到清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 key 在数组中找不到,那就好说了,直接创建一个新的就可以了</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 slotToExpunge != staleSlot 说明存在过期的对象,就需要进行清理</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 <code>replaceStaleEntry</code> 方法中,需要注意一下刚开始的两个 for 循环中内容(我再贴一下):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 当 e.get() == null 时, slotToExpunge 记录下此时的 i 值</span></span><br><span class="line">    <span class="comment">// 即 slotToExpunge 记录的是 staleSlot 左手边第一个空的 Entry</span></span><br><span class="line">    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line">                        </span><br><span class="line">    <span class="comment">// 如果 slotToExpunge == staleSlot 说明向前遍历时没有找到过期的</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    <span class="comment">// 进行清理过期数据</span></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这两个 for 循环中的 if 到底是在做什么?<br>看第一个 if ,当 <code>e.get() == null</code> 时,此时将 i 的值给 slotToExpunge<br>第二个 if ,当 <code>k ==key</code> 时,此时将 i 给了 staleSlot 来进行交换<br>为什么要对 staleSlot 进行交换呢?画图说明一下<br>如下图,假设此时表长为 10 ,其中下标为 3 和 5 的 key 已经被回收( key 被回收掉的就是 null ),因为采用的开放地址法,所以 15 mod 10 应该是 5 ,但是因为位置被占,所以在 6 的位置,同样 25 mod 10 也应该是 5 ,但是因为位置被占,下个位置也被占,所以就在第 7 号的位置上了<br>按照上面的分析,此时 slotToExpunge 值为 3 , staleSlot 值为 5 , i 为 6 </font></p><p><img src="/images/2020/exchangeOne.jpg"></p><p><font face="华文中宋" size="3">假设,假设这个时候如果不进行交换,而是直接回收的话,此时位置为 5 的数据就被回收掉,然后接下来要插入一个 key 为 15 的数据,此时 15 mod 10 算出来是 5 ,正好这个时候位置为 5 的被回收完毕,这个位置就被空出来了,那么此时就会这样:</font></p><p><img src="/images/2020/exchangeTwo.jpg"></p><p><font face="华文中宋" size="3">同样的 key 值竟然出现了两次?!这肯定是咱们不希望看到的结果,所以一定要进行数据交换<br>在上面代码中有一行代码 <code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code> ,说明接下来的处理是交给了 <code>expungeStaleEntry</code> ,接下来去分析一下 <code>expungeStaleEntry</code></font></p><h1 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry"></a><font face="华文中宋" size="3">expungeStaleEntry</font></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果 k == null ,说明 value 就应该被回收掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时直接将 e.value 置为 null </span></span><br><span class="line">            <span class="comment">// 这样就将 thread -&gt; threadLocalMap -&gt; value 这条引用链给打破</span></span><br><span class="line">            <span class="comment">// 方便了 GC</span></span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这个时候要重新 hash ,因为采用的是开放地址法,所以可以理解为就是将后面的元素向前移动</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">因为是在 <code>replaceStaleEntry</code> 方法中调用的此方法,传进来的值是 staleSlot ,继续上图,经过 <code>replaceStaleEntry</code> 之后,它的数据结构是这样:</font></p><p><img src="/images/2020/exchangeThree.jpg"></p><p><font face="华文中宋" size="3">此时传进来的 staleSlot 值为 6 ,因为此时的 key 为 null ,所以接下来会走 <code>e.value = null</code> ,这一步结束之后,就成了:</font></p><p><img src="/images/2020/exchangeFour.jpg"></p><p><font face="华文中宋" size="3">接下来 i 为 7 ,此时的 key 不为 null ,那么就会重新 hash : <code>int h = k.threadLocalHashCode &amp; (len - 1);</code> ,得到的 h 应该是 5 ,但是实际上 i 为 7 ,说明出现了 hash 冲突,就会继续向下走,最终的结果是这样:</font></p><p><img src="/images/2020/exchangeFive.jpg"></p><p><font face="华文中宋" size="3">可以看到,原来的 key 为 null ,值为 V5 的已经被回收掉了.我认为之所以回收掉之后,还要再次进行重新 hash ,就是为了防止 key 值重复插入情况的发生<br>假设 key 为 25 的并没有进行向前移动,也就是它还在位置 7 ,位置 6 是空的,再插入一个 key 为 25 ,经过 hash 应该在位置 5 ,但是有数据了,那就向下走,到了位置 6 ,诶,竟然是空的,赶紧插进去,这不就又造成了上面说到的问题,同样的一个 key 竟然出现了两次?!<br>而且经过 <code>expungeStaleEntry</code> 之后,将 key 为 null 的值,也设置为了 null ,这样就方便 GC</font></p><p><font face="华文中宋" size="3">分析到这里应该就比较明确了,在 <code>expungeStaleEntry</code> 中,有些地方是帮助 GC 的,而通过源码能够发现, set 方法调用了该方法进行了 GC 处理, get 方法也有,不信你瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果能够找到寻找的值,直接 return 即可</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果找不到,则调用 getEntryAfterMiss 方法去处理</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直探测寻找下一个元素,直到找到的元素是要找的</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果 k == null 说明有 value 没有及时回收</span></span><br><span class="line">            <span class="comment">// 调用 expungeStaleEntry 方法去处理,帮助 GC</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">get 和 set 方法都有进行帮助 GC ,所以正常情况下是不会有内存溢出的,但是如果创建了之后一直没有调用 get 或者 set 方法,还是有可能会内存溢出<br>那么最保险的方法就是,使用完之后就及时 remove 一下,加快垃圾回收,就完美的避免了垃圾回收</font></p><p><font face="华文中宋" size="3">以上,这篇文章到这里就结束了(说句真心话,我自己都没想到这篇文章写完这么长…<br>越深入理解就越是惊叹,大神的思考真是缜密~不是会因为没有及时回收 value 造成内存泄漏么,那我在 set 和 get 方法中再做一些处理,虽然没办法做到 100% 完美,但我做到 80% 可还行?</font></p><hr><p><font face="华文中宋" size="3">又是脑细胞疯狂死掉的一天 :|</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;如果说 ThreadLocal 的话,那肯定就会涉及到内存泄漏&lt;br&gt;为啥嘞&lt;br&gt;因为 吧啦吧啦 ~&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[MySQL]再谈索引</title>
    <link href="https://www.dynamic-zheng.com/posts/4fa89adb.html"/>
    <id>https://www.dynamic-zheng.com/posts/4fa89adb.html</id>
    <published>2020-08-23T00:22:35.000Z</published>
    <updated>2020-08-23T00:30:03.889Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在这篇文章:  <a href="https://www.dynamic-zheng.com/posts/a02f5441.html#more">[mysql]手把手教你给 SQL 做个优化</a>  中介绍了,给 SQL 做优化的时候,最主要的一点就是建索引<br><a id="more"></a><br>那你有没有新的疑问呢?<br>索引采用的数据结构是啥呢,为什么一提到 mysql 就会问 B 树, B+ 树呢<br>今天这篇文章来说说</font></p><p><font face="华文中宋" size="3">在我们给数据库中一个字段建立索引的时候,能够看到可以选择是 Hash 类型,还是 BTREE 类型的索引</font></p><p><img src="/images/2020/索引.jpg"></p><p><font face="华文中宋" size="3">那为什么 InnoDB 引擎默认使用的是 B+ 树而不是 Hash 嘞<br>你想,你细想<br>使用 Hash 的话很容易出现哈希冲突,特别是在数据量非常大的时候,出现了大量的哈希冲突会导致程序的整体查询性能变慢<br>假设我现在有个查询语句是这样写的 <code>select name,age from student where age &gt; 18</code> 这不是蛮简单的嘛,就找出来所有 age 大于 18 的数据就可以了嘛<br>但是对于使用 Hash 数据结构的索引来说,太难了.因为 Hash 是 key-value 的结构,所以它擅长的是精确查询,如果你让它查找  <code>select name,age from student where age = 18</code> 它返回结果就非常快了<br>那既然 Hash 不支持范围查询,支持 key-value ,那它的应用场景是啥呢?就是等值查询咯,给我一个 key 就可以快速回应一个 value ,咦?怎么和 Redis 那么像呢?<br>就是嘛, Redis , Memcached 它们都有用到 Hash 结构</font></p><p><font face="华文中宋" size="3">Hash 不支持范围查找,但是有序数组支持啊<br>那为啥不用有序数组嘞<br>没错,有序数组的查询性能可以说非常好了,不管是等值查询,还是范围查询,效率简直完爆其他<br>但是咱们的应用场景又不是只有查询对吧,还有插入,修改,删除呢,有序数组这个时候就顶不住了<br>特别是如果插入到头部,第一个位置,从第二位开始往后都要开始向后移动,将第一个位置空出来,这么一来,我的天,还没等你插入完毕,用户都等不及跑了</font></p><p><font face="华文中宋" size="3">那新的疑惑来了<br>B+ 树属于树的一种,二叉树也是树的一种,你咋不用二叉树呢<br>你想,你再想</font></p><p><img src="/images/2020/二叉树.jpg"></p><p><font face="华文中宋" size="3">二叉树是每个节点最多只有两个分支,每个节点只存储一个数据的树结构,那如果我的数据量非常大的话呢,比方说一个小目标, 1 亿数据<br>这个时候二叉树的高度就会变得非常高<br>既然是数据,不做持久化嘛?肯定是要持久化到磁盘的,而且就目前公司的成本来说,应该还没富到服务器的硬盘全是固态吧,有些还是机械硬盘,机械硬盘的读取速度又比较慢<br>那么此时我需要在 1 亿数据里面,查找一个数据,再加上机械硬盘的读取速度,可能给它一分钟的时间都找不到需要的数据<br>乖乖,让你在一个空白的页面上呆一分钟,你会么?<br>这个时候你的注意力早就不知道跑哪儿去了,或者这个界面打不开对么?行嘞,关闭界面,浏览下一个</font></p><p><font face="华文中宋" size="3">用户流失不是咱们希望看到的,对吧<br>所以嘞,既然二叉树是树的高度比较高,那我让它低点儿不就好了嘛<br>怎么低呢<br>因为二叉树每个节点只存储一个数据,那我现在让它一个节点多存储几个数据就好了嘛<br>这就是 B 树<br>B 树的一个节点可以存储多个数据</font></p><p><img src="/images/2020/B树.jpg"></p><p><font face="华文中宋" size="3">能够明显看到, B 树相对于二叉树来说,高度降低了不少<br>那为啥不用 B 树做索引呢,采用 B+ 树<br>因为 B+ 树在 B 树的基础上又做了优化<br>那做了什么优化呢<br>咱瞅瞅</font></p><p><img src="/images/2020/B+树.jpg"></p><p><font face="华文中宋" size="3">有没有看出来一些内容<br>在 B+ 树中,叶子节点之间有指针指向,在 B 树中则没有<br>在 B+ 树中,非叶子节点会冗余一份在叶子节点中(比如图中的数据 50 ,在叶子节点中也能看到它)<br>在 B+ 树中,非叶子节点不存储数据,只存储索引<br>在 B+树中,查询必须查找到叶子节点, B 树只要匹配到就可以了, 不需要 care 元素位置,所以 B+ 树查找更慢</font></p><p><font face="华文中宋" size="3">我这个人比较懒,图中用到的图片都是直接从网上拿下来的,拿完也忘了原文地址是啥(非常抱歉,我这个人懒不说,记性也不咋滴,懒 + 记性差到这种理直气壮的程度估计也是没谁了…<br>侵权的话您和我说一声,我立马撤下来</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在这篇文章:  &lt;a href=&quot;https://www.dynamic-zheng.com/posts/a02f5441.html#more&quot;&gt;[mysql]手把手教你给 SQL 做个优化&lt;/a&gt;  中介绍了,给 SQL 做优化的时候,最主要的一点就是建索引&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[Java 集合]你确定LinkedList 在新增/删除元素时,效率比 ArrayList 高?</title>
    <link href="https://www.dynamic-zheng.com/posts/bde049c8.html"/>
    <id>https://www.dynamic-zheng.com/posts/bde049c8.html</id>
    <published>2020-08-15T05:59:21.000Z</published>
    <updated>2020-08-15T06:07:53.571Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在面试的时候都会被问到集合相关的问题,比如:你能讲讲 ArrayList 和 LinkedList 的区别吗?<br><a id="more"></a><br>那么我相信你肯定能够答上来: ArrayList 是基于数组实现的, LinkedList 是基于链表实现的<br>接下来面试官就会连环问了,那你能讲讲,它们都用在什么场景下吗?<br>我猜你一定会回答:因为 ArrayList 是基于数组实现的,所以在遍历的时候, ArrayList 的效率是要比 LinkedList 高的, LinkedList 是基于链表实现的,所以在进行新增/删除元素的时候, LinkedList 的效率是要比 ArrayList 高的<br>面试官:哦哦,好的,我大概了解了,我这边没有什么想问的了,您回去等消息可以吗<br>???发生了什么?</font></p><p><font face="华文中宋" size="3">哈哈,上面模拟了一个面试场景,是想引出来这篇文章的主题:LinkedList 在新增/删除元素时,效率比 ArrayList 高,这是真的吗?<br>我相信你也知道套路,一般这么一问,那肯定就不是真的了<br>放一张图片,这是经过我测试之后的真实结果</font></p><p><img src="/images/2020/ArrayList-LinkedList.jpg"></p><p><font face="华文中宋" size="3">测试代码因为比较多,我放在了 github 上,感兴趣想要自己动手实践的,可以去看看:  <a href="https://github.com/justdojava/java-samples/tree/master/arraylist-linkedlist-test" target="_blank" rel="noopener">arraylist-linkedlist-test</a><br>接下来分析下,为什么和以前认为的不一样</font></p><h2 id="ArrayList-与-LinkedList-新增元素比较"><a href="#ArrayList-与-LinkedList-新增元素比较" class="headerlink" title="ArrayList 与 LinkedList 新增元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 新增元素比较</font></h2><p><font face="华文中宋" size="3">从图中可以看出来, LinkedList 在新增元素时,它的效率不一定比 ArrayList 高,这是要分情况的<br>如果是从集合头部位置新增元素的话,那确实是 LinkedList 的效率要比 ArrayList 高<br>但是如果是从集合中间位置或者是尾部位置新增元素, ArrayList 效率反而要比 LinkedList 效率要高</font></p><p><font face="华文中宋" size="3">Excuse me ?竟然和我以前学的不一样?博主我学的浅,你别骗我<br>哈哈哈,为什么会这样呢<br>这是因为 ArrayList 是基于数组实现的嘛,而数组是一块连续的内存空间,所以在添加元素到数组头部时,需要对头部后面的数据进行复制重排,所以效率是蛮低的<br>但是 LinkedList 是基于链表实现的,在添加元素的时候,首先会通过循环查找到添加元素的位置,如果要添加的位置处于 List 前半段,那就从前向后找;如果位置在后半段,那就从后往前找,所以 LinkedList 添加元素到头部是非常高效的(小声 BB ,这我知道</font></p><p><font face="华文中宋" size="3">哦,这你知道?看来基础蛮不错的嘛~<br>所以当 ArrayList 在添加元素到数组中间时,有一部分数据需要复制重排,效率就不是很高,那为啥 LinkedList 比它还要低呢?这是因为 LinkedList 把元素添加到中间位置的时候,需要在添加之前先遍历查找,这个查找的时间比较耗时</font></p><p><font face="华文中宋" size="3">添加元素到尾部操作中, ArrayList 的效率要比 LinkedList 的还要高,这是为啥嘞<br>因为 ArrayList 在添加的时候不需要什么操作,直接插入就好了,所以效率蛮高的<br>但是 LinkedList 就不一样了,对于 LinkedList 来说,也不需要查找啥的,直接插入就可以了,但是需要 new 对象,还有变换指针指向对象呀,这些过程耗时加起来可就比 ArrayList 长了</font></p><p><strong><font face="华文中宋" size="3">它是有前提的,那就是 ArrayList 初始化容量是足够的情况下,才有上述的特点,如果 ArrayList 涉及到动态扩容,那它的效率肯定会降低</font></strong></p><h2 id="ArrayList-与-LinkedList-删除元素比较"><a href="#ArrayList-与-LinkedList-删除元素比较" class="headerlink" title="ArrayList 与 LinkedList 删除元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 删除元素比较</font></h2><p><font face="华文中宋" size="3">删除元素和新增元素的原理是一样的,所以删除元素的操作和新增元素的操作耗时也是很相近<br>这里就不再赘述</font></p><h2 id="ArrayList-与-LinkedList-遍历元素比较"><a href="#ArrayList-与-LinkedList-遍历元素比较" class="headerlink" title="ArrayList 与 LinkedList 遍历元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 遍历元素比较</font></h2><p><font face="华文中宋" size="3">测试结果非常明显,对于 LinkedList 来说,如果使用 for 循环的话,效率特别低,但是 ArrayList 使用 for 循环去遍历的话,就比较高<br>为啥呢?<br>emmm ,得从源码说起</font></p><p><font face="华文中宋" size="3">先来看 ArrayList 的源码吧,这个比较简单</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够看到, ArrayList 实现了 List , RandomAccess , Cloneable 还有 Serializable 接口<br>你是不是对 RandomAccess 这个接口挺陌生的?这是个啥?<br>但是通过查阅源码能够发现它也只是个空的接口罢了,那 ArrayList 为啥还要去实现它嘞<br>因为 RandomAccess 接口是一个标志接口,它标识着”只要实现该接口的 list 类,都可以实现快速随机访问”<br>实现快速随机访问?你能想到什么?这不就是数组的特性嘛!可以直接通过 index 来快速定位 &amp; 读取</font></p><p><font face="华文中宋" size="3">那你是不是就能想到, ArrayList 是数组实现的,所以实现了 RandomAccess 接口, LinkedList 是用链表实现的,所以它没有用 RandomAccess 接口实现吧?<br>beautiful ~就是这样<br>咱瞅瞅 LinkedList 源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">果然,跟咱们设想的一样,没有实现 RandomAccess 接口<br>那为啥 LinkedList 接口使用 for 循环去遍历的时候,慢的不行呢?<br>咱们瞅瞅 LinkedList 在 get 元素时,都干了点儿啥</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 get 方法中,主要调用了 node() 方法,因为 LinkedList 是双向链表,所以 <code>if (index &lt; (size &gt;&gt; 1))</code> 在判断 i 是在前半段还是后半段,如果是前半段就正序遍历,如果是在后半段那就倒序遍历,那么为什么使用 for 循环遍历 LinkedList 时,会这么慢?(好像离真相越来越近了<br>原因就在两个 for 循环之中,以第一个 for 循环为例</font></p><ul><li><font face="华文中宋" size="3">get(0) :直接拿到了node0 地址,然后拿到 node0 的数据</font></li><li><font face="华文中宋" size="3">get(1) :先拿到 node0 地址,然后 i &lt; index ,开始拿 node1 的地址,符合条件,然后去拿 node1 的数据</font></li><li><font face="华文中宋" size="3">get(2) :先拿到 node0 的地址,然后 i &lt; index ,拿到 node1 的地址, i &lt; index ,继续向下走,拿到 node2 的地址,符合条件,获取 node2 的数据</font></li></ul><p><font face="华文中宋" size="3">发现问题了嘛?我就是想要 2 的数据, LinkedList 在遍历时,将 0 和 1 也给遍历了,如果数据量非常大的话,那效率可不就唰唰的下来了嘛</font></p><p><font face="华文中宋" size="3">那到现在,咱们也就非常明确了,如果是要遍历 ArrayList 的话,最好是用 for 循环去做,如果要遍历 LinkedList 的话,最好是用迭代器去做<br>我猜你一定会说,那如果对方就给我传过来了一个 list ,我不知道它是 ArrayList 还是 LinkedList 呀?我该怎么办呢<br>还记得 ArrayList 和 LinkedList 有什么不同吗?是不是 ArrayList 实现了 RandomAccess 接口,但是 LinkedList 没有实现,所以可以从这点去着手解决</font></p><p><font face="华文中宋" size="3">我在这里给个简单的小 demo ,你可以参考下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/8/15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList.add(<span class="string">"aaa"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"bbb"</span>);</span><br><span class="line">        isUseIterator(arrayList);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        linkedList.add(<span class="string">"ccc"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"ddd"</span>);</span><br><span class="line">        isUseIterator(linkedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isUseIterator</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)&#123;</span><br><span class="line">            System.out.println(<span class="string">"实现了 RandomAccess 接口,使用 for 循环遍历"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.size(); i++ )&#123;</span><br><span class="line">                System.out.println(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有实现 RandomAccess 接口,使用迭代器遍历"</span>);</span><br><span class="line"></span><br><span class="line">            Iterator it = list.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                System.out.println(it.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">本篇文章用到的所有代码,都上传到了 github 上,需要的可以去看看:   <a href="https://github.com/justdojava/java-samples/tree/master/arraylist-linkedlist-test" target="_blank" rel="noopener">arraylist-linkedlist-test</a></font></p><p><font face="华文中宋" size="3">参考:<br>极客时间: Java 性能调优实战</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在面试的时候都会被问到集合相关的问题,比如:你能讲讲 ArrayList 和 LinkedList 的区别吗?&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.dynamic-zheng.com/categories/java/"/>
    
    
      <category term="java 基础" scheme="https://www.dynamic-zheng.com/tags/java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[设计模式]你不是对单例模式比较熟吗?你倒是写一个线程安全的出来呀!</title>
    <link href="https://www.dynamic-zheng.com/posts/2645232e.html"/>
    <id>https://www.dynamic-zheng.com/posts/2645232e.html</id>
    <published>2020-08-09T12:48:28.000Z</published>
    <updated>2020-08-14T04:45:27.551Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我也不知道为什么,上周我明明写了文章传上来了,结果今天一瞅,嗯?我的文章呢?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">为了证明我没有说谎,我这里有图为证:</font></p><p><img src="/images/2020/设计模式.jpg"></p><p><font face="华文中宋" size="3">不多说了,咱们直接正文开始<br>单例模式比较好理解,就是保证只有一个对象被创建<br>如果是单线程下代码还比较好写一些:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面的是饿汉模式,在类加载时就开始创建<br>懒汉模式就比较懒,在使用的时候才会创建</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全--并不推荐,因为带来了性能上的开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">如果是在单线程环境下,上面的代码是没有任何问题的<br>但是如果是在多线程环境下呢?<br>现在同时有线程 A 和 B 要创建线程,此时线程 A 拿到了 instance 的值为 null ,然后 CPU 停止了当前线程 A ,线程 B 开始运行,也拿到了 instance 的值为 null ,接下来线程 A 和 B 都会去创建<br>怎么办呢?加个双重检测机制,再加个锁</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式--&gt;双重同步锁模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> * 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2, ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3, instance = memory 设置 instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 和 cpu 优化时,会发生指令重排</span></span><br><span class="line">    <span class="comment">// 有可能发生 1,3,2</span></span><br><span class="line">    <span class="comment">//此时会导致线程不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;   <span class="comment">// 使用了双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123;   <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这样双重检测再加锁看似是没有问题了<br>但是还记得吗? JVM 是会指令重排的,本来 1,2,3 运行下来没问题,结果呢,指令重排之后就变成了 1,3,2 ,还是两个线程,线程 A 拿到第一个的 instance 为 null ,线程 B 拿到的是指令重排之后的第二个 instance 为 null ,此时仍然有线程不安全的问题<br>那我不让它指令重排不就好了? volatile 就要大显身手了</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式--&gt;双重同步锁模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2, ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3, instance = memory 设置 instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 和 cpu 优化时,会发生指令重排</span></span><br><span class="line">    <span class="comment">// 有可能发生 1,3,2</span></span><br><span class="line">    <span class="comment">//此时会导致线程不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象--- volatile + 双重检测机制--&gt;禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;   <span class="comment">// 使用了双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class) &#123;   <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面都是对懒汉模式的优化,饿汉模式也想线程安全,该咋办嘞</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全---&gt;要注意 private static 和 static 的先后执行顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample6</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample6</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample6 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">还有一种最安全的方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全---最安全</span></span><br><span class="line"><span class="comment"> * 推荐使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line">        <span class="comment">// JVM 保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;我也不知道为什么,上周我明明写了文章传上来了,结果今天一瞅,嗯?我的文章呢?&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.dynamic-zheng.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.dynamic-zheng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[mysql]手把手教你给 SQL 做个优化</title>
    <link href="https://www.dynamic-zheng.com/posts/a02f5441.html"/>
    <id>https://www.dynamic-zheng.com/posts/a02f5441.html</id>
    <published>2020-08-02T12:10:34.000Z</published>
    <updated>2020-08-02T12:17:30.279Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">首先明确一个问题:如果我的 SQL 语句执行的足够快,还有没有必要去做优化?<br>完全没有必要对吧<br><a id="more"></a><br>所以我们一般说,要给 SQL 做个优化,那肯定就是这条 SQL 语句执行的比较慢了<br>那么,为什么它会执行比较慢呢?</font></p><h1 id="SQL-语句执行较慢的-3-个原因"><a href="#SQL-语句执行较慢的-3-个原因" class="headerlink" title="SQL 语句执行较慢的 3 个原因"></a><font face="华文中宋" size="3">SQL 语句执行较慢的 3 个原因</font></h1><h2 id="没有建立索引-或者索引失效导致了-SQL-语句执行较慢"><a href="#没有建立索引-或者索引失效导致了-SQL-语句执行较慢" class="headerlink" title="没有建立索引,或者索引失效导致了 SQL 语句执行较慢"></a><font face="华文中宋" size="3">没有建立索引,或者索引失效导致了 SQL 语句执行较慢</font></h2><p><font face="华文中宋" size="3">这个应该是比较好理解的,如果数据比较多,在千万级别以上,然后呢又没有建立索引,在这千万级别的数据中查找你想要的内容,简直就是在肉搏啊<br>索引失效这块内容说起来就比较多了,比如在查询的时候,让 like 通配符在前面了,比如经常念叨的”最左匹配原则”,又比如我们在查询条件中使用 or ,而且 or 前后条件中有一个列没有索引,等等这些情况都会导致索引失效</font></p><h2 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a><font face="华文中宋" size="3">锁等待</font></h2><p><font face="华文中宋" size="3">常用的存储引擎主要有 InnoDB 和 MyISAM 这两种了,前者支持行锁和表锁,后者就只支持表锁<br>如果数据库操作都是基于表锁的话,意思就是说,现在有个更新操作,就会把整张表锁起来,那么查询的操作都不被允许,所以就不要说提高系统的并发性能了</font></p><ul><li><font face="华文中宋" size="3">聪明的你肯定就知道了,既然 MyISAM 只支持表锁,那么使用 InnoDB 不就好了?你以为 InnoDB 的行锁不会升级成表锁嘛? too young too simple !</font></li><li><font face="华文中宋" size="3">如果对一张表进行大量的更新操作, mysql 就觉得你这样用会让事务的执行效率降低,到最后还是会导致性能下降,这样的话,还不如把你的行锁升级成表锁呢</font></li><li><font face="华文中宋" size="3">还有一点,行锁可是基于索引加的锁,在执行更新操作时,条件索引都失效了,那么这个锁也会执行从行锁升级为表锁</font></li></ul><h2 id="不恰当的-SQL-语句"><a href="#不恰当的-SQL-语句" class="headerlink" title="不恰当的 SQL 语句"></a><font face="华文中宋" size="3">不恰当的 SQL 语句</font></h2><p><font face="华文中宋" size="3">这个也比较常见了,啥是不恰当的 SQL 语句呢?就比如,明明你需要查找的内容是 name , age ,但是呢,为了省事,直接 select * ,或者在 order by 时,后面的条件不是索引字段,这就是不恰当的 SQL 语句</font></p><h1 id="优化-SQL-语句"><a href="#优化-SQL-语句" class="headerlink" title="优化 SQL 语句"></a><font face="华文中宋" size="3">优化 SQL 语句</font></h1><p><font face="华文中宋" size="3">在知道了 SQL 语句执行比较慢的原因之后,接下来要做的就是对症下药了<br>针对 没有索引/索引失效 这块,最有效的办法就是 EXPLAIN 语法了,其实 Show Profile 也可以<br>针对 锁等待 这块,没办法了,只能自己多注意<br>针对 不恰当的 SQL 语句 这块,介绍几个常用的 SQL 优化,比如分页查询怎么优化一下可以查询的更快一些呀,你不是说 select * 不是正确的打开方式嘛?那什么是正确的 select 方式呢?我下面都会讲讲<br>废话不多说,咱们开始了</font></p><h1 id="先来个表"><a href="#先来个表" class="headerlink" title="先来个表"></a><font face="华文中宋" size="3">先来个表</font></h1><p><font face="华文中宋" size="3">为了确保优化后的结果和我写的一样(起码 90% 是相符的<br>所以咱们用一样的数据库好不好<br>首先建个 demo 的数据库</font></p><p><img src="/images/2020/建库.jpg"></p><p><font face="华文中宋" size="3">接下来咱们建表,就建个非常简单的表好不好</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE demo.table(</span><br><span class="line"><span class="function">id <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> NOT NULL,</span></span><br><span class="line"><span class="function">a <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> DEFAULT NULL,</span></span><br><span class="line"><span class="function">b <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> DEFAULT NULL,</span></span><br><span class="line"><span class="function">PRIMARY <span class="title">KEY</span><span class="params">(id)</span></span></span><br><span class="line"><span class="function">) ENGINE </span>= INNODB</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">然后插入 10 万条数据</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS demo_insert;</span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">demo_insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">    DECLARE i INT</span>; </span><br><span class="line">SET i = <span class="number">1</span>;</span><br><span class="line">    WHILE i &lt;= <span class="number">100000</span> DO</span><br><span class="line">        INSERT INTO demo.`table` VALUES (i, i, i);</span><br><span class="line">        SET i = i + <span class="number">1</span> ;</span><br><span class="line">    END WHILE;</span><br><span class="line">END;</span><br><span class="line"><span class="function">CALL <span class="title">demo_insert</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3"> OK ,准备工作做好了,接下来开始实战</font></p><h2 id="通过-EXPLAIN-分析-SQL-是怎样执行的"><a href="#通过-EXPLAIN-分析-SQL-是怎样执行的" class="headerlink" title="通过 EXPLAIN 分析 SQL 是怎样执行的"></a><font face="华文中宋" size="3">通过 EXPLAIN 分析 SQL 是怎样执行的</font></h2><p><font face="华文中宋" size="3">只要说 SQL 调优,那就离不开 EXPLAIN </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `table` WHERE id &lt; <span class="number">100</span> ORDER BY a;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/explain.jpg"></p><p><font face="华文中宋" size="3">咱们能够看到有好几个参数:</font></p><ul><li><font face="华文中宋" size="3">id :每个执行计划都会有一个 id ,如果是一个联合查询的话,这里就会显示好多个 id</font></li><li><font face="华文中宋" size="3">select_type :表示的是 select 查询类型,常见的就是 SIMPLE (普通查询,也就是没有联合查询/子查询), PRIMARY (主查询), UNION ( UNION 中后面的查询), SUBQUERY (子查询)</font></li><li><font face="华文中宋" size="3">table :执行查询计划的表,在这里我查的就是 table ,所以显示的是 table, 那如果我给 table 起了别名 a ,在这里显示的就是 a</font></li><li><font face="华文中宋" size="3">type :查询所执行的方式,这是咱们在分析 SQL 优化的时候一个非常重要的指标,这个值从好到坏依次是: system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL <ul><li><font face="华文中宋" size="3">system/const :说明表中只有一行数据匹配,这个时候根据索引查询一次就能找到对应的数据</font></li><li><font face="华文中宋" size="3">eq_ref :使用唯一索引扫描,这个经常在多表连接里面,使用主键和唯一索引作为关联条件时可以看到</font></li><li><font face="华文中宋" size="3">ref :非唯一索引扫描,也可以在唯一索引最左原则匹配扫描看到</font></li><li><font face="华文中宋" size="3">range :索引范围扫描,比如查询条件使用到了 &lt; ,  &gt; ,  between 等条件</font></li><li><font face="华文中宋" size="3">index :索引全表扫描,这个时候会遍历整个索引树</font></li><li><font face="华文中宋" size="3">ALL :表示全表扫描,也就是需要遍历整张表才能找到对应的行</font></li></ul></font></li><li><font face="华文中宋" size="3">possible_keys :表示可能使用到的索引</font></li><li><font face="华文中宋" size="3">key :实际使用到的索引</font></li><li><font face="华文中宋" size="3">key_len :使用的索引长度</font></li><li><font face="华文中宋" size="3">ref :关联 id 等信息</font></li><li><font face="华文中宋" size="3">rows :找到符合条件时,所扫描的行数,在这里虽然有 10 万条数据,但是因为索引的缘故,所以扫描了 99 行的数据</font></li><li><font face="华文中宋" size="3">Extra :额外的信息,常见的有以下几种<ul><li><font face="华文中宋" size="3">Using where :不用读取表里面的所有信息,只需要通过索引就可以拿到需要的数据,这个过程发生在对表的全部请求列都是同一个索引部分时</font></li><li><font face="华文中宋" size="3">Using temporary :表示 mysql 需要使用临时表来存储结果集,常见于 group by / order by</font></li><li><font face="华文中宋" size="3">Using filesort :当查询的语句中包含 order by 操作的时候,而且 order by 后面的内容不是索引,这样就没有办法利用索引完成排序,就会使用”文件排序”,就像例子中给出的,建立的索引是 id , 但是我的查询语句 order by 后面是 a ,没有办法使用索引</font></li><li><font face="华文中宋" size="3">Using join buffer :使用了连接缓存</font></li><li><font face="华文中宋" size="3">Using index :使用了覆盖索引</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">如果对这些参数了解的非常不错,那么 EXPLAIN 这块内容就难不住你了</font></p><h2 id="Show-Profile-分析下-SQL-执行性能"><a href="#Show-Profile-分析下-SQL-执行性能" class="headerlink" title="Show Profile 分析下 SQL 执行性能"></a><font face="华文中宋" size="3">Show Profile 分析下 SQL 执行性能</font></h2><p><font face="华文中宋" size="3">通过 EXPLAIN 分析执行计划,只能说明 SQL 的外部执行情况,如果想要知道 mysql 具体是如何查询的,需要通过 Show Profile 来分析</font></p><p><font face="华文中宋" size="3">可以通过 <code>SHOW PROFILES;</code> 语句来查询最近发送给服务器的 SQL 语句,默认情况下是记录最近已经执行的 15 条记录,如下图我们可以看到:</font></p><p><img src="/images/2020/showprofile.jpg"></p><p><font face="华文中宋" size="3">我想看具体的一条语句,看到 Query_ID 了嘛?然后运行下 <code>SHOW PROFILE FOR QUERY 82;</code> 这条命令就可以了:</font></p><p><img src="/images/2020/queryid.jpg"></p><p><font face="华文中宋" size="3">可以看到,在结果中, Sending data 耗时是最长的,这是因为此时 mysql 线程开始读取数据并且把这些数据返回到客户端,在这个过程中会有大量磁盘 I/O 操作<br>通过这样的分析,我们就能知道, SQL 语句在查询过程中,到底是 磁盘 I/O 影响了查询速度,还是 System lock 影响了查询速度</font></p><h2 id="分页查询怎么可以更快一些"><a href="#分页查询怎么可以更快一些" class="headerlink" title="分页查询怎么可以更快一些"></a><font face="华文中宋" size="3">分页查询怎么可以更快一些</font></h2><p><font face="华文中宋" size="3">在使用分页查询时,都会使用 limit 关键字<br>但是对于分页查询,其实还可以优化一步<br>我这里给出的数据库不是太好,因为它太简单了,看不出来有什么区别,我使用目前项目上正在用的表来做个实验,可以看下区别(使用的 SQL 语句如下面):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `te_paper_record` ORDER BY id LIMIT <span class="number">10000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM `te_paper_record` WHERE id &gt;= ( SELECT id FROM `te_paper_record` ORDER BY id LIMIT <span class="number">10000</span>, <span class="number">1</span>) LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/不使用子查询.jpg"></p><p><img src="/images/2020/使用子查询.jpg"></p><p><font face="华文中宋" size="3">上面一张图片,我没有使用子查询,可以看到执行了 0.033s ,下面的查询语句,我使用了子查询去做优化,能够看到执行了 0.007s ,优化的结果还是很显而易见的</font></p><p><font face="华文中宋" size="3">那么,为什么使用了子查询,查询的速度就提上来了呢,这是因为当我们没有使用子查询时,查询到的 10020 行数据都返回回来了,接下来要对这 10020 行数据再进行操作<br>那可不可以直接就返回需要的 20 行数据呢?可以,子查询就是在做这件事情<br>所以查询时间上有了一个很大的优化</font></p><h2 id="正确的-select-打开方式"><a href="#正确的-select-打开方式" class="headerlink" title="正确的 select 打开方式"></a><font face="华文中宋" size="3">正确的 select 打开方式</font></h2><p><font face="华文中宋" size="3">在查询时,有时为了省事,直接使用 <code>select * from table where id = 1</code> 这样的 SQL 语句,但是这样的写法在一些环境下是会存在一定的性能损耗的<br>所以最好的 select 查询就是,需要什么字段就查询什么字段<br>一般在查询时,都会有条件,按照条件查找<br>这个时候正确的 select 打开方式是什么呢?</font></p><p><font face="华文中宋" size="3">如果可以通过主键索引的话, where 后面的条件,优先选择主键索引<br>为什么呢?这就要知道 MySQL 的存储规则<br>MySQL 常用的存储引擎有 MyISAM 和 InnoDB , InnoDB 会创建主键索引,而主键索引属于聚簇索引,也就是在存储数据时,索引是基于 B+ 树构成的,具体的行数据则存储在叶子节点</font></p><p><font face="华文中宋" size="3">也就是说,如果是通过主键索引查询的,会直接搜索 B+ 树,从而查询到数据<br>如果不是通过主键索引查询的,需要先搜索索引树,得到在 B+ 树上的值,再到 B+ 树上搜索符合条件的数据,这个过程就是”回表”<br>很显然,回表能够产生时间.<br>这也是为什么建议, where 后面的条件,优先选择主键索引</font></p><h1 id="其他调优"><a href="#其他调优" class="headerlink" title="其他调优"></a><font face="华文中宋" size="3">其他调优</font></h1><p><font face="华文中宋" size="3">看完上面的,心里应该就大概有数了, SQL 调优主要就是建立索引/防止产生锁等待/使用恰当的 SQL 语句去查询<br>但是,如果问你除了索引,除了上面这些手段,还有没有其他调优方式<br>啥?竟然还有?!<br>有的,这就需要跳出来,不要局限在具体的 SQL 语句上了,需要在数据库设计之初就考虑好<br>比如说,我们常说的要遵循三范式,但是其实有些时候,表里面有些冗余字段带来的效果要更好<br>当然了,这块的内容可能 DBA 就已经考虑好了,但是多了解一点儿也没什么坏处嘛</font></p><p><font face="华文中宋" size="3">OK ,这次的分享就这样啦~<br>非常感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;首先明确一个问题:如果我的 SQL 语句执行的足够快,还有没有必要去做优化?&lt;br&gt;完全没有必要对吧&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://www.dynamic-zheng.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://www.dynamic-zheng.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]我最近在做的事情</title>
    <link href="https://www.dynamic-zheng.com/posts/6240cbda.html"/>
    <id>https://www.dynamic-zheng.com/posts/6240cbda.html</id>
    <published>2020-07-26T09:40:28.000Z</published>
    <updated>2020-07-26T09:41:34.252Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周的时候,就已经预告了,这周文章也是水文一篇,因为我说最近比较忙嘛<br>那今天就来交代下,最近在忙什么<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">自考<br>八月初有考试,自学考试.(是的,你没看错,就是下周<br>我知道要早点儿开始学,但是一直到七月初我才开始看书,七月二十号的样子,才把课本第一遍看完,这个时候还没看课后题,也没有刷题<br>没办法,都是以前欠下的债<br>为了抓紧一切时间学习,大早上六点就起床,自己都被自己感动哭了</font></p><p><font face="华文中宋" size="3">写作训练营<br>我感觉自己最近写作遇到了瓶颈,我不知道该怎么去写一篇文章,写完之后阅读量也不怎么样,也不知道该写什么<br>这个时候就需要一位老师来帮助我了.正好一直信任的明白老师开了一个写作训练营,果断花了 1K+ 报名,说实话,因为训练营还有筛选机制,我还真的挺怕把我筛掉…不过蛮幸运的,没有被筛选掉<br>所以这几天的精力,除了工作,就是自考,要么是写作训练营</font></p><p><font face="华文中宋" size="3">三件事,就足够把我的时间和精力占满,每天都掏空了自己<br>总得想办法逃出自己的舒适区不是~<br>等我忙完了考试 &amp; 参加完训练营,我再认认真真写文章</font></p><p><font face="华文中宋" size="3">目前的话,我的脑袋里面已经有了一篇文章的大纲了,预计完整写出来的话,字数大概在 3000+<br>但是因为我下周有考试嘛,所以怎么也要等我考试完了,写完发出来的话,估计就是周日晚上了<br>就这样~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;上周的时候,就已经预告了,这周文章也是水文一篇,因为我说最近比较忙嘛&lt;br&gt;那今天就来交代下,最近在忙什么&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]坦白了,这是我最喜欢的一部动漫</title>
    <link href="https://www.dynamic-zheng.com/posts/18ababf6.html"/>
    <id>https://www.dynamic-zheng.com/posts/18ababf6.html</id>
    <published>2020-07-19T13:05:50.000Z</published>
    <updated>2020-07-19T13:10:45.870Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">坦白点儿,最近没有沉迷于学习,下班了就赖在床上刷动漫,真香!<br>虽然考试在即,可我还是想去刷我的动漫(废材就是我了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我还记得小时候看这部动漫,下课了就跑回家就是为了看这部动漫,如果停电了,都能被气的半死…(那个时候孩子还小;<br>这部动漫就是:犬夜叉<br>我自己都不知道这是刷的第几次了,自己压力大的时候,睡不着的时候,就会刷一遍,然后再刷一遍</font></p><p><img src="/images/2020/犬夜叉.jpg"></p><p><font face="华文中宋" size="3">小时候最喜欢的几部动漫:犬夜叉,名侦探柯南,网球王子,黑子的篮球,东京食尸鬼…这么一数好像喜欢的不少<br>之所以喜欢追动漫,是因为它真的给了我很多力量,特别适合在自己压力大的时候,去看看,然后我就动力满满,跟打了鸡血一样</font></p><p><font face="华文中宋" size="3">犬夜叉这部是我最喜欢的一部动漫,既然是水文一篇,那我就随便说说咯</font></p><p><font face="华文中宋" size="3">犬夜叉<br>刚开始的他,总是想获得更强大的力量,想要成为真正的妖怪<br>但是遇到桔梗之后,懂得了守护,开始想要陪伴一个人,但是因为命运,唉~<br>后来遇到了戈薇,七宝,弥勒,珊瑚,在和他们一起奋斗的日子里,开始慢慢变得信任别人,自己恢复为人的日子是不能让别人知道的,因为在这天会失去妖力,如果让别人知道,自己可能就会失去性命,到最后,越来越多的人知道朔日之夜,在变成人类的那个夜晚,他也越来越坦然<br>应该是真正接受了自己的身份吧</font></p><p><font face="华文中宋" size="3">戈薇<br>不得不说高桥留老师的心思细腻,戈薇只是一个女孩,她喜欢犬夜叉,当她看到犬夜叉放不下桔梗的时候,自己也会悲伤,也会嫉妒<br>桔梗被奈落的瘴气所伤,能净化的只有戈薇,戈薇但凡是有一点不想救桔梗的心,就会失败<br>最后成功救到了桔梗,因为她的心是善良的<br>她会大大方方的承认自己喜欢犬夜叉,也大大方方的承认自己嫉妒桔梗,这份坦诚,真的让人很感动</font></p><p><font face="华文中宋" size="3">弥勒 &amp; 珊瑚<br>这两个人,背负的东西都太多了<br>一个是不知道自己什么时候会死,一个是亲眼目睹了自己的家人被弟弟亲手杀害<br>但他们在旅行的途中,彼此治愈着 &amp; 温暖着<br>特别是完结篇,弥勒为了能够更好的保护珊瑚,喝下了可以抑制痛苦的药;在最后珊瑚说想陪他,最后还是不忍心</font></p><p><font face="华文中宋" size="3">杀生丸<br>这个人物简直不要太帅~<br>我还记得小时候看的,觉得杀生丸特别讨厌犬夜叉,因为犬夜叉是半妖,杀生丸是从内心鄙视犬夜叉的<br>相比于犬夜叉因为半妖的身份受尽欺负,杀生丸简直是含着金钥匙出生的,一出生就拥有很强大的力量,直接就是别人的顶点,但也是这一点,让他不知道什么是害怕,什么是恐惧,别人执着的东西,他是不屑的,就像四魂之玉一样,别的妖怪费尽心思想要,他却一看都不看<br>一直执着于获得铁碎牙的他,却一直被铁碎牙的结界给拒绝,后来在玲的陪伴下,慢慢了解到什么是恐惧,在完结篇中,玲因为在冥界承受不住阴气失去呼吸,天生牙也没办法拯救她时,杀生丸慌了,整个表情痛苦不已<br>啊啊啊,整部动漫就这里让杀生丸痛苦了,可以想象他的改变有多大~<br>知道害怕和恐惧之后,不再执着于获得铁碎牙的力量,反而因此获得了自己的力量—爆碎牙</font></p><p><font face="华文中宋" size="3">奈落<br>每次看到他,都想不行,我一定要继续快点儿看,这样才能看到他死去<br>奈落为了获得四魂之玉伤害了很多人,利用了很多人,践踏别人的感情<br>但是他又是可怜的,他所做的一切,也不过是为了得到桔梗的心<br>但是啊,爱情这种事情,怎么可能是你想得到就可以得到的呢<br>爱而不得的奈落,杀死了桔梗,玩弄别人的感情在股掌之中,可是想想,如果不曾体会过感情的话,又怎么可能玩弄别人的感情呢<br>奈落是爱桔梗的,但是他的爱,等不来她</font></p><p><font face="华文中宋" size="3">桔梗<br>这个人物是我最不想写的,太悲情了<br>身为一个巫女,她的一生都是活在战斗中的,后来复活的她,也是为了消除四魂之玉奋斗着,独自一人奋斗着,想想就觉得好孤独啊<br>印象特别深刻的是一个场景:在一个夜晚,犬夜叉和戈薇起来看星星,戈薇身上披着的是犬夜叉的火鼠裘,靠在犬夜叉的肩上,而与此同时,桔梗孤独一人只有死魂虫陪着她,在月色下她在想:犬夜叉,你现在在做什么呢<br>太让人心疼了~<br>明明她也只是一个平凡的女子啊,明明她也只是想过平凡的日子呀</font></p><p><font face="华文中宋" size="3">这篇文章就是这样啦~其实其他人物也很饱满 &amp; 鲜活,如果有想写的,等我再刷一遍,哈哈哈<br>对了,预告下,估计下周的文章我也要水一篇了<br>emmm ,最近有点儿忙<br>就酱~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;坦白点儿,最近没有沉迷于学习,下班了就赖在床上刷动漫,真香!&lt;br&gt;虽然考试在即,可我还是想去刷我的动漫(废材就是我了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
