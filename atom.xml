<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑璐璐|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dynamic-zheng.com/"/>
  <updated>2020-11-08T11:53:25.331Z</updated>
  <id>https://www.dynamic-zheng.com/</id>
  
  <author>
    <name>郑璐璐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[MySQL]是不是 redo log 和 binlog 傻傻分不清楚?</title>
    <link href="https://www.dynamic-zheng.com/posts/42d9f222.html"/>
    <id>https://www.dynamic-zheng.com/posts/42d9f222.html</id>
    <published>2020-11-08T11:44:45.000Z</published>
    <updated>2020-11-08T11:53:25.331Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在 MySQL 中,特别是存储引擎使用的是 InnoDB 时,那肯定绕不过去两个概念: redo log (重做日志) 和 binlog (二进制日志)<br><a id="more"></a><br>简单点儿说: redo log 是 InnoDB 存储引擎层方面的日志,所以如果你使用的存储引擎不是 InnoDB 的话,那就根本谈不上 redo log<br>binlog 是 MySQL Server 层记录的日志,所以不管是用的什么存储引擎,只要是 MySQL 都是会有 binlog 的存在,在做 MySQL 主从复制的时候,利用的就是 binlog<br>那么,你有疑问嘛?为什么要有 redo log 和 binlog ,只用一个 log 不可以嘛?<br>咱们详细来看看它们都分别做了啥</font></p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a><font face="华文中宋" size="3">redo log</font></h1><p><font face="华文中宋" size="3">为什么要有 redo log ?<br>我们可以这样想,如果没有 redo log 的话, MySQL 是如何进行工作的<br>查询还好说,毕竟只是查询一下记录而已,并没有对数据进行更改<br>那如果是增加和更新操作呢?现在一条 update 语句过来,后面是不是一定会有限定条件,就比如现在要更新一条记录,把 A 的银行卡余额更新到 1k ,那这条语句是不是应该来个限定条件,类似 <code>where userName = &#39;A&#39;</code> ,也就是说,一般 update 操作都伴随着查询的操作,得先找到这个人,然后再进行更新操作对吧<br>如果数据量比较小还好,很快就能找到并且更新完毕<br>但是如果数据量比较大,里面有一亿条数据,怎么办?而且更新操作肯定是要写到磁盘上去的,那这中间的 IO 成本呢?如果我有好几十条 update 语句先后更新呢?这样想的话,你就能想到,就这些操作,成本就高的不行,那能不能降低一下这些成本呢?</font></p><p><font face="华文中宋" size="3">这就是 redo log 的作用<br>就是当有一条记录更新的时候, InnoDB 引擎就会先把记录写到 redo log 里面去,同时更新内存,这样就算是更新这条数据成功了<br>但是此时,它并没有更新到磁盘上去对吧?别担心, InnoDB 会在恰当的时候,把这条及记录更新到磁盘上去<br>这样的思想或者技术,有个专有名词: WAL 技术,也就是 WriteAheadLogging ,核心就是先写日志,再写磁盘</font></p><p><font face="华文中宋" size="3">同样,这里面有个问题<br>redo log 不能一直写吧?如果更新操作一直写入到 redo log 中的话,不限制大小的话,可能服务器上的存储空间都被 redo log 给占满了<br>所以 InnoDB 的 redo log 是固定大小的,比如我们配置了一组 4 个文件,每个文件大小是 1GB ,那么它的操作可能就会这样:</font></p><p><img src="/images/2020/mysql.jpg"></p><p><font face="华文中宋" size="3">能够看到,主要就是 write pos 和 checkpoint , write pos 比较好理解,它就是当前记录的位置,有需要记录的操作就从当前位置向后移,等把 ib_logfile_3 写完之后,就回到 ib_logfile_0 文件开头继续写<br>checkpoint 是当前要擦除的位置,就是 InnoDB 引擎不是会在恰当的时候,将这些操作进行持久化,更新到磁盘上去,那持久化之后的数据是不是就可以擦除了<br>write pos 和 checkpoint 之间的部分就是可以用来记录操作的部分,那么如果 write pos 和 checkpoint 相遇了怎么办?相遇了是不是说明这个时候分配的 redo log 大小用完了,那这时候就不能再进行更新操作了,必须停下来处理一下,将 checkpoint 往前推推才行</font></p><p><font face="华文中宋" size="3">就是因为有了 redo log ,所以 InnoDB 才可以保证即使数据库发生了异常重启,也没关系,之前提交的记录都还在,只需要根据 redo log 里面的记录进行相应恢复就可以了<br>所以如果你和 DBA 比较熟的话,可以问问,咱们的 MySQL 是不是可以恢复到半个月内任意一秒的状态,如果对方回答是,别怀疑,他真的不是在吹牛逼</font></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a><font face="华文中宋" size="3">binlog</font></h1><p><font face="华文中宋" size="3">binlog 是 MySQL Server 层的记录日志,这块举个例子来说吧</font></p><p><font face="华文中宋" size="3">在说之前,我们要明白 redo log 和 binlog 的区别:</font></p><ul><li><font face="华文中宋" size="3">redo log 是 InnoDB 引擎特有的, binlog 是 MySQL 的 Server 层实现的,所有的引擎都是可以的</font></li><li><font face="华文中宋" size="3">redo log 是物理日志,记录的是”在 XXX 页上做了 XXX 修改”; binlog 是逻辑日志,比如” 给 id = 2 这一行的 c 字段加 1”</font></li><li><font face="华文中宋" size="3">redo log 是有固定大小的,所以它的空间会用完,如果用完的话,一定要进行一些写入磁盘的操作才可以继续; binlog 是可以追加写入的,也就是 binlog 没有空间的概念,一直写就行了</font></li></ul><p><font face="华文中宋" size="3">理解了它们之间区别之后,我们拿一个更新操作来举例<br>我现在要给 <code>id = 2 这一行的 c 字段加 1</code> ,到 MySQL 层面,它是如何去做的呢?<br>首先,会先找到这条 <code>id = 2</code> 的数据,然后找到 c 字段进行加 1 操作,这个时候,引擎会将这行数据更新到内存中,同时把这个更新操作记录到 redo log 里面,这个时候 redo log 处于 prepare 状态,随后执行器生成这个操作的 binlog ,并且把 binlog 写入到磁盘完成之后,执行器调用引擎的提交事务接口,引擎把刚刚写入的 redo log 从 prepare 状态改成 commit 状态,这样更新操作才算完成</font></p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><font face="华文中宋" size="3">两阶段提交</font></h1><p><font face="华文中宋" size="3">在上面的描述中,你能发现 redo log 竟然是先 prepare 状态,等 binlog 写完之后,才是 commit 状态,这种方式就叫”两阶段提交”<br>为什么会有这种方式呢?<br>redo log 和 binlog 都可以用于表示事务的提交状态,而两阶段提交就是让这两个状态保持逻辑上的一致</font></p><p><font face="华文中宋" size="3">可以假设一下,如果不采用这种方式,而是就先写 redo log ,再写 binlog ,会怎样?<br>如果在写 binlog 时,发生了异常,更新操作已经到 redo log 中了,但是此时 binlog 并没有进行更新,是不是出现了数据不一致?<br>先写 binlog 再写 redo log 也是一样<br>所以,在写时,先让 redo log 处于 prepare 状态,等 binlog 写完之后,再让 redo log 处于 commit 状态,这样就保持了逻辑上的一致</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇~</font></p><p><font face="华文中宋" size="3">参考<br>极客时间 – MySQL 实战 45 讲</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在 MySQL 中,特别是存储引擎使用的是 InnoDB 时,那肯定绕不过去两个概念: redo log (重做日志) 和 binlog (二进制日志)&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[项目]在 swagger 界面实现 token 验证</title>
    <link href="https://www.dynamic-zheng.com/posts/e23cc848.html"/>
    <id>https://www.dynamic-zheng.com/posts/e23cc848.html</id>
    <published>2020-10-30T15:43:16.000Z</published>
    <updated>2020-10-30T15:46:13.094Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我先说下背景:我最近不是换了家公司工作,然后这家公司就是不管发什么请求都是需要带着 token 信息的,也就是说,比如现在我写好代码了,想要验证我写的代码对不对,咱们现在用的都是 springboot , springcloud 框架,写完了直接在 swagger 界面上进行调试就 OK 了,但是现在不管什么请求都要携带 token 信息,默认的 swagger 配置是没有的<br><a id="more"></a><br>我在上家公司的时候,当时的权限部门帮我们都做好了 token 验证,只要是能够进入到我们系统的用户,那就是有权限的,所以当时的项目直接在 swagger 界面上进行测试就 OK 了<br>我刚接手项目熟悉的时候,想要测试一下请求, swagger 上没办法添加 token 信息,所以我就得用 postman 去测</font></p><p><font face="华文中宋" size="3">对我来说是有点儿难受的,你想想,我以前就是写好了接口,启动项目,去 swagger 项目上一测试,没问题提交代码完事儿,有问题我就可以直接进行调试<br>现在使用 postman 测试没问题还好,有问题的话, token 不知道怎么添加进去,感觉就是明明可以直接使用 swagger 的,现在要再进行一个第三方 postman ,就感觉用的不是很顺手嘛</font></p><p><font face="华文中宋" size="3">所以我就想,能不能在 swagger 上直接就可以添加上 token 信息,这样的话,我就不需要再借助第三方工具 postman 了<br>一倒腾还真的让我给搞成功了</font></p><p><font face="华文中宋" size="3">swagger 整合细节我就不说了,这里主要就是 swagger 启动那里需要设置,具体代码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">controllerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加 head 参数配置 start</span></span><br><span class="line">    ParameterBuilder token = <span class="keyword">new</span> ParameterBuilder();</span><br><span class="line">    List&lt;Parameter&gt; pars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    token.name(<span class="string">"Authorization"</span>).description(<span class="string">"token 信息"</span>).modelRef(<span class="keyword">new</span> ModelRef(<span class="string">"String"</span>))</span><br><span class="line">            .parameterType(<span class="string">"header"</span>).required(<span class="keyword">false</span>).build();</span><br><span class="line">    pars.add(token.build());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .enable(enable)</span><br><span class="line">            .apiInfo(<span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                    .title(projectName + <span class="string">"接口文档"</span>)</span><br><span class="line">                    .description(projectDesc + <span class="string">""</span>)</span><br><span class="line">                    .license(<span class="string">"郑璐璐 csdn"</span>)</span><br><span class="line">                    .licenseUrl(<span class="string">"https://blog.csdn.net/zll_0405"</span>)</span><br><span class="line">                    .version(version)</span><br><span class="line">                    .build())</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(basePackage))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            <span class="comment">// 注意一下 globalOperationParameters 这行配置</span></span><br><span class="line">            .globalOperationParameters(pars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">OK ,添加好上面的代码之后,再启动就能在 swagger 界面上看到下面的改动了:</font></p><p><img src="/images/2020/token.png"></p><p><font face="华文中宋" size="3">在图中红框框的地方,输入 token 信息,然后执行一下,你就会发现,使用 swagger 我又可以了,哈哈哈</font></p><p><font face="华文中宋" size="3">注意:给出的代码只是一个小 demo ,具体信息请根据自己的项目信息去配置<br>以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;我先说下背景:我最近不是换了家公司工作,然后这家公司就是不管发什么请求都是需要带着 token 信息的,也就是说,比如现在我写好代码了,想要验证我写的代码对不对,咱们现在用的都是 springboot , springcloud 框架,写完了直接在 swagger 界面上进行调试就 OK 了,但是现在不管什么请求都要携带 token 信息,默认的 swagger 配置是没有的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[碎碎念]是的,我换了家公司工作</title>
    <link href="https://www.dynamic-zheng.com/posts/83a68896.html"/>
    <id>https://www.dynamic-zheng.com/posts/83a68896.html</id>
    <published>2020-10-25T05:59:50.000Z</published>
    <updated>2020-10-25T06:02:41.935Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近我在忙着换公司工作的事情,虽然平时也一直在学习 &amp; 输出,也一直在尽力把自己写的文章系统化,但是去面试还是要好好准备的,所以各位读者可能也感受到了,最近这两周的文章质量都不是很高,毕竟我的时间精力都在那里嘛<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">经过最近的面试之后,有些感受,在这里写写,如果对你能够有所帮助的话,那可真是太好了</font></p><p><font face="华文中宋" size="3">1 ,自己简历上的东西,既然写了熟悉或者精通,那就一定要能够达到那样的层次<br>面试官面试的时候,都是根据你的简历来问你的,所以一定要对自己的简历负责.如果写了精通,那就一定要有对应的深度<br>因为我上家公司是做在线教育方面的,我负责的主要业务就是学生考试,并发量什么的都是比较多的,那最好就是使用多线程去处理啦,所以我对多线程这块就很熟悉,如果面试的话,不问那就算了,只要一问这块就是我的亮点<br>那么你肯定就会问了,什么程度算是精通呢,什么算是熟练使用呢,什么算是熟悉呢<br>我觉得精通的话,那肯定是不管这方面问你什么问题都是问不倒的.比如你说你精通多线程这块内容是吧,那么多内容,别的咱先别问,就问个 synchronized 关键字,它的锁膨胀是怎样的呢,你是怎么判断当前是有锁状态,无锁状态的, synchronized 后来做了优化,具体优化是什么呢,提到 synchronized 的话,它和 ReentrantLock 有什么区别? ReentrantLock 又是基于 AQS 实现的,又能说出来多少.我觉得如果这些问题都没问住你的话,那么你说你精通,我是相信的.<br>熟练使用的话,就需要你达到出现了问题知道怎么解决,比如你说你熟练使用 mysql , OK ,那现在有个 sql 语句执行特别慢,如果是你的话,你会怎么处理呢,其中的几个关键参数也是能够说出来的;你说你熟练使用 Linux 命令,那么我想要查看日志,想要查看特定进程,是不是都应该答上来<br>熟悉的话,我觉得就是一个你知道的层次,比如你说你熟悉 GC 算法,那 标记清除/标记复制/标记整理 优缺点,适用于新生代还是老年代就应该答出来<br>所以简历上如果写了精通,那就一定要有对应的深度;如果写了熟悉,那一些基本的知识应该能够答上来的</font></p><p><font face="华文中宋" size="3">2 ,如果面试官问了你不会的内容,那就坦白说自己不会<br>说来比较愧疚,虽然一直在用 ssm, springboot, springcloud 这些框架,但是 spring 源码我还没读过,一直都处在使用的层面<br>当时面试的时候,面试官就问我有没有阅读过 spring 的源码,我就很坦白的说,我没有阅读过,只是一直在用,面试官也就没有继续追问下去<br>如果我当时为了装逼说我阅读过源码的话,那估计被吊打的就是我了</font></p><p><font face="华文中宋" size="3">3 ,如果你面了几家公司,后续都没有了消息,别怀疑自己,只是职位不匹配而已<br>我当时在找工作的时候,恰好另外一位朋友也在找工作,所以我俩那时候交流就比较多嘛<br>然后他面了有十几家公司了,面到最后都没有了后话,那段时间他就一直问我,是不是自己不够好,是不是自己不够优秀.有一说一,我那位朋友技术上比我厉害是真的,所以我就安慰他,没事儿的,再面面,说不定下家公司就要你了呢<br>结果现在他手上有好几个 offer ,在愁去哪家公司比较好.<br>所以在面试的过程中,如果面了几家,几十家公司,还没收到一份 offer ,别怀疑自己,真的<br>这就像你去超市买东西一样,怎么那么多东西不拿,就拿快乐肥宅水呢,无他,只是匹配你的需求而已.那其他的就不好么?不是,只是目前还没有遇到买家而已<br>找工作也是这样,可能只是你的技术栈和对方不匹配,但总会有一家公司的技术栈和你是匹配的对吧,别灰心,继续努力就行</font></p><p><font face="华文中宋" size="3">4 ,面试过程中,不要怕,展示你自己就可以了<br>我记得我当时投简历的时候,想要换个领域去看看嘛,毕竟世界那么大<br>我就投了一家区块链公司,说真的,区块链公司和我目前接触的领域,差别太大了.我目前接触的领域,一天的数据量最多也就几百万数据,这还是最多的,但是我去面的那家区块链公司,数据量都已经达到了 T 级别<br>而且大家应该也都知道,很小的一个问题,当数据量非常大的时候,那么这个小问题可能就是一个大问题.比如现在要往数据库里面插入一条数据,插入之前先看看数据库中有没有,如果有的话,那就直接更新,如果没有再做插入<br>如果我来做的话,那就直接一个 if else 就完了,但是面试官说,如果直接 if else 的话,我现在的数据量就是几个 T ,只是判断数据库中有没有这条数据就可能要花费很多时间<br>就我上面的这个例子,大家也能看到,我接触的领域对于区块链领域来说,是非常不匹配的,当时面试的时候面试官也很坦率,就和我说他们想要的 java 不是我这样的,技术栈不匹配<br>我当时听了面试官这样说,就觉得都这样说了,可能就没有后续了,结果面试官说,但是在面试的整个过程中,我觉得你的性格,沟通能力都是蛮不错的,很适合和我们团队一起做事<br>所以嘞,面试过程中,别怕,哪怕去面试的领域不是自己擅长的领域,那也没啥怕的,会就说,不会就说不会,不懂就向面试官请教,说不定你身上的哪点特质就被面试官相中了呢~</font></p><p><font face="华文中宋" size="3">5,算法和数据结构是真的重要<br>实话实说,我的算法就不是很好,去面试的时候能够感觉到不管是大公司,还是小公司都是挺看重算法的,动不动就让你手写几个算法,真的就是标配了<br>所以面试的话,这块最好还是准备一下</font></p><p><font face="华文中宋" size="3">经过面试之后,发现了自己需要提高的地方还是蛮多的,接下来我就继续努力就完了</font></p><p><font face="华文中宋" size="3">感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;最近我在忙着换公司工作的事情,虽然平时也一直在学习 &amp;amp; 输出,也一直在尽力把自己写的文章系统化,但是去面试还是要好好准备的,所以各位读者可能也感受到了,最近这两周的文章质量都不是很高,毕竟我的时间精力都在那里嘛&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]爬上来说两句</title>
    <link href="https://www.dynamic-zheng.com/posts/78166b12.html"/>
    <id>https://www.dynamic-zheng.com/posts/78166b12.html</id>
    <published>2020-10-18T04:33:30.000Z</published>
    <updated>2020-10-18T04:35:37.284Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">先道个歉,因为上周博客我鸽了,另外我再摸着良心说,尴尬,我没良心<br>这周技术上没啥输入,也就没啥高质量的输出了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我最近在准备换家公司工作的事情,所以不管是时间上,还是精力上,都有些不够用,有时候真的恨不得把自己掰成好几个,一个在工作,一个在学习,一个在输出高质量文章,一个在准备面试,一个在面试,哈哈哈</font></p><p><font face="华文中宋" size="3">在交接工作的时候,我才发现原来在过去的时间里我成长了这么多<br>不管是开发,还是运维,还是管理,或是沟通,或是表达,都让我和几年前的自己全然不同<br>不过,能够有这样的我,中间付出了多少,怕是只有自己才知道吧<br>但是付出的东西我不想总是过多的去说,因为这都是我想要付出的,无怨无悔的那种,而且还是非常享受的那种,甘之如始</font></p><p><font face="华文中宋" size="3">我记得面试的时候,面试官问过我接下来的发展,这两天我也在问自己,未来到底是想要成为什么<br>我到现在都没有想清楚,我未来到底是想要成为什么,但是有一点是非常清楚的,就是我喜欢去钻技术,我想让自己的技术沉淀下来,我想通过业务去将我身上的技术价值发挥到最大,我喜欢看着自己写的代码通过网络给一些人带去了一些改变和方便<br>这是我目前享受,乐意去做的事情</font></p><p><font face="华文中宋" size="3">我觉得现在让我去计划五年之后的事情,太难了<br>就像五年前的我,没有想过我会走上编程的道路,成为一个程序媛一样,现在让我去想五年后的事情,我想象不出来<br>我能够想象出来的就是,五年之后的我,肯定比现在的自己,还要优秀.因为我在坚持每天进步一点点~</font></p><p><font face="华文中宋" size="3">就这样吧~主要是自己这周没啥输入,所以废话了好多文字<br>总是写这样的文章,我自己心里感觉也是挺过意不去的,因为我最近总是水文…</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;先道个歉,因为上周博客我鸽了,另外我再摸着良心说,尴尬,我没良心&lt;br&gt;这周技术上没啥输入,也就没啥高质量的输出了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[redis]关于 缓存穿透/缓存击穿/缓存雪崩 看这篇文章就够了</title>
    <link href="https://www.dynamic-zheng.com/posts/2d85a910.html"/>
    <id>https://www.dynamic-zheng.com/posts/2d85a910.html</id>
    <published>2020-10-04T09:41:52.000Z</published>
    <updated>2020-10-04T09:45:27.891Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">redis 在项目中用的话,主要就是用作缓存了<br>既然用作缓存,那就肯定会有 缓存穿透/缓存击穿/缓存雪崩 的问题<br>这篇文章就来说说,遇到这种情况时,该如何去处理<br><a id="more"></a></font></p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><font face="华文中宋" size="3">缓存穿透</font></h1><p><font face="华文中宋" size="3">首先咱们搞明白什么是缓存穿透?这三个词这么像,得把概念搞清楚不是<br>其实只是从字面意思上来看的话,大概也能知道一点儿,缓存穿透嘛,就是直接穿过了缓存,将请求打到了数据库上面去<br>一般情况下,去查询数据的话,缓存里面应该都是有的,但是防不住黑客呀,如果黑客请求查询的是数据库里面根本不存在的数据,数据库里面都没有的数据,缓存里面肯定也不会有了,对吧,那么此时请求就会打到咱们的数据库里面去,这就是<strong>缓存穿透</strong><br>你想啊,黑客想要攻击的话,怎么可能只请求一次呢,肯定是大量的请求过来,因为是拿数据库里面不存在的 id 来请求的,那么这些请求毫无疑问直接打到了数据库上面去,那咱们的数据库可能就会因为这些大量的请求直接宕掉</font></p><p><font face="华文中宋" size="3">如何解决呢?<br>咱们回到产生这个问题的场景中,为什么大量的请求会打到数据库上面来?因为缓存里面没有对应的 key 对吧,所以才会越过缓存直接到数据库<br>那么问题就好解决了嘛,缓存里面没有对应的 key ? OK,如果这个 key 数据库里面也没有,那我就在 redis 里面,存上这个 key ,值是 null ,这样如果有查询这个 key 的请求,我直接返回 null 就完事儿了,也就不用打到数据库上面去了<br>注意一下,要记得设置它的过期时间,一般三到五分钟就够了</font></p><p><font face="华文中宋" size="3">但是对方是个黑客呀,可能就用一个 key 去请求么?他可能会在短时间内用大量的 key 来发送请求,那如果一个 key 就在 redis 中存储一个 null 值的话,那么多 key 是不是就会存储那么多个 null 值嘞?<br>这样的话, redis 里面是不是都是值为 null 的了?<br>所以有没有更好的解决办法呢?<br>那必须得有!<br>布隆过滤器,你值得尝试</font></p><p><font face="华文中宋" size="3">什么是布隆过滤器呢?就是它能告诉你,某个值一定不存在或者可能存在( emmmm ,也不知道我有没有说清楚<br>所以可以将数据库的内容缓存一份到布隆过滤器,这样的话,当大量的请求过来的时候,<br> redis 里面没有,没关系,再去布隆过滤器过滤一下,这样请求不用打到数据库上面去,就能确定这个 key 数据库中有没有<br> 这样不就降低了数据库的压力么,可真是个天才~</font></p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><font face="华文中宋" size="3">缓存击穿</font></h1><p><font face="华文中宋" size="3">缓存击穿说的是,在高并发情况下,如果好多个请求都在查询一个 key ,好巧不巧的是,这个 key 因为某些原因失效了(比如设置的过期时间到了,缓存服务器宕机了),这样就会导致那么多的请求都直接打到数据库上面去了<br>那如果这些请求的数量足够大的话,可能直接把数据库就干掉了</font></p><p><font face="华文中宋" size="3">知道了造成结果的原因,那么寻找解决方案也就好办了<br>不是因为好多个请求打到了数据库嘛,但是它们请求的都只是一个 key ,所以这里可以使用排斥锁来实现,第一个请求达到请求 key 发现缓存里面没有,允许它去数据库查询,同时加锁,这样第二个请求,第三个请求…都会被锁阻塞到当前,不会再打到数据库,这样就减少了数据库的并发压力</font></p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><font face="华文中宋" size="3">缓存雪崩</font></h1><p><font face="华文中宋" size="3">缓存雪崩,雪崩雪崩嘛,就比较严重,击穿说的是一个 key 失效的情况,雪崩指的是大规模的缓存失效情况的发生,这是有可能发生的,比如说我的缓存服务器宕机了,那是不是直接就大规模的缓存失效了;或者说,我当时为了图省事,好多个 key 设置的过期时间都是一样的,然后刚好在缓存都失效的时候,好多请求不同的 key 过来了</font></p><p><font face="华文中宋" size="3">解决方案的话,其实就不适合使用加锁的方式去解决了,因为这是好多请求不同的 key ,它不是一个嘛<br>而且嘞,咱们是因为好多个 key 设置的过期时间都是一样的,所以解决方案就是,咱们不设置同样的时间让缓存失效了,咱们给一个随机时间,让缓存随机失效,这样的话,大规模的缓存失效情况就减少很多了<br>那还要一种情况呢,就是如果我的缓存服务器直接宕机了,这怎么办?也好弄,来个集群就解决了,这里只是一个解决方案,它的落地实现不是本文重点哈~</font></p><h1 id="再谈-布隆过滤器"><a href="#再谈-布隆过滤器" class="headerlink" title="再谈 布隆过滤器"></a><font face="华文中宋" size="3">再谈 布隆过滤器</font></h1><p><font face="华文中宋" size="3">OK ,你如果看到这里的话,其实这篇文章的内容就说完了<br>但是我感觉布隆过滤器那块,我没有说清楚,所以在这里拿出来详细说一说</font></p><p><font face="华文中宋" size="3">布隆过滤器是一种数据结构,它是一种概率型的数据结构,就是它能告诉你”某样东西一定不存在或者可能存在”<br>唉,你可能会说,这话刚刚不是说过了嘛,本来就挺拗口的,你咋还说<br>还不是因为这句话比较重要,我觉得把这句话理解透彻了,那么对布隆过滤器理解的应该也就到位了</font></p><p><font face="华文中宋" size="3">来,为了形象生动一些,咱们举个例子~<br>布隆过滤器是一个 bit 向量或者说 bit 数组,大概长这样:</font></p><p><img src="/images/2020/布隆过滤器-初始.jpg"></p><p><font face="华文中宋" size="3">现在,我们需要把 “AliPay” 这个字段给存储进去<br>大概的存储过程就是:将要映射的值,使用多个不同的哈希函数生成多个哈希值,然后每个生成的哈希值指向的 bit 置为 1<br>以给的为例,我们现在将 “AliPay” 这个值,通过三个不同的哈希函数进行映射,那么大概就是这样了:</font></p><p><img src="/images/2020/布隆过滤器-第一次映射.jpg"></p><p><font face="华文中宋" size="3">同样,现在我要存储另外一个值 “WechatPay” ,那么可能映射之后就是下面这样:</font></p><p><img src="/images/2020/布隆过滤器-第二次映射.jpg"></p><p><font face="华文中宋" size="3">细心的你可能就会发现, 4 号位置的值,刚开始不是给 “AliPay” 了么,后来 “WechatPay” 也在那里,这样的话,值不就给覆盖掉了嘛<br>嗯,没错,是给覆盖到了</font></p><p><font face="华文中宋" size="3">接下来,我们查询 “Ali” 那么查询之后,布隆过滤器可能会给你 “0,1,2” 的值, 结果呢 “2” 的位置是 0 ,说明没有任何值映射到这个位置上来,所以我们就可以判定数据库里面没有 “Ali” 这个值<br>那我查询 “AliPay” 的话,毫无疑问,肯定会返回给我 “1,4,6” ,那我们能说数据库里面一定有 “AliPay” 么?不能,因为 “1,4,6” 的值有可能被其他的值给映射了,所以我们只能说,数据库里可能存在 “AliPay”<br>这就是布隆过滤器说的”某个值一定不存在或者可能存在”<br>你理解了嘛?(不理解的话,我也就写到这儿了~</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;redis 在项目中用的话,主要就是用作缓存了&lt;br&gt;既然用作缓存,那就肯定会有 缓存穿透/缓存击穿/缓存雪崩 的问题&lt;br&gt;这篇文章就来说说,遇到这种情况时,该如何去处理&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="https://www.dynamic-zheng.com/categories/redis/"/>
    
    
      <category term="redis" scheme="https://www.dynamic-zheng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]面试官:三个线程顺序执行,你来说说有几种实现方式?</title>
    <link href="https://www.dynamic-zheng.com/posts/f0d1ecb0.html"/>
    <id>https://www.dynamic-zheng.com/posts/f0d1ecb0.html</id>
    <published>2020-09-25T13:44:49.000Z</published>
    <updated>2020-09-25T13:46:24.772Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">写在前面:<br>越是基础知识,越要系统<br><a id="more"></a><br>正文开始:</font></p><p><font face="华文中宋" size="3">先说下要求,就是三个线程,假设是线程 1,2,3, 现在的要求是:必须是线程 1 先执行,然后线程 2 再执行,最后是线程 3 执行<br>然后有几种实现方法呢?<br>其实它的本质就是实现,让线程 2,3  等待线程 1 执行完毕,所以重点就是有哪些方法可以让线程 2,3 等待</font></p><h1 id="join"><a href="#join" class="headerlink" title="join"></a><font face="华文中宋" size="3">join</font></h1><p><font face="华文中宋" size="3">第一反应应该就是使用 join 方法,因为 join 本来就是支持这种机制的<br>比如,我在线程 B 中调用了线程 A 的 join 方法,那么线程 B 就会等线程 A 执行结束之后再执行.<br>那么具体应该怎么使用嘞?<br>别慌嘛,我这里有例子,你瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(<span class="keyword">null</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t1));</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t2));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Thread beforeThread)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果有线程,就 join 进来,没有的话就直接输出</span></span><br><span class="line">            <span class="keyword">if</span> (beforeThread != <span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join();</span><br><span class="line">                    System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><font face="华文中宋" size="3">CountDownLatch</font></h1><p><font face="华文中宋" size="3">刚才说了,本质就是让线程 B,C 等待线程 A 执行完毕<br>那么信号量就是一个不错的选择<br>如果想要实现的话,那大概就是下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置线程 1 的信号量为 0</span></span><br><span class="line">        CountDownLatch cOne = <span class="keyword">new</span> CountDownLatch(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置线程 2 的信号量为 1</span></span><br><span class="line">        CountDownLatch cTwo = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置线程 3 的信号量为 1</span></span><br><span class="line">        CountDownLatch cThree = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 cOne 为 0 ,故 t1 可以直接执行</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cOne,cTwo));</span><br><span class="line">        <span class="comment">// 线程 t1 执行完毕之后,此时的 cTwo 为 0 , t2 开始执行</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cTwo,cThree));</span><br><span class="line">        <span class="comment">// 线程 t2 执行完毕,此时 cThree 为 0 , t3 开始执行</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cThree,cThree));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        CountDownLatch cOne;</span><br><span class="line">        CountDownLatch cTwo;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(CountDownLatch cOne, CountDownLatch cTwo)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.cOne = cOne;</span><br><span class="line">            <span class="keyword">this</span>.cTwo = cTwo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前一个线程信号量为 0 时,才执行</span></span><br><span class="line">                cOne.await();</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 后一个线程信号量减 1</span></span><br><span class="line">                cTwo.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用单个线程池"><a href="#使用单个线程池" class="headerlink" title="使用单个线程池"></a><font face="华文中宋" size="3">使用单个线程池</font></h1><p> <font face="华文中宋" size="3">之所以线程 1,2,3 的执行顺序无法保证,是因为在编译器可能会去做一些优化,导致没有办法按照顺序执行<br> 如果我们使用单个线程池去执行的话,那就没有这样的问题了<br> 具体实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopThree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run one"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run two"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run three"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 将线程依次加入到线程池中</span></span><br><span class="line">        executor.submit(t1);</span><br><span class="line">        executor.submit(t2);</span><br><span class="line">        executor.submit(t3);</span><br><span class="line">        <span class="comment">// 及时将线程池关闭</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><font face="华文中宋" size="3">CompletableFuture</font></h1><p><font face="华文中宋" size="3">如果使用 CompletableFuture 来实现的话,代码就非常简洁了</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopFour</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(()-&gt; t1.start())</span><br><span class="line">                .thenRun(()-&gt;t2.start())</span><br><span class="line">                .thenRun(()-&gt;t3.start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">你还有别的什么方法么?欢迎评论区和我交流~<br>以上,非常感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;写在前面:&lt;br&gt;越是基础知识,越要系统&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]面试官让我手写一个读写锁出来,我...</title>
    <link href="https://www.dynamic-zheng.com/posts/76a7b252.html"/>
    <id>https://www.dynamic-zheng.com/posts/76a7b252.html</id>
    <published>2020-09-18T14:35:25.000Z</published>
    <updated>2020-09-18T14:40:13.781Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">题目是个标题党,主要是想写一下 ReentrantReadWriteLock<br><a id="more"></a></font></p><h1 id="ReentrantReadWriteLock-与-ReentrantLock-区别"><a href="#ReentrantReadWriteLock-与-ReentrantLock-区别" class="headerlink" title="ReentrantReadWriteLock 与 ReentrantLock 区别?"></a><font face="华文中宋" size="3">ReentrantReadWriteLock 与 ReentrantLock 区别?</font></h1><p><font face="华文中宋" size="3">在这篇文章中:  <a href="https://blog.csdn.net/zll_0405/article/details/105927574" target="_blank" rel="noopener">[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</a>  对 ReentrantLock 已经做了非常详细的讲解了<br>那么,今天想要说的 ReentrantReadWriteLock 和 ReentrantLock 有什么区别呢?如果只是从名字上来说的话,就是多了一个 ReadWrite 嘛<br>如果对 ReentrantLock 比较熟的话,那么我问 ReentrantLock 是独占锁还是共享锁,你的第一反应就是: 独占锁</font></p><p><font face="华文中宋" size="3">ReentrantReadWriteLock 是在 ReentrantLock 的基础上做的优化,什么优化呢? ReentrantLock 就是不管操作是读操作还是写操作都会对资源进行加锁,但是你想想,如果好几个操作都只是读的话,并没有让数据的状态发生改变,这样的话是不是可以允许多个读操作同时运行?这样的话,相对来说是不是就提高了并发<br>很多事情都是说起来容易,具体是怎么实现的呢?<br>啥也不多说,咱们直接上源码好吧</font></p><p><font face="华文中宋" size="3">在使用 ReentrantReadWriteLock 时,一般都是调用 <code>writeLock</code> 和 <code>readLock</code> 两种方法,它在源码中定义如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">而 <code>writeLock</code> 和 <code>readLock</code> 是 <code>ReentrantReadWriteLock</code> 的两个内部类,其中这两种锁的实现如下(其中省略了一些代码):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享锁</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 共享锁</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 独占锁</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">从源码就能够看出,对于读锁 <code>readLock</code> 它使用的是共享锁,也就是多个线程读没问题<br>但是对于写锁 <code>writeLock</code> 它使用的是独占锁,就是当一个线程要进行写操作时,其他的线程都要停下来等待<br>简单点儿说就是:一个资源可以被多个读线程访问,或者被一个写线程访问,但是不能同时存在读线程和写线程,这也是读写锁的定义</font></p><h1 id="ReadLock-和-WriteLock-共享一个变量"><a href="#ReadLock-和-WriteLock-共享一个变量" class="headerlink" title="ReadLock 和 WriteLock 共享一个变量"></a><font face="华文中宋" size="3">ReadLock 和 WriteLock 共享一个变量</font></h1><p><font face="华文中宋" size="3">如果让你设计一个读写锁的话,会怎样设计?<br>我还真的认真想了想这个问题,如果让我设计的话,我应该会用两个变量去控制读和写,当线程获取到读锁时就对读变量进行 +1 操作,当获取到写锁时,就对写变量进行 +1 操作<br>但是通过看 ReentrantReadWriteLock 源码发现,它只是通过一个 state 来实现的<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">有两个关键方法 <code>sharedCount</code> 和 <code>exclusiveCount</code> ,乖,光是从名字意思来看应该也是可以猜出来的吧: <code>sharedCount</code> 就是共享锁的数量,而 <code>exclusiveCount</code> 则是独占锁的数量<br>通过看源码,能够看出来,对于 <code>sharedCount</code> 来说,它的计算方式就是无符号右移 16 位,空位都以 0 来补齐( <code>c &gt;&gt;&gt; SHARED_SHIFT;</code> )<br>对于 <code>exclusiveCount</code> 来说,它的计算方式就是将传进来的 c 和 <code>EXCLUSIVE_MASK</code> 做 “&amp;” 运算,那么 <code>EXCLUSIVE_MASK</code> 的值是什么呢?就是 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> ,如果对位运算比较熟的话,应该会很容易看出来 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> 的值就是 65535 ,化成二进制就是 16 个 1,传进来 c 的值,和 16 位全为 1 做 “&amp;” 运算的话,只有 <code>1 &amp; 1</code> 才为 1 ,也就是说,传进来的 c 值经过这样转换之后,还是原来的值</font></p><p> <font face="华文中宋" size="3">说到这里,可能有点儿懵了,没关系,咱们来个总结就好说了(为了好理解,我就用大白话说了,争取各位都能看懂<br> 对于 <code>sharedCount</code> 来说,只要传进来的值不大于 65535 ,那么经过计算之后,值都是 0<br> 对于 <code>exclusiveCount</code> 来说,传进来的值是多少,经过计算之后还是多少<br> 不管是 <code>sharedCount</code> 还是 <code>exclusiveCount</code> ,最大值都是 65535 ,因为是和 16 做位运算,其实这个数字也是相当够用了<br> 那么,看到这里,各位应该就比较了解了吧,对于 <code>ReadLock</code> 和 <code>WriteLock</code> 来说,在源码层次其实并不是用两个变量去做的,而是通过一个 state 来实现的,思路真的是非常的巧妙</font></p><p><font face="华文中宋" size="3">对于我上面说的,如果还是不清楚的话,可以自己写个 demo 去验证一下,很简单的,就比如下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shareCount = <span class="number">3000</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    System.out.println(<span class="string">"shareCount : "</span> + shareCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> exclusiveCount = <span class="number">1</span> &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"exclusiveCount : "</span> + exclusiveCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">等你运行完之后,你就发现,哇,怎么和我说的一样,哈哈哈哈<br>对于 <code>sharedCount</code> 来说,它是针对读锁的,所以不管多少进程进行读取资源,都没关系,所以它的值就是 0<br>对于 <code>exclusiveCount</code> 来说,它是针对写锁的,那么只要有一个进程在进行写入,其他线程都要停下来等待,所以它的值就是传进来的值<br>综上,使用一个状态的话,我们只需要去判断这个状态是否是 0 就可以了</font></p><h1 id="WriteLock-的具体实现"><a href="#WriteLock-的具体实现" class="headerlink" title="WriteLock 的具体实现"></a><font face="华文中宋" size="3">WriteLock 的具体实现</font></h1><p><font face="华文中宋" size="3">OK ,既然你都看到了这里,我就默认上面的内容你都理解了<br>WriteLock 说白了就是独占锁,所以在获取 WriteLock 时,不能只考虑是否有写锁在占用,还要考虑有没有读锁.接下来咱们就去探究一下, WriteLock 它具体是怎么实现的</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取到锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 获取写锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c != 0 说明有读锁/写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// w == 0 说明此时没有写锁,有读锁 或者 持有写锁的线程不是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果写锁数量超出了最大值,没啥说的,抛异常就完事儿了</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 当前线程持有写锁,为重入锁,直接 +acquires 即可</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS 操作,确保修改值成功</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">如果对 ReentrantLock 比较熟的话,你会发现,上面的代码大部分都是见过的<br>有一点区别就是调用了 <code>exclusiveCount</code> 方法,看当前是否有写锁存在,接下来通过 <code>c != 0 and w == 0</code> 判断了当前是否有读锁存在</font></p><h1 id="ReadLock-的具体实现"><a href="#ReadLock-的具体实现" class="headerlink" title="ReadLock 的具体实现"></a><font face="华文中宋" size="3">ReadLock 的具体实现</font></h1><p><font face="华文中宋" size="3">WriteLock 探究完了,接下来瞅瞅 ReadLock ,话不多说,直接上源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写锁不等于 0 时,看看当前写锁是否在尝试获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 读锁不需要阻塞,而且读锁需要小于最大读锁数量,同时 cas 操作进行加 1 操作</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 当前线程是第一个并且第一次获取读锁时</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程再次获取读锁,则直接进行 ++ 操作即可</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是第一个获取读锁的线程,就放入线程本地变量</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">看完有没有觉得和写锁那块挺像的,不同就在于因为是读锁嘛,所以只要没有写锁占用,而且读锁的数量没有超过最大的获取数量,就都可以获取读锁<br>在上面, <code>firstReader</code>  <code>firstReaderHoldCount</code>  <code>cachedHoldCounter</code> 都是为 <code>readHolds</code> 服务的,它是为了获取当前线程持有锁的数量,在 <code>ThreadLocal</code> 基础上添加了 Int 变量来统计,这样比较方便嘛<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程持有锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="comment">// 当前线程 ID</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回到题目-手写一个读写锁出来"><a href="#回到题目-手写一个读写锁出来" class="headerlink" title="回到题目,手写一个读写锁出来?"></a><font face="华文中宋" size="3">回到题目,手写一个读写锁出来?</font></h1><p><font face="华文中宋" size="3">接下来,再回到题目,如果面试官让手写一个读写锁出来,你会如何实现呢?<br>在读了源码之后,相信你心里应该有谱了<br>首先来个 state 变量,然后高 16 位设置为读锁数量,低 16 位设置为写锁数量低,然后在进行读锁时,先判断下是不是有写锁,如果没有,直接读取即可,如果有的话那就需要等待;在写锁想要拿到锁的时候,就要判断写锁和读锁是不是都存在了,如果存在那就等着,如果不存在才进行接下来的操作<br>在这里我给出一个简单版的实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个读写锁共享变量 state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 高 16 位为读锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getReadCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 低 16 位为写锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getWriteCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &amp; (( <span class="number">1</span> &lt;&lt; <span class="number">16</span> ) - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读锁时,先判断是否有写锁</span></span><br><span class="line">    <span class="comment">// 如果有写锁,就等待</span></span><br><span class="line">    <span class="comment">// 如果没有,进行加 1 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( getWriteCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"lockRead --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state = state + ( <span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放读锁数量减 1 ,通知其他线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unLockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = state - ( <span class="number">1</span> &lt;&lt; <span class="number">16</span> );</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取写锁时需要判断读锁和写锁是否都存在,有则等待,没有则将写锁数量加 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getReadCount() &gt; <span class="number">0</span> || getWriteCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"lockWrite --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放写锁数量减 1 ,通知所有等待线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWriters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state --;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">我自己测试了下,没啥大问题<br>但是如果细究的话,还是有问题的,就比如,如果现在我有好多个读锁,如果一直不释放的话,那么写锁是一直没办法获取到的,这样就造成了饥饿现象的产生嘛<br>解决的话也蛮好解决的,就是在上面添加一个记录写锁数量的变量,然后在读锁之前,去判断一下是否有线程要获取写锁,如果有的话,优先处理,没有的话再进行读锁操作<br>这块大家试试自己实现吧~我这里就不给具体实现了</font></p><p><font face="华文中宋" size="3">最后,我觉得一个专栏至少是要写 15 篇文章,才可以算得上专栏一说<br>Java 并发这个系列,带上这一篇,就已经写了 14 篇了,计划是再写一篇文章,然后 Java 并发这个系列就告一个段落,接下来 Java 并发系列的更新就随缘,看我兴趣了~<br>Java 并发结束之后,就想去写写 JVM/Dubbo/Zookeeper/Redis/RabbitMQ 等等的内容(总之是要写的内容还有好多</font></p><p><font face="华文中宋" size="3">保持饥饿,保持对技术的热情,就酱~<br>大晚上的更新一篇,感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;题目是个标题党,主要是想写一下 ReentrantReadWriteLock&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]最近有点儿飘</title>
    <link href="https://www.dynamic-zheng.com/posts/38d2bcc6.html"/>
    <id>https://www.dynamic-zheng.com/posts/38d2bcc6.html</id>
    <published>2020-09-13T11:01:59.000Z</published>
    <updated>2020-09-13T11:03:18.785Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周博客鸽了<br>因为最近有点儿飘<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">可能是前段时间逼自己太狠了,因为我在写博客之余,还和一群朋友们一起在做公众号,我负责的那一周文章几乎都是我自己硬怼出来的,再加上工作真的是把自己搞的有些累了<br>所以最近有点儿放松自己,下班之后没有看源码/技术书籍这种,是看了一本相对轻松愉快的书籍:  &lt;哑舍&gt;<br>这本书我在高中的时候就开始追了,但是没追完,毕竟当时学业比较繁重,后来上大学,工作了就忘了这回事儿,前几天在微信读书上看到这本书,顿时回忆袭来,所以下班之后就在看这本书了<br>这本书,是我看了这么久还不知道主角名字的一本书,但是它真的很好看,很适合我这种历史不好的人~</font></p><p><font face="华文中宋" size="3">昨天和朋友一起去爬了香山,爬完之后就觉得积累在自己心中的那些焦虑啊,迷茫啊,在这大自然面前都消失的无影无踪~<br>人生这么长,何必计较这一时的得与失,目前做的所有事情,都放在五年十年之后再看,就一定是另外一番景色,所以当下的得与失没必要看得那么重,继续踏踏实实的干就完事儿了<br>所以今天感觉自己以前的情绪,状态都回来了,明天我又是一个打不死的小强,哈哈哈哈<br>不过有一说一,爬完山的我,今天整个人都瘫了</font></p><p><font face="华文中宋" size="3">下周的博客应该会是一篇干货,写什么主题我还没有确定,不过写出来的话,应该不会让读文章的你失望的<br>就这样吧~<br>我再去看会儿书~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;上周博客鸽了&lt;br&gt;因为最近有点儿飘&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发] ThreadLocal 你怎么动不动就内存泄漏?</title>
    <link href="https://www.dynamic-zheng.com/posts/c4ae514c.html"/>
    <id>https://www.dynamic-zheng.com/posts/c4ae514c.html</id>
    <published>2020-08-29T08:42:12.000Z</published>
    <updated>2020-09-18T14:35:43.787Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果说 ThreadLocal 的话,那肯定就会涉及到内存泄漏<br>为啥嘞<br>因为 吧啦吧啦 ~<br><a id="more"></a></font></p><h1 id="ThreadLocal-解决了什么问题呢"><a href="#ThreadLocal-解决了什么问题呢" class="headerlink" title="ThreadLocal 解决了什么问题呢?"></a><font face="华文中宋" size="3">ThreadLocal 解决了什么问题呢?</font></h1><p><font face="华文中宋" size="3">它是为了解决<strong>对象不能被多线程共享访问的问题</strong>,通过 threadLocal.set() 方法将对象实例保存在每个线程自己所拥有的 threadLocalMap 中,这样的话每个线程都使用自己的对象实例,彼此不会影响从而达到了隔离的作用,这样就解决了对象在被共享访问时带来的线程安全问题<br>啥意思呢?打个比方,现在公司所有人都要填写一个表格,但是只有一支笔,这个时候就只能上个人用完了之后,下个人才可以使用,为了保证”笔”这个资源的可用性,只需要保证在接下来每个人的获取顺序就可以了,这就是 lock 的作用,当这支笔被别人用的时候,我就加 lock ,你来了那就进入队列排队等待获取资源(非公平方式那就另外说了),这支笔用完之后就释放 lock ,然后按照顺序给下个人使用<br>但是完全可以一个人一支笔对不对,这样的话,你填写你的表格,我填写我的表格,咱俩谁都不耽搁谁.这就是 ThreadLocal 在做的事情.因为每个 Thread 都有一个副本,就不存在资源竞争,所以也就不需要加锁,这不就是拿空间去换了时间嘛</font></p><p><font face="华文中宋" size="3">在开始之前,咱们先把 Thread, ThreadLocal, ThreadLocalMap 的关系捋一捋</font></p><p><img src="/images/2020/thread.jpg"></p><p><font face="华文中宋" size="3">可以看到,在 Thread 中持有一个 ThreadLocalMap , ThreadLocalMap 又是由 Entry 来组成的,在 Entry 里面有 ThreadLocal 和 value</font></p><h1 id="ThreadLocal-为啥动不动就内存泄漏呢"><a href="#ThreadLocal-为啥动不动就内存泄漏呢" class="headerlink" title="ThreadLocal 为啥动不动就内存泄漏呢?"></a><font face="华文中宋" size="3">ThreadLocal 为啥动不动就内存泄漏呢?</font></h1><p><font face="华文中宋" size="3">在这里先给个解释,后面咱们再详细分析:<br>首先是因为 ThreadLocal 是基于 ThreadLocalMap 实现的,其中 ThreadLocalMap 的 Entry 继承了 WeakReference ,而 Entry 对象中的 key 使用了 WeakReference 封装,也就是说, Entry 中的 key 是一个弱引用类型,对于弱引用来说,它只能存活到下次 GC 之前<br>如果此时一个线程调用了 ThreadLocalMap 的 set 设置变量,当前的 ThreadLocalMap 就会新增一条记录,但由于发生了一次垃圾回收,这样就会造成一个结果: key 值被回收掉了,但是 value 值还在内存中,而且如果线程一直存在的话,那么它的 value 值就会一直存在<br>这样被垃圾回收掉的 key 就会一直存在一条引用链: Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; Value :</font></p><p><img src="/images/2020/引用链.jpg"></p><p><font face="华文中宋" size="3">就是因为这条引用链的存在,就会导致如果 Thread 还在运行,那么 Entry 不会被回收,进而 value 也不会被回收掉,但是 Entry 里面的 key 值已经被回收掉了<br>这只是一个线程,如果再来一个线程,又来一个线程…多了之后就会造成内存泄漏</font></p><p><font face="华文中宋" size="3">知道是怎么造成内存泄漏之后,接下来要做的事情就好说了,不是因为 value 值没有被回收掉所以才会导致内存泄露的嘛<br>那使用完 key 值之后,将 value 值通过 remove 方法 remove 掉,这样的话内存中就不会有 value 值了,也就防止了内存泄漏嘛</font></p><h1 id="ThreadLocal-是基于-ThreadLocalMap-实现的"><a href="#ThreadLocal-是基于-ThreadLocalMap-实现的" class="headerlink" title="ThreadLocal 是基于 ThreadLocalMap 实现的?"></a><font face="华文中宋" size="3">ThreadLocal 是基于 ThreadLocalMap 实现的?</font></h1><p><font face="华文中宋" size="3">OK ,上面的内容讲完了,接下来一一来看<br>首先,你怎么知道 ThreadLocal 是基于 ThreadLocalMap 实现的呢?<br>从源码知道的~<br>在源码中能够看到下面这几行代码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">代码中说的很清楚了,在 ThreadLocal 内部维护着 ThreadLocalMap ,而它的 Entry 则继承自 WeakReference 的 ThreadLocal&lt;?&gt; ,其中 Entry 的 k 为 ThreadLocal , v 为 Object ,在调用 super(k) 时就将 ThreadLocal 实例包装成了一个 WeakReference</font></p><p><font face="华文中宋" size="3">强弱引用这块内容我就直接放一个表格吧:</font></p><table><thead><tr><th style="text-align:center">引用类型</th><th style="text-align:center">功能特点</th></tr></thead><tbody><tr><td style="text-align:center">强引用 ( Strong Reference )</td><td style="text-align:center">被强引用关联的对象永远不会被垃圾回收器回收掉</td></tr><tr><td style="text-align:center">软引用( Soft Reference )</td><td style="text-align:center">软引用关联的对象,只有当系统将要发生内存溢出时,才会去回收软引用引用的对象</td></tr><tr><td style="text-align:center">弱引用 ( Weak Reference )</td><td style="text-align:center">只被弱引用关联的对象,只要发生垃圾收集事件,就会被回收</td></tr><tr><td style="text-align:center">虚引用 ( Phantom Reference )</td><td style="text-align:center">被虚引用关联的对象的唯一作用是能在这个对象被回收器回收时收到一个系统通知</td></tr></tbody></table><p><font face="华文中宋" size="3">从表格中应该能够看出来,弱引用的对象只要发生垃圾收集事件,就会被回收<br>所以弱引用的存活时间也就是下次 GC 之前了<br>在这里我有个问题:为什么 ThreadLocal 采用弱引用,而不是强引用呢?<br>在 ThreadLocalMap 上面有些注释,我在这里摘录一部分,或许可以从中窥探一二:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To help deal with very large and <span class="keyword">long</span>-lived usages, the hash table entries use WeakReferences <span class="keyword">for</span> keys</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">翻译一下就是:(虽然我英语不是很好<br>为了解决非常大且长期使用的问题,哈希表使用了弱引用的 key<br>假设,假设, ThreadLocal 使用的是强引用,会怎样呢?<br>如果是强引用的话,在表格中也能够看出来,被强引用关联的对象,永远都不会被垃圾回收器回收掉<br>如果引用的 ThreadLocal 对象被回收了,但是 ThreadLocalMap 还持有对 ThreadLocal 的强引用,如果没有 remove 的话, 在 GC 时进行可达性分析, ThreadLocal 依然可达,这样就不会对 ThreadLocal 进行回收,但是我们期望的是引用的 ThreadLocal 对象被回收,这样不就达不到目的了嘛<br>使用弱引用的话,虽然会出现内存泄漏的问题,但是在 ThreadLocal 生命周期里面,都有对 key 值为 null 时进行回收的处理操作<br>所以,使用弱引用的话,可以在 ThreadLocal 生命周期中尽可能保证不出现内存泄漏的问题</font></p><p><font face="华文中宋" size="3">啥?在 ThreadLcoal 生命周期里面,都有对 key 值为 null 时进行回收的处理操作?<br>有证据么?<br>我这篇文章都这么写了,要是没有敢拿出来说么(毕竟我是个负责任的博主不是;<br>在源码中, get 方法, set 方法中都有相应的处理,咱们瞅瞅具体是怎么做的(先来看 set 方法)</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         <span class="comment">// 如果 e 不为空,说明 hash 冲突,需要向后查找</span></span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">// 从这里可以看出, ThreadLocalMap 采用的是开放地址法解决的 hash 冲突</span></span><br><span class="line">         <span class="comment">// 是最经典的 线性探测法 --&gt; 我觉得之所以选择这种方法解决冲突时因为数据量不大</span></span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要查找的 ThreadLocal 对象找到了,直接设置需要设置的值,然后 return</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 k 为 null ,说明有 value 没有及时回收,此时通过 replaceStaleEntry 进行处理</span></span><br><span class="line">        <span class="comment">// replaceStaleEntry 具体内容等下分析</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 tab[i] == null ,则直接创建新的 entry 即可</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 在创建之后调用 cleanSomeSlots 方法检查是否有 value 值没有及时回收</span></span><br><span class="line">    <span class="comment">// 如果 sz &gt;= threshold ,则需要扩容,重新 hash 即, rehash();</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">通过源码可以看到,在 set 方法中,主要是通过 <code>replaceStaleEntry</code> 方法和 <code>cleanSomeSlots</code> 方法去做的检测和处理<br>那咱从源码看看 <code>replaceStaleEntry</code> 它干了啥</font></p><h1 id="replaceStaleEntry"><a href="#replaceStaleEntry" class="headerlink" title="replaceStaleEntry"></a><font face="华文中宋" size="3">replaceStaleEntry</font></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前 staleSlot 位置开始向前遍历</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 当 e.get() == null 时, slotToExpunge 记录下此时的 i 值</span></span><br><span class="line">            <span class="comment">// 即 slotToExpunge 记录的是 staleSlot 左手边第一个空的 Entry</span></span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来从当前 staleSlot 位置向后遍历</span></span><br><span class="line">    <span class="comment">// 这两个遍历是为了清理在左边遇到的第一个空的 entry 到右边的第一个空的 entry 之间所有过期的对象</span></span><br><span class="line">    <span class="comment">// 但是如果在向后遍历过程中,找到了需要设置值的 key ,就开始清理,不会再继续向下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 k == key 说明在插入之前就已经有相同的 key 值存在,所以需要替换旧的值</span></span><br><span class="line">        <span class="comment">// 同时和前面过期的对象进行交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 slotToExpunge == staleSlot 说明向前遍历时没有找到过期的</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 进行清理过期数据</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在向后遍历时,没有找到 value 被回收的 Entry 对象</span></span><br><span class="line">        <span class="comment">// 且刚开始 staleSlot 的 key 为空,那么它本身就是需要设置 value 的 Entry 对象</span></span><br><span class="line">        <span class="comment">// 此时不涉及到清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 key 在数组中找不到,那就好说了,直接创建一个新的就可以了</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 slotToExpunge != staleSlot 说明存在过期的对象,就需要进行清理</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 <code>replaceStaleEntry</code> 方法中,需要注意一下刚开始的两个 for 循环中内容(我再贴一下):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">// 当 e.get() == null 时, slotToExpunge 记录下此时的 i 值</span></span><br><span class="line">    <span class="comment">// 即 slotToExpunge 记录的是 staleSlot 左手边第一个空的 Entry</span></span><br><span class="line">    slotToExpunge = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">    e.value = value;</span><br><span class="line"></span><br><span class="line">    tab[i] = tab[staleSlot];</span><br><span class="line">    tab[staleSlot] = e;</span><br><span class="line">                        </span><br><span class="line">    <span class="comment">// 如果 slotToExpunge == staleSlot 说明向前遍历时没有找到过期的</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">        slotToExpunge = i;</span><br><span class="line">    <span class="comment">// 进行清理过期数据</span></span><br><span class="line">    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这两个 for 循环中的 if 到底是在做什么?<br>看第一个 if ,当 <code>e.get() == null</code> 时,此时将 i 的值给 slotToExpunge<br>第二个 if ,当 <code>k ==key</code> 时,此时将 i 给了 staleSlot 来进行交换<br>为什么要对 staleSlot 进行交换呢?画图说明一下<br>如下图,假设此时表长为 10 ,其中下标为 3 和 5 的 key 已经被回收( key 被回收掉的就是 null ),因为采用的开放地址法,所以 15 mod 10 应该是 5 ,但是因为位置被占,所以在 6 的位置,同样 25 mod 10 也应该是 5 ,但是因为位置被占,下个位置也被占,所以就在第 7 号的位置上了<br>按照上面的分析,此时 slotToExpunge 值为 3 , staleSlot 值为 5 , i 为 6 </font></p><p><img src="/images/2020/exchangeOne.jpg"></p><p><font face="华文中宋" size="3">假设,假设这个时候如果不进行交换,而是直接回收的话,此时位置为 5 的数据就被回收掉,然后接下来要插入一个 key 为 15 的数据,此时 15 mod 10 算出来是 5 ,正好这个时候位置为 5 的被回收完毕,这个位置就被空出来了,那么此时就会这样:</font></p><p><img src="/images/2020/exchangeTwo.jpg"></p><p><font face="华文中宋" size="3">同样的 key 值竟然出现了两次?!这肯定是咱们不希望看到的结果,所以一定要进行数据交换<br>在上面代码中有一行代码 <code>cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</code> ,说明接下来的处理是交给了 <code>expungeStaleEntry</code> ,接下来去分析一下 <code>expungeStaleEntry</code></font></p><h1 id="expungeStaleEntry"><a href="#expungeStaleEntry" class="headerlink" title="expungeStaleEntry"></a><font face="华文中宋" size="3">expungeStaleEntry</font></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果 k == null ,说明 value 就应该被回收掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时直接将 e.value 置为 null </span></span><br><span class="line">            <span class="comment">// 这样就将 thread -&gt; threadLocalMap -&gt; value 这条引用链给打破</span></span><br><span class="line">            <span class="comment">// 方便了 GC</span></span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这个时候要重新 hash ,因为采用的是开放地址法,所以可以理解为就是将后面的元素向前移动</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">因为是在 <code>replaceStaleEntry</code> 方法中调用的此方法,传进来的值是 staleSlot ,继续上图,经过 <code>replaceStaleEntry</code> 之后,它的数据结构是这样:</font></p><p><img src="/images/2020/exchangeThree.jpg"></p><p><font face="华文中宋" size="3">此时传进来的 staleSlot 值为 6 ,因为此时的 key 为 null ,所以接下来会走 <code>e.value = null</code> ,这一步结束之后,就成了:</font></p><p><img src="/images/2020/exchangeFour.jpg"></p><p><font face="华文中宋" size="3">接下来 i 为 7 ,此时的 key 不为 null ,那么就会重新 hash : <code>int h = k.threadLocalHashCode &amp; (len - 1);</code> ,得到的 h 应该是 5 ,但是实际上 i 为 7 ,说明出现了 hash 冲突,就会继续向下走,最终的结果是这样:</font></p><p><img src="/images/2020/exchangeFive.jpg"></p><p><font face="华文中宋" size="3">可以看到,原来的 key 为 null ,值为 V5 的已经被回收掉了.我认为之所以回收掉之后,还要再次进行重新 hash ,就是为了防止 key 值重复插入情况的发生<br>假设 key 为 25 的并没有进行向前移动,也就是它还在位置 7 ,位置 6 是空的,再插入一个 key 为 25 ,经过 hash 应该在位置 5 ,但是有数据了,那就向下走,到了位置 6 ,诶,竟然是空的,赶紧插进去,这不就又造成了上面说到的问题,同样的一个 key 竟然出现了两次?!<br>而且经过 <code>expungeStaleEntry</code> 之后,将 key 为 null 的值,也设置为了 null ,这样就方便 GC</font></p><p><font face="华文中宋" size="3">分析到这里应该就比较明确了,在 <code>expungeStaleEntry</code> 中,有些地方是帮助 GC 的,而通过源码能够发现, set 方法调用了该方法进行了 GC 处理, get 方法也有,不信你瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果能够找到寻找的值,直接 return 即可</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果找不到,则调用 getEntryAfterMiss 方法去处理</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直探测寻找下一个元素,直到找到的元素是要找的</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 如果 k == null 说明有 value 没有及时回收</span></span><br><span class="line">            <span class="comment">// 调用 expungeStaleEntry 方法去处理,帮助 GC</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">get 和 set 方法都有进行帮助 GC ,所以正常情况下是不会有内存溢出的,但是如果创建了之后一直没有调用 get 或者 set 方法,还是有可能会内存溢出<br>那么最保险的方法就是,使用完之后就及时 remove 一下,加快垃圾回收,就完美的避免了垃圾回收</font></p><p><font face="华文中宋" size="3">以上,这篇文章到这里就结束了(说句真心话,我自己都没想到这篇文章写完这么长…<br>越深入理解就越是惊叹,大神的思考真是缜密~不是会因为没有及时回收 value 造成内存泄漏么,那我在 set 和 get 方法中再做一些处理,虽然没办法做到 100% 完美,但我做到 80% 可还行?</font></p><hr><p><font face="华文中宋" size="3">又是脑细胞疯狂死掉的一天 :|</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;如果说 ThreadLocal 的话,那肯定就会涉及到内存泄漏&lt;br&gt;为啥嘞&lt;br&gt;因为 吧啦吧啦 ~&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[MySQL]再谈索引</title>
    <link href="https://www.dynamic-zheng.com/posts/4fa89adb.html"/>
    <id>https://www.dynamic-zheng.com/posts/4fa89adb.html</id>
    <published>2020-08-23T00:22:35.000Z</published>
    <updated>2020-08-23T00:30:03.889Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在这篇文章:  <a href="https://www.dynamic-zheng.com/posts/a02f5441.html#more">[mysql]手把手教你给 SQL 做个优化</a>  中介绍了,给 SQL 做优化的时候,最主要的一点就是建索引<br><a id="more"></a><br>那你有没有新的疑问呢?<br>索引采用的数据结构是啥呢,为什么一提到 mysql 就会问 B 树, B+ 树呢<br>今天这篇文章来说说</font></p><p><font face="华文中宋" size="3">在我们给数据库中一个字段建立索引的时候,能够看到可以选择是 Hash 类型,还是 BTREE 类型的索引</font></p><p><img src="/images/2020/索引.jpg"></p><p><font face="华文中宋" size="3">那为什么 InnoDB 引擎默认使用的是 B+ 树而不是 Hash 嘞<br>你想,你细想<br>使用 Hash 的话很容易出现哈希冲突,特别是在数据量非常大的时候,出现了大量的哈希冲突会导致程序的整体查询性能变慢<br>假设我现在有个查询语句是这样写的 <code>select name,age from student where age &gt; 18</code> 这不是蛮简单的嘛,就找出来所有 age 大于 18 的数据就可以了嘛<br>但是对于使用 Hash 数据结构的索引来说,太难了.因为 Hash 是 key-value 的结构,所以它擅长的是精确查询,如果你让它查找  <code>select name,age from student where age = 18</code> 它返回结果就非常快了<br>那既然 Hash 不支持范围查询,支持 key-value ,那它的应用场景是啥呢?就是等值查询咯,给我一个 key 就可以快速回应一个 value ,咦?怎么和 Redis 那么像呢?<br>就是嘛, Redis , Memcached 它们都有用到 Hash 结构</font></p><p><font face="华文中宋" size="3">Hash 不支持范围查找,但是有序数组支持啊<br>那为啥不用有序数组嘞<br>没错,有序数组的查询性能可以说非常好了,不管是等值查询,还是范围查询,效率简直完爆其他<br>但是咱们的应用场景又不是只有查询对吧,还有插入,修改,删除呢,有序数组这个时候就顶不住了<br>特别是如果插入到头部,第一个位置,从第二位开始往后都要开始向后移动,将第一个位置空出来,这么一来,我的天,还没等你插入完毕,用户都等不及跑了</font></p><p><font face="华文中宋" size="3">那新的疑惑来了<br>B+ 树属于树的一种,二叉树也是树的一种,你咋不用二叉树呢<br>你想,你再想</font></p><p><img src="/images/2020/二叉树.jpg"></p><p><font face="华文中宋" size="3">二叉树是每个节点最多只有两个分支,每个节点只存储一个数据的树结构,那如果我的数据量非常大的话呢,比方说一个小目标, 1 亿数据<br>这个时候二叉树的高度就会变得非常高<br>既然是数据,不做持久化嘛?肯定是要持久化到磁盘的,而且就目前公司的成本来说,应该还没富到服务器的硬盘全是固态吧,有些还是机械硬盘,机械硬盘的读取速度又比较慢<br>那么此时我需要在 1 亿数据里面,查找一个数据,再加上机械硬盘的读取速度,可能给它一分钟的时间都找不到需要的数据<br>乖乖,让你在一个空白的页面上呆一分钟,你会么?<br>这个时候你的注意力早就不知道跑哪儿去了,或者这个界面打不开对么?行嘞,关闭界面,浏览下一个</font></p><p><font face="华文中宋" size="3">用户流失不是咱们希望看到的,对吧<br>所以嘞,既然二叉树是树的高度比较高,那我让它低点儿不就好了嘛<br>怎么低呢<br>因为二叉树每个节点只存储一个数据,那我现在让它一个节点多存储几个数据就好了嘛<br>这就是 B 树<br>B 树的一个节点可以存储多个数据</font></p><p><img src="/images/2020/B树.jpg"></p><p><font face="华文中宋" size="3">能够明显看到, B 树相对于二叉树来说,高度降低了不少<br>那为啥不用 B 树做索引呢,采用 B+ 树<br>因为 B+ 树在 B 树的基础上又做了优化<br>那做了什么优化呢<br>咱瞅瞅</font></p><p><img src="/images/2020/B+树.jpg"></p><p><font face="华文中宋" size="3">有没有看出来一些内容<br>在 B+ 树中,叶子节点之间有指针指向,在 B 树中则没有<br>在 B+ 树中,非叶子节点会冗余一份在叶子节点中(比如图中的数据 50 ,在叶子节点中也能看到它)<br>在 B+ 树中,非叶子节点不存储数据,只存储索引<br>在 B+树中,查询必须查找到叶子节点, B 树只要匹配到就可以了, 不需要 care 元素位置,所以 B+ 树查找更慢</font></p><p><font face="华文中宋" size="3">我这个人比较懒,图中用到的图片都是直接从网上拿下来的,拿完也忘了原文地址是啥(非常抱歉,我这个人懒不说,记性也不咋滴,懒 + 记性差到这种理直气壮的程度估计也是没谁了…<br>侵权的话您和我说一声,我立马撤下来</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在这篇文章:  &lt;a href=&quot;https://www.dynamic-zheng.com/posts/a02f5441.html#more&quot;&gt;[mysql]手把手教你给 SQL 做个优化&lt;/a&gt;  中介绍了,给 SQL 做优化的时候,最主要的一点就是建索引&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[Java 集合]你确定LinkedList 在新增/删除元素时,效率比 ArrayList 高?</title>
    <link href="https://www.dynamic-zheng.com/posts/bde049c8.html"/>
    <id>https://www.dynamic-zheng.com/posts/bde049c8.html</id>
    <published>2020-08-15T05:59:21.000Z</published>
    <updated>2020-08-15T06:07:53.571Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在面试的时候都会被问到集合相关的问题,比如:你能讲讲 ArrayList 和 LinkedList 的区别吗?<br><a id="more"></a><br>那么我相信你肯定能够答上来: ArrayList 是基于数组实现的, LinkedList 是基于链表实现的<br>接下来面试官就会连环问了,那你能讲讲,它们都用在什么场景下吗?<br>我猜你一定会回答:因为 ArrayList 是基于数组实现的,所以在遍历的时候, ArrayList 的效率是要比 LinkedList 高的, LinkedList 是基于链表实现的,所以在进行新增/删除元素的时候, LinkedList 的效率是要比 ArrayList 高的<br>面试官:哦哦,好的,我大概了解了,我这边没有什么想问的了,您回去等消息可以吗<br>???发生了什么?</font></p><p><font face="华文中宋" size="3">哈哈,上面模拟了一个面试场景,是想引出来这篇文章的主题:LinkedList 在新增/删除元素时,效率比 ArrayList 高,这是真的吗?<br>我相信你也知道套路,一般这么一问,那肯定就不是真的了<br>放一张图片,这是经过我测试之后的真实结果</font></p><p><img src="/images/2020/ArrayList-LinkedList.jpg"></p><p><font face="华文中宋" size="3">测试代码因为比较多,我放在了 github 上,感兴趣想要自己动手实践的,可以去看看:  <a href="https://github.com/justdojava/java-samples/tree/master/arraylist-linkedlist-test" target="_blank" rel="noopener">arraylist-linkedlist-test</a><br>接下来分析下,为什么和以前认为的不一样</font></p><h2 id="ArrayList-与-LinkedList-新增元素比较"><a href="#ArrayList-与-LinkedList-新增元素比较" class="headerlink" title="ArrayList 与 LinkedList 新增元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 新增元素比较</font></h2><p><font face="华文中宋" size="3">从图中可以看出来, LinkedList 在新增元素时,它的效率不一定比 ArrayList 高,这是要分情况的<br>如果是从集合头部位置新增元素的话,那确实是 LinkedList 的效率要比 ArrayList 高<br>但是如果是从集合中间位置或者是尾部位置新增元素, ArrayList 效率反而要比 LinkedList 效率要高</font></p><p><font face="华文中宋" size="3">Excuse me ?竟然和我以前学的不一样?博主我学的浅,你别骗我<br>哈哈哈,为什么会这样呢<br>这是因为 ArrayList 是基于数组实现的嘛,而数组是一块连续的内存空间,所以在添加元素到数组头部时,需要对头部后面的数据进行复制重排,所以效率是蛮低的<br>但是 LinkedList 是基于链表实现的,在添加元素的时候,首先会通过循环查找到添加元素的位置,如果要添加的位置处于 List 前半段,那就从前向后找;如果位置在后半段,那就从后往前找,所以 LinkedList 添加元素到头部是非常高效的(小声 BB ,这我知道</font></p><p><font face="华文中宋" size="3">哦,这你知道?看来基础蛮不错的嘛~<br>所以当 ArrayList 在添加元素到数组中间时,有一部分数据需要复制重排,效率就不是很高,那为啥 LinkedList 比它还要低呢?这是因为 LinkedList 把元素添加到中间位置的时候,需要在添加之前先遍历查找,这个查找的时间比较耗时</font></p><p><font face="华文中宋" size="3">添加元素到尾部操作中, ArrayList 的效率要比 LinkedList 的还要高,这是为啥嘞<br>因为 ArrayList 在添加的时候不需要什么操作,直接插入就好了,所以效率蛮高的<br>但是 LinkedList 就不一样了,对于 LinkedList 来说,也不需要查找啥的,直接插入就可以了,但是需要 new 对象,还有变换指针指向对象呀,这些过程耗时加起来可就比 ArrayList 长了</font></p><p><strong><font face="华文中宋" size="3">它是有前提的,那就是 ArrayList 初始化容量是足够的情况下,才有上述的特点,如果 ArrayList 涉及到动态扩容,那它的效率肯定会降低</font></strong></p><h2 id="ArrayList-与-LinkedList-删除元素比较"><a href="#ArrayList-与-LinkedList-删除元素比较" class="headerlink" title="ArrayList 与 LinkedList 删除元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 删除元素比较</font></h2><p><font face="华文中宋" size="3">删除元素和新增元素的原理是一样的,所以删除元素的操作和新增元素的操作耗时也是很相近<br>这里就不再赘述</font></p><h2 id="ArrayList-与-LinkedList-遍历元素比较"><a href="#ArrayList-与-LinkedList-遍历元素比较" class="headerlink" title="ArrayList 与 LinkedList 遍历元素比较"></a><font face="华文中宋" size="3">ArrayList 与 LinkedList 遍历元素比较</font></h2><p><font face="华文中宋" size="3">测试结果非常明显,对于 LinkedList 来说,如果使用 for 循环的话,效率特别低,但是 ArrayList 使用 for 循环去遍历的话,就比较高<br>为啥呢?<br>emmm ,得从源码说起</font></p><p><font face="华文中宋" size="3">先来看 ArrayList 的源码吧,这个比较简单</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够看到, ArrayList 实现了 List , RandomAccess , Cloneable 还有 Serializable 接口<br>你是不是对 RandomAccess 这个接口挺陌生的?这是个啥?<br>但是通过查阅源码能够发现它也只是个空的接口罢了,那 ArrayList 为啥还要去实现它嘞<br>因为 RandomAccess 接口是一个标志接口,它标识着”只要实现该接口的 list 类,都可以实现快速随机访问”<br>实现快速随机访问?你能想到什么?这不就是数组的特性嘛!可以直接通过 index 来快速定位 &amp; 读取</font></p><p><font face="华文中宋" size="3">那你是不是就能想到, ArrayList 是数组实现的,所以实现了 RandomAccess 接口, LinkedList 是用链表实现的,所以它没有用 RandomAccess 接口实现吧?<br>beautiful ~就是这样<br>咱瞅瞅 LinkedList 源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">果然,跟咱们设想的一样,没有实现 RandomAccess 接口<br>那为啥 LinkedList 接口使用 for 循环去遍历的时候,慢的不行呢?<br>咱们瞅瞅 LinkedList 在 get 元素时,都干了点儿啥</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 get 方法中,主要调用了 node() 方法,因为 LinkedList 是双向链表,所以 <code>if (index &lt; (size &gt;&gt; 1))</code> 在判断 i 是在前半段还是后半段,如果是前半段就正序遍历,如果是在后半段那就倒序遍历,那么为什么使用 for 循环遍历 LinkedList 时,会这么慢?(好像离真相越来越近了<br>原因就在两个 for 循环之中,以第一个 for 循环为例</font></p><ul><li><font face="华文中宋" size="3">get(0) :直接拿到了node0 地址,然后拿到 node0 的数据</font></li><li><font face="华文中宋" size="3">get(1) :先拿到 node0 地址,然后 i &lt; index ,开始拿 node1 的地址,符合条件,然后去拿 node1 的数据</font></li><li><font face="华文中宋" size="3">get(2) :先拿到 node0 的地址,然后 i &lt; index ,拿到 node1 的地址, i &lt; index ,继续向下走,拿到 node2 的地址,符合条件,获取 node2 的数据</font></li></ul><p><font face="华文中宋" size="3">发现问题了嘛?我就是想要 2 的数据, LinkedList 在遍历时,将 0 和 1 也给遍历了,如果数据量非常大的话,那效率可不就唰唰的下来了嘛</font></p><p><font face="华文中宋" size="3">那到现在,咱们也就非常明确了,如果是要遍历 ArrayList 的话,最好是用 for 循环去做,如果要遍历 LinkedList 的话,最好是用迭代器去做<br>我猜你一定会说,那如果对方就给我传过来了一个 list ,我不知道它是 ArrayList 还是 LinkedList 呀?我该怎么办呢<br>还记得 ArrayList 和 LinkedList 有什么不同吗?是不是 ArrayList 实现了 RandomAccess 接口,但是 LinkedList 没有实现,所以可以从这点去着手解决</font></p><p><font face="华文中宋" size="3">我在这里给个简单的小 demo ,你可以参考下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2020/8/15</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList.add(<span class="string">"aaa"</span>);</span><br><span class="line">        arrayList.add(<span class="string">"bbb"</span>);</span><br><span class="line">        isUseIterator(arrayList);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        linkedList.add(<span class="string">"ccc"</span>);</span><br><span class="line">        linkedList.add(<span class="string">"ddd"</span>);</span><br><span class="line">        isUseIterator(linkedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">isUseIterator</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)&#123;</span><br><span class="line">            System.out.println(<span class="string">"实现了 RandomAccess 接口,使用 for 循环遍历"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; list.size(); i++ )&#123;</span><br><span class="line">                System.out.println(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"没有实现 RandomAccess 接口,使用迭代器遍历"</span>);</span><br><span class="line"></span><br><span class="line">            Iterator it = list.iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">                System.out.println(it.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">本篇文章用到的所有代码,都上传到了 github 上,需要的可以去看看:   <a href="https://github.com/justdojava/java-samples/tree/master/arraylist-linkedlist-test" target="_blank" rel="noopener">arraylist-linkedlist-test</a></font></p><p><font face="华文中宋" size="3">参考:<br>极客时间: Java 性能调优实战</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在面试的时候都会被问到集合相关的问题,比如:你能讲讲 ArrayList 和 LinkedList 的区别吗?&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.dynamic-zheng.com/categories/java/"/>
    
    
      <category term="java 基础" scheme="https://www.dynamic-zheng.com/tags/java-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[设计模式]你不是对单例模式比较熟吗?你倒是写一个线程安全的出来呀!</title>
    <link href="https://www.dynamic-zheng.com/posts/2645232e.html"/>
    <id>https://www.dynamic-zheng.com/posts/2645232e.html</id>
    <published>2020-08-09T12:48:28.000Z</published>
    <updated>2020-08-14T04:45:27.551Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我也不知道为什么,上周我明明写了文章传上来了,结果今天一瞅,嗯?我的文章呢?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">为了证明我没有说谎,我这里有图为证:</font></p><p><img src="/images/2020/设计模式.jpg"></p><p><font face="华文中宋" size="3">不多说了,咱们直接正文开始<br>单例模式比较好理解,就是保证只有一个对象被创建<br>如果是单线程下代码还比较好写一些:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample2 instance = <span class="keyword">new</span> SingletonExample2();</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面的是饿汉模式,在类加载时就开始创建<br>懒汉模式就比较懒,在使用的时候才会创建</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全--并不推荐,因为带来了性能上的开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample3</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample3 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonExample3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonExample3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">如果是在单线程环境下,上面的代码是没有任何问题的<br>但是如果是在多线程环境下呢?<br>现在同时有线程 A 和 B 要创建线程,此时线程 A 拿到了 instance 的值为 null ,然后 CPU 停止了当前线程 A ,线程 B 开始运行,也拿到了 instance 的值为 null ,接下来线程 A 和 B 都会去创建<br>怎么办呢?加个双重检测机制,再加个锁</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式--&gt;双重同步锁模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> * 线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample4</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2, ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3, instance = memory 设置 instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 和 cpu 优化时,会发生指令重排</span></span><br><span class="line">    <span class="comment">// 有可能发生 1,3,2</span></span><br><span class="line">    <span class="comment">//此时会导致线程不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample4 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample4 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;   <span class="comment">// 使用了双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample4.class) &#123;   <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这样双重检测再加锁看似是没有问题了<br>但是还记得吗? JVM 是会指令重排的,本来 1,2,3 运行下来没问题,结果呢,指令重排之后就变成了 1,3,2 ,还是两个线程,线程 A 拿到第一个的 instance 为 null ,线程 B 拿到的是指令重排之后的第二个 instance 为 null ,此时仍然有线程不安全的问题<br>那我不让它指令重排不就好了? volatile 就要大显身手了</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *懒汉模式--&gt;双重同步锁模式</span></span><br><span class="line"><span class="comment"> * 单例实例在第一次使用时进行创建</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample5</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample5</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1, memory = allocate() 分配对象的内存空间</span></span><br><span class="line">    <span class="comment">// 2, ctorInstance() 初始化对象</span></span><br><span class="line">    <span class="comment">// 3, instance = memory 设置 instance 指向刚分配的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// JVM 和 cpu 优化时,会发生指令重排</span></span><br><span class="line">    <span class="comment">// 有可能发生 1,3,2</span></span><br><span class="line">    <span class="comment">//此时会导致线程不安全</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单例对象--- volatile + 双重检测机制--&gt;禁止指令重排</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonExample5 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample5 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;   <span class="comment">// 使用了双重检测机制</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonExample5.class) &#123;   <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonExample5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面都是对懒汉模式的优化,饿汉模式也想线程安全,该咋办嘞</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *饿汉模式</span></span><br><span class="line"><span class="comment"> * 单例实例在类装载时进行创建</span></span><br><span class="line"><span class="comment"> * 线程安全---&gt;要注意 private static 和 static 的先后执行顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample6</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample6</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonExample6 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> SingletonExample6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态的工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample6 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">        System.out.println(getInstance().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">还有一种最安全的方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全---最安全</span></span><br><span class="line"><span class="comment"> * 推荐使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonExample7</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonExample7</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> SingletonExample7 singleton;</span><br><span class="line">        <span class="comment">// JVM 保证这个方法绝对只调用一次</span></span><br><span class="line">        Singleton()&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> SingletonExample7();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonExample7 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;我也不知道为什么,上周我明明写了文章传上来了,结果今天一瞅,嗯?我的文章呢?&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.dynamic-zheng.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.dynamic-zheng.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>[mysql]手把手教你给 SQL 做个优化</title>
    <link href="https://www.dynamic-zheng.com/posts/a02f5441.html"/>
    <id>https://www.dynamic-zheng.com/posts/a02f5441.html</id>
    <published>2020-08-02T12:10:34.000Z</published>
    <updated>2020-08-02T12:17:30.279Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">首先明确一个问题:如果我的 SQL 语句执行的足够快,还有没有必要去做优化?<br>完全没有必要对吧<br><a id="more"></a><br>所以我们一般说,要给 SQL 做个优化,那肯定就是这条 SQL 语句执行的比较慢了<br>那么,为什么它会执行比较慢呢?</font></p><h1 id="SQL-语句执行较慢的-3-个原因"><a href="#SQL-语句执行较慢的-3-个原因" class="headerlink" title="SQL 语句执行较慢的 3 个原因"></a><font face="华文中宋" size="3">SQL 语句执行较慢的 3 个原因</font></h1><h2 id="没有建立索引-或者索引失效导致了-SQL-语句执行较慢"><a href="#没有建立索引-或者索引失效导致了-SQL-语句执行较慢" class="headerlink" title="没有建立索引,或者索引失效导致了 SQL 语句执行较慢"></a><font face="华文中宋" size="3">没有建立索引,或者索引失效导致了 SQL 语句执行较慢</font></h2><p><font face="华文中宋" size="3">这个应该是比较好理解的,如果数据比较多,在千万级别以上,然后呢又没有建立索引,在这千万级别的数据中查找你想要的内容,简直就是在肉搏啊<br>索引失效这块内容说起来就比较多了,比如在查询的时候,让 like 通配符在前面了,比如经常念叨的”最左匹配原则”,又比如我们在查询条件中使用 or ,而且 or 前后条件中有一个列没有索引,等等这些情况都会导致索引失效</font></p><h2 id="锁等待"><a href="#锁等待" class="headerlink" title="锁等待"></a><font face="华文中宋" size="3">锁等待</font></h2><p><font face="华文中宋" size="3">常用的存储引擎主要有 InnoDB 和 MyISAM 这两种了,前者支持行锁和表锁,后者就只支持表锁<br>如果数据库操作都是基于表锁的话,意思就是说,现在有个更新操作,就会把整张表锁起来,那么查询的操作都不被允许,所以就不要说提高系统的并发性能了</font></p><ul><li><font face="华文中宋" size="3">聪明的你肯定就知道了,既然 MyISAM 只支持表锁,那么使用 InnoDB 不就好了?你以为 InnoDB 的行锁不会升级成表锁嘛? too young too simple !</font></li><li><font face="华文中宋" size="3">如果对一张表进行大量的更新操作, mysql 就觉得你这样用会让事务的执行效率降低,到最后还是会导致性能下降,这样的话,还不如把你的行锁升级成表锁呢</font></li><li><font face="华文中宋" size="3">还有一点,行锁可是基于索引加的锁,在执行更新操作时,条件索引都失效了,那么这个锁也会执行从行锁升级为表锁</font></li></ul><h2 id="不恰当的-SQL-语句"><a href="#不恰当的-SQL-语句" class="headerlink" title="不恰当的 SQL 语句"></a><font face="华文中宋" size="3">不恰当的 SQL 语句</font></h2><p><font face="华文中宋" size="3">这个也比较常见了,啥是不恰当的 SQL 语句呢?就比如,明明你需要查找的内容是 name , age ,但是呢,为了省事,直接 select * ,或者在 order by 时,后面的条件不是索引字段,这就是不恰当的 SQL 语句</font></p><h1 id="优化-SQL-语句"><a href="#优化-SQL-语句" class="headerlink" title="优化 SQL 语句"></a><font face="华文中宋" size="3">优化 SQL 语句</font></h1><p><font face="华文中宋" size="3">在知道了 SQL 语句执行比较慢的原因之后,接下来要做的就是对症下药了<br>针对 没有索引/索引失效 这块,最有效的办法就是 EXPLAIN 语法了,其实 Show Profile 也可以<br>针对 锁等待 这块,没办法了,只能自己多注意<br>针对 不恰当的 SQL 语句 这块,介绍几个常用的 SQL 优化,比如分页查询怎么优化一下可以查询的更快一些呀,你不是说 select * 不是正确的打开方式嘛?那什么是正确的 select 方式呢?我下面都会讲讲<br>废话不多说,咱们开始了</font></p><h1 id="先来个表"><a href="#先来个表" class="headerlink" title="先来个表"></a><font face="华文中宋" size="3">先来个表</font></h1><p><font face="华文中宋" size="3">为了确保优化后的结果和我写的一样(起码 90% 是相符的<br>所以咱们用一样的数据库好不好<br>首先建个 demo 的数据库</font></p><p><img src="/images/2020/建库.jpg"></p><p><font face="华文中宋" size="3">接下来咱们建表,就建个非常简单的表好不好</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE demo.table(</span><br><span class="line"><span class="function">id <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> NOT NULL,</span></span><br><span class="line"><span class="function">a <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> DEFAULT NULL,</span></span><br><span class="line"><span class="function">b <span class="title">int</span><span class="params">(<span class="number">11</span>)</span> DEFAULT NULL,</span></span><br><span class="line"><span class="function">PRIMARY <span class="title">KEY</span><span class="params">(id)</span></span></span><br><span class="line"><span class="function">) ENGINE </span>= INNODB</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">然后插入 10 万条数据</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS demo_insert;</span><br><span class="line"><span class="function">CREATE PROCEDURE <span class="title">demo_insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BEGIN</span></span><br><span class="line"><span class="function">    DECLARE i INT</span>; </span><br><span class="line">SET i = <span class="number">1</span>;</span><br><span class="line">    WHILE i &lt;= <span class="number">100000</span> DO</span><br><span class="line">        INSERT INTO demo.`table` VALUES (i, i, i);</span><br><span class="line">        SET i = i + <span class="number">1</span> ;</span><br><span class="line">    END WHILE;</span><br><span class="line">END;</span><br><span class="line"><span class="function">CALL <span class="title">demo_insert</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3"> OK ,准备工作做好了,接下来开始实战</font></p><h2 id="通过-EXPLAIN-分析-SQL-是怎样执行的"><a href="#通过-EXPLAIN-分析-SQL-是怎样执行的" class="headerlink" title="通过 EXPLAIN 分析 SQL 是怎样执行的"></a><font face="华文中宋" size="3">通过 EXPLAIN 分析 SQL 是怎样执行的</font></h2><p><font face="华文中宋" size="3">只要说 SQL 调优,那就离不开 EXPLAIN </font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `table` WHERE id &lt; <span class="number">100</span> ORDER BY a;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/explain.jpg"></p><p><font face="华文中宋" size="3">咱们能够看到有好几个参数:</font></p><ul><li><font face="华文中宋" size="3">id :每个执行计划都会有一个 id ,如果是一个联合查询的话,这里就会显示好多个 id</font></li><li><font face="华文中宋" size="3">select_type :表示的是 select 查询类型,常见的就是 SIMPLE (普通查询,也就是没有联合查询/子查询), PRIMARY (主查询), UNION ( UNION 中后面的查询), SUBQUERY (子查询)</font></li><li><font face="华文中宋" size="3">table :执行查询计划的表,在这里我查的就是 table ,所以显示的是 table, 那如果我给 table 起了别名 a ,在这里显示的就是 a</font></li><li><font face="华文中宋" size="3">type :查询所执行的方式,这是咱们在分析 SQL 优化的时候一个非常重要的指标,这个值从好到坏依次是: system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL <ul><li><font face="华文中宋" size="3">system/const :说明表中只有一行数据匹配,这个时候根据索引查询一次就能找到对应的数据</font></li><li><font face="华文中宋" size="3">eq_ref :使用唯一索引扫描,这个经常在多表连接里面,使用主键和唯一索引作为关联条件时可以看到</font></li><li><font face="华文中宋" size="3">ref :非唯一索引扫描,也可以在唯一索引最左原则匹配扫描看到</font></li><li><font face="华文中宋" size="3">range :索引范围扫描,比如查询条件使用到了 &lt; ,  &gt; ,  between 等条件</font></li><li><font face="华文中宋" size="3">index :索引全表扫描,这个时候会遍历整个索引树</font></li><li><font face="华文中宋" size="3">ALL :表示全表扫描,也就是需要遍历整张表才能找到对应的行</font></li></ul></font></li><li><font face="华文中宋" size="3">possible_keys :表示可能使用到的索引</font></li><li><font face="华文中宋" size="3">key :实际使用到的索引</font></li><li><font face="华文中宋" size="3">key_len :使用的索引长度</font></li><li><font face="华文中宋" size="3">ref :关联 id 等信息</font></li><li><font face="华文中宋" size="3">rows :找到符合条件时,所扫描的行数,在这里虽然有 10 万条数据,但是因为索引的缘故,所以扫描了 99 行的数据</font></li><li><font face="华文中宋" size="3">Extra :额外的信息,常见的有以下几种<ul><li><font face="华文中宋" size="3">Using where :不用读取表里面的所有信息,只需要通过索引就可以拿到需要的数据,这个过程发生在对表的全部请求列都是同一个索引部分时</font></li><li><font face="华文中宋" size="3">Using temporary :表示 mysql 需要使用临时表来存储结果集,常见于 group by / order by</font></li><li><font face="华文中宋" size="3">Using filesort :当查询的语句中包含 order by 操作的时候,而且 order by 后面的内容不是索引,这样就没有办法利用索引完成排序,就会使用”文件排序”,就像例子中给出的,建立的索引是 id , 但是我的查询语句 order by 后面是 a ,没有办法使用索引</font></li><li><font face="华文中宋" size="3">Using join buffer :使用了连接缓存</font></li><li><font face="华文中宋" size="3">Using index :使用了覆盖索引</font></li></ul></font></li></ul><p><font face="华文中宋" size="3">如果对这些参数了解的非常不错,那么 EXPLAIN 这块内容就难不住你了</font></p><h2 id="Show-Profile-分析下-SQL-执行性能"><a href="#Show-Profile-分析下-SQL-执行性能" class="headerlink" title="Show Profile 分析下 SQL 执行性能"></a><font face="华文中宋" size="3">Show Profile 分析下 SQL 执行性能</font></h2><p><font face="华文中宋" size="3">通过 EXPLAIN 分析执行计划,只能说明 SQL 的外部执行情况,如果想要知道 mysql 具体是如何查询的,需要通过 Show Profile 来分析</font></p><p><font face="华文中宋" size="3">可以通过 <code>SHOW PROFILES;</code> 语句来查询最近发送给服务器的 SQL 语句,默认情况下是记录最近已经执行的 15 条记录,如下图我们可以看到:</font></p><p><img src="/images/2020/showprofile.jpg"></p><p><font face="华文中宋" size="3">我想看具体的一条语句,看到 Query_ID 了嘛?然后运行下 <code>SHOW PROFILE FOR QUERY 82;</code> 这条命令就可以了:</font></p><p><img src="/images/2020/queryid.jpg"></p><p><font face="华文中宋" size="3">可以看到,在结果中, Sending data 耗时是最长的,这是因为此时 mysql 线程开始读取数据并且把这些数据返回到客户端,在这个过程中会有大量磁盘 I/O 操作<br>通过这样的分析,我们就能知道, SQL 语句在查询过程中,到底是 磁盘 I/O 影响了查询速度,还是 System lock 影响了查询速度</font></p><h2 id="分页查询怎么可以更快一些"><a href="#分页查询怎么可以更快一些" class="headerlink" title="分页查询怎么可以更快一些"></a><font face="华文中宋" size="3">分页查询怎么可以更快一些</font></h2><p><font face="华文中宋" size="3">在使用分页查询时,都会使用 limit 关键字<br>但是对于分页查询,其实还可以优化一步<br>我这里给出的数据库不是太好,因为它太简单了,看不出来有什么区别,我使用目前项目上正在用的表来做个实验,可以看下区别(使用的 SQL 语句如下面):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM `te_paper_record` ORDER BY id LIMIT <span class="number">10000</span>, <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM `te_paper_record` WHERE id &gt;= ( SELECT id FROM `te_paper_record` ORDER BY id LIMIT <span class="number">10000</span>, <span class="number">1</span>) LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/不使用子查询.jpg"></p><p><img src="/images/2020/使用子查询.jpg"></p><p><font face="华文中宋" size="3">上面一张图片,我没有使用子查询,可以看到执行了 0.033s ,下面的查询语句,我使用了子查询去做优化,能够看到执行了 0.007s ,优化的结果还是很显而易见的</font></p><p><font face="华文中宋" size="3">那么,为什么使用了子查询,查询的速度就提上来了呢,这是因为当我们没有使用子查询时,查询到的 10020 行数据都返回回来了,接下来要对这 10020 行数据再进行操作<br>那可不可以直接就返回需要的 20 行数据呢?可以,子查询就是在做这件事情<br>所以查询时间上有了一个很大的优化</font></p><h2 id="正确的-select-打开方式"><a href="#正确的-select-打开方式" class="headerlink" title="正确的 select 打开方式"></a><font face="华文中宋" size="3">正确的 select 打开方式</font></h2><p><font face="华文中宋" size="3">在查询时,有时为了省事,直接使用 <code>select * from table where id = 1</code> 这样的 SQL 语句,但是这样的写法在一些环境下是会存在一定的性能损耗的<br>所以最好的 select 查询就是,需要什么字段就查询什么字段<br>一般在查询时,都会有条件,按照条件查找<br>这个时候正确的 select 打开方式是什么呢?</font></p><p><font face="华文中宋" size="3">如果可以通过主键索引的话, where 后面的条件,优先选择主键索引<br>为什么呢?这就要知道 MySQL 的存储规则<br>MySQL 常用的存储引擎有 MyISAM 和 InnoDB , InnoDB 会创建主键索引,而主键索引属于聚簇索引,也就是在存储数据时,索引是基于 B+ 树构成的,具体的行数据则存储在叶子节点</font></p><p><font face="华文中宋" size="3">也就是说,如果是通过主键索引查询的,会直接搜索 B+ 树,从而查询到数据<br>如果不是通过主键索引查询的,需要先搜索索引树,得到在 B+ 树上的值,再到 B+ 树上搜索符合条件的数据,这个过程就是”回表”<br>很显然,回表能够产生时间.<br>这也是为什么建议, where 后面的条件,优先选择主键索引</font></p><h1 id="其他调优"><a href="#其他调优" class="headerlink" title="其他调优"></a><font face="华文中宋" size="3">其他调优</font></h1><p><font face="华文中宋" size="3">看完上面的,心里应该就大概有数了, SQL 调优主要就是建立索引/防止产生锁等待/使用恰当的 SQL 语句去查询<br>但是,如果问你除了索引,除了上面这些手段,还有没有其他调优方式<br>啥?竟然还有?!<br>有的,这就需要跳出来,不要局限在具体的 SQL 语句上了,需要在数据库设计之初就考虑好<br>比如说,我们常说的要遵循三范式,但是其实有些时候,表里面有些冗余字段带来的效果要更好<br>当然了,这块的内容可能 DBA 就已经考虑好了,但是多了解一点儿也没什么坏处嘛</font></p><p><font face="华文中宋" size="3">OK ,这次的分享就这样啦~<br>非常感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;首先明确一个问题:如果我的 SQL 语句执行的足够快,还有没有必要去做优化?&lt;br&gt;完全没有必要对吧&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="https://www.dynamic-zheng.com/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://www.dynamic-zheng.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]我最近在做的事情</title>
    <link href="https://www.dynamic-zheng.com/posts/6240cbda.html"/>
    <id>https://www.dynamic-zheng.com/posts/6240cbda.html</id>
    <published>2020-07-26T09:40:28.000Z</published>
    <updated>2020-07-26T09:41:34.252Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周的时候,就已经预告了,这周文章也是水文一篇,因为我说最近比较忙嘛<br>那今天就来交代下,最近在忙什么<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">自考<br>八月初有考试,自学考试.(是的,你没看错,就是下周<br>我知道要早点儿开始学,但是一直到七月初我才开始看书,七月二十号的样子,才把课本第一遍看完,这个时候还没看课后题,也没有刷题<br>没办法,都是以前欠下的债<br>为了抓紧一切时间学习,大早上六点就起床,自己都被自己感动哭了</font></p><p><font face="华文中宋" size="3">写作训练营<br>我感觉自己最近写作遇到了瓶颈,我不知道该怎么去写一篇文章,写完之后阅读量也不怎么样,也不知道该写什么<br>这个时候就需要一位老师来帮助我了.正好一直信任的明白老师开了一个写作训练营,果断花了 1K+ 报名,说实话,因为训练营还有筛选机制,我还真的挺怕把我筛掉…不过蛮幸运的,没有被筛选掉<br>所以这几天的精力,除了工作,就是自考,要么是写作训练营</font></p><p><font face="华文中宋" size="3">三件事,就足够把我的时间和精力占满,每天都掏空了自己<br>总得想办法逃出自己的舒适区不是~<br>等我忙完了考试 &amp; 参加完训练营,我再认认真真写文章</font></p><p><font face="华文中宋" size="3">目前的话,我的脑袋里面已经有了一篇文章的大纲了,预计完整写出来的话,字数大概在 3000+<br>但是因为我下周有考试嘛,所以怎么也要等我考试完了,写完发出来的话,估计就是周日晚上了<br>就这样~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;上周的时候,就已经预告了,这周文章也是水文一篇,因为我说最近比较忙嘛&lt;br&gt;那今天就来交代下,最近在忙什么&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]坦白了,这是我最喜欢的一部动漫</title>
    <link href="https://www.dynamic-zheng.com/posts/18ababf6.html"/>
    <id>https://www.dynamic-zheng.com/posts/18ababf6.html</id>
    <published>2020-07-19T13:05:50.000Z</published>
    <updated>2020-07-19T13:10:45.870Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">坦白点儿,最近没有沉迷于学习,下班了就赖在床上刷动漫,真香!<br>虽然考试在即,可我还是想去刷我的动漫(废材就是我了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我还记得小时候看这部动漫,下课了就跑回家就是为了看这部动漫,如果停电了,都能被气的半死…(那个时候孩子还小;<br>这部动漫就是:犬夜叉<br>我自己都不知道这是刷的第几次了,自己压力大的时候,睡不着的时候,就会刷一遍,然后再刷一遍</font></p><p><img src="/images/2020/犬夜叉.jpg"></p><p><font face="华文中宋" size="3">小时候最喜欢的几部动漫:犬夜叉,名侦探柯南,网球王子,黑子的篮球,东京食尸鬼…这么一数好像喜欢的不少<br>之所以喜欢追动漫,是因为它真的给了我很多力量,特别适合在自己压力大的时候,去看看,然后我就动力满满,跟打了鸡血一样</font></p><p><font face="华文中宋" size="3">犬夜叉这部是我最喜欢的一部动漫,既然是水文一篇,那我就随便说说咯</font></p><p><font face="华文中宋" size="3">犬夜叉<br>刚开始的他,总是想获得更强大的力量,想要成为真正的妖怪<br>但是遇到桔梗之后,懂得了守护,开始想要陪伴一个人,但是因为命运,唉~<br>后来遇到了戈薇,七宝,弥勒,珊瑚,在和他们一起奋斗的日子里,开始慢慢变得信任别人,自己恢复为人的日子是不能让别人知道的,因为在这天会失去妖力,如果让别人知道,自己可能就会失去性命,到最后,越来越多的人知道朔日之夜,在变成人类的那个夜晚,他也越来越坦然<br>应该是真正接受了自己的身份吧</font></p><p><font face="华文中宋" size="3">戈薇<br>不得不说高桥留老师的心思细腻,戈薇只是一个女孩,她喜欢犬夜叉,当她看到犬夜叉放不下桔梗的时候,自己也会悲伤,也会嫉妒<br>桔梗被奈落的瘴气所伤,能净化的只有戈薇,戈薇但凡是有一点不想救桔梗的心,就会失败<br>最后成功救到了桔梗,因为她的心是善良的<br>她会大大方方的承认自己喜欢犬夜叉,也大大方方的承认自己嫉妒桔梗,这份坦诚,真的让人很感动</font></p><p><font face="华文中宋" size="3">弥勒 &amp; 珊瑚<br>这两个人,背负的东西都太多了<br>一个是不知道自己什么时候会死,一个是亲眼目睹了自己的家人被弟弟亲手杀害<br>但他们在旅行的途中,彼此治愈着 &amp; 温暖着<br>特别是完结篇,弥勒为了能够更好的保护珊瑚,喝下了可以抑制痛苦的药;在最后珊瑚说想陪他,最后还是不忍心</font></p><p><font face="华文中宋" size="3">杀生丸<br>这个人物简直不要太帅~<br>我还记得小时候看的,觉得杀生丸特别讨厌犬夜叉,因为犬夜叉是半妖,杀生丸是从内心鄙视犬夜叉的<br>相比于犬夜叉因为半妖的身份受尽欺负,杀生丸简直是含着金钥匙出生的,一出生就拥有很强大的力量,直接就是别人的顶点,但也是这一点,让他不知道什么是害怕,什么是恐惧,别人执着的东西,他是不屑的,就像四魂之玉一样,别的妖怪费尽心思想要,他却一看都不看<br>一直执着于获得铁碎牙的他,却一直被铁碎牙的结界给拒绝,后来在玲的陪伴下,慢慢了解到什么是恐惧,在完结篇中,玲因为在冥界承受不住阴气失去呼吸,天生牙也没办法拯救她时,杀生丸慌了,整个表情痛苦不已<br>啊啊啊,整部动漫就这里让杀生丸痛苦了,可以想象他的改变有多大~<br>知道害怕和恐惧之后,不再执着于获得铁碎牙的力量,反而因此获得了自己的力量—爆碎牙</font></p><p><font face="华文中宋" size="3">奈落<br>每次看到他,都想不行,我一定要继续快点儿看,这样才能看到他死去<br>奈落为了获得四魂之玉伤害了很多人,利用了很多人,践踏别人的感情<br>但是他又是可怜的,他所做的一切,也不过是为了得到桔梗的心<br>但是啊,爱情这种事情,怎么可能是你想得到就可以得到的呢<br>爱而不得的奈落,杀死了桔梗,玩弄别人的感情在股掌之中,可是想想,如果不曾体会过感情的话,又怎么可能玩弄别人的感情呢<br>奈落是爱桔梗的,但是他的爱,等不来她</font></p><p><font face="华文中宋" size="3">桔梗<br>这个人物是我最不想写的,太悲情了<br>身为一个巫女,她的一生都是活在战斗中的,后来复活的她,也是为了消除四魂之玉奋斗着,独自一人奋斗着,想想就觉得好孤独啊<br>印象特别深刻的是一个场景:在一个夜晚,犬夜叉和戈薇起来看星星,戈薇身上披着的是犬夜叉的火鼠裘,靠在犬夜叉的肩上,而与此同时,桔梗孤独一人只有死魂虫陪着她,在月色下她在想:犬夜叉,你现在在做什么呢<br>太让人心疼了~<br>明明她也只是一个平凡的女子啊,明明她也只是想过平凡的日子呀</font></p><p><font face="华文中宋" size="3">这篇文章就是这样啦~其实其他人物也很饱满 &amp; 鲜活,如果有想写的,等我再刷一遍,哈哈哈<br>对了,预告下,估计下周的文章我也要水一篇了<br>emmm ,最近有点儿忙<br>就酱~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;坦白点儿,最近没有沉迷于学习,下班了就赖在床上刷动漫,真香!&lt;br&gt;虽然考试在即,可我还是想去刷我的动漫(废材就是我了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]CopyOnWrite 了解吗?</title>
    <link href="https://www.dynamic-zheng.com/posts/9af0bfae.html"/>
    <id>https://www.dynamic-zheng.com/posts/9af0bfae.html</id>
    <published>2020-07-11T11:22:27.000Z</published>
    <updated>2020-07-11T11:26:01.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font face="华文中宋" size="3">概念</font></h1><p><font face="华文中宋" size="3">CopyOnWrite 只是看字面意思就能看出来,就是在写入时复制<br>说得轻巧,写入时复制,具体是怎么实现的呢?<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">先来说说思想,具体怎么实现等下分析<br>CopyOnWrite 的思想就是:当向一个容器中添加元素的时候,不是直接在当前这个容器里面添加的,而是复制出来一个新的容器,在新的容器里面添加元素,添加完毕之后再将原容器的引用指向新的容器,这样就实现了写入时复制<br>你还记得在提到数据库的时候,我们经常说主从复制,读写分离吗? CopyOnWrite 的设计思想是不是和经常说的主从复制,读写分离如出一撤?</font></p><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><font face="华文中宋" size="3">优缺点</font></h1><p><font face="华文中宋" size="3">了解概念之后,对它的优缺点应该就比较好理解了<br>优点就是,读和写可以并行执行,因为读的是原来的容器,写的是新的容器,它们之间互不影响,所以读和写是可以并行执行的,在某些高并发场景下,可以提高程序的响应时间</font></p><p><font face="华文中宋" size="3">但是呢,你也看到了, CopyOnWrite 是在写入的时候,复制了一个新的容器出来,所以要考虑它的内存开销问题,又回到了在学算法时一直强调的一个思想:拿空间换时间<br>还有一点就是,它只保证数据的最终一致性.因为在读的时候,读取的内容是原容器里面的内容,新添加的内容是读取不到的</font></p><p><font face="华文中宋" size="3">基于它的优缺点应该就可以得出一个结论: CopyOnWrite 适用于写操作非常少的场景,而且还能够容忍读写的暂时不一致<br>如果你的应用场景不适合,那还是考虑使用别的方法来实现吧</font></p><p><font face="华文中宋" size="3">还有一点需要注意的是:在写入时,它会复制一个新的容器,所以如果有写入需求的话,最好可以批量写入,因为每次写入的时候,容器都会进行复制,如果能够减少写入的次数,就可以减少容器的复制次数</font></p><p><font face="华文中宋" size="3">在 JUC 包下,实现 CopyOnWrite 思想的就是 CopyOnWriteArrayList &amp; CopyOnWriteArraySet 这两个方法,本篇文章侧重于讲清楚 CopyOnWriteArrayList</font></p><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><font face="华文中宋" size="3">CopyOnWriteArrayList</font></h1><p><font face="华文中宋" size="3">在 CopyOnWriteArrayList 中,需要注意的是 add 方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 在写入的时候,需要加锁,如果不加锁的话,在多线程场景下可能会被 copy 出 n 个副本出来</span></span><br><span class="line">    <span class="comment">// 加锁之后,就能保证在进行写时,只有一个线程在操作</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 复制原来的数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将要添加的元素添加到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">// 将对原数组的引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在写的时候需要加锁,但是在读取的时候不需要添加<br>因为读取的是原数组的元素,对新数组没有什么影响,加了锁反而会增加性能开销</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子:"></a><font face="华文中宋" size="3">举个例子:</font></h1><p><font face="华文中宋" size="3">CopyOnWrite 在 JUC 包下,那么它就保证了线程安全<br>咱们来做个小 demo 验证一下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面是客户端请求 5000 次,有 200 个线程在同时请求,我使用的是 ArrayList 实现,咱们看下打印结果:</font></p><p><img src="/images/2020/ArrayListDemo.jpg"></p><p><font face="华文中宋" size="3">如果是线程安全的话,那么最后的结果应该是 5000 才对,多运行几次你会发现,每次程序的执行结果都是不一样的<br>如果是 CopyOnWriteArrayList 呢?</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"excepiton"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>,list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">多运行几次,结果都是一样的:</font></p><p><img src="/images/2020/CopyOnWriteArrayListDemo.jpg"></p><p><font face="华文中宋" size="3">CopyOnWriteArrayList 是线程安全的</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读~</font></p><hr><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p><p><font face="华文中宋" size="3">最近感觉状态不对劲,容我调整调整</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;概念&lt;/font&gt;&lt;/h1&gt;&lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;CopyOnWrite 只是看字面意思就能看出来,就是在写入时复制&lt;br&gt;说得轻巧,写入时复制,具体是怎么实现的呢?&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[年中总结]若能控制住粗鄙的狂喜</title>
    <link href="https://www.dynamic-zheng.com/posts/2d11cb2d.html"/>
    <id>https://www.dynamic-zheng.com/posts/2d11cb2d.html</id>
    <published>2020-07-04T12:49:10.000Z</published>
    <updated>2020-07-04T12:50:17.752Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">每次都是感叹,时间怎么就过的这么快呢~<br>七月份了,说明啥?说明就这么一眨眼的时间,半年就过去了(要不我不眨眼了行不,时间就别过这么快了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">还记得以前自己的总结都能写出好长一篇出来,这次真的是有点儿惆怅了,不知道该写点儿啥</font></p><p><font face="华文中宋" size="3">要说起来的话,这半年就做了两件事:好好工作,好好精进自己<br>好好工作没啥说的,精进自己主要是从 技术 &amp; 眼界 两方面来提高自己</font></p><p><font face="华文中宋" size="3">今年情况也都知道,寒冬嘛,更应该做的就是提高自己<br>技术方面看我以前写的博客就能够看出来最近都干了啥<br>眼界这方面,第一就是自己不断地去学习吧(大年三十那天我还在读书 &amp; 写作,你敢信?<br>第二就是看自己身边优秀的朋友们都在做什么.我是觉得他们都那么厉害,那我跟着他们的脚步去走,最后应该也不会很差</font></p><p><font face="华文中宋" size="3">过去的一年,受明白老师影响蛮大的<br>看到他也会偷懒,看到他也会嫉妒,看到他也会焦虑,看到他也会纠结,让我觉得我不是一个人<br>我是那种,如果今天一天我是睡过去了,或者是玩过去了,没有看一会儿书,没有输出一点儿内容,就会无限制的责怪自己:你怎么能这样呢,时间这么宝贵,你怎么就这么浪费了呢<br>近距离观察明白老师之后,让我知道了再厉害的人也都有自己的情绪,所以现在我也在慢慢的去接受自己,或好或坏都在努力接受着<br>但是有时候如果一天什么都没做,就又会自觉不自觉的去责怪自己,比以前做的好的一点是:发现自己有这方面的倾向之后,觉察到自己的情绪之后,赶快去做调整<br>明白老师,乔老师还有 Ju 老师会在我不知所措的时候给我建议 &amp; 鼓励,能够得到他们的指点和教导,真的是一件值得感恩的事情<br>不知不觉认识他们都一年了,感觉就像是老友一般</font></p><p><font face="华文中宋" size="3">如果真要说起来的话,过去的半年,甚至是过去的很多年里,我一直都被身边的朋友们善待着 &amp; 治愈着<br>感恩,感谢遇到的所有~</font></p><p><font face="华文中宋" size="3">我知道,到了人生这一个时刻,其实都是要靠自己的,对那句话: <code>一个人的对手只有一个,那就是自己</code> 理解的也更加深刻<br>因为在这漫长的岁月中,你要不断的和自己的情绪,懒惰和意志去做斗争,而且你会发现,在绝大多数情况下,只能缴械投降,你还会发现,这事儿吧,就得你自己去做,你的朋友帮不了你,你的家人也帮不了你,只有你,只有你自己去面对这一切,是好的还是坏的,都是自己的,要自己接纳自己,要自己去努力 &amp; 奋斗<br>众生皆苦,只可自渡</font></p><p><font face="华文中宋" size="3">其实也正是因为能够深刻理解一个人才是常态,所以更加觉得成年人之间的温暖,是及其珍贵的<br>帮助过我的,一直惦记着我的,总是鼓励着我的,我都有记在心里,没啥说的,拿行动说话<br>如果你有幸感受到成年人之间的温暖,好好珍惜<br>如果还没有遇到,别太担心,照顾好自己</font></p><p><font face="华文中宋" size="3">人生最重要的不是快乐,而是平和<br>所以,如果能够控制住粗鄙的狂喜,就不会有深入骨髓的悲伤<br>人生路还长,不要着急,要慢慢来</font></p><p><font face="华文中宋" size="3">我又成功的水了一篇文章,又成功的骗你看到这里<br>哈哈哈,谢谢你,耐心看这篇文章到这里,看我的各种碎碎念</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;每次都是感叹,时间怎么就过的这么快呢~&lt;br&gt;七月份了,说明啥?说明就这么一眨眼的时间,半年就过去了(要不我不眨眼了行不,时间就别过这么快了&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="https://www.dynamic-zheng.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年中总结" scheme="https://www.dynamic-zheng.com/tags/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]你知道不知道 Fork/Join ?</title>
    <link href="https://www.dynamic-zheng.com/posts/a16e4d0e.html"/>
    <id>https://www.dynamic-zheng.com/posts/a16e4d0e.html</id>
    <published>2020-06-27T00:38:37.000Z</published>
    <updated>2020-06-27T00:40:36.251Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果要说 Fork/Join 的话,就得来说说分治.<br><a id="more"></a><br>分治分治,就是分而治之嘛,具体一点儿就是把一个复杂的问题分解成多个相似的子问题,然后呢,再把子问题分解成更小的子问题,直到子问题简单到可以直接求解才算结束<br>这种思想,是不是让你想起了归并排序/快速排序/二分查找?没错,这些算法的实现也是借助了分治的思想</font></p><p><font face="华文中宋" size="3">分治分治,估计可以猜出来吧,最重要的就是两点:一个是分,一个是治<br>分什么呢?就是把一个复杂的问题分解成子问题,直到子问题可以直接求解结束<br>治什么呢?刚刚把分解的子问题求解出来了对吧?那是不是要汇总一下,最后求出总问题的解?<br>千言万语不如一张图,那就来张图:</font></p><p><img src="/images/2020/fork&join.jpg"></p><p><font face="华文中宋" size="3">看完有没有觉得,哦,原来这就是 fork/join 的赶脚?<br>如果有的话,那我这张图就没白画,头发没白掉~</font></p><h1 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a><font face="华文中宋" size="3">ForkJoinTask</font></h1><p><font face="华文中宋" size="3">Fork/Join 是一个并行计算的框架,主要就是用来支持分治任务模型的<br>Fork/Join 计算框架主要包含两部分,一部分是<strong>分治任务的线程池 ForkJoinPool </strong> ,另一部分是<strong>分治任务 ForkJoinTask </strong> ,先来看 ForkJoinTask<br>因为如果你想要 join 的话,是不是要先有 fork ?而 fork 方法在 ForkJoinTask 里面,所以咱们先来看看它</font></p><p><font face="华文中宋" size="3">在源码中,能够看到 fork 方法:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="comment">// ForkJoinWorkerThread 是执行 ForkJoinTask 的专有线程</span></span><br><span class="line">    <span class="comment">// 判断当前线程是否是 ForkJoin 专有线程,如果是则将任务 push 到当前线程所负责的队列里面去</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 如果不是 ForkJoin 专有线程,就将任务提交到默认的 common 线程池中</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">仔细看的话, fork() 就做了一件事,就是把<strong>任务放到当前工作线程的工作队列中</strong><br>咱们继续往下看, fork() 结束,是怎么做的 join()</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">// 调用 dojoin 方法来获取当前任务的执行状态</span></span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">    <span class="comment">// 任务异常,抛出异常</span></span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="comment">// 任务完成,返回结果</span></span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">能够看到, join() 方法就是等待处理任务的线程结束,然后拿到返回值<br>在 join 方法中调用了 doJoin 方法,咱们来瞅瞅它具体是个啥</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="comment">// 首先判断任务是否执行完毕,如果执行完毕,直接返回结果就可以了</span></span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">    <span class="comment">// 如果没有执行完毕,接下来要判断是不是 ForkJoinWorkerThread 线程</span></span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        <span class="comment">// 如果是,判断这个任务是不是在工作队列最前边(也就是下一个执行的就是它)</span></span><br><span class="line">        <span class="comment">// tryUnpush() 方法判断任务是不是在工作队列最前边,是的话就返回 true</span></span><br><span class="line">        <span class="comment">// doExec() 方法执行任务</span></span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        <span class="comment">// 如果是在工作队列最前边,并且任务执行完毕,直接返回结果即可</span></span><br><span class="line">        tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        <span class="comment">// 如果不是工作队列最前边或者任务没有执行完毕,调用 awaitJoin() 来执行任务</span></span><br><span class="line">        <span class="comment">// awaitJoin(): 使用自旋使得任务执行完成,返回结果</span></span><br><span class="line">        wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        <span class="comment">// 如果不是 ForkJoinWorkThread 线程,执行 externalAwaitDone() 返回任务结果</span></span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">我知道,你看完上面的分析之后,就懵逼了<br>因为我当时分析这块还理解了好久<br>那如果来张图呢?</font></p><p><img src="/images/2020/join流程图.png"></p><p><font face="华文中宋" size="3">ForkJoinTask 有两个子类 –&gt; RecursiveAction &amp; RecursiveTask ,它们都是通过递归的方式来处理分治任务的,这两个子类都定义了抽象方法 compute() ,不过区别就是 RecursiveAction 定义的 compute() 没有返回值,而 RecursiveTask 定义的 compute() 方法是有返回值的</font></p><h1 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a><font face="华文中宋" size="3">ForkJoinPool</font></h1><p><font face="华文中宋" size="3">ForkJoinPool 是用来执行 ForkJoinTask 任务的线程池,它负责管理线程池中的线程和任务队列,还有就是线程池是否还接受任务,显示线程的运行状态也是在这里处理<br>ForkJoinPool 本质上是一个 生产者-消费者 的实现,但是它更加的只能,因为它可以窃取别的任务,也就是说,如果一个工作线程空闲了,那么它可以”窃取”其他工作队列中的任务来做<br>接下来咱们瞅瞅 ForkJoinPool 的源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> ForkJoinPool&#125; with the given parameters, without</span></span><br><span class="line"><span class="comment"> * any security checks or parameter validation.  Invoked directly by</span></span><br><span class="line"><span class="comment"> * makeCommonPool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 私有构造方法,没有任何的安全检查和参数校验,由 makeCommonPool 直接调用</span></span><br><span class="line"> <span class="comment">// parallelism 并行度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">ForkJoinPool 由 makeCommonPool 直接调用,来瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates and returns the common pool, respecting user settings</span></span><br><span class="line"><span class="comment"> * specified via system properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title">makeCommonPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    ForkJoinWorkerThreadFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    UncaughtExceptionHandler handler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 通过系统指定相关参数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing properties</span></span><br><span class="line">        String pp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>);</span><br><span class="line">        String fp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.threadFactory"</span>);</span><br><span class="line">        String hp = System.getProperty</span><br><span class="line">            (<span class="string">"java.util.concurrent.ForkJoinPool.common.exceptionHandler"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="keyword">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="keyword">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler)ClassLoader.</span><br><span class="line">                       getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 factory 为空</span></span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 getSecurityManager 返回 null ,说明系统还没有为当前应用程序建立安全管理器</span></span><br><span class="line">    <span class="comment">// 使用 defaultForkJoinWorkerThreadFactory 来进行创建</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="keyword">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">        <span class="comment">// 如果 getSecurityManager 返回不是 null ,说明系统为当前应用程序建立好了安全管理器</span></span><br><span class="line">        <span class="comment">// 使用 InnocuousForkJoinWorkerThreadFactory 来进行创建</span></span><br><span class="line">            factory = <span class="keyword">new</span> InnocuousForkJoinWorkerThreadFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">        (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">                            <span class="string">"ForkJoinPool.commonPool-worker-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">这篇文章到这里,我就要划一个句号了<br>摸着良心说,这篇文章内容,相对来说不是很多,因为很多源码都还没分析到,比如使用的 <code>workQueues</code> 队列,比如如何实现的任务窃取,都还没说到,等我回头再写一篇文章出来<br>主要是分析源码,太费脑细胞 &amp; 头发了 ٩(º﹃º٩)<br>再加上最近有点儿放飞自我,沉迷于动漫中,等我刷完了动漫我再把细节补充上来</font></p><p><font face="华文中宋" size="3">就酱~<br>感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;如果要说 Fork/Join 的话,就得来说说分治.&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发] ThreadPoolExecutor 是如何做到线程复用的</title>
    <link href="https://www.dynamic-zheng.com/posts/9595861d.html"/>
    <id>https://www.dynamic-zheng.com/posts/9595861d.html</id>
    <published>2020-06-21T06:02:30.000Z</published>
    <updated>2020-06-21T06:04:37.447Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在上篇文章 <a href="https://www.dynamic-zheng.com/posts/d3e00aa7.html#more">[Java 并发]详解 ThreadPoolExecutor</a>  中说过了,创建线程池的好处之一就是它可以做到线程复用<br>那么,它是如何做到线程复用的呢?<br>这事儿,还得从源码说起<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">先解决一个基础问题:啥是线程复用?<br>如果是一个线程的话,那么在它创建的时候,我们会给它指定一个线程任务对不对?那如果执行完任务之后,这个线程是不是就会自动销毁?<br>但是在线程池中可不是呦~线程池中的线程,在执行完任务之后不会销毁,会继续执行另外的任务<br>这就是我们说的,线程复用</font></p><p><font face="华文中宋" size="3">OK ,线程复用明白了,新的问题就来了:在 ThreadPoolExecutor 中,它是如何做到线程复用的呢?<br>这就得去看源码是怎么写的了</font></p><h1 id="execute"><a href="#execute" class="headerlink" title=" execute"></a><font face="华文中宋" size="3"> execute</font></h1><p><font face="华文中宋" size="3">做到线程复用,肯定要先 execute 起来吧(这块在刚开始的文章中已经有过解释了,就直接放源码了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于 corePoolSize 时,调用 addWorker 创建核心线程来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程数不小于 corePoolSize ,就将任务添加到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="comment">// 获取到当前线程的状态,赋值给 recheck ,是为了重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果 isRunning 返回 false ,那就 remove 掉这个任务,然后执行拒绝策略,也就是回滚重新排队</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 线程池处于 running 状态,但是没有线程,那就创建线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入 workQueue 失败,尝试通过创建非核心线程来执行任务</span></span><br><span class="line">    <span class="comment">// 如果还是失败,说明线程池已经关闭或者已经饱和,会拒绝执行该任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a><font face="华文中宋" size="3">addWorker</font></h1><p><font face="华文中宋" size="3">从上面能够看出来,主要是 addWorker 方法<br>addWorker 主要是用来创建核心线程的,它主要的实现逻辑是:</font></p><ul><li><font face="华文中宋" size="3">判断线程数量有没有超过规定的数量,如果超过了就返回 false</font></li><li><font face="华文中宋" size="3">如果没有超过,就会创建 worker 对象,并初始化一个 Thread 对象,然后启动这个线程对象</font></li></ul><p><font face="华文中宋" size="3">接下来瞅瞅源码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line"><span class="comment">// 线程池状态 &gt;= SHUTDOWN 时,不再接受新的任务,直接返回 false</span></span><br><span class="line"><span class="comment">// 如果 rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty() 同样不接受新的任务,返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"><span class="comment">// wc &gt;= CAPACITY 说明线程数不够,所以就返回 false</span></span><br><span class="line"><span class="comment">// wc &gt;= (core ? corePoolSize : maximumPoolSize) 是在做判断</span></span><br><span class="line"><span class="comment">// 如果 core 为 true ,说明要创建的线程是核心线程,接下来判断 wc 是否大于 核心线程数 ,如果大于返回 false</span></span><br><span class="line"><span class="comment">// 如果 core 为 false ,说明要创建的线程是非核心线程,接下来判断 wc 是否大于 最大线程数 ,如果大于返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// CAS 操作增加 workerCount 的值,如果成功跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line"><span class="comment">// 判断线程池状态有没有变化,如果有变化,则重试</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// workerCount 增加成功之后开始走下面的代码</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个 worker 对象</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"><span class="comment">// 实例化一个 Thread 对象</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 接下来的操作需要加锁进行</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"><span class="comment">// 将任务线程添加到线程池中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line"><span class="comment">// 启动任务线程,开始执行任务</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line"><span class="comment">// 如果任务线程启动失败调用 addWorkerFailed </span></span><br><span class="line"><span class="comment">// addWorkerFailed 方法里面主要做了两件事:将该线程从线程池中移除;将 workerCount 的值减 1</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Worker-类"><a href="#Worker-类" class="headerlink" title="Worker 类"></a><font face="华文中宋" size="3">Worker 类</font></h1><p><font face="华文中宋" size="3">在 addWorker 中,主要是由 Worker 类去做一些相应处理, worker 继承 AQS ,实现 Runnable 接口<br>线程池维护的是 <code>HashSet&lt;Worker&gt;</code> ,一个由 <code>worker</code> 对象组成的 <code>HashSet</code></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">worker 继承 AQS 主要是利用 AQS 独占锁机制,来标识线程是否空闲;另外, worker 还实现了 Runnable 接口,所以它本身就是一个线程任务,在构造方法中创建了一个线程,线程的任务就是自己 <code>this.thread = getThreadFactory().newThread(this);</code><br>咱们瞅瞅里面的源码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">   </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">        * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 处理任务的线程</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">// worker 传入的任务</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Worker(Runnable firstTask) &#123;</span><br><span class="line">       <span class="comment">// 将 state 设为 -1 ,避免 worker 在执行前被中断</span></span><br><span class="line">           setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">           <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line"><span class="comment">// 创建一个线程,来执行任务</span></span><br><span class="line">           <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           runWorker(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Lock methods</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">       <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           setState(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Thread t;</span><br><span class="line">           <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   t.interrupt();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a><font face="华文中宋" size="3">runWorker</font></h1><p><font face="华文中宋" size="3">worker 类在执行 run 方法时,实际上调用的是 runWorker 方法</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">       Thread wt = Thread.currentThread();</span><br><span class="line">       Runnable task = w.firstTask;</span><br><span class="line">       w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">// 允许中断</span></span><br><span class="line">       w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">       <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 判断 task 是否为空,如果不为空直接执行</span></span><br><span class="line">       <span class="comment">// 如果 task 为空,调用 getTask() 方法,从 workQueue 中取出新的 task 执行</span></span><br><span class="line">           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 加锁,防止被其他线程中断</span></span><br><span class="line">               w.lock();</span><br><span class="line">               <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">               <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">               <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">               <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">               <span class="comment">// 检查线程池的状态,如果线程池处于 stop 状态,则需要中断当前线程</span></span><br><span class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                   !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 执行 beforeExecute </span></span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行任务</span></span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">// 执行 afterExecute 方法</span></span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="comment">// 将 task 设置为 null ,循环操作</span></span><br><span class="line">                   task = <span class="keyword">null</span>;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   <span class="comment">// 释放锁</span></span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在 runWorker 方法中,首先会去执行创建这个 worker 时就有的任务,当执行完这个任务之后, worker 并不会被销毁,而是在 while 循环中, worker 会不断的调用 getTask 方法从阻塞队列中获取任务然后调用 <code>task.run()</code> 来执行任务,这样就达到了<strong>复用线程</strong>的目的.通过循环条件 <code>while (task != null || (task = getTask()) != null)</code> 可以看出,只要 getTask 方法返回值不为 null ,就会一直循环下去,这个线程也就会一直在执行,从而达到了线程复用的目的</font></p><h1 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a><font face="华文中宋" size="3">getTask</font></h1><p><font face="华文中宋" size="3">咱们来看看 getTask 方法的实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">           <span class="comment">// allowCoreThreadTimeOut 变量默认为 false ,也就是核心线程就算是空闲也不会被销毁</span></span><br><span class="line">           <span class="comment">// 如果为 true ,核心线程在 keepAliveTime 内是空闲的,就会被销毁</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果运行线程数大于最大线程数,但是缓存队列已经空了,此时递减 worker 数量</span></span><br><span class="line">           <span class="comment">// 如果有设置允许线程超时或者线程数量超过了核心线程数量,并且线程在规定时间内没有 poll 到任务并且队列为空,此时也递减 worker 数量</span></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 如果 timed 为 true ,会调用 workQueue 的 poll 方法</span></span><br><span class="line">               <span class="comment">// 超时时间为 keepAliveTime ,如果超过 keepAliveTime 时长的话, poll 就会返回 null </span></span><br><span class="line">               <span class="comment">// 如果返回为 null ,在 runWorker 中 </span></span><br><span class="line">               <span class="comment">// while (task != null || (task = getTask()) != null) 循环条件被打破,从而跳出循环,此时线程执行完毕</span></span><br><span class="line">               <span class="comment">// 如果 timed 为 false ( allowCoreThreadTimeOut 为 false ,并且 wc &gt; corePoolSize 为 false )</span></span><br><span class="line">               <span class="comment">// 会调用 workQueue 的 take 方法阻塞到当前</span></span><br><span class="line">               <span class="comment">// 当队列中有任务加入时,线程被唤醒, take 方法返回任务,开始执行</span></span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> r;</span><br><span class="line">               timedOut = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">源码分析到这里就差不多清楚了<br>线程复用主要体现在 runWorker 方法中的 while 循环中,在 while 循环里面, worker 会不断的调用 getTask 方法,而在 getTask 方法里,如果任务队列中没有了任务,此时如果线程是核心线程则会一直卡在 workQueue.take 方法,这个时候会被阻塞并挂起,不会占用 CPU 资源,直到拿到任务然后返回 true , 此时 runWorker 中得到这个任务来继续执行任务,从而实现了线程复用</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在上篇文章 &lt;a href=&quot;https://www.dynamic-zheng.com/posts/d3e00aa7.html#more&quot;&gt;[Java 并发]详解 ThreadPoolExecutor&lt;/a&gt;  中说过了,创建线程池的好处之一就是它可以做到线程复用&lt;br&gt;那么,它是如何做到线程复用的呢?&lt;br&gt;这事儿,还得从源码说起&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]详解 ThreadPoolExecutor</title>
    <link href="https://www.dynamic-zheng.com/posts/d3e00aa7.html"/>
    <id>https://www.dynamic-zheng.com/posts/d3e00aa7.html</id>
    <published>2020-06-14T02:29:12.000Z</published>
    <updated>2020-06-14T02:32:38.687Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">ThreadPoolExecutor 可能在别的地方已经看过好多了,那我就尽量讲点儿不一样的知识出来<br><a id="more"></a></font></p><h1 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a><font face="华文中宋" size="3">为什么要用线程池</font></h1><p><font face="华文中宋" size="3">你有没有这样的疑惑,为什么要用线程池呢?可能你会说,我可以复用已经创建的线程呀;线程是个重量级对象,为了避免频繁创建和销毁,使用线程池来管理最好了<br>没毛病,各位都很懂哈~<br>不过使用线程池还有一个重要的点:可以控制并发的数量.如果并发数量太多了,导致消耗的资源增多,直接把服务器给搞趴下了,肯定也是不行的</font></p><p><font face="华文中宋" size="3">咱们再看看 ThreadPoolExecutor ,把这三个单词分开看, <code>Thread 线程</code>, <code>Pool 池</code>, <code>Executor</code> 执行者.如果连起来的话,是线程池执行者<br>所以呢, ThreadPoolExecutor 它强调的是 <code>Executor</code> ,而不是一般意义上的池化资源</font></p><h1 id="绕不过去的几个参数"><a href="#绕不过去的几个参数" class="headerlink" title="绕不过去的几个参数"></a><font face="华文中宋" size="3">绕不过去的几个参数</font></h1><p><font face="华文中宋" size="3">提到 ThreadPoolExecutor 那么你的小脑袋肯定会想到那么几个参数,咱们来瞅瞅源码(我就直接放有 7 个参数的那个方法了):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">咱们分别来看:</font></p><ul><li><font face="华文中宋" size="3">corePoolSize :<br><font face="华文中宋" size="3">核心线程数,在线程池中有两种线程,核心线程和非核心线程.在线程池中的核心线程,就算是它什么都不做,也会一直在线程池中,除非设置了  <code>allowCoreThreadTimeOut</code> 参数</font></font></li><li><font face="华文中宋" size="3">maximumPoolSize:<br><font face="华文中宋" size="3">线程池能够创建的最大线程数.这个值 = 核心线程数 + 非核心线程数</font></font></li><li><font face="华文中宋" size="3">keepAliveTime &amp; unit :<br><font face="华文中宋" size="3">线程池是可以撤销线程的,那么什么时候撤销呢?一个线程如果在一段时间内,都没有执行任务,那说明这个线程很闲啊,那是不是就可以把它撤销掉了?<br>所以呢,如果一个线程不是核心线程,而且在 keepAliveTime &amp; unit 这段时间内,还没有干活,那么很抱歉,只能请你走人了<br>核心线程就算是很闲,也不会将它从线程池中清除,没办法谁让它是 <code>core</code> 线程呢~</font></font></li><li><font face="华文中宋" size="3">workQueue :<br><font face="华文中宋" size="3">工作队列,这个队列维护的是等待执行的 Runnable 任务对象<br>常用的几个队列: LinkedBlockingQueue , ArrayBlockingQueue , SynchronousQueue , DelayQueue<br>大厂的编码规范,相信各位都知道,并不建议使用 Executors ,最重要的一个原因就是: Executors 提供的很多方法默认使用的都是无界的 LinkedBlockingQueue ,在高负载情况下,无界队列很容易就导致 OOM ,而 OOM 会让所有请求都无法处理,所以在使用时,<strong>强烈建议使用有界队列</strong>,因为如果你使用的是有界队列的话,当线程数量太多时,它会走拒绝策略</font></font></li><li><font face="华文中宋" size="3">threadFactory :<br><font face="华文中宋" size="3">创建线程的工厂,用来批量创建线程的.如果不指定的话,就会创建一个默认的线程工厂</font></font></li><li><font face="华文中宋" size="3">handler :<br><font face="华文中宋" size="3">拒绝处理策略.在 workQueue 那里说了,如果使用的是有界队列,那么当线程数量大于最大线程数的时候,拒绝处理策略就起到作用了<br>常用的有四种处理策略:<ul><li><font face="华文中宋" size="3">AbortPolicy :默认的拒绝策略,会丢弃任务并抛出 RejectedExecutionException 异常</font></li><li><font face="华文中宋" size="3">CallerRunsPolicy :提交任务的线程,自己去执行这个任务</font></li><li><font face="华文中宋" size="3">DiscardOldestPolicy :直接丢弃新来的任务,也没有任何异常抛出</font></li><li><font face="华文中宋" size="3">DiscardOldestPolicy :丢弃最老的任务,然后将新任务加入到工作队列中</font></li></ul></font></font></li></ul><p><font face="华文中宋" size="3">默认拒绝策略是 AbortPolicy ,会  throw RejectedExecutionException 异常,但是这是一个运行时异常,对于运行时异常编译器不会强制 catch 它,所以就会比较容易忽略掉错误.<br>所以,如果线程池处理的任务非常重要,<strong>尽量自定义自己的拒绝策略</strong></font></p><h1 id="线程池的几个状态"><a href="#线程池的几个状态" class="headerlink" title="线程池的几个状态"></a><font face="华文中宋" size="3">线程池的几个状态</font></h1><p><font face="华文中宋" size="3">这篇文章开始我就说了,希望能写出一点儿不一样的东西,那咱们就从源码撸一撸<br>撸啥呢,源码那么多,总不能毫无目的的撸吧?<br>咱们来吧线程池的 5 种状态来撸一撸<br>在源码中,我们能够很明显看到定义的 5 种状态:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p>同时,使用 AtomicInteger 类型的变量 ctl 来控制线程池的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><ul><li><font face="华文中宋" size="3">线程池创建之后就处于 RUNNING 状态</font></li><li><font face="华文中宋" size="3">调用 shutdown() 方法之后处于 SHUTDOWN 状态,此时线程池不再接受新的任务,清除一些空闲 worker ,等待阻塞队列的任务完成</font></li><li><font face="华文中宋" size="3">调用 shutdownNow() 方法后处于 STOP 状态,此时线程池不再接受新的任务,中断所有的线程,阻塞队列中没有被执行的任务也会被全部丢弃</font></li><li><font face="华文中宋" size="3">当线程池中执行的任务为空时,也就是此时 ctl 的值为 0 时,线程池会变为 TIDYING 状态,接下来会执行 terminated() 方法</font></li><li><font face="华文中宋" size="3">执行完 terminated() 方法之后,线程池的状态就由 TIDYING 转到 TERMINATED 状态</font></li></ul><p><font face="华文中宋" size="3">最后上张图总结一下:</font></p><p><img src="/images/2020/线程池状态转换.jpg"></p><h2 id="线程池是如何处理任务的"><a href="#线程池是如何处理任务的" class="headerlink" title="线程池是如何处理任务的"></a><font face="华文中宋" size="3">线程池是如何处理任务的</font></h2><p><font face="华文中宋" size="3">线程池处理任务的核心方法是 execute ,大概思路就是:</font></p><ul><li><font face="华文中宋" size="3">如果 command 为 null ,没啥说的,直接抛出异常就完事儿了</font></li><li><font face="华文中宋" size="3">如果当前线程数小于 corePoolSize ,会新建一个核心线程执行任务</font></li><li><font face="华文中宋" size="3">如果当前线程数不小于 corePoolSize ,就会将任务放到队列中等待,如果任务排队成功,仍然需要检查是否应该添加线程,所以需要重新检查状态,并且在必要时回滚排队;如果线程池处于 running 状态,但是此时没有线程,就会创建线程</font></li><li><font face="华文中宋" size="3">如果没有办法给任务排队,说明这个时候,缓存队列满了,而且线程数达到了 maximumPoolSize 或者是线程池关闭了,系统没办法再响应新的请求,此时会执行拒绝策略</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于 corePoolSize 时,调用 addWorker 创建核心线程来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前线程数不小于 corePoolSize ,就将任务添加到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    <span class="comment">// 获取到当前线程的状态,赋值给 recheck ,是为了重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果 isRunning 返回 false ,那就 remove 掉这个任务,然后执行拒绝策略,也就是回滚重新排队</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 线程池处于 running 状态,但是没有线程,那就创建线程执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果放入 workQueue 失败,尝试通过创建非核心线程来执行任务</span></span><br><span class="line">    <span class="comment">// 如果还是失败,说明线程池已经关闭或者已经饱和,会拒绝执行该任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">在上面源码中,判断了两次线程池的状态,为什么要这么做呢?<br>这是因为在多线程环境下,线程池的状态是时刻发生变化的,可能刚获取线程池状态之后,这个状态就立刻发生了改变.如果没有二次检查的话,线程池处于非 RUNNING 状态时, command 就永远不会执行<br>来张图,总结一下上面说的:</font></p><p><img src="/images/2020/线程执行任务过程.jpg"></p><p><font face="华文中宋" size="3">这篇文章写到这里就没有啦~<br>希望你能从中得到一些收获<br>感谢你的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;ThreadPoolExecutor 可能在别的地方已经看过好多了,那我就尽量讲点儿不一样的知识出来&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
