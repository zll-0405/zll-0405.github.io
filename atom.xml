<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑璐璐|个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dynamic-zheng.com/"/>
  <updated>2021-03-20T13:57:20.106Z</updated>
  <id>https://www.dynamic-zheng.com/</id>
  
  <author>
    <name>郑璐璐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java 并发]关于线程优先级的相关问题,看完这篇文章就明白了</title>
    <link href="https://www.dynamic-zheng.com/posts/cddfeba2.html"/>
    <id>https://www.dynamic-zheng.com/posts/cddfeba2.html</id>
    <published>2021-03-20T13:56:01.000Z</published>
    <updated>2021-03-20T13:57:20.106Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">线程的优先级是可以被定义的<br><a id="more"></a><br>通过源码我们能够看到:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="comment">// 如果设置的 priority 大于系统设置的最大值,或者小于系统设置的最小值</span></span><br><span class="line">        <span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果设置线程的优先级大于线程组的优先级,则重置线程的优先级为线程组的优先级</span></span><br><span class="line">            <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">一个 Thread 必然存在于一个 ThreadGroup , Thread 有自己的优先级, ThreadGroup 也有优先级,如果 Thread 的优先级大于 ThreadGroup 的优先级了,那么就以 ThreadGroup 的优先级为准<br>接下来咱们聊聊关于线程优先级的其他问题</font></p><h1 id="线程优先级是否具有继承性"><a href="#线程优先级是否具有继承性" class="headerlink" title="线程优先级是否具有继承性?"></a><font face="华文中宋" size="3">线程优先级是否具有继承性?</font></h1><p><font face="华文中宋" size="3">如果在线程 A 中启动了线程 B ,此时线程 A 的优先级为 5 , 那么线程 B 的优先级是否也是 5 呢?<br>答案是: 是的,线程 B 会继承线程 A 的优先级,也就是此时线程 B 的优先级就是 5 .即: 线程优先级具有继承性<br>我们具体来看例子,具体代码如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span>: 验证线程优先级具有继承性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2021-3-14 12:09:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInheritOne</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ThreadInheritOne Priority is "</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">        ThreadInheritTwo threadInheritTwo = <span class="keyword">new</span> ThreadInheritTwo();</span><br><span class="line">        threadInheritTwo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span>: 验证线程优先级具有继承性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2021-3-14 12:09:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInheritTwo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ThreadInheritTwo Priority is "</span> + <span class="keyword">this</span>.getPriority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span>: 验证线程优先级具有继承性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2021-3-14 12:09:51</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInheritRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"main thread start, its priority is "</span> + Thread.currentThread().getPriority());</span><br><span class="line">        Thread.currentThread().setPriority(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"main thread end, its priority is "</span> + Thread.currentThread().getPriority());</span><br><span class="line">        ThreadInheritOne threadInheritOne = <span class="keyword">new</span> ThreadInheritOne();</span><br><span class="line">        threadInheritOne.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">运行一下以上代码,执行结果如下:<br><img src="https://img-blog.csdnimg.cn/20210314121314245.png" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">我们能够看到,本来运行的 main 线程优先级是 5 ,后来设置成 10 之后,再在里面启动 <code>ThreadInheritOne</code> 线程,此时它的线程优先级也变成了 10 , <code>ThreadInheritOne</code> 线程里又启动了 <code>ThreadInheritTwo</code> ,此时 <code>ThreadInheritTwo</code> 的线程优先级也是 10<br>由此,可以验证线程优先级具有继承性</font></p><h1 id="设置线程优先级具有什么意义"><a href="#设置线程优先级具有什么意义" class="headerlink" title="设置线程优先级具有什么意义?"></a><font face="华文中宋" size="3">设置线程优先级具有什么意义?</font></h1><p><font face="华文中宋" size="3">设置线程优先级,我们是肯定希望这个线程相对于其他线程,能够优先被 CPU 执行的,那么这一点怎么验证下呢?<br>还是来看个例子:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span>: 验证线程优先级高的优先被 CPU 执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2021-3-14 12:26:12</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityOne</span> <span class="keyword">extends</span>  <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                random.nextInt();</span><br><span class="line">                result = result + j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"★★★★★ threadOne priority is relatively high , use time = "</span> + (endTime - beginTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span>: 验证线程优先级高的优先被 CPU 执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2021-3-14 12:26:12</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityTwo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50000</span>; j++) &#123;</span><br><span class="line">                Random random = <span class="keyword">new</span> Random();</span><br><span class="line">                random.nextInt();</span><br><span class="line">                result = result + j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"☆☆☆☆☆ threadTwo priority is relatively low , use time = "</span> + (endTime - beginTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@introduce</span>: 验证线程优先级高的优先被 CPU 执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DATE</span>: 2021-3-14 12:26:12</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityRun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            ThreadPriorityOne threadOne = <span class="keyword">new</span> ThreadPriorityOne();</span><br><span class="line">            threadOne.setPriority(<span class="number">10</span>);</span><br><span class="line">            threadOne.start();</span><br><span class="line"></span><br><span class="line">            ThreadPriorityTwo threadTwo = <span class="keyword">new</span> ThreadPriorityTwo();</span><br><span class="line">            threadTwo.setPriority(<span class="number">1</span>);</span><br><span class="line">            threadTwo.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">来看下代码的运行效果:<br><img src="https://img-blog.csdnimg.cn/20210314122943791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">上面的截图只是一部分,不过也能让我们发现规律了,就是: 线程优先级高的,会优先被 CPU 执行<br>你可能会说了,那是当然的,因为在 main 线程中,将 <code>ThreadPriorityOne</code> 线程写在了 <code>ThreadPriorityTwo</code> 线程前面,根据线程调用顺序,此时 main 线程中肯定先执行 <code>ThreadPriorityOne</code> 线程,那么 <code>ThreadPriorityOne</code> 线程优先被执行完也就不足为奇了</font></p><p><font face="华文中宋" size="3">那我们将这两个线程的优先级换一下,看看效果(所以代码有些微调整,也就是将 <code>ThreadPriorityOne</code> 的优先级调整为 1 , <code>ThreadPriorityTwo</code> 线程优先级调整为 10 ,相应的文案也进行了调整)<br><img src="https://img-blog.csdnimg.cn/20210314124204729.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">可以看到,尽管 main 线程先调用了 <code>ThreadPriorityOne</code> 线程,但是 <code>ThreadPriorityTwo</code> 线程还是优先被执行了<br>也就是:线程优先级比较高的话,就会被 CPU 优先执行,和此时 main 线程先调用哪儿个线程没有关系</font></p><p><font face="华文中宋" size="3">参考:</font></p><ul><li><font face="华文中宋" size="3">Java 多线程编程核心技术</font></li></ul><p><font face="华文中宋" size="3">以上,<br>感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;线程的优先级是可以被定义的&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]再谈为什么启动线程时使用 start ,而不是 run</title>
    <link href="https://www.dynamic-zheng.com/posts/2cc48466.html"/>
    <id>https://www.dynamic-zheng.com/posts/2cc48466.html</id>
    <published>2021-03-14T02:26:07.000Z</published>
    <updated>2021-03-14T02:30:19.008Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">其实这个主题,原来我写过: <a href="https://www.dynamic-zheng.com/posts/335e06cd.html#more">[Java 并发]为什么启动线程时使用 start 而不是 run ?</a><br><a id="more"></a><br>在上篇文章中,主要是通过例子,向大家展示了如果调用 <code>run</code> 方法,线程并不是运行在自己的线程中,而是运行在了当前线程中<br>也就是,如果调用 <code>run</code> 方法的话,它本来应该是在 A 线程中运行的,但是因为直接调用了 <code>run</code> 方法,它可能就执行在了 <code>main</code> 线程中<br>我们本来是希望这些线程异步执行的,结果直接调用了 <code>run</code> 方法就成了同步执行</font></p><p><font face="华文中宋" size="3">所以为什么直接调用 <code>run</code> 方法就成了同步,而如果使用 <code>start</code> 方法,则成了异步<br>原因就是因为它们告诉 CPU 不同的内容</font></p><p><font face="华文中宋" size="3">当调用  <code>start</code> 方法时,只是告诉了”线程规划器”说这个线程已经准备就绪了,就差调用线程对象的 <code>run</code> 方法了,此时系统就会安排一个时间来调用这个线程的 <code>run</code> 方法,进而线程得到运行,启动线程,达到了异步执行的效果</font></p><p><font face="华文中宋" size="3">而如果调用 <code>run</code> 方法,那就不是异步执行了,因为调用 <code>run</code> 方法,就相当于现在就要启动运行,此时的线程对象并没有交给”线程规划器”来进行处理,而是直接由 <code>main</code> 线程接管了,来调用 <code>run</code> 方法让线程得到运行,启动线程<br>但是此时的 <code>main</code> 线程有可能正在运行其他的线程,根本没有空余时间来运行此次调用的 <code>run</code> 方法,结果呢,就是要等到 <code>main</code> 线程中的代码执行完毕,才会来执行 <code>run</code> 方法<br>这不就是同步执行了嘛</font></p><p><font face="华文中宋" size="3">所以,调用 <code>start</code> 方法,真正达到了异步执行的效果<br>而调用 <code>run</code> 方法,还是在同步执行代码,并没有充分利用多线程的优势</font></p><p><font face="华文中宋" size="3">以上<br>我觉得我这次理解到位了<br>你呢?</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;其实这个主题,原来我写过: &lt;a href=&quot;https://www.dynamic-zheng.com/posts/335e06cd.html#more&quot;&gt;[Java 并发]为什么启动线程时使用 start 而不是 run ?&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Maven]讲讲它的构建生命周期和拉取 jar 包流程</title>
    <link href="https://www.dynamic-zheng.com/posts/58185145.html"/>
    <id>https://www.dynamic-zheng.com/posts/58185145.html</id>
    <published>2021-03-07T06:18:21.000Z</published>
    <updated>2021-03-07T06:19:59.702Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我们都知道, Maven 是一款非常优秀的软件项目管理 &amp; 自动构建的工具,相信各位在项目中都多多少少接触过<br>那么今天咱们就来扒一扒它的构建生命周期都有哪些,以及拉取 jar 包时它的一个流程是怎样的<br><a id="more"></a></font></p><h1 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title=" Maven 生命周期"></a><font face="华文中宋" size="3"> Maven 生命周期</font></h1><p><font face="华文中宋" size="3">说到 Maven 的构建生命周期,我的小脑瓜里面冒出来的就是: <code>clean</code> <code>install</code> <code>deploy</code>  这些了<br>但是其实 Maven 生命周期不仅仅是这些~</font></p><p><font face="华文中宋" size="3">Maven 整个生命周期大概可以分为三大类:</font></p><ul><li><font face="华文中宋" size="3">clean : 目的在于清理项目</font></li><li><font face="华文中宋" size="3">default : 目的在于构建项目</font></li><li><font face="华文中宋" size="3">site : 目的在于建立项目站点</font></li></ul><p><font face="华文中宋" size="3">其中 <code>default</code> 生命周期它的目的在于构建项目,所以详细来说又可以再分:</font></p><ul><li><font face="华文中宋" size="3">validate: 验证要构建的项目是正确的,并且所需要的资源是存在的</font></li><li><font face="华文中宋" size="3">compile: 编译项目中的 java 文件成为虚拟机能识别的 .class 字节码文件</font></li><li><font face="华文中宋" size="3">test: 使用合适的单元测试框架来测试编译的源码是否可以正确运行</font></li><li><font face="华文中宋" size="3">package :将编译后的源代码打包( jar 或者 war )</font></li><li><font face="华文中宋" size="3">verify: 验证测试结果确保达到目标</font></li><li><font face="华文中宋" size="3">install: 将 package 放到本地仓库中,用作本地其他项目的依赖项</font></li><li><font face="华文中宋" size="3">deploy: 在构建环境中完成之后,将最终的 package 传到远程仓库中,便于共享</font></li></ul><p><font face="华文中宋" size="3">我经常用的 Maven 生命周期就是刚开始我的小脑袋瓜就冒出来的那几个了: <code>clean</code> <code>install</code> <code>deploy</code><br>但是现在 idea 和 Maven 已经有了一个非常完美的配合了,所以一般都是直接在 idea 里面操作,这些命令说起来也是很久没用过了</font></p><h1 id="拉取-jar-包流程"><a href="#拉取-jar-包流程" class="headerlink" title="拉取 jar 包流程"></a><font face="华文中宋" size="3">拉取 jar 包流程</font></h1><p><font face="华文中宋" size="3">讲完了 Maven 的生命周期,接下来说说,当我们使用 Maven 时,它是如何帮助我们拉取 jar 包的<br>首先上一张图:(问我为啥都是英文么?因为这样显得我很有文化的样子嘛~</font></p><p><img src="https://img-blog.csdnimg.cn/20210227171322941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><font face="华文中宋" size="3">接下来分析一下它的整个流程<br><code>local repository</code> 就是本地仓库啦,在项目中使用到的 jar 包如果本地仓库中有,那就好了,什么都不用做,直接引用就 OK 了<br>但是如果本地仓库中没有呢?<br>有两种方法可以找到</font></p><p><font face="华文中宋" size="3">第一种就是直接在我们项目中的 <code>pom.xml</code> 文件中,写上使用到的 <code>&lt;repository&gt;</code> <code>&lt;pluginRepository&gt;</code> , Maven 就会根据这个路径去找到要下载的 jar 包,但是这种方式我们一般都不怎么使用,因为我们更喜欢在 <code>pom.xml</code> 文件中以这样的方式使用:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;23.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">第二种方法就是我们常见的,将使用到的仓库地址存放在 Maven 的 setting 文件中,例如这样定义:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;  </span><br><span class="line">&lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">&lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">&lt;url&gt;http:<span class="comment">//maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span></span><br><span class="line">&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;          </span><br><span class="line">      &lt;/mirror&gt;</span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">当需要的 jar 包本地仓库没有时,就会通过 Maven 中的 setting 文件,我们设置的 <code>mirror</code> 通过 <code>Repository Manager</code> 找到镜像仓库,再通过分组/版本等信息,定位到我们想要的 jar 包<br>镜像仓库肯定都是公共的嘛,也就是 <code>central repository</code> ,然后肯定也会去做 cdn 处理,也就是 <code>central CDN</code> ,那么问题就是 <code>central repository</code> 中的相关数据是从哪里来的呢<br>是从 <code>project-dedicated staging repositories</code> (专用于项目的暂存库) 中同步过来的,我的理解就是:这个仓库是专用于项目的,然后经过大量项目的实践验证之后的 jar 包,会同步到 <code>central data</code> 中,再由 <code>central data</code> 向下同步,同时 <code>central data</code> 中的数据,也会 <code>push</code> (推送)到 <code>public forges(multi-projects) staging repositories</code> (公共库) 中<br>这样整个流程就建立起来了</font></p><h1 id="扩展-推送-jar-包到私服"><a href="#扩展-推送-jar-包到私服" class="headerlink" title="扩展: 推送 jar 包到私服"></a><font face="华文中宋" size="3">扩展: 推送 jar 包到私服</font></h1><p><font face="华文中宋" size="3">我记得原来折腾 Maven 的时候,弄过怎么推送 jar 包到私服(当时搭建的私服是 Nexus ),当时也记录了一些东西,放在这里当个扩展内容吧</font></p><p><font face="华文中宋" size="3">推送 jar 包到私服,主要有两种方式:</font></p><ul><li><font face="华文中宋" size="3">使用命令推送 jar 包</font></li><li><font face="华文中宋" size="3">通过私服界面进行手动推送</font></li></ul><p><font face="华文中宋" size="3">接下来详细讲讲该如何推送,在这里以向 Nexus 推送为例</font></p><p><font face="华文中宋" size="3">在使用命令推送 jar 包时,要在私服界面上允许远程推送,具体设置如下图:<br><img src="https://img-blog.csdnimg.cn/20210227185512881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">设置完之后,再使用下面的命令就可以推送了<br><code>mvn deploy:deploy-file -Dmaven.test.skip=true -Dfile=C:\test\tool-1.0.jar -DgroupId=com.example -DartifactId=tool -Dversion=1.0 -Dpackaging=jar -DrepositoryId=thirdparty -Durl=http://192.168.163.129:8081/nexus/content/repositories/thirdparty/</code></font></p><p><font face="华文中宋" size="3">其中一些字段的含义是:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Dmaven.test.skip=<span class="keyword">true</span>                      <span class="comment">//跳过编译、测试</span></span><br><span class="line">-Dfile=C:\test\tool-<span class="number">1.0</span>.jar                 <span class="comment">//jar包文件地址,绝对路径</span></span><br><span class="line">-DgroupId=com.example                       <span class="comment">//gruopId--pom坐标，自定义</span></span><br><span class="line">-DartifactId=tool                           <span class="comment">//artifactId--pom坐标，自定义</span></span><br><span class="line">-Dversion                                   <span class="comment">//版本号</span></span><br><span class="line">-Dpackaging                                 <span class="comment">//打包方式</span></span><br><span class="line">-DrepositoryId                              <span class="comment">//远程库服务器ID</span></span><br><span class="line">-Durl                                       <span class="comment">//远程库服务器地址</span></span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">手动上传的话,就好说很多了,直接在 Nexus 界面操作即可<br>如下图,就上传好了</font></p><p><img src="https://img-blog.csdnimg.cn/20210227190036816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><font face="华文中宋" size="3">看完这里关于如何推送 jar 包到远程服务器就没有啦~<br>但是我好奇心比较强,因为推送 jar 包到远程服务器上面的话,那这个 jar 包肯定是保存在服务器上面了,我就想知道它保存到哪里了,一定是有路径的<br>然后各处点的时候发现了</font></p><p><img src="https://img-blog.csdnimg.cn/2021022719034977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><font face="华文中宋" size="3">我们去这个路径下看看,发现真的是上传到了这里<br><img src="https://img-blog.csdnimg.cn/20210227190430527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">以上,就是我想要分享的内容了`<br>感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;我们都知道, Maven 是一款非常优秀的软件项目管理 &amp;amp; 自动构建的工具,相信各位在项目中都多多少少接触过&lt;br&gt;那么今天咱们就来扒一扒它的构建生命周期都有哪些,以及拉取 jar 包时它的一个流程是怎样的&lt;br&gt;
    
    </summary>
    
      <category term="Maven" scheme="https://www.dynamic-zheng.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="https://www.dynamic-zheng.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]可能要恢复更新了</title>
    <link href="https://www.dynamic-zheng.com/posts/3a3d2bd6.html"/>
    <id>https://www.dynamic-zheng.com/posts/3a3d2bd6.html</id>
    <published>2021-02-27T06:43:54.000Z</published>
    <updated>2021-02-27T06:45:31.087Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">哈喽,各位是不是好久没看我写的文章了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">元旦更新了一篇年终总结之后,到现在都没有发表什么文章了,是因为最近比较忙<br>元旦结束之后,就接了一版新的需求,需要用 php 去做,你们知道的,我是做 java 后端开发的嘛,所以刚开始接触 php 的话,肯定是有很多东西要去学的,这版需求年前就要做完<br>我负责的那块还是前后端都要做,也就是前端我要用 js 去搞,后端要用 php 去做, js 不熟, php 不会,所以年前一段时间就都没有更新</font></p><p><font face="华文中宋" size="3">过年的时候当然就是玩疯了,毕竟年前我可是承担了不少的压力,要放松一下啦<br>以至于到现在,才有了我今天的这篇文章(还是一篇碎碎念,各位没有想到吧,哈哈哈</font></p><p><font face="华文中宋" size="3">其实就是想说跟各位说一下,项目忙的差不多了, php 上手也差不多了,然后过年期间玩也玩了,所以接下来应该会恢复稳定更新的<br>只是可能哈,不要抱太大的期待~<br>以上</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;哈喽,各位是不是好久没看我写的文章了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[年终总结]过去,现在,未来</title>
    <link href="https://www.dynamic-zheng.com/posts/53020967.html"/>
    <id>https://www.dynamic-zheng.com/posts/53020967.html</id>
    <published>2021-01-03T12:59:59.000Z</published>
    <updated>2021-01-03T13:01:07.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过去一年值得感恩的事情"><a href="#过去一年值得感恩的事情" class="headerlink" title="过去一年值得感恩的事情"></a><font face="华文中宋" size="3">过去一年值得感恩的事情</font></h1><a id="more"></a><ul><li><font face="华文中宋" size="3">在最困难的时候,是 小姐姐 &amp; 小师姐 二话不说就帮忙解决的</font></li><li><font face="华文中宋" size="3">压力大的时候,是 华玫姐 &amp; 小公主 一直在陪伴</font></li><li><font face="华文中宋" size="3">换公司的时候,是 小侯 给了我很多底气</font></li><li><font face="华文中宋" size="3">和 邱总 成为了很好的朋友,指点了我很多,从她身上也学到了很多</font></li><li><font face="华文中宋" size="3">换了家公司,遇到了超 nice 的老大 &amp; 团队</font></li><li><font face="华文中宋" size="3">多了一个会督促我学习的小伙伴 – 邵聪</font></li><li><font face="华文中宋" size="3">因为 明白老师 &amp; 乔老师 &amp; Ju 老师 我才有动力一直去精进自己</font></li><li><font face="华文中宋" size="3">遇到了 Java 极客技术,让我一直有动力写博客到现在</font></li></ul><h1 id="过去一年比较遗憾的事情"><a href="#过去一年比较遗憾的事情" class="headerlink" title="过去一年比较遗憾的事情"></a><font face="华文中宋" size="3">过去一年比较遗憾的事情</font></h1><ul><li><font face="华文中宋" size="3">没能去看看周董的演唱会</font></li><li><font face="华文中宋" size="3">没能去一趟大同</font></li></ul><h1 id="现在正在做的"><a href="#现在正在做的" class="headerlink" title="现在正在做的"></a><font face="华文中宋" size="3">现在正在做的</font></h1><ul><li><font face="华文中宋" size="3">阅读的习惯,过去一年 技术书籍 &amp; 非技术书籍 50+</font></li><li><font face="华文中宋" size="3">输出的习惯,做到了每周尽量输出一篇,虽然有时候会写水文</font></li><li><font face="华文中宋" size="3">有时候会去爬爬山,尽可能让自己多动动</font></li><li><font face="华文中宋" size="3">有意识的去照顾身体,毕竟它是革命的本钱</font></li></ul><h1 id="未来一年想要尝试的"><a href="#未来一年想要尝试的" class="headerlink" title="未来一年想要尝试的"></a><font face="华文中宋" size="3">未来一年想要尝试的</font></h1><ul><li><font face="华文中宋" size="3">继续保持阅读习惯,很多问题书里都有答案</font></li><li><font face="华文中宋" size="3">多去尝试一些不一样的东西,让自己的生命多一些体验</font></li><li><font face="华文中宋" size="3">尽自己所能去帮助一些人,希望别人提起我的时候,第一反应就是:哦,那个人啊,挺靠谱的.我觉得如果在别人心中我是这样的存在的话,就非常开心了</font></li></ul><p><font face="华文中宋" size="3">最后,如果要说感谢的人的话,是非常多的,比如因为我说了一句电脑比较热,就帮我给 CPU 清理灰尘的贺信;比如我说我想吃蛋黄酥,得空就给我做的祥铭;比如当初我想让亚雯姐帮我看简历,那么忙的她还认真看了,给了很多建议;比如去年年初,还记得给我买年货的佳丽姐…这些事情,我都有记在心里,并没有忘记<br>在以后的日子里,我也会向他们表达我的感谢之情,虽然对方不一定能看得上吧,哈哈~</font></p><p><font face="华文中宋" size="3">我还想对自己说:过去的时间里你可真是辛苦了,接下来的日子,不要着急,慢慢来,你会越来越好的,非常看好你~</font></p><p><font face="华文中宋" size="3">最后的最后,对 郑先生 &amp; 董小姐 说一句谢谢,对他们的捣蛋鬼一直的宠爱和照顾</font></p><p><font face="华文中宋" size="3">以上<br>感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;过去一年值得感恩的事情&quot;&gt;&lt;a href=&quot;#过去一年值得感恩的事情&quot; class=&quot;headerlink&quot; title=&quot;过去一年值得感恩的事情&quot;&gt;&lt;/a&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;过去一年值得感恩的事情&lt;/font&gt;&lt;/h1&gt;
    
    </summary>
    
      <category term="年终总结" scheme="https://www.dynamic-zheng.com/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="年终总结" scheme="https://www.dynamic-zheng.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]我都惊呆了...</title>
    <link href="https://www.dynamic-zheng.com/posts/31a903ec.html"/>
    <id>https://www.dynamic-zheng.com/posts/31a903ec.html</id>
    <published>2020-12-27T11:02:02.000Z</published>
    <updated>2020-12-27T11:03:59.315Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">今天照例爬上来写文章的时候,我自己有点儿惊呆<br><a id="more"></a></font></p><p><img src="/images/2020/碎碎念.jpg"></p><p><font face="华文中宋" size="3">写的技术文章,现在过去半个月了,阅读量还没有最水的那篇水文阅读量高<br>哼,你们看我写的碎碎念看的还是蛮开心的嘛<br>嗯,如你们所料,这周的文章又是一篇碎碎念,哈哈哈哈</font></p><p><font face="华文中宋" size="3">下周就是元旦了,然后你们知道的,我的年终总结就该出来了<br>不过对我的年终总结也别抱太大的期待,因为我已经把能删的都删了,感觉以前写的太啰嗦了,所以这次的年终总结字数不会太多</font></p><p><font face="华文中宋" size="3">最近北京的疫情搞得我小心脏扑腾扑腾的,真想回到我的小农村<br>不过也就是想想了,这种情况,我就在家赖着了,比如今天一觉睡到中午<br>然后技术文的话,我现在已经开始准备写了,不过考虑到明天要上班,所以发表出来的话,可能就到下下周了吧<br>毕竟写技术文比较费脑子</font></p><p><img src="/images/2020/书籍.jpg"></p><p><font face="华文中宋" size="3">emmm ,明天要去单位上班了,希望我有神龙护体,助我这段时间都没什么事儿~</font></p><p><font face="华文中宋" size="3">以上,就是这样了<br>希望你看的开心(坏笑~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;今天照例爬上来写文章的时候,我自己有点儿惊呆&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]要不要进来唠唠嗑?</title>
    <link href="https://www.dynamic-zheng.com/posts/f77502f5.html"/>
    <id>https://www.dynamic-zheng.com/posts/f77502f5.html</id>
    <published>2020-12-20T14:42:09.000Z</published>
    <updated>2020-12-20T14:48:43.656Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我记得我说过,最近在忙着写年终总结,还有就是去见见想见的人嘛<br>因为总觉得自己在乎的人,年前都应该见一见的<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">最近见的人都是比我厉害很多的人,所以通过和他们吃饭我也学到了很多东西,毕竟吃饭的时候不可能只是吃饭对吧,还会聊聊天什么的<br>而且有时候真的,线上聊千遍,不如线下见一面<br>所以这篇文章就和大家唠唠嗑,说一说各种碎碎念~</font></p><h1 id="对自己有清晰的定位"><a href="#对自己有清晰的定位" class="headerlink" title="对自己有清晰的定位"></a><font face="华文中宋" size="3">对自己有清晰的定位</font></h1><p><font face="华文中宋" size="3">我发现最近见的几位朋友,对自己都是有清晰的定位的<br>他们知道自己身上的优点,也知道自己身上的缺点,所以对于能发挥自己优势的事情,会尽全力去做好,遇到不擅长的,会拜托给比自己擅长的人去做<br>也正是因为对自己有一个非常清晰的定位,所以他们都是非常自信的,在和他们交流过程中你就能发现,在讲自己做的一些事情的时候,他们眼里有光~<br>还有一点能从他们身上感受到的就是:满足感<br>快节奏的生活下,有满足感其实是比较难的,因为生活节奏比较快,别说开心啥的了,能度日就已经是非常不错的了</font></p><p><font face="华文中宋" size="3">但是和厉害的人聊天,能感受到他们身上的那种乐观,嘴角上扬,整个人给你的 feel 是很向上的<br>我觉得可能就是因为对自己有清晰的定位,知道自己想要什么,也知道该如何努力去得到,所以就比较满足吧,也很从容</font></p><h1 id="沟通交流表达能力都很强"><a href="#沟通交流表达能力都很强" class="headerlink" title="沟通交流表达能力都很强"></a><font face="华文中宋" size="3">沟通交流表达能力都很强</font></h1><p><font face="华文中宋" size="3">不知道你有没有这种感受,有的人说出来的话意思都是一样的,但是有的人一两句就可以说清楚,就能让你 get 到他的点,但是有的人说了好几句,你都不知道对方在说什么(比如我,手动狗头<br>这就是沟通交流表达能力不是很好,但是和厉害的人在一块聊天的时候,比如有时候说到一个技术,我没办法明白,然后对方就可以立刻换一个我熟悉的例子去跟我讲<br>这一点,我是真的还需要再练习</font></p><h1 id="不给自己设限"><a href="#不给自己设限" class="headerlink" title="不给自己设限"></a><font face="华文中宋" size="3">不给自己设限</font></h1><p><font face="华文中宋" size="3">我先说个场景:比如你是做开发的,但是你老大让你去研究一个网络问题,你会怎么办?比如你是做开发的,但是你老大让你去研究一款产品,你会怎么反应?<br>我觉得可能很多人的第一反应就是:我就是一个干开发的,为什么要让我去研究网络?为什么要让我去研究产品?这对我的工作有啥提高?<br>然后心不甘情不愿的去做了<br>你是这样的嘛?</font></p><p><font face="华文中宋" size="3">我观察了一下见过的这几位朋友,他们都是没有什么怨言,扭头就去做的,而且都会尽力做到最好<br>上面我举的例子不是我朋友的真实案例,是想到了 tk 教主分享的一段内容</font></p><p><img src="/images/2020/tk.jpg"></p><p><font face="华文中宋" size="3">给我的感觉就是,那些厉害的人,遇到事情的时候,第一反应不是这件事我做不来,而是会想办法,这件事情我该怎么才能完成它</font></p><h1 id="说说自己的个签"><a href="#说说自己的个签" class="headerlink" title="说说自己的个签"></a><font face="华文中宋" size="3">说说自己的个签</font></h1><p><font face="华文中宋" size="3">最近换了个签<br>以前的个签是: 自由而不独立,仍是奴隶<br>这句话是胡适先生在北大的一次演讲中提到的,当时他问现场学生,为什么校园里贴的标语是”自由思想,自由学术”,而不是”独立思想”? ——因为北大向来开明,自由,学校当然能给你们自由,但是独立是靠你们自己去争取的<br>也就是说,自由是针对外面的束缚来说的,独立才是自己的事情<br>因为如果自己不够独立的话,没有自己的思考,没有自己的想法的话,就算给了你自由,那么到最后可能还是会随大流,会别人做什么自己也去做什么<br>所以就一直放在博客上,来警醒自己,要做一个独立的人,勤思考</font></p><p><font face="华文中宋" size="3">最近的个签换了,换成了:  一个贪财好色,但仍有所不卖的小人<br>我承认我是一个小人,我承认有时候我会比较自私,我也承认我有时候会比较强势,我承认我贪财,满脑子想的都是赚钱,我也承认我好色,对于这世界上的一切美好事物我都想要去尝试,去体验<br>但是有一些事情我也是不为的<br>所以换了个签,活的更加随性洒脱一些~</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;我记得我说过,最近在忙着写年终总结,还有就是去见见想见的人嘛&lt;br&gt;因为总觉得自己在乎的人,年前都应该见一见的&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]为什么启动线程时使用 start 而不是 run ?</title>
    <link href="https://www.dynamic-zheng.com/posts/335e06cd.html"/>
    <id>https://www.dynamic-zheng.com/posts/335e06cd.html</id>
    <published>2020-12-12T12:00:32.000Z</published>
    <updated>2020-12-12T12:02:50.483Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在多线程中,如果想让一个线程启动,你使用的方法一定是 <code>thread.start()</code> 方法,而不是 <code>thread.run()</code> 方法(啥,你用的不是 <code>thread.start()</code> 方法?你的打开方式不对哦,下次不要这样了~<br><a id="more"></a><br>有没有疑惑,为什么每次我们都习惯调用 <code>start()</code> 方法,为什么不直接调用 <code>run()</code> 方法来启动线程呢?<br>而且如果去看源码的话,你会发现,在 <code>thread.start()</code> 方法中,其实最后还是调用了 <code>thread.run()</code> 方法来执行</font></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Causes <span class="keyword">this</span> thread to begin execution; the Java Virtual Machine</span><br><span class="line"> calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面的注释翻译一下:当线程开始执行时, JVM 会调用此线程的 run 方法<br>也就是说,线程的 run 方法是由 JVM 直接调用的,在 Java 中如果我们想要直接调用 run 方法也是可以的,因为在 Java 中 run 方法是 public 的</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">那既然 start 方法最后调用的也是 run 方法,再加上 run 方法本身支持直接调用,那为啥我们平时写的程序都是调用 start 方法,而不是 run 方法呢<br>那是因为,如果直接调用 run 方法,就不是多线程了<br>为了方便解释,咱们看个小 demo :</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread runThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">"Run begin another , 当前线程 : %s.%n"</span> ,Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        runThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接调用 run 方法 -- 演示使用,实际中不要这么做!</span></span><br><span class="line">        runThread.run();</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Run begin , 当前线程 : %s.%n"</span> ,Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">上面的程序运行结果如下:<br><img src="/images/2020/thread-run.jpg"></font></p><p><font face="华文中宋" size="3">你会发现, <code>runThread</code> 的 <code>run</code> 方法被执行了两次<br>一次是 run 方法运行在自己的线程中,从 <code>Run begin another , 当前线程 : Thread-0</code> 可以看到,这个线程是运行在 <code>Thread-0</code> 中<br>另外一次是因为我们的程序代码直接调用了 run 方法,此时的线程运行在 main 线程中,从 <code>Run begin another , 当前线程 : main</code> 可以看出来<br>也就是说,如果我们直接调用 run 方法的话,线程并不是运行在自己的线程中,而是运行在了当前线程中</font></p><p><font face="华文中宋" size="3">我们为什么要创建多线程?不就是希望多个线程并行执行,比如现在我是线程 A ,此时又起了一个线程,那么我希望这个线程是和线程 A 一起运行的,如果直接调用了 run 方法的话,就运行在线程 A 里面来了<br>并没有达到创建多线程的目标,这怎么行呢,对不对<br>所以在启动线程时,都是使用 start 方法,而不是 run 方法</font></p><p><font face="华文中宋" size="3">这一点,其实在源码中也有说明:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the Java Virtual Machine calls the run method of <span class="keyword">this</span> thread.</span><br><span class="line">The result is that two threads are running concurrently: </span><br><span class="line"><span class="function">the current <span class="title">thread</span> <span class="params">(which returns from the call to the start method)</span> </span></span><br><span class="line"><span class="function">and the other <span class="title">thread</span> <span class="params">(which executes its run method)</span>.</span></span><br></pre></td></tr></table></figure></font></p><p><font face="华文中宋" size="3">在 JVM 调用线程的 run 方法之后,结果就是两个线程同时运行:</font></p><ul><li><font face="华文中宋" size="3">当前线程(从调用返回到 start 方法)</font></li><li><font face="华文中宋" size="3"> 另一个线程(执行 run 方法)</font></li></ul><p><font face="华文中宋" size="3">以上,感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在多线程中,如果想让一个线程启动,你使用的方法一定是 &lt;code&gt;thread.start()&lt;/code&gt; 方法,而不是 &lt;code&gt;thread.run()&lt;/code&gt; 方法(啥,你用的不是 &lt;code&gt;thread.start()&lt;/code&gt; 方法?你的打开方式不对哦,下次不要这样了~&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]这周没有输入的我</title>
    <link href="https://www.dynamic-zheng.com/posts/76fe9e7d.html"/>
    <id>https://www.dynamic-zheng.com/posts/76fe9e7d.html</id>
    <published>2020-12-06T13:01:20.000Z</published>
    <updated>2020-12-06T13:02:24.082Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">一篇没有营养的文章<br>这不是今年的最后一个月了嘛,所以我最近的精力就在年终总结上了,写了几个版本都不满意,还在重新推翻重新写<br>然后,最后的这一个月,除了工作时间,其他时间几乎都约出去了,想着在 2021 年之前尽可能多见一些自己在乎的人吧,如果再不见的话,再见面就是 2021 年了,仪式感还是要有的</font></p><p><font face="华文中宋" size="3">这几天简单的复盘了一下去年的目标,除了一个目标没有实现之外,其他的目标都实现了,整体来说,对自己的表现还算满意吧,其实有些地方还是可以做的更好的,那就是明年要改进的地方了<br>今天和几个朋友去吃好吃的去了,吃了一肚子肉回来的我,现在满脑子大搞就是想要睡觉了~</font></p><p><font face="华文中宋" size="3">这周文章就是这样,没啥营养<br>依旧感谢您的阅读~</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;一篇没有营养的文章&lt;br&gt;这不是今年的最后一个月了嘛,所以我最近的精力就在年终总结上了,写了几个版本都不满意,还在重新推翻重新写&lt;br&gt;然后,最后的这一个月,除了工作时间,其他时间几乎都约出去了,想着在 2021 年之前
      
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[Java]面试官你能不能别问我 HashMap 了?</title>
    <link href="https://www.dynamic-zheng.com/posts/7163f33e.html"/>
    <id>https://www.dynamic-zheng.com/posts/7163f33e.html</id>
    <published>2020-11-29T11:54:58.000Z</published>
    <updated>2020-12-05T13:19:41.821Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">如果你是个 Java 程序员,那一定对 HashMap 不陌生,巧的是只要你去面试,大概率都会被问到 HashMap 的相关内容<br>基于此,就总结一篇,争取不让面试官问倒~<br><a id="more"></a></font></p><h1 id="HashMap-的底层数据结构"><a href="#HashMap-的底层数据结构" class="headerlink" title="HashMap 的底层数据结构"></a><font face="华文中宋" size="3">HashMap 的底层数据结构</font></h1><p><font face="华文中宋" size="3">先来聊聊 HashMap 的底层数据结构<br>HashMap 的底层数据结构, 1.7 版本和 1.8 版本是有些不同的,但大体上都是 数组 + 链表 的形式来实现的<br>1.7 版本是这个样子:<br><img src="https://img-blog.csdnimg.cn/2020112912213098.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">1.8 版本是这样:<br><img src="https://img-blog.csdnimg.cn/2020112912221571.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">很明显就能看出来, 1.8 版本怎么多了一个树?还是红黑的?<br>这就要来分析 1.7 版本 HashMap 的实现有什么不足了.<br>1.7 版本主要就是 数组 + 链表,那么如果有一个 hash 值总是会发生碰撞,那么由此对应的链表结构也会越来越长,这个时候如果再想要进行查询操作,就会非常耗时,所以该如何优化这一点就是 1.8 版本想要实现的<br>1.8 版本采用了 数组 + 链表 + 红黑树 的方式去实现,当链表的长度大于 8 时,就会将链表转为红黑树.</font></p><p><font face="华文中宋" size="3">这个时候问题就来了,为什么会将链表转红黑树的值设定为 8 ?<br>这个问题我们或许可以从源码中窥探一二:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution </span><br><span class="line">with a parameter of about <span class="number">0.5</span> on average <span class="keyword">for</span> the <span class="keyword">default</span> resizing threshold of <span class="number">0.75</span>, although </span><br><span class="line">with a large variance because of resizing granularity. Ignoring variance, the expected </span><br><span class="line"><span class="function">occurrences of list size k <span class="title">are</span> <span class="params">(exp(<span class="number">-0.5</span>)</span> * <span class="title">pow</span><span class="params">(<span class="number">0.5</span>, k)</span> / <span class="title">factorial</span><span class="params">(k)</span>). </span></span><br><span class="line"><span class="function">The first values are:</span></span><br><span class="line"><span class="function">      0:    0.60653066</span></span><br><span class="line"><span class="function">      1:    0.30326533</span></span><br><span class="line"><span class="function">      2:    0.07581633</span></span><br><span class="line"><span class="function">      3:    0.01263606</span></span><br><span class="line"><span class="function">      4:    0.00157952</span></span><br><span class="line"><span class="function">      5:    0.00015795</span></span><br><span class="line"><span class="function">      6:    0.00001316</span></span><br><span class="line"><span class="function">      7:    0.00000094</span></span><br><span class="line"><span class="function">      8:    0.00000006</span></span><br><span class="line"><span class="function">      more: less than 1 in ten million</span></span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">为什么将链表转为红黑树,而不是平衡二叉树( AVL 树)呢?</font></p><ul><li><font face="华文中宋" size="3">因为 AVL 树比红黑树保持着更加严格的平衡, AVL 树中从根到最深叶的路径最多为 <code>1.44lg(n + 2)</code> ,红黑树中则最多为 <code>2lg( n + 1)</code> ,所以 AVL 树查找效果会比较快,如果是查找密集型任务使用 AVL 树比较好,相反插入密集型任务,使用红黑树效果就比较 nice</font></li><li><font face="华文中宋" size="3">AVL 树在每个节点上都会存储平衡因子</font></li><li><font face="华文中宋" size="3">AVL 树的旋转比红黑树的旋转更加难以平衡和调试,如果两个都给 O(lgn) 查找, AVL 树可能需要 O(log n) 旋转,而红黑树最多需要两次旋转使其达到平衡</font></li></ul><h1 id="HashMap-为什么是线程不安全的"><a href="#HashMap-为什么是线程不安全的" class="headerlink" title="HashMap 为什么是线程不安全的?"></a><font face="华文中宋" size="3">HashMap 为什么是线程不安全的?</font></h1><p><font face="华文中宋" size="3">HashMap 的线程不安全主要体现在两个方面: 扩容时导致的死循环 &amp; 数据覆盖<br>扩容时导致的死循环,这个问题只会在 1.7 版本及以前出现,因为在 1.7 版本及以前,扩容时的实现,采用的是头插法,这样就会导致循环链表的问题<br>什么时候会触发扩容呢?如果存储的数据,大于 当前的 <code>HashMap 长度( Capacity ) * 负载因子( LoadFactor )</code> 时,就会发生扩容.比如当前容量是 16 , <code>16 * 0.75 = 12</code> ,当存储第 13 个元素时,经过判断发现需要进行扩容,那么这个时候 HashMap 就会先进行扩容的操作<br>扩容也不是简简单单的将原来的容量扩大就完事儿了,扩容时,首先创建一个新的 Entry 空数组,长度是原数组的 2 倍,扩容完毕之后还会再进行 ReHash ,也就是将原 Entry 数组里面的数据,重新 hash 到新数组里面去<br>假设现在有一个 Entry 数组,大小是 2 ,那么当我们插入第 2 个元素时,大于 <code>2 * 0.75</code> 那么此时就会发生扩容,具体如下图:<br><img src="https://img-blog.csdnimg.cn/20201129192459721.jpg#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">扩容完毕之后,因为采用的是头插法,所以后面的元素会放在头部位置,那么就可能会这样:<br><img src="https://img-blog.csdnimg.cn/20201129193144151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3psbF8wNDA1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">刚开始记录的是 <code>A.next = B</code> ,经过扩容之后是 <code>B.next = A</code> ,那么最后可能就是这样了:<br><img src="https://img-blog.csdnimg.cn/20201129193349908.jpg#pic_center" alt="在这里插入图片描述"></font></p><p><font face="华文中宋" size="3">明显看到造成了死循环,比较好的是, 1.8 版本之后采用了尾插法,解决了这个问题<br>还有个问题, 1.8 版本是没有解决的,那就是数据覆盖问题<br>假设现在线程 A 和线程 B 同时进行 put 操作,特别巧的是这两条不同的数据 hash 值一样,并且这个位置数据为 null ,那么是不是应该让线程 A 和 B 都执行 put 操作.假设线程 A 在要进行插入数据时被挂起,然后线程 B 正常执行将数据插入了,然后线程 A 获得了 CPU 时间片,也开始进行数据插入操作,那么就将线程 B 的数据给覆盖掉了<br>因为 HashMap 对 put 操作没有进行加锁的操作,那么就不能保证下一个线程 get 到的值,就一定是没有被修改过的值,所以 HashMap 是不安全的</font></p><h1 id="那既然-HashMap-线程不安全-你给推荐一个安全的"><a href="#那既然-HashMap-线程不安全-你给推荐一个安全的" class="headerlink" title="那既然 HashMap 线程不安全,你给推荐一个安全的?"></a><font face="华文中宋" size="3">那既然 HashMap 线程不安全,你给推荐一个安全的?</font></h1><p><font face="华文中宋" size="3">如果推荐的话,那肯定推荐 ConcurrentHashMap ,说到 ConcurrentHashMap 也有一个比较有趣的事情,那就是 ConcurrentHashMap 的 1.7 版本和 1.8 版本实现也不是很一样<br>在 1.7 版本, ConcurrentHashMap 采用的是分段锁( ReentrantLock + Segment + HashEntry )实现,也就是将一个 HashMap 分成多个段,然后每一段都分配一把锁,这样去支持多线程环境下的访问.但是这样锁的粒度太大了,因为你锁的直接就是一段嘛<br>所以 1.8 版本又做了优化,使用 CAS + synchronized + Node + 红黑树 来实现,这样就将锁的粒度降低了,同时使用 synchronized 来加锁,相比于 ReentrantLock 来说,会节省比较多的内存空间</font></p><p><font face="华文中宋" size="3">HashMap 这块,其实还可以扩展,比如 HashMap 和 HashTable 的区别, ConcurrentHashMap 1.7 版本和 1.8 版本具体的实现,等等等等<br>但是这篇文章已经比较长了,就写到这里吧~<br>感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;如果你是个 Java 程序员,那一定对 HashMap 不陌生,巧的是只要你去面试,大概率都会被问到 HashMap 的相关内容&lt;br&gt;基于此,就总结一篇,争取不让面试官问倒~&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.dynamic-zheng.com/categories/java/"/>
    
    
      <category term="java" scheme="https://www.dynamic-zheng.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>[JVM]来说说垃圾回收怎么样~</title>
    <link href="https://www.dynamic-zheng.com/posts/a228901d.html"/>
    <id>https://www.dynamic-zheng.com/posts/a228901d.html</id>
    <published>2020-11-22T02:55:52.000Z</published>
    <updated>2020-11-22T02:57:22.955Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">JVM 的自动内存管理,让原本应该是开发人员去做的事情,变成了垃圾回收器来做的事情<br><a id="more"></a><br>既然是别人帮忙做的事情,那么可能就不是自己想要的,所以就需要我们了解一下垃圾回收相关的内容</font></p><h1 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a><font face="华文中宋" size="3">引用计数法与可达性分析</font></h1><p><font face="华文中宋" size="3">垃圾回收,垃圾回收,那就是有的内存分配给了一些对象,但是这些对象已经用完了,那么它所占用的内存也就应该该释放掉了,却还没有释放<br>那么,这里就有个问题:该如何确定一个对象用完了呢?<br>其中一种方法就是引用计数法</font></p><p><font face="华文中宋" size="3">引用计数法就是给每个对象添加一个引用计数器,来统计指向该对象的引用个数<br>比如:如果有一个引用,被赋值为某一个对象,那么这个对象的引用计数器就 +1 ,如果一个指向这个对象的引用,被赋值为了其他的值,那么这个对象的引用计数器就 -1 ,这样如果这个对象的引用计数器为 0 ,我们就可以认为这个对象已经使用完毕,它所占用的内存空间可以回收掉了<br>这种方案听上去无懈可击,但是有一个致命的漏洞,就是没办法处理循环引用的问题<br>比如说: A 和 B 互相引用,除此之外也没有其他的引用指向 A 或者 B ,在这种情况下,其实 A 和 B 所占用的内存就可以释放掉了,但是因为它们互相都有引用,所以此时的引用计数器并不为 0 ,在这种情况下,就不能对它们进行回收<br>现在只是两个对象,如果再来两个,再来两个,这样循环引用的对象多了之后,就会造成内存泄露</font></p><p><font face="华文中宋" size="3">基于引用计数法的弊端,当前 JVM 主流的垃圾回收器采取的是可达性分析算法<br>这个算法本质就是将一系列的 GC Roots 作为初始的存活对象合集( live set ),然后从这个合集出发,探索所有能够被该集合引用到的对象,并把这些对象加入到集合中来,这个过程就叫做标记( mark ),遍历到最后,没有被探索到的对象就是可以回收的对象<br>那么什么是 GC Roots 嘞?一般包括(但不限于)以下几种:</font></p><ul><li><font face="华文中宋" size="3">Java 方法栈桢中的局部变量</font></li><li><font face="华文中宋" size="3">已加载类的静态变量</font></li><li><font face="华文中宋" size="3">JNI handles</font></li><li><font face="华文中宋" size="3">已启动并且没有停止的 Java 线程</font></li></ul><p><font face="华文中宋" size="3">刚才说因为引用计数法存在循环引用的问题,所以目前主流垃圾回收器选用的都是可达性分析法,也就是说,它解决了循环引用问题,其实这一点也比较好理解,虽然 A 和 B 相互引用,但是这个时候从 GC Roots 开始出发,是没有办法到达 A 和 B 的,那么就不会把它们放到存活对象合集之中,自然也就会被回收掉<br>但是在实际中还是会有问题的,比如:在多线程环境下,就会有其他线程更新已经访问过的对象中的引用,但是是多线程并行的嘛,这个时候可达性分析法已经把这个引用设置成了 null ,或者这个对象还在使用,但可达性分析法把它标记为了没有被访问过的对象,被回收掉了,这种情况可能直接导致 JVM 崩溃掉</font></p><h1 id="Stop-the-world-amp-safepoint"><a href="#Stop-the-world-amp-safepoint" class="headerlink" title="Stop-the-world &amp; safepoint"></a><font face="华文中宋" size="3">Stop-the-world &amp; safepoint</font></h1><p><font face="华文中宋" size="3">既然可达性分析法也有自己的一些缺陷,总得有解决方案吧?比较暴力的一种方法就是 Stop-the-world ,估计听名字也能知道,就是让全世界都停下来,也就是说,在进行垃圾回收的时候,其他所有非垃圾回收线程的工作都需要停下来,先让垃圾回收器工作完毕再说.这就是所谓的暂停时间( GC pause )<br>Stop-the-world 是通过安全点( safepoint )机制来实现的.啥意思嘞?咱先想个场景,现在你敲代码敲的特别开心,又有思路,状态又好,美滋滋的正在工作,突然毫无缘由的就让你现在不准敲代码,你会不会不开心?好不容易思路来了对吧,就一点儿理由都不给的就让我停下,不合理吧?<br>同样的场景,一个线程现在跑的特别 happy ,而且再有一秒钟就完成了任务,这个时候 JVM 收到了 Stop-the-world 请求,二话不说就把所有的线程给停掉,不太好吧?那么这个时候安全点( safepoint )机制就登场了.有了安全点机制,当 JVM 收到 Stop-the-world 请求的时候,它就会等待所有的线程都达到安全点,才允许请求 Stop-the-world 的线程进行独占的工作<br>那么,什么时候是安全点呢?举个例子来说:当 Java 程序通过 JNI 执行本地代码时,如果这段代码不访问 Java 对象,不调用 Java 方法,不返回到原 Java 方法,那么 Java 虚拟机的堆栈就不会发生改变,那这段本地代码就可以作为一个安全点.只要不离开这个安全点, JVM 就可以在垃圾回收的同时,继续运行这段本地代码<br>因为本地代码需要通过 JNI 的 API 来完成上述三个操作,因此 JVM 只需要在 API 的入口处进行安全点检测( safepoint poll ),看看有没有其他线程请求停留在安全点这里,就可以在必要的时候挂起当前线程</font></p><h1 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a><font face="华文中宋" size="3">垃圾回收的三种方式</font></h1><p><font face="华文中宋" size="3">当标记好存活的对象之后,就可以进行垃圾回收了<br>主流的垃圾回收方式,可以分为三种:清除( sweep ),压缩( compact ),复制( copy ).</font></p><p><font face="华文中宋" size="3">清除,就是把死亡对象所占据的内存标记成空闲内存,并把它记录在一个空闲列表( free list )中,当需要新建对象的时候,就直接在空闲列表中寻找空闲内存,划分给新建的对象就完了<br>但是这里会产生一个问题,因为死亡的对象所占据的内存可能是随机的,回收完毕之后,内存就是碎片化的,如果此时有对象申请一块连续的内存空间,尽管碎片化的内存空间是够用的,也没办法进行分配</font></p><p><font face="华文中宋" size="3">压缩,就是把存活的对象聚集到内存区域的起始位置,这样就可以留下一段连续的内存空间.这样去做的话,可以解决内存碎片化的问题,代价就是压缩算法带来的性能开销</font></p><p><font face="华文中宋" size="3">复制,就是把内存区域分成两等分,分别用两个指针 from 和 to 来维护,并且只是用 from 指针指向的内存区域来分配内存.当进行垃圾回收时,就把存活的对象复制到 to 指针指向的内存区域中,并且交换 from 指针和 to 指针的内容.<br>复制这种方式也可以解决内存碎片化的问题,但是它的缺点也是比较明显的,因为把内存区域分成了两等分嘛,那利用率就比较低咯,最高也是 50% 了,不能再高了</font></p><h1 id="垃圾回收在-JVM-中的应用"><a href="#垃圾回收在-JVM-中的应用" class="headerlink" title="垃圾回收在 JVM 中的应用"></a><font face="华文中宋" size="3">垃圾回收在 JVM 中的应用</font></h1><p><font face="华文中宋" size="3">上面说的三种垃圾回收方式是理论上的,那么在 JVM 中是如何应用的呢?<br>这就先要来了解下 JVM 的堆划分<br>大概就是这样子:</font></p><p><img src="/images/2020/内存区域划分.jpg"></p><p><font face="华文中宋" size="3">JVM 将堆划分为新生代和老年代,在新生代中又划分为 Eden 区,还有两个大小相同的 Survivor 区<br>当程序调用 new 指令时,会在 Eden 区中划出一块作为存储对象的内存,但是因为堆空间是线程共享的,所以在这里面划分空间的话就需要同步,要不然出现了两个对象共用一段内存,那不就该打架了嘛<br>JVM 为了避免两个对象打架的事情发生,就让每个线程向 JVM 申请一段连续的内存,来作为线程私有的 TLAB ( Thread Local Allocation Buffer ,对应虚拟机参数 <code>-XX:+UseTLAB</code> ,默认开启的)<br>Eden 区一直进行分配,总有空间分配完毕的时候,该怎么办?此时 JVM 就会触发一次 Minor GC ,来收集新生代的垃圾,存活下来的对象就会被送到 Survivor 区<br>在图中可以看到, Survivor 区有两个,一个是 from ,一个是 to ,其中 to 指向的 Survivor 区是空的</font></p><p><font face="华文中宋" size="3">当发生 Minor GC 时, Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区,然后交换 from 和 to 指针,这样就保证了下一次 Minor GC 时, to 指向的 Survivor 区还是空的<br>同时 JVM 会记录 Survivor 区的对象一共被来回复制了几次,如果一个对象被复制的次数为 15 (对应虚拟机参数 <code>-XX:+MaxTenuringThreshold</code> ),这个对象就会被晋升( promote )到老年代</font></p><p><font face="华文中宋" size="3">那么在发生 Minor GC 时,采用哪种垃圾回收方式会比较好一些呢?采用复制方式,也就是 标记-复制 算法会好一些.为什么呢?因为在新生代中,大部分的 Java 对象只存活一小段时间,那么我们就可以采用耗时比较短的垃圾回收算法,让大部分的垃圾都能在新生代被回收掉.使用 标记-复制 算法的话,理想情况下就是 Eden 区中的对象基本都死亡了,那么需要复制的数据非常少,此时这种算法的优势就被极大的体现了出来</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读~</font></p><p><font face="华文中宋" size="3">参考:<br>极客时间  – 深入拆解 Java 虚拟机</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;JVM 的自动内存管理,让原本应该是开发人员去做的事情,变成了垃圾回收器来做的事情&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[JVM] JVM 是如何加载 Java 类的?</title>
    <link href="https://www.dynamic-zheng.com/posts/743ef9a0.html"/>
    <id>https://www.dynamic-zheng.com/posts/743ef9a0.html</id>
    <published>2020-11-15T06:48:13.000Z</published>
    <updated>2020-11-22T03:03:41.247Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">看到这个题目的时候,你可能就会觉得,这不是挺简单的一个问题么<br><a id="more"></a><br>如何加载?不就是 加载,链接,初始化 这三步嘛,说白了不就是类加载过程么<br>那么,你知道这三步具体又做了什么嘛?这就是本篇文章想要写的</font></p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a><font face="华文中宋" size="3">加载</font></h1><p><font face="华文中宋" size="3">加载的过程,就是查找字节流,并根据查找到的字节流来创建类的一个过程<br>Java 语言的类型可以分成两大类:基本类型和引用类型.基本类型就是由 JVM 预先定义好的,所以也就没有查找字节流这一说了<br>对于引用类型来说的话,又可以细分为四种:类,接口,数组类和泛型参数.因为泛型参数在编译过程中会被擦除,所以在 JVM 中就只有前三种.而数组类又是由 JVM 直接生成的,所以查找字节流的话,就只有类和接口了.</font></p><p><font face="华文中宋" size="3">那么 JVM 是怎么查找字节流的呢?如果你对这块内容比较熟的话,应该就能想起来类加载器,它主要有四类: 启动类加载器,扩展类加载器,应用程序类加载器和用户自定义类加载器<br>这块又有个知识点就是双亲委派机制:大概就是如果一个类加载器收到了类加载的请求,首先不会自己去加载这个类,而是把这个请求委派给父类加载器去完成.通过双亲委派机制就能保证同样一个类只被加载一次<br>经过类加载器之后,这个类就算是加载进来了</font></p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a><font face="华文中宋" size="3">链接</font></h1><p><font face="华文中宋" size="3">链接这块又分为三部分:验证,准备,解析</font></p><p><font face="华文中宋" size="3">验证阶段就是想要看看 class 文件的前 8 位是不是 java 标识符,想看看符不符合规范什么的</font></p><p><font face="华文中宋" size="3">准备阶段就是给静态字段分配内存.除了分配内存之外,部分 JVM 还会在此阶段构造其他跟类层次相关的数据结构,比如说用来实现虚方法的动态绑定的方法表<br>在 class 文件被加载到 JVM 之前,这个类没办法知道其他类和方法,字段所对应的具体地址,甚至都不知道自己的方法,字段的地址,所以如果需要引用这些成员时, Java 编译器就会生成一个符号引用,在运行阶段,这个符号引用一般都可以准确的定位到具体目标上</font></p><p><font face="华文中宋" size="3">解析阶段主要就是将符号引用解析成实际引用.如果符号引用指向一个未被加载的类,或者没有被加载类的字段或方法,此时解析阶段就会触发这个类的加载(但不一定会触发这个类的链接以及初始化)</font></p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><font face="华文中宋" size="3">初始化</font></h1><p><font face="华文中宋" size="3">在 Java 代码中,如果想要初始化一个静态字段,可以在声明的时候直接赋值,也可以选择在静态代码块中对它赋值<br>如果直接赋值的静态字段被 final 修饰了,而且这个静态字段是基本类型或者字符串时,就会被 Java  编译器标记成常量值,初始化就直接被 JVM 完成了.除此之外的直接赋值操作,还有所有静态代码块中的代码,就会被 Java 编译器放到同一个方法中,并且把它命名为 <code>&lt;clinit&gt;</code><br>类加载的最后一步就是初始化,就是给标记为常量值的字段赋值,执行 <code>&lt;clinit&gt;</code> 方法的过程.这个时候 JVM 会通过加锁来确保类的 <code>&lt;clinit&gt;</code> 方法只被执行一次<br>至此, JVM 成功的加载了 Java 类</font></p><h1 id="类的初始化何时会被触发"><a href="#类的初始化何时会被触发" class="headerlink" title="类的初始化何时会被触发?"></a><font face="华文中宋" size="3">类的初始化何时会被触发?</font></h1><p><font face="华文中宋" size="3">那么,类的初始化什么时候会被触发呢?<br>JVM 规范列举了以下几种触发情况:<br>1 , 当虚拟机启动时,初始化用户指定的主类;<br>2 ,当遇到用以新建目标类实例的 new 指令时,初始化 new 指令的目标类;<br>3 ,当遇到调用静态方法的指令时,初始化该静态方法所在的类;<br>4 ,当遇到访问静态字段的指令时,初始化该静态字段所在的类;<br>5 ,子类的初始化会触发父类的初始化;<br>6 ,如果一个接口定义了 default 方法,那么直接实现或者间接实现该接口的类的初始化,会触发该接口的初始化;<br>7 ,使用反射 API 对某个类进行反射调用时,初始化这个类;<br>8 ,当初次调用 MethodHandle 实例时,初始化该 MethodHandle 指向的方法所在的类</font></p><h1 id="再谈-双亲委派机制"><a href="#再谈-双亲委派机制" class="headerlink" title="再谈 双亲委派机制"></a><font face="华文中宋" size="3">再谈 双亲委派机制</font></h1><p><font face="华文中宋" size="3">在上面类加载机制那块,提了一下双亲委派机制<br>我觉得之所以有这样的机制,就是为了避免资源的浪费.上面的双亲委派机制我们在现实中也可以找到例子,比如说:公司部门有位程序员 A 发现如果做一个数据系统的话,来把公司各部门的数据打通,这样就可以减少很多交流成本,那么他可能就会和老大去说,申请去做这个系统,如果老大发现这个完全可以写成公共系统啊,就会对 A 说,这个系统我来做就可以了(公共内容父类加载器进行加载),那如果老大发现不太适合做成公共系统,就会对 A 说,想做就去做吧(父类不进行加载时,子类才进行加载)巧的是,程序员 B 也发现了,他也去找老大说,这个时候老大会说什么呢?这个事情 A 去做了,就不用太担心了(同样一个类只加载一次)<br>那如果程序员 A 和 B 发现了之后没有和老大交流,都自己闷头去做了,这样的话,同样的系统做了两遍,还浪费了两个人的时间精力,由此造成的资源浪费太大了<br>我觉得双亲委派的机制类似于这样,因为这个机制的存在,让资源浪费的现象大大减少了</font></p><p><font face="华文中宋" size="3">但是 tomcat 打破了这种机制,这怎么说?<br>我们都知道 tomcat 是个 web 容器,那么它应该:</font></p><ul><li><font face="华文中宋" size="3">支持部署两个应用程序,不同的应用程序可能会依赖同一个第三方类库的不同版本,就比如两个应用程序,其中一个依赖的是一个类库的 v1.0 ,另外一个依赖的是同样一个类库的 v2.0 ,那么 tomcat 是不是应该允许这个类库的 1.0 和 2.0 版本都存在?</font></li><li><font face="华文中宋" size="3">部署在同一个 web 容器中相同的类库相同的版本是应该可以共享的.就比如,服务器上有 100 个应用程序,这些程序依赖的都是相同的类库,那 tomcat 总不能把这 100 份相同的类库都加载到虚拟机里面去吧,要是非要加载进去,那服务器不得分分钟炸了</font></li><li><font face="华文中宋" size="3">web 容器需要支持 jsp 文件的修改,也就是说,当程序运行之后,我对 jsp 文件进行了修改,那么 tomcat 是不是也应该支持?如果不支持的话,那我修改一次就不能用了,不合适吧?</font></li></ul><p><font face="华文中宋" size="3">基于上面三点,就能看到 tomcat 其实是打破了双亲委派机制的<br>比如第一个问题,第三方类库就是同样一个资源,在双亲委派机制中,同样一个资源是不应该加载两次的,但是在 tomcat 里面却被允许了;但是第二个问题好像又在说双亲委派的机制,正是因为双亲委派机制的存在,所以第二个问题就不是问题了嘛;第三个问题又打破了双亲委派机制,因为如果不打破的话,原来的 jsp 文件已经加载进来了,现在对它进行了修改,那么应该还会加载原来的 jsp 文件,这样的话修改岂不是无效了?<br>所以, tomcat 打破了双亲委派机制,但并不是完全打破</font></p><p><font face="华文中宋" size="3">至于 tomcat 打破双亲委派的机制,我还没搞懂,等我搞懂了再来写吧<br>或者你搞懂了嘛?给我讲讲~</font></p><p><font face="华文中宋" size="3">参考: 极客时间 – 深入拆解 Java 虚拟机</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;看到这个题目的时候,你可能就会觉得,这不是挺简单的一个问题么&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.dynamic-zheng.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>[MySQL]是不是 redo log 和 binlog 傻傻分不清楚?</title>
    <link href="https://www.dynamic-zheng.com/posts/42d9f222.html"/>
    <id>https://www.dynamic-zheng.com/posts/42d9f222.html</id>
    <published>2020-11-08T11:44:45.000Z</published>
    <updated>2020-11-08T11:53:25.331Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">在 MySQL 中,特别是存储引擎使用的是 InnoDB 时,那肯定绕不过去两个概念: redo log (重做日志) 和 binlog (二进制日志)<br><a id="more"></a><br>简单点儿说: redo log 是 InnoDB 存储引擎层方面的日志,所以如果你使用的存储引擎不是 InnoDB 的话,那就根本谈不上 redo log<br>binlog 是 MySQL Server 层记录的日志,所以不管是用的什么存储引擎,只要是 MySQL 都是会有 binlog 的存在,在做 MySQL 主从复制的时候,利用的就是 binlog<br>那么,你有疑问嘛?为什么要有 redo log 和 binlog ,只用一个 log 不可以嘛?<br>咱们详细来看看它们都分别做了啥</font></p><h1 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a><font face="华文中宋" size="3">redo log</font></h1><p><font face="华文中宋" size="3">为什么要有 redo log ?<br>我们可以这样想,如果没有 redo log 的话, MySQL 是如何进行工作的<br>查询还好说,毕竟只是查询一下记录而已,并没有对数据进行更改<br>那如果是增加和更新操作呢?现在一条 update 语句过来,后面是不是一定会有限定条件,就比如现在要更新一条记录,把 A 的银行卡余额更新到 1k ,那这条语句是不是应该来个限定条件,类似 <code>where userName = &#39;A&#39;</code> ,也就是说,一般 update 操作都伴随着查询的操作,得先找到这个人,然后再进行更新操作对吧<br>如果数据量比较小还好,很快就能找到并且更新完毕<br>但是如果数据量比较大,里面有一亿条数据,怎么办?而且更新操作肯定是要写到磁盘上去的,那这中间的 IO 成本呢?如果我有好几十条 update 语句先后更新呢?这样想的话,你就能想到,就这些操作,成本就高的不行,那能不能降低一下这些成本呢?</font></p><p><font face="华文中宋" size="3">这就是 redo log 的作用<br>就是当有一条记录更新的时候, InnoDB 引擎就会先把记录写到 redo log 里面去,同时更新内存,这样就算是更新这条数据成功了<br>但是此时,它并没有更新到磁盘上去对吧?别担心, InnoDB 会在恰当的时候,把这条及记录更新到磁盘上去<br>这样的思想或者技术,有个专有名词: WAL 技术,也就是 WriteAheadLogging ,核心就是先写日志,再写磁盘</font></p><p><font face="华文中宋" size="3">同样,这里面有个问题<br>redo log 不能一直写吧?如果更新操作一直写入到 redo log 中的话,不限制大小的话,可能服务器上的存储空间都被 redo log 给占满了<br>所以 InnoDB 的 redo log 是固定大小的,比如我们配置了一组 4 个文件,每个文件大小是 1GB ,那么它的操作可能就会这样:</font></p><p><img src="/images/2020/mysql.jpg"></p><p><font face="华文中宋" size="3">能够看到,主要就是 write pos 和 checkpoint , write pos 比较好理解,它就是当前记录的位置,有需要记录的操作就从当前位置向后移,等把 ib_logfile_3 写完之后,就回到 ib_logfile_0 文件开头继续写<br>checkpoint 是当前要擦除的位置,就是 InnoDB 引擎不是会在恰当的时候,将这些操作进行持久化,更新到磁盘上去,那持久化之后的数据是不是就可以擦除了<br>write pos 和 checkpoint 之间的部分就是可以用来记录操作的部分,那么如果 write pos 和 checkpoint 相遇了怎么办?相遇了是不是说明这个时候分配的 redo log 大小用完了,那这时候就不能再进行更新操作了,必须停下来处理一下,将 checkpoint 往前推推才行</font></p><p><font face="华文中宋" size="3">就是因为有了 redo log ,所以 InnoDB 才可以保证即使数据库发生了异常重启,也没关系,之前提交的记录都还在,只需要根据 redo log 里面的记录进行相应恢复就可以了<br>所以如果你和 DBA 比较熟的话,可以问问,咱们的 MySQL 是不是可以恢复到半个月内任意一秒的状态,如果对方回答是,别怀疑,他真的不是在吹牛逼</font></p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a><font face="华文中宋" size="3">binlog</font></h1><p><font face="华文中宋" size="3">binlog 是 MySQL Server 层的记录日志,这块举个例子来说吧</font></p><p><font face="华文中宋" size="3">在说之前,我们要明白 redo log 和 binlog 的区别:</font></p><ul><li><font face="华文中宋" size="3">redo log 是 InnoDB 引擎特有的, binlog 是 MySQL 的 Server 层实现的,所有的引擎都是可以的</font></li><li><font face="华文中宋" size="3">redo log 是物理日志,记录的是”在 XXX 页上做了 XXX 修改”; binlog 是逻辑日志,比如” 给 id = 2 这一行的 c 字段加 1”</font></li><li><font face="华文中宋" size="3">redo log 是有固定大小的,所以它的空间会用完,如果用完的话,一定要进行一些写入磁盘的操作才可以继续; binlog 是可以追加写入的,也就是 binlog 没有空间的概念,一直写就行了</font></li></ul><p><font face="华文中宋" size="3">理解了它们之间区别之后,我们拿一个更新操作来举例<br>我现在要给 <code>id = 2 这一行的 c 字段加 1</code> ,到 MySQL 层面,它是如何去做的呢?<br>首先,会先找到这条 <code>id = 2</code> 的数据,然后找到 c 字段进行加 1 操作,这个时候,引擎会将这行数据更新到内存中,同时把这个更新操作记录到 redo log 里面,这个时候 redo log 处于 prepare 状态,随后执行器生成这个操作的 binlog ,并且把 binlog 写入到磁盘完成之后,执行器调用引擎的提交事务接口,引擎把刚刚写入的 redo log 从 prepare 状态改成 commit 状态,这样更新操作才算完成</font></p><h1 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><font face="华文中宋" size="3">两阶段提交</font></h1><p><font face="华文中宋" size="3">在上面的描述中,你能发现 redo log 竟然是先 prepare 状态,等 binlog 写完之后,才是 commit 状态,这种方式就叫”两阶段提交”<br>为什么会有这种方式呢?<br>redo log 和 binlog 都可以用于表示事务的提交状态,而两阶段提交就是让这两个状态保持逻辑上的一致</font></p><p><font face="华文中宋" size="3">可以假设一下,如果不采用这种方式,而是就先写 redo log ,再写 binlog ,会怎样?<br>如果在写 binlog 时,发生了异常,更新操作已经到 redo log 中了,但是此时 binlog 并没有进行更新,是不是出现了数据不一致?<br>先写 binlog 再写 redo log 也是一样<br>所以,在写时,先让 redo log 处于 prepare 状态,等 binlog 写完之后,再让 redo log 处于 commit 状态,这样就保持了逻辑上的一致</font></p><p><font face="华文中宋" size="3">以上,非常感谢您的阅读哇~</font></p><p><font face="华文中宋" size="3">参考<br>极客时间 – MySQL 实战 45 讲</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;在 MySQL 中,特别是存储引擎使用的是 InnoDB 时,那肯定绕不过去两个概念: redo log (重做日志) 和 binlog (二进制日志)&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://www.dynamic-zheng.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[项目]在 swagger 界面实现 token 验证</title>
    <link href="https://www.dynamic-zheng.com/posts/e23cc848.html"/>
    <id>https://www.dynamic-zheng.com/posts/e23cc848.html</id>
    <published>2020-10-30T15:43:16.000Z</published>
    <updated>2020-10-30T15:46:13.094Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">我先说下背景:我最近不是换了家公司工作,然后这家公司就是不管发什么请求都是需要带着 token 信息的,也就是说,比如现在我写好代码了,想要验证我写的代码对不对,咱们现在用的都是 springboot , springcloud 框架,写完了直接在 swagger 界面上进行调试就 OK 了,但是现在不管什么请求都要携带 token 信息,默认的 swagger 配置是没有的<br><a id="more"></a><br>我在上家公司的时候,当时的权限部门帮我们都做好了 token 验证,只要是能够进入到我们系统的用户,那就是有权限的,所以当时的项目直接在 swagger 界面上进行测试就 OK 了<br>我刚接手项目熟悉的时候,想要测试一下请求, swagger 上没办法添加 token 信息,所以我就得用 postman 去测</font></p><p><font face="华文中宋" size="3">对我来说是有点儿难受的,你想想,我以前就是写好了接口,启动项目,去 swagger 项目上一测试,没问题提交代码完事儿,有问题我就可以直接进行调试<br>现在使用 postman 测试没问题还好,有问题的话, token 不知道怎么添加进去,感觉就是明明可以直接使用 swagger 的,现在要再进行一个第三方 postman ,就感觉用的不是很顺手嘛</font></p><p><font face="华文中宋" size="3">所以我就想,能不能在 swagger 上直接就可以添加上 token 信息,这样的话,我就不需要再借助第三方工具 postman 了<br>一倒腾还真的让我给搞成功了</font></p><p><font face="华文中宋" size="3">swagger 整合细节我就不说了,这里主要就是 swagger 启动那里需要设置,具体代码:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Docket <span class="title">controllerApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加 head 参数配置 start</span></span><br><span class="line">    ParameterBuilder token = <span class="keyword">new</span> ParameterBuilder();</span><br><span class="line">    List&lt;Parameter&gt; pars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    token.name(<span class="string">"Authorization"</span>).description(<span class="string">"token 信息"</span>).modelRef(<span class="keyword">new</span> ModelRef(<span class="string">"String"</span>))</span><br><span class="line">            .parameterType(<span class="string">"header"</span>).required(<span class="keyword">false</span>).build();</span><br><span class="line">    pars.add(token.build());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .enable(enable)</span><br><span class="line">            .apiInfo(<span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                    .title(projectName + <span class="string">"接口文档"</span>)</span><br><span class="line">                    .description(projectDesc + <span class="string">""</span>)</span><br><span class="line">                    .license(<span class="string">"郑璐璐 csdn"</span>)</span><br><span class="line">                    .licenseUrl(<span class="string">"https://blog.csdn.net/zll_0405"</span>)</span><br><span class="line">                    .version(version)</span><br><span class="line">                    .build())</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(basePackage))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            <span class="comment">// 注意一下 globalOperationParameters 这行配置</span></span><br><span class="line">            .globalOperationParameters(pars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">OK ,添加好上面的代码之后,再启动就能在 swagger 界面上看到下面的改动了:</font></p><p><img src="/images/2020/token.png"></p><p><font face="华文中宋" size="3">在图中红框框的地方,输入 token 信息,然后执行一下,你就会发现,使用 swagger 我又可以了,哈哈哈</font></p><p><font face="华文中宋" size="3">注意:给出的代码只是一个小 demo ,具体信息请根据自己的项目信息去配置<br>以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;我先说下背景:我最近不是换了家公司工作,然后这家公司就是不管发什么请求都是需要带着 token 信息的,也就是说,比如现在我写好代码了,想要验证我写的代码对不对,咱们现在用的都是 springboot , springcloud 框架,写完了直接在 swagger 界面上进行调试就 OK 了,但是现在不管什么请求都要携带 token 信息,默认的 swagger 配置是没有的&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[碎碎念]是的,我换了家公司工作</title>
    <link href="https://www.dynamic-zheng.com/posts/83a68896.html"/>
    <id>https://www.dynamic-zheng.com/posts/83a68896.html</id>
    <published>2020-10-25T05:59:50.000Z</published>
    <updated>2020-10-25T06:02:41.935Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">最近我在忙着换公司工作的事情,虽然平时也一直在学习 &amp; 输出,也一直在尽力把自己写的文章系统化,但是去面试还是要好好准备的,所以各位读者可能也感受到了,最近这两周的文章质量都不是很高,毕竟我的时间精力都在那里嘛<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">经过最近的面试之后,有些感受,在这里写写,如果对你能够有所帮助的话,那可真是太好了</font></p><p><font face="华文中宋" size="3">1 ,自己简历上的东西,既然写了熟悉或者精通,那就一定要能够达到那样的层次<br>面试官面试的时候,都是根据你的简历来问你的,所以一定要对自己的简历负责.如果写了精通,那就一定要有对应的深度<br>因为我上家公司是做在线教育方面的,我负责的主要业务就是学生考试,并发量什么的都是比较多的,那最好就是使用多线程去处理啦,所以我对多线程这块就很熟悉,如果面试的话,不问那就算了,只要一问这块就是我的亮点<br>那么你肯定就会问了,什么程度算是精通呢,什么算是熟练使用呢,什么算是熟悉呢<br>我觉得精通的话,那肯定是不管这方面问你什么问题都是问不倒的.比如你说你精通多线程这块内容是吧,那么多内容,别的咱先别问,就问个 synchronized 关键字,它的锁膨胀是怎样的呢,你是怎么判断当前是有锁状态,无锁状态的, synchronized 后来做了优化,具体优化是什么呢,提到 synchronized 的话,它和 ReentrantLock 有什么区别? ReentrantLock 又是基于 AQS 实现的,又能说出来多少.我觉得如果这些问题都没问住你的话,那么你说你精通,我是相信的.<br>熟练使用的话,就需要你达到出现了问题知道怎么解决,比如你说你熟练使用 mysql , OK ,那现在有个 sql 语句执行特别慢,如果是你的话,你会怎么处理呢,其中的几个关键参数也是能够说出来的;你说你熟练使用 Linux 命令,那么我想要查看日志,想要查看特定进程,是不是都应该答上来<br>熟悉的话,我觉得就是一个你知道的层次,比如你说你熟悉 GC 算法,那 标记清除/标记复制/标记整理 优缺点,适用于新生代还是老年代就应该答出来<br>所以简历上如果写了精通,那就一定要有对应的深度;如果写了熟悉,那一些基本的知识应该能够答上来的</font></p><p><font face="华文中宋" size="3">2 ,如果面试官问了你不会的内容,那就坦白说自己不会<br>说来比较愧疚,虽然一直在用 ssm, springboot, springcloud 这些框架,但是 spring 源码我还没读过,一直都处在使用的层面<br>当时面试的时候,面试官就问我有没有阅读过 spring 的源码,我就很坦白的说,我没有阅读过,只是一直在用,面试官也就没有继续追问下去<br>如果我当时为了装逼说我阅读过源码的话,那估计被吊打的就是我了</font></p><p><font face="华文中宋" size="3">3 ,如果你面了几家公司,后续都没有了消息,别怀疑自己,只是职位不匹配而已<br>我当时在找工作的时候,恰好另外一位朋友也在找工作,所以我俩那时候交流就比较多嘛<br>然后他面了有十几家公司了,面到最后都没有了后话,那段时间他就一直问我,是不是自己不够好,是不是自己不够优秀.有一说一,我那位朋友技术上比我厉害是真的,所以我就安慰他,没事儿的,再面面,说不定下家公司就要你了呢<br>结果现在他手上有好几个 offer ,在愁去哪家公司比较好.<br>所以在面试的过程中,如果面了几家,几十家公司,还没收到一份 offer ,别怀疑自己,真的<br>这就像你去超市买东西一样,怎么那么多东西不拿,就拿快乐肥宅水呢,无他,只是匹配你的需求而已.那其他的就不好么?不是,只是目前还没有遇到买家而已<br>找工作也是这样,可能只是你的技术栈和对方不匹配,但总会有一家公司的技术栈和你是匹配的对吧,别灰心,继续努力就行</font></p><p><font face="华文中宋" size="3">4 ,面试过程中,不要怕,展示你自己就可以了<br>我记得我当时投简历的时候,想要换个领域去看看嘛,毕竟世界那么大<br>我就投了一家区块链公司,说真的,区块链公司和我目前接触的领域,差别太大了.我目前接触的领域,一天的数据量最多也就几百万数据,这还是最多的,但是我去面的那家区块链公司,数据量都已经达到了 T 级别<br>而且大家应该也都知道,很小的一个问题,当数据量非常大的时候,那么这个小问题可能就是一个大问题.比如现在要往数据库里面插入一条数据,插入之前先看看数据库中有没有,如果有的话,那就直接更新,如果没有再做插入<br>如果我来做的话,那就直接一个 if else 就完了,但是面试官说,如果直接 if else 的话,我现在的数据量就是几个 T ,只是判断数据库中有没有这条数据就可能要花费很多时间<br>就我上面的这个例子,大家也能看到,我接触的领域对于区块链领域来说,是非常不匹配的,当时面试的时候面试官也很坦率,就和我说他们想要的 java 不是我这样的,技术栈不匹配<br>我当时听了面试官这样说,就觉得都这样说了,可能就没有后续了,结果面试官说,但是在面试的整个过程中,我觉得你的性格,沟通能力都是蛮不错的,很适合和我们团队一起做事<br>所以嘞,面试过程中,别怕,哪怕去面试的领域不是自己擅长的领域,那也没啥怕的,会就说,不会就说不会,不懂就向面试官请教,说不定你身上的哪点特质就被面试官相中了呢~</font></p><p><font face="华文中宋" size="3">5,算法和数据结构是真的重要<br>实话实说,我的算法就不是很好,去面试的时候能够感觉到不管是大公司,还是小公司都是挺看重算法的,动不动就让你手写几个算法,真的就是标配了<br>所以面试的话,这块最好还是准备一下</font></p><p><font face="华文中宋" size="3">经过面试之后,发现了自己需要提高的地方还是蛮多的,接下来我就继续努力就完了</font></p><p><font face="华文中宋" size="3">感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;最近我在忙着换公司工作的事情,虽然平时也一直在学习 &amp;amp; 输出,也一直在尽力把自己写的文章系统化,但是去面试还是要好好准备的,所以各位读者可能也感受到了,最近这两周的文章质量都不是很高,毕竟我的时间精力都在那里嘛&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]爬上来说两句</title>
    <link href="https://www.dynamic-zheng.com/posts/78166b12.html"/>
    <id>https://www.dynamic-zheng.com/posts/78166b12.html</id>
    <published>2020-10-18T04:33:30.000Z</published>
    <updated>2020-10-18T04:35:37.284Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">先道个歉,因为上周博客我鸽了,另外我再摸着良心说,尴尬,我没良心<br>这周技术上没啥输入,也就没啥高质量的输出了<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">我最近在准备换家公司工作的事情,所以不管是时间上,还是精力上,都有些不够用,有时候真的恨不得把自己掰成好几个,一个在工作,一个在学习,一个在输出高质量文章,一个在准备面试,一个在面试,哈哈哈</font></p><p><font face="华文中宋" size="3">在交接工作的时候,我才发现原来在过去的时间里我成长了这么多<br>不管是开发,还是运维,还是管理,或是沟通,或是表达,都让我和几年前的自己全然不同<br>不过,能够有这样的我,中间付出了多少,怕是只有自己才知道吧<br>但是付出的东西我不想总是过多的去说,因为这都是我想要付出的,无怨无悔的那种,而且还是非常享受的那种,甘之如始</font></p><p><font face="华文中宋" size="3">我记得面试的时候,面试官问过我接下来的发展,这两天我也在问自己,未来到底是想要成为什么<br>我到现在都没有想清楚,我未来到底是想要成为什么,但是有一点是非常清楚的,就是我喜欢去钻技术,我想让自己的技术沉淀下来,我想通过业务去将我身上的技术价值发挥到最大,我喜欢看着自己写的代码通过网络给一些人带去了一些改变和方便<br>这是我目前享受,乐意去做的事情</font></p><p><font face="华文中宋" size="3">我觉得现在让我去计划五年之后的事情,太难了<br>就像五年前的我,没有想过我会走上编程的道路,成为一个程序媛一样,现在让我去想五年后的事情,我想象不出来<br>我能够想象出来的就是,五年之后的我,肯定比现在的自己,还要优秀.因为我在坚持每天进步一点点~</font></p><p><font face="华文中宋" size="3">就这样吧~主要是自己这周没啥输入,所以废话了好多文字<br>总是写这样的文章,我自己心里感觉也是挺过意不去的,因为我最近总是水文…</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;先道个歉,因为上周博客我鸽了,另外我再摸着良心说,尴尬,我没良心&lt;br&gt;这周技术上没啥输入,也就没啥高质量的输出了&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>[redis]关于 缓存穿透/缓存击穿/缓存雪崩 看这篇文章就够了</title>
    <link href="https://www.dynamic-zheng.com/posts/2d85a910.html"/>
    <id>https://www.dynamic-zheng.com/posts/2d85a910.html</id>
    <published>2020-10-04T09:41:52.000Z</published>
    <updated>2020-10-04T09:45:27.891Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">redis 在项目中用的话,主要就是用作缓存了<br>既然用作缓存,那就肯定会有 缓存穿透/缓存击穿/缓存雪崩 的问题<br>这篇文章就来说说,遇到这种情况时,该如何去处理<br><a id="more"></a></font></p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><font face="华文中宋" size="3">缓存穿透</font></h1><p><font face="华文中宋" size="3">首先咱们搞明白什么是缓存穿透?这三个词这么像,得把概念搞清楚不是<br>其实只是从字面意思上来看的话,大概也能知道一点儿,缓存穿透嘛,就是直接穿过了缓存,将请求打到了数据库上面去<br>一般情况下,去查询数据的话,缓存里面应该都是有的,但是防不住黑客呀,如果黑客请求查询的是数据库里面根本不存在的数据,数据库里面都没有的数据,缓存里面肯定也不会有了,对吧,那么此时请求就会打到咱们的数据库里面去,这就是<strong>缓存穿透</strong><br>你想啊,黑客想要攻击的话,怎么可能只请求一次呢,肯定是大量的请求过来,因为是拿数据库里面不存在的 id 来请求的,那么这些请求毫无疑问直接打到了数据库上面去,那咱们的数据库可能就会因为这些大量的请求直接宕掉</font></p><p><font face="华文中宋" size="3">如何解决呢?<br>咱们回到产生这个问题的场景中,为什么大量的请求会打到数据库上面来?因为缓存里面没有对应的 key 对吧,所以才会越过缓存直接到数据库<br>那么问题就好解决了嘛,缓存里面没有对应的 key ? OK,如果这个 key 数据库里面也没有,那我就在 redis 里面,存上这个 key ,值是 null ,这样如果有查询这个 key 的请求,我直接返回 null 就完事儿了,也就不用打到数据库上面去了<br>注意一下,要记得设置它的过期时间,一般三到五分钟就够了</font></p><p><font face="华文中宋" size="3">但是对方是个黑客呀,可能就用一个 key 去请求么?他可能会在短时间内用大量的 key 来发送请求,那如果一个 key 就在 redis 中存储一个 null 值的话,那么多 key 是不是就会存储那么多个 null 值嘞?<br>这样的话, redis 里面是不是都是值为 null 的了?<br>所以有没有更好的解决办法呢?<br>那必须得有!<br>布隆过滤器,你值得尝试</font></p><p><font face="华文中宋" size="3">什么是布隆过滤器呢?就是它能告诉你,某个值一定不存在或者可能存在( emmmm ,也不知道我有没有说清楚<br>所以可以将数据库的内容缓存一份到布隆过滤器,这样的话,当大量的请求过来的时候,<br> redis 里面没有,没关系,再去布隆过滤器过滤一下,这样请求不用打到数据库上面去,就能确定这个 key 数据库中有没有<br> 这样不就降低了数据库的压力么,可真是个天才~</font></p><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><font face="华文中宋" size="3">缓存击穿</font></h1><p><font face="华文中宋" size="3">缓存击穿说的是,在高并发情况下,如果好多个请求都在查询一个 key ,好巧不巧的是,这个 key 因为某些原因失效了(比如设置的过期时间到了,缓存服务器宕机了),这样就会导致那么多的请求都直接打到数据库上面去了<br>那如果这些请求的数量足够大的话,可能直接把数据库就干掉了</font></p><p><font face="华文中宋" size="3">知道了造成结果的原因,那么寻找解决方案也就好办了<br>不是因为好多个请求打到了数据库嘛,但是它们请求的都只是一个 key ,所以这里可以使用排斥锁来实现,第一个请求达到请求 key 发现缓存里面没有,允许它去数据库查询,同时加锁,这样第二个请求,第三个请求…都会被锁阻塞到当前,不会再打到数据库,这样就减少了数据库的并发压力</font></p><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><font face="华文中宋" size="3">缓存雪崩</font></h1><p><font face="华文中宋" size="3">缓存雪崩,雪崩雪崩嘛,就比较严重,击穿说的是一个 key 失效的情况,雪崩指的是大规模的缓存失效情况的发生,这是有可能发生的,比如说我的缓存服务器宕机了,那是不是直接就大规模的缓存失效了;或者说,我当时为了图省事,好多个 key 设置的过期时间都是一样的,然后刚好在缓存都失效的时候,好多请求不同的 key 过来了</font></p><p><font face="华文中宋" size="3">解决方案的话,其实就不适合使用加锁的方式去解决了,因为这是好多请求不同的 key ,它不是一个嘛<br>而且嘞,咱们是因为好多个 key 设置的过期时间都是一样的,所以解决方案就是,咱们不设置同样的时间让缓存失效了,咱们给一个随机时间,让缓存随机失效,这样的话,大规模的缓存失效情况就减少很多了<br>那还要一种情况呢,就是如果我的缓存服务器直接宕机了,这怎么办?也好弄,来个集群就解决了,这里只是一个解决方案,它的落地实现不是本文重点哈~</font></p><h1 id="再谈-布隆过滤器"><a href="#再谈-布隆过滤器" class="headerlink" title="再谈 布隆过滤器"></a><font face="华文中宋" size="3">再谈 布隆过滤器</font></h1><p><font face="华文中宋" size="3">OK ,你如果看到这里的话,其实这篇文章的内容就说完了<br>但是我感觉布隆过滤器那块,我没有说清楚,所以在这里拿出来详细说一说</font></p><p><font face="华文中宋" size="3">布隆过滤器是一种数据结构,它是一种概率型的数据结构,就是它能告诉你”某样东西一定不存在或者可能存在”<br>唉,你可能会说,这话刚刚不是说过了嘛,本来就挺拗口的,你咋还说<br>还不是因为这句话比较重要,我觉得把这句话理解透彻了,那么对布隆过滤器理解的应该也就到位了</font></p><p><font face="华文中宋" size="3">来,为了形象生动一些,咱们举个例子~<br>布隆过滤器是一个 bit 向量或者说 bit 数组,大概长这样:</font></p><p><img src="/images/2020/布隆过滤器-初始.jpg"></p><p><font face="华文中宋" size="3">现在,我们需要把 “AliPay” 这个字段给存储进去<br>大概的存储过程就是:将要映射的值,使用多个不同的哈希函数生成多个哈希值,然后每个生成的哈希值指向的 bit 置为 1<br>以给的为例,我们现在将 “AliPay” 这个值,通过三个不同的哈希函数进行映射,那么大概就是这样了:</font></p><p><img src="/images/2020/布隆过滤器-第一次映射.jpg"></p><p><font face="华文中宋" size="3">同样,现在我要存储另外一个值 “WechatPay” ,那么可能映射之后就是下面这样:</font></p><p><img src="/images/2020/布隆过滤器-第二次映射.jpg"></p><p><font face="华文中宋" size="3">细心的你可能就会发现, 4 号位置的值,刚开始不是给 “AliPay” 了么,后来 “WechatPay” 也在那里,这样的话,值不就给覆盖掉了嘛<br>嗯,没错,是给覆盖到了</font></p><p><font face="华文中宋" size="3">接下来,我们查询 “Ali” 那么查询之后,布隆过滤器可能会给你 “0,1,2” 的值, 结果呢 “2” 的位置是 0 ,说明没有任何值映射到这个位置上来,所以我们就可以判定数据库里面没有 “Ali” 这个值<br>那我查询 “AliPay” 的话,毫无疑问,肯定会返回给我 “1,4,6” ,那我们能说数据库里面一定有 “AliPay” 么?不能,因为 “1,4,6” 的值有可能被其他的值给映射了,所以我们只能说,数据库里可能存在 “AliPay”<br>这就是布隆过滤器说的”某个值一定不存在或者可能存在”<br>你理解了嘛?(不理解的话,我也就写到这儿了~</font></p><p><font face="华文中宋" size="3">以上,感谢您的阅读哇~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;redis 在项目中用的话,主要就是用作缓存了&lt;br&gt;既然用作缓存,那就肯定会有 缓存穿透/缓存击穿/缓存雪崩 的问题&lt;br&gt;这篇文章就来说说,遇到这种情况时,该如何去处理&lt;br&gt;
    
    </summary>
    
      <category term="redis" scheme="https://www.dynamic-zheng.com/categories/redis/"/>
    
    
      <category term="redis" scheme="https://www.dynamic-zheng.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]面试官:三个线程顺序执行,你来说说有几种实现方式?</title>
    <link href="https://www.dynamic-zheng.com/posts/f0d1ecb0.html"/>
    <id>https://www.dynamic-zheng.com/posts/f0d1ecb0.html</id>
    <published>2020-09-25T13:44:49.000Z</published>
    <updated>2020-09-25T13:46:24.772Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">写在前面:<br>越是基础知识,越要系统<br><a id="more"></a><br>正文开始:</font></p><p><font face="华文中宋" size="3">先说下要求,就是三个线程,假设是线程 1,2,3, 现在的要求是:必须是线程 1 先执行,然后线程 2 再执行,最后是线程 3 执行<br>然后有几种实现方法呢?<br>其实它的本质就是实现,让线程 2,3  等待线程 1 执行完毕,所以重点就是有哪些方法可以让线程 2,3 等待</font></p><h1 id="join"><a href="#join" class="headerlink" title="join"></a><font face="华文中宋" size="3">join</font></h1><p><font face="华文中宋" size="3">第一反应应该就是使用 join 方法,因为 join 本来就是支持这种机制的<br>比如,我在线程 B 中调用了线程 A 的 join 方法,那么线程 B 就会等线程 A 执行结束之后再执行.<br>那么具体应该怎么使用嘞?<br>别慌嘛,我这里有例子,你瞅瞅:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopOne</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(<span class="keyword">null</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t1));</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(t2));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread beforeThread;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(Thread beforeThread)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.beforeThread = beforeThread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果有线程,就 join 进来,没有的话就直接输出</span></span><br><span class="line">            <span class="keyword">if</span> (beforeThread != <span class="keyword">null</span> )&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeThread.join();</span><br><span class="line">                    System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a><font face="华文中宋" size="3">CountDownLatch</font></h1><p><font face="华文中宋" size="3">刚才说了,本质就是让线程 B,C 等待线程 A 执行完毕<br>那么信号量就是一个不错的选择<br>如果想要实现的话,那大概就是下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopTwo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置线程 1 的信号量为 0</span></span><br><span class="line">        CountDownLatch cOne = <span class="keyword">new</span> CountDownLatch(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置线程 2 的信号量为 1</span></span><br><span class="line">        CountDownLatch cTwo = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置线程 3 的信号量为 1</span></span><br><span class="line">        CountDownLatch cThree = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 cOne 为 0 ,故 t1 可以直接执行</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cOne,cTwo));</span><br><span class="line">        <span class="comment">// 线程 t1 执行完毕之后,此时的 cTwo 为 0 , t2 开始执行</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cTwo,cThree));</span><br><span class="line">        <span class="comment">// 线程 t2 执行完毕,此时 cThree 为 0 , t3 开始执行</span></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work(cThree,cThree));</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        CountDownLatch cOne;</span><br><span class="line">        CountDownLatch cTwo;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(CountDownLatch cOne, CountDownLatch cTwo)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.cOne = cOne;</span><br><span class="line">            <span class="keyword">this</span>.cTwo = cTwo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前一个线程信号量为 0 时,才执行</span></span><br><span class="line">                cOne.await();</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 后一个线程信号量减 1</span></span><br><span class="line">                cTwo.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用单个线程池"><a href="#使用单个线程池" class="headerlink" title="使用单个线程池"></a><font face="华文中宋" size="3">使用单个线程池</font></h1><p> <font face="华文中宋" size="3">之所以线程 1,2,3 的执行顺序无法保证,是因为在编译器可能会去做一些优化,导致没有办法按照顺序执行<br> 如果我们使用单个线程池去执行的话,那就没有这样的问题了<br> 具体实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopThree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run one"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run two"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName() + <span class="string">" run three"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 将线程依次加入到线程池中</span></span><br><span class="line">        executor.submit(t1);</span><br><span class="line">        executor.submit(t2);</span><br><span class="line">        executor.submit(t3);</span><br><span class="line">        <span class="comment">// 及时将线程池关闭</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a><font face="华文中宋" size="3">CompletableFuture</font></h1><p><font face="华文中宋" size="3">如果使用 CompletableFuture 来实现的话,代码就非常简洁了</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLoopFour</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Work());</span><br><span class="line"></span><br><span class="line">        CompletableFuture.runAsync(()-&gt; t1.start())</span><br><span class="line">                .thenRun(()-&gt;t2.start())</span><br><span class="line">                .thenRun(()-&gt;t3.start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"thread start : "</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">你还有别的什么方法么?欢迎评论区和我交流~<br>以上,非常感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;写在前面:&lt;br&gt;越是基础知识,越要系统&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[Java 并发]面试官让我手写一个读写锁出来,我...</title>
    <link href="https://www.dynamic-zheng.com/posts/76a7b252.html"/>
    <id>https://www.dynamic-zheng.com/posts/76a7b252.html</id>
    <published>2020-09-18T14:35:25.000Z</published>
    <updated>2020-09-18T14:40:13.781Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">题目是个标题党,主要是想写一下 ReentrantReadWriteLock<br><a id="more"></a></font></p><h1 id="ReentrantReadWriteLock-与-ReentrantLock-区别"><a href="#ReentrantReadWriteLock-与-ReentrantLock-区别" class="headerlink" title="ReentrantReadWriteLock 与 ReentrantLock 区别?"></a><font face="华文中宋" size="3">ReentrantReadWriteLock 与 ReentrantLock 区别?</font></h1><p><font face="华文中宋" size="3">在这篇文章中:  <a href="https://blog.csdn.net/zll_0405/article/details/105927574" target="_blank" rel="noopener">[Java 并发]带你从源码解读 ReentrantLock 就不信还搞不定它!</a>  对 ReentrantLock 已经做了非常详细的讲解了<br>那么,今天想要说的 ReentrantReadWriteLock 和 ReentrantLock 有什么区别呢?如果只是从名字上来说的话,就是多了一个 ReadWrite 嘛<br>如果对 ReentrantLock 比较熟的话,那么我问 ReentrantLock 是独占锁还是共享锁,你的第一反应就是: 独占锁</font></p><p><font face="华文中宋" size="3">ReentrantReadWriteLock 是在 ReentrantLock 的基础上做的优化,什么优化呢? ReentrantLock 就是不管操作是读操作还是写操作都会对资源进行加锁,但是你想想,如果好几个操作都只是读的话,并没有让数据的状态发生改变,这样的话是不是可以允许多个读操作同时运行?这样的话,相对来说是不是就提高了并发<br>很多事情都是说起来容易,具体是怎么实现的呢?<br>啥也不多说,咱们直接上源码好吧</font></p><p><font face="华文中宋" size="3">在使用 ReentrantReadWriteLock 时,一般都是调用 <code>writeLock</code> 和 <code>readLock</code> 两种方法,它在源码中定义如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock  <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">而 <code>writeLock</code> 和 <code>readLock</code> 是 <code>ReentrantReadWriteLock</code> 的两个内部类,其中这两种锁的实现如下(其中省略了一些代码):</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 共享锁</span></span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 共享锁</span></span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 独占锁</span></span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 独占锁</span></span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">从源码就能够看出,对于读锁 <code>readLock</code> 它使用的是共享锁,也就是多个线程读没问题<br>但是对于写锁 <code>writeLock</code> 它使用的是独占锁,就是当一个线程要进行写操作时,其他的线程都要停下来等待<br>简单点儿说就是:一个资源可以被多个读线程访问,或者被一个写线程访问,但是不能同时存在读线程和写线程,这也是读写锁的定义</font></p><h1 id="ReadLock-和-WriteLock-共享一个变量"><a href="#ReadLock-和-WriteLock-共享一个变量" class="headerlink" title="ReadLock 和 WriteLock 共享一个变量"></a><font face="华文中宋" size="3">ReadLock 和 WriteLock 共享一个变量</font></h1><p><font face="华文中宋" size="3">如果让你设计一个读写锁的话,会怎样设计?<br>我还真的认真想了想这个问题,如果让我设计的话,我应该会用两个变量去控制读和写,当线程获取到读锁时就对读变量进行 +1 操作,当获取到写锁时,就对写变量进行 +1 操作<br>但是通过看 ReentrantReadWriteLock 源码发现,它只是通过一个 state 来实现的<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">有两个关键方法 <code>sharedCount</code> 和 <code>exclusiveCount</code> ,乖,光是从名字意思来看应该也是可以猜出来的吧: <code>sharedCount</code> 就是共享锁的数量,而 <code>exclusiveCount</code> 则是独占锁的数量<br>通过看源码,能够看出来,对于 <code>sharedCount</code> 来说,它的计算方式就是无符号右移 16 位,空位都以 0 来补齐( <code>c &gt;&gt;&gt; SHARED_SHIFT;</code> )<br>对于 <code>exclusiveCount</code> 来说,它的计算方式就是将传进来的 c 和 <code>EXCLUSIVE_MASK</code> 做 “&amp;” 运算,那么 <code>EXCLUSIVE_MASK</code> 的值是什么呢?就是 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> ,如果对位运算比较熟的话,应该会很容易看出来 <code>(1 &lt;&lt; SHARED_SHIFT) - 1</code> 的值就是 65535 ,化成二进制就是 16 个 1,传进来 c 的值,和 16 位全为 1 做 “&amp;” 运算的话,只有 <code>1 &amp; 1</code> 才为 1 ,也就是说,传进来的 c 值经过这样转换之后,还是原来的值</font></p><p> <font face="华文中宋" size="3">说到这里,可能有点儿懵了,没关系,咱们来个总结就好说了(为了好理解,我就用大白话说了,争取各位都能看懂<br> 对于 <code>sharedCount</code> 来说,只要传进来的值不大于 65535 ,那么经过计算之后,值都是 0<br> 对于 <code>exclusiveCount</code> 来说,传进来的值是多少,经过计算之后还是多少<br> 不管是 <code>sharedCount</code> 还是 <code>exclusiveCount</code> ,最大值都是 65535 ,因为是和 16 做位运算,其实这个数字也是相当够用了<br> 那么,看到这里,各位应该就比较了解了吧,对于 <code>ReadLock</code> 和 <code>WriteLock</code> 来说,在源码层次其实并不是用两个变量去做的,而是通过一个 state 来实现的,思路真的是非常的巧妙</font></p><p><font face="华文中宋" size="3">对于我上面说的,如果还是不清楚的话,可以自己写个 demo 去验证一下,很简单的,就比如下面这样:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shareCount = <span class="number">3000</span> &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    System.out.println(<span class="string">"shareCount : "</span> + shareCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> exclusiveCount = <span class="number">1</span> &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">"exclusiveCount : "</span> + exclusiveCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">等你运行完之后,你就发现,哇,怎么和我说的一样,哈哈哈哈<br>对于 <code>sharedCount</code> 来说,它是针对读锁的,所以不管多少进程进行读取资源,都没关系,所以它的值就是 0<br>对于 <code>exclusiveCount</code> 来说,它是针对写锁的,那么只要有一个进程在进行写入,其他线程都要停下来等待,所以它的值就是传进来的值<br>综上,使用一个状态的话,我们只需要去判断这个状态是否是 0 就可以了</font></p><h1 id="WriteLock-的具体实现"><a href="#WriteLock-的具体实现" class="headerlink" title="WriteLock 的具体实现"></a><font face="华文中宋" size="3">WriteLock 的具体实现</font></h1><p><font face="华文中宋" size="3">OK ,既然你都看到了这里,我就默认上面的内容你都理解了<br>WriteLock 说白了就是独占锁,所以在获取 WriteLock 时,不能只考虑是否有写锁在占用,还要考虑有没有读锁.接下来咱们就去探究一下, WriteLock 它具体是怎么实现的</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取到锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 获取写锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c != 0 说明有读锁/写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// w == 0 说明此时没有写锁,有读锁 或者 持有写锁的线程不是当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果写锁数量超出了最大值,没啥说的,抛异常就完事儿了</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        <span class="comment">// 当前线程持有写锁,为重入锁,直接 +acquires 即可</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// CAS 操作,确保修改值成功</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">如果对 ReentrantLock 比较熟的话,你会发现,上面的代码大部分都是见过的<br>有一点区别就是调用了 <code>exclusiveCount</code> 方法,看当前是否有写锁存在,接下来通过 <code>c != 0 and w == 0</code> 判断了当前是否有读锁存在</font></p><h1 id="ReadLock-的具体实现"><a href="#ReadLock-的具体实现" class="headerlink" title="ReadLock 的具体实现"></a><font face="华文中宋" size="3">ReadLock 的具体实现</font></h1><p><font face="华文中宋" size="3">WriteLock 探究完了,接下来瞅瞅 ReadLock ,话不多说,直接上源码</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写锁不等于 0 时,看看当前写锁是否在尝试获取读锁</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 读锁不需要阻塞,而且读锁需要小于最大读锁数量,同时 cas 操作进行加 1 操作</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// 当前线程是第一个并且第一次获取读锁时</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程再次获取读锁,则直接进行 ++ 操作即可</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是第一个获取读锁的线程,就放入线程本地变量</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">看完有没有觉得和写锁那块挺像的,不同就在于因为是读锁嘛,所以只要没有写锁占用,而且读锁的数量没有超过最大的获取数量,就都可以获取读锁<br>在上面, <code>firstReader</code>  <code>firstReaderHoldCount</code>  <code>cachedHoldCounter</code> 都是为 <code>readHolds</code> 服务的,它是为了获取当前线程持有锁的数量,在 <code>ThreadLocal</code> 基础上添加了 Int 变量来统计,这样比较方便嘛<br>具体实现如下:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程持有锁的数量</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="comment">// 当前线程 ID</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回到题目-手写一个读写锁出来"><a href="#回到题目-手写一个读写锁出来" class="headerlink" title="回到题目,手写一个读写锁出来?"></a><font face="华文中宋" size="3">回到题目,手写一个读写锁出来?</font></h1><p><font face="华文中宋" size="3">接下来,再回到题目,如果面试官让手写一个读写锁出来,你会如何实现呢?<br>在读了源码之后,相信你心里应该有谱了<br>首先来个 state 变量,然后高 16 位设置为读锁数量,低 16 位设置为写锁数量低,然后在进行读锁时,先判断下是不是有写锁,如果没有,直接读取即可,如果有的话那就需要等待;在写锁想要拿到锁的时候,就要判断写锁和读锁是不是都存在了,如果存在那就等着,如果不存在才进行接下来的操作<br>在这里我给出一个简单版的实现:</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWrite</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个读写锁共享变量 state</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 高 16 位为读锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getReadCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state 低 16 位为写锁数量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getWriteCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state &amp; (( <span class="number">1</span> &lt;&lt; <span class="number">16</span> ) - <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读锁时,先判断是否有写锁</span></span><br><span class="line">    <span class="comment">// 如果有写锁,就等待</span></span><br><span class="line">    <span class="comment">// 如果没有,进行加 1 操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockRead</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> ( getWriteCount() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"lockRead --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state = state + ( <span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放读锁数量减 1 ,通知其他线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unLockRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state = state - ( <span class="number">1</span> &lt;&lt; <span class="number">16</span> );</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取写锁时需要判断读锁和写锁是否都存在,有则等待,没有则将写锁数量加 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lockWrite</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getReadCount() &gt; <span class="number">0</span> || getWriteCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"lockWrite --- "</span> + Thread.currentThread().getName());</span><br><span class="line">        state ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放写锁数量减 1 ,通知所有等待线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlockWriters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        state --;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font face="华文中宋" size="3">我自己测试了下,没啥大问题<br>但是如果细究的话,还是有问题的,就比如,如果现在我有好多个读锁,如果一直不释放的话,那么写锁是一直没办法获取到的,这样就造成了饥饿现象的产生嘛<br>解决的话也蛮好解决的,就是在上面添加一个记录写锁数量的变量,然后在读锁之前,去判断一下是否有线程要获取写锁,如果有的话,优先处理,没有的话再进行读锁操作<br>这块大家试试自己实现吧~我这里就不给具体实现了</font></p><p><font face="华文中宋" size="3">最后,我觉得一个专栏至少是要写 15 篇文章,才可以算得上专栏一说<br>Java 并发这个系列,带上这一篇,就已经写了 14 篇了,计划是再写一篇文章,然后 Java 并发这个系列就告一个段落,接下来 Java 并发系列的更新就随缘,看我兴趣了~<br>Java 并发结束之后,就想去写写 JVM/Dubbo/Zookeeper/Redis/RabbitMQ 等等的内容(总之是要写的内容还有好多</font></p><p><font face="华文中宋" size="3">保持饥饿,保持对技术的热情,就酱~<br>大晚上的更新一篇,感谢您的阅读哇</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;题目是个标题党,主要是想写一下 ReentrantReadWriteLock&lt;br&gt;
    
    </summary>
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/categories/Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://www.dynamic-zheng.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>[碎碎念]最近有点儿飘</title>
    <link href="https://www.dynamic-zheng.com/posts/38d2bcc6.html"/>
    <id>https://www.dynamic-zheng.com/posts/38d2bcc6.html</id>
    <published>2020-09-13T11:01:59.000Z</published>
    <updated>2020-09-13T11:03:18.785Z</updated>
    
    <content type="html"><![CDATA[<p><font face="华文中宋" size="3">上周博客鸽了<br>因为最近有点儿飘<br><a id="more"></a></font></p><p><font face="华文中宋" size="3">可能是前段时间逼自己太狠了,因为我在写博客之余,还和一群朋友们一起在做公众号,我负责的那一周文章几乎都是我自己硬怼出来的,再加上工作真的是把自己搞的有些累了<br>所以最近有点儿放松自己,下班之后没有看源码/技术书籍这种,是看了一本相对轻松愉快的书籍:  &lt;哑舍&gt;<br>这本书我在高中的时候就开始追了,但是没追完,毕竟当时学业比较繁重,后来上大学,工作了就忘了这回事儿,前几天在微信读书上看到这本书,顿时回忆袭来,所以下班之后就在看这本书了<br>这本书,是我看了这么久还不知道主角名字的一本书,但是它真的很好看,很适合我这种历史不好的人~</font></p><p><font face="华文中宋" size="3">昨天和朋友一起去爬了香山,爬完之后就觉得积累在自己心中的那些焦虑啊,迷茫啊,在这大自然面前都消失的无影无踪~<br>人生这么长,何必计较这一时的得与失,目前做的所有事情,都放在五年十年之后再看,就一定是另外一番景色,所以当下的得与失没必要看得那么重,继续踏踏实实的干就完事儿了<br>所以今天感觉自己以前的情绪,状态都回来了,明天我又是一个打不死的小强,哈哈哈哈<br>不过有一说一,爬完山的我,今天整个人都瘫了</font></p><p><font face="华文中宋" size="3">下周的博客应该会是一篇干货,写什么主题我还没有确定,不过写出来的话,应该不会让读文章的你失望的<br>就这样吧~<br>我再去看会儿书~</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font face=&quot;华文中宋&quot; size=&quot;3&quot;&gt;上周博客鸽了&lt;br&gt;因为最近有点儿飘&lt;br&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="碎碎念" scheme="https://www.dynamic-zheng.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
